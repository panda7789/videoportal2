function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d3 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d3) {
            Object.defineProperty(n2, k2, d3.get ? d3 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        var args = [null];
        args.push.apply(args, arguments);
        var Ctor = Function.bind.apply(f2, args);
        return new Ctor();
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d3 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d3.get ? d3 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntimeExports = {};
var jsxRuntime$1 = {
  get exports() {
    return jsxRuntimeExports;
  },
  set exports(v2) {
    jsxRuntimeExports = v2;
  }
};
var reactJsxRuntime_production_min = {};
var reactExports = {};
var react = {
  get exports() {
    return reactExports;
  },
  set exports(v2) {
    reactExports = v2;
  }
};
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$5 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$6 = Symbol.for("react.fragment"), q$6 = Symbol.for("react.strict_mode"), r$5 = Symbol.for("react.profiler"), t$4 = Symbol.for("react.provider"), u$3 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$3 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$4 = Symbol.iterator;
function A$4(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$4 && a2[z$4] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$3 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$2 = {};
function E$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$3;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$3.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
F$2.prototype = E$3.prototype;
function G$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$3;
}
var H$3 = G$3.prototype = new F$2();
H$3.constructor = G$3;
C$2(H$3, E$3.prototype);
H$3.isPureReactComponent = true;
var I$3 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e2) {
  var d3, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d3 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$1.call(b2, d3) && !L$2.hasOwnProperty(d3) && (c2[d3] = b2[d3]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d3 in g2 = a2.defaultProps, g2)
      void 0 === c2[d3] && (c2[d3] = g2[d3]);
  return { $$typeof: l$5, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$2(a2, b2) {
  return { $$typeof: l$5, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$1(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$5;
}
function escape$2(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$2(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$2("" + a2.key) : b2.toString(36);
}
function R$1(a2, b2, e2, d3, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$5:
          case n$6:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d3 ? "." + Q$2(h2, 0) : d3, I$3(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$1(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$1(c2) && (c2 = N$2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d3 = "" === d3 ? "." : d3 + ":";
  if (I$3(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d3 + Q$2(k2, g2);
      h2 += R$1(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$4(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d3 + Q$2(k2, g2++), h2 += R$1(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d3 = [], c2 = 0;
  R$1(a2, d3, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d3;
}
function T$2(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
  S$2(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$1(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$6;
react_production_min.Profiler = r$5;
react_production_min.PureComponent = G$3;
react_production_min.StrictMode = q$6;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d3 = C$2({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$1.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d3[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d3.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d3.children = g2;
  }
  return { $$typeof: l$5, type: a2.type, key: c2, ref: k2, props: d3, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$3, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$4, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$5, render: a2 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a2 }, _init: T$2 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$3, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$2.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$2.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$2.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$2.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$2.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$2.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$2.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$2.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$2.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$2.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$2.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$2.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
(function(module) {
  {
    module.exports = react_production_min;
  }
})(react);
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$3 = reactExports, k$5 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$5 = Object.prototype.hasOwnProperty, n$5 = f$3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$5 = { key: true, ref: true, __self: true, __source: true };
function q$5(c2, a2, g2) {
  var b2, d3 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$5.call(a2, b2) && !p$5.hasOwnProperty(b2) && (d3[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d3[b2] && (d3[b2] = a2[b2]);
  return { $$typeof: k$5, type: c2, key: e2, ref: h2, props: d3, _owner: n$5.current };
}
reactJsxRuntime_production_min.Fragment = l$4;
reactJsxRuntime_production_min.jsx = q$5;
reactJsxRuntime_production_min.jsxs = q$5;
(function(module) {
  {
    module.exports = reactJsxRuntime_production_min;
  }
})(jsxRuntime$1);
const Fragment = jsxRuntimeExports.Fragment;
const jsx = jsxRuntimeExports.jsx;
const jsxs = jsxRuntimeExports.jsxs;
const jsxRuntime = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Fragment,
  jsx,
  jsxs
}, Symbol.toStringTag, { value: "Module" }));
var reactDomExports = {};
var reactDom = {
  get exports() {
    return reactDomExports;
  },
  set exports(v2) {
    reactDomExports = v2;
  }
};
var reactDom_production_min = {};
var schedulerExports = {};
var scheduler$1 = {
  get exports() {
    return schedulerExports;
  },
  set exports(v2) {
    schedulerExports = v2;
  }
};
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d3 = c2 - 1 >>> 1, e2 = a2[d3];
        if (0 < g2(e2, b2))
          a2[d3] = b2, a2[c2] = e2, c2 = d3;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d3 = 0, e2 = a2.length, w2 = e2 >>> 1; d3 < w2; ) {
          var m2 = 2 * (d3 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x, C2) ? (a2[d3] = x, a2[n2] = c2, d3 = n2) : (a2[d3] = C2, a2[m2] = c2, d3 = m2);
          else if (n2 < e2 && 0 > g2(x, c2))
            a2[d3] = x, a2[n2] = c2, d3 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r3 = [], t3 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t3); null !== b2; ) {
      if (null === b2.callback)
        k2(t3);
      else if (b2.startTime <= a2)
        k2(t3), b2.sortIndex = b2.expirationTime, f2(r3, b2);
      else
        break;
      b2 = h2(t3);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r3))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t3);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r3); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d3 = v2.callback;
        if ("function" === typeof d3) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d3(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r3) && k2(r3);
          G2(b2);
        } else
          k2(r3);
        v2 = h2(r3);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t3);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r3);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d3 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d3 + c2 : d3) : c2 = d3;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d3 ? (a2.sortIndex = c2, f2(t3, a2), null === h2(r3) && a2 === h2(t3) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d3))) : (a2.sortIndex = e2, f2(r3, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
(function(module) {
  {
    module.exports = scheduler_production_min;
  }
})(scheduler$1);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$4(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d3) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d3)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d3) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d3))
    return true;
  if (d3)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$4(a2, b2, c2, d3, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d3;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$3 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$3[a2] = new v$4(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$3[b2] = new v$4(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$3[a2] = new v$4(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$3[b2] = new v$4(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$4(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$3.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$3[a2] = new v$4(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d3) {
  var e2 = z$3.hasOwnProperty(b2) ? z$3[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d3 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d3) && (c2 = null), d3 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d3 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d3 ? a2.setAttributeNS(d3, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$3 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d3 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d3 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d3 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d3 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d3.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d3 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d3 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d3;
    }, setValue: function(a3) {
      d3 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d3 = "";
  a2 && (d3 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d3;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$3({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d3 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d3, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d3 = b2.type;
  if (null != c2)
    if ("number" === d3) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d3 || "reset" === d3) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d3 = b2.type;
    if (!("submit" !== d3 && "reset" !== d3 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d3) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d3 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d3 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$4(91));
  return A$3({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$4(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$4(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d3 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d3 && (a2.defaultValue = "" + d3);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d3, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d3, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d3 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d3);
      "float" === c2 && (c2 = "cssFloat");
      d3 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$4(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$4(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$4(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$4(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$4(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d3 = Db(c2);
  if (null === d3)
    return null;
  c2 = d3[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d3 = !d3.disabled) || (a2 = a2.type, d3 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d3;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$4(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$4(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$4(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$4(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d3 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d3 = e2.return;
      if (null !== d3) {
        c2 = d3;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d3)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$4(188));
    }
    if (c2.return !== d3.return)
      c2 = e2, d3 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d3 = f2;
          break;
        }
        if (h2 === d3) {
          g2 = true;
          d3 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d3 = e2;
            break;
          }
          if (h2 === d3) {
            g2 = true;
            d3 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$4(189));
      }
    }
    if (c2.alternate !== d3)
      throw Error(p$4(190));
  }
  if (3 !== c2.tag)
    throw Error(p$4(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d3 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d3 = tc(h2) : (f2 &= g2, 0 !== f2 && (d3 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d3 = tc(g2) : 0 !== f2 && (d3 = tc(f2));
  if (0 === d3)
    return 0;
  if (0 !== b2 && b2 !== d3 && 0 === (b2 & e2) && (e2 = d3 & -d3, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d3 & 4) && (d3 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d3; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d3 |= a2[c2], b2 &= ~e2;
  return d3;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d3 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d3))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d3 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d3[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d3 = 31 - oc(c2), e2 = 1 << d3;
    e2 & b2 | a2[d3] & b2 && (a2[d3] |= b2);
    c2 &= ~e2;
  }
}
var C$1 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d3, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d3, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d3;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d3, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d3, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d3, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d3, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d3, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d3, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d3 = new c2.constructor(c2.type, c2);
      wb = d3;
      c2.target.dispatchEvent(d3);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d3 = Kc[c2];
      d3.blockedOn === a2 && (d3.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d3 = Qc[c2], d3.blockedOn === a2 && (d3.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d3) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a2, b2, c2, d3);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d3) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a2, b2, c2, d3);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d3) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d3);
    if (null === e2)
      hd(a2, b2, d3, id, c2), Sc(a2, d3);
    else if (Uc(e2, a2, b2, c2, d3))
      d3.stopPropagation();
    else if (Sc(a2, d3), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d3);
        null === f2 && hd(a2, b2, d3, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d3.stopPropagation();
    } else
      hd(a2, b2, d3, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d3) {
  id = null;
  a2 = xb(d3);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d3, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d3 = 1; d3 <= g2 && b2[c2 - d3] === e2[f2 - d3]; d3++)
    ;
  return md = e2.slice(a2, 1 < d3 ? 1 - d3 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d3, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d3;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$3(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$3({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$3({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$3({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$3({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$3({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$3({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$3({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$3({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$3({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$3({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$3({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$3({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae$1 || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$1 = false;
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke$1(a2, b2) {
  if (ie$1)
    return "compositionend" === a2 || !ae$1 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$2(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d3) {
  Eb(d3);
  b2 = oe$1(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d3), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe$1 = null;
function re$1(a2) {
  se$1(a2, 0);
}
function te$1(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$1 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$1(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a2, xb(a2));
    Jb(re$1, b2);
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$1();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$1(qe$1);
}
function Ee$1(a2, b2) {
  if ("click" === a2)
    return te$1(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$1(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie(a2, b2) {
  if (He$1(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d3 = Object.keys(b2);
  if (c2.length !== d3.length)
    return false;
  for (d3 = 0; d3 < c2.length; d3++) {
    var e2 = c2[d3];
    if (!ja.call(b2, e2) || !He$1(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d3; c2; ) {
    if (3 === c2.nodeType) {
      d3 = a2 + c2.textContent.length;
      if (a2 <= b2 && d3 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d3;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d3) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me$1(), c2 = a2.focusedElem, d3 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d3 && Ne$1(c2)) {
      if (b2 = d3.start, a2 = d3.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d3.start, e2);
        d3 = void 0 === d3.end ? f2 : Math.min(d3.end, e2);
        !a2.extend && f2 > d3 && (e2 = d3, d3 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d3
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d3 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue$1(a2, b2, c2) {
  var d3 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe || Qe !== Xa(d3) || (d3 = Qe, "selectionStart" in d3 && Ne$1(d3) ? d3 = { start: d3.selectionStart, end: d3.selectionEnd } : (d3 = (d3.ownerDocument && d3.ownerDocument.defaultView || window).getSelection(), d3 = { anchorNode: d3.anchorNode, anchorOffset: d3.anchorOffset, focusNode: d3.focusNode, focusOffset: d3.focusOffset }), Se$1 && Ie(Se$1, d3) || (Se$1 = d3, d3 = oe$1(Re$1, "onSelect"), 0 < d3.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d3 }), b2.target = Qe)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We[a2])
    return a2;
  var b2 = We[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d3 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d3, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$1(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d3 = a2[c2], e2 = d3.event;
    d3 = d3.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d3.length - 1; 0 <= g2; g2--) {
          var h2 = d3[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d3.length; g2++) {
          h2 = d3[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$1(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d3 = a2 + "__bubble";
  c2.has(d3) || (pf(b2, a2, 2, false), c2.add(d3));
}
function qf(a2, b2, c2) {
  var d3 = 0;
  b2 && (d3 |= 4);
  pf(c2, a2, d3, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d3) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d3 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d3, e2) {
  var f2 = d3;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d3)
    a:
      for (; ; ) {
        if (null === d3)
          return;
        var g2 = d3.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d3.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d3.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d3 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d3 = d3.return;
      }
  Jb(function() {
    var d4 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t3 = 0 !== (b2 & 4), J2 = !t3 && "scroll" === a2, x = t3 ? null !== h3 ? h3 + "Capture" : null : h3;
        t3 = [];
        for (var w2 = d4, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x && (F2 = Kb(w2, x), null != F2 && t3.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t3.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t3 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d4, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d4;
          if (k3 !== n2) {
            t3 = Bd;
            F2 = "onMouseLeave";
            x = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t3 = Td, F2 = "onPointerLeave", x = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t3(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d4 && (t3 = new t3(x, w2 + "enter", n2, c2, e3), t3.target = u2, t3.relatedTarget = J2, F2 = t3);
            J2 = F2;
            if (k3 && n2)
              b: {
                t3 = k3;
                x = n2;
                w2 = 0;
                for (u2 = t3; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t3 = vf(t3), w2--;
                for (; 0 < u2 - w2; )
                  x = vf(x), u2--;
                for (; w2--; ) {
                  if (t3 === x || null !== x && t3 === x.alternate)
                    break b;
                  t3 = vf(t3);
                  x = vf(x);
                }
                t3 = null;
              }
            else
              t3 = null;
            null !== k3 && wf(g3, h3, k3, t3, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t3, true);
          }
        }
      }
      a: {
        h3 = d4 ? ue$1(d4) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me$2(h3))
          if (we$1)
            na = Fe;
          else {
            na = De$1;
            var xa = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$1);
        if (na && (na = na(a2, d4))) {
          ne$1(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d4);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d4 ? ue$1(d4) : window;
      switch (a2) {
        case "focusin":
          if (me$2(xa) || "true" === xa.contentEditable)
            Qe = xa, Re$1 = d4, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$1 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$1(d4, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je$1(a2, c2) : ke$1(a2, c2))
        d4 = oe$1(d4, "onBeforeInput"), 0 < d4.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d4 }), e3.data = $a);
    }
    se$1(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$1(a2, b2) {
  for (var c2 = b2 + "Capture", d3 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d3.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d3.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d3;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d3, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d3; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d3)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$4(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d3 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d3) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d3--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d3++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$4(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$2(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$2(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d3 = a2.stateNode;
  if (d3 && d3.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d3.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d3 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$2(Wf);
  E$2(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$4(168));
  G$2(H$2, b2);
  G$2(Wf, c2);
}
function bg(a2, b2, c2) {
  var d3 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d3.getChildContext)
    return c2;
  d3 = d3.getChildContext();
  for (var e2 in d3)
    if (!(e2 in b2))
      throw Error(p$4(108, Ra(a2) || "Unknown", e2));
  return A$3({}, c2, d3);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$2(H$2, a2);
  G$2(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d3 = a2.stateNode;
  if (!d3)
    throw Error(p$4(169));
  c2 ? (a2 = bg(a2, b2, Xf), d3.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$2), G$2(H$2, a2)) : E$2(Wf);
  G$2(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$1;
    try {
      var c2 = eg;
      for (C$1 = 1; a2 < c2.length; a2++) {
        var d3 = c2[a2];
        do
          d3 = d3(true);
        while (null !== d3);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$1 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d3 = rg;
  a2 = sg;
  var e2 = 32 - oc(d3) - 1;
  d3 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d3 & (1 << g2) - 1).toString(32);
    d3 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d3;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d3, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$2) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$4(418));
        b2 = Lf(c2.nextSibling);
        var d3 = xg;
        b2 && Cg(a2, b2) ? Ag(d3, c2) : (a2.flags = a2.flags & -4097 | 2, I$2 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$4(418));
      a2.flags = a2.flags & -4097 | 2;
      I$2 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$2)
    return Fg(a2), I$2 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$4(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$4(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$3({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$2(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d3 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d3 && (d3.childLanes |= b2)) : null !== d3 && (d3.childLanes & b2) !== b2 && (d3.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$4(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d3) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d3);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d3 = a2.updateQueue;
  if (null === d3)
    return null;
  d3 = d3.shared;
  if (0 !== (K$1 & 2)) {
    var e2 = d3.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d3.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d3.interleaved;
  null === e2 ? (b2.next = b2, Xg(d3)) : (b2.next = e2.next, e2.next = b2);
  d3.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d3 = b2.lanes;
    d3 &= a2.pendingLanes;
    c2 |= d3;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d3 = a2.alternate;
  if (null !== d3 && (d3 = d3.updateQueue, c2 === d3)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d3.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d3.shared, effects: d3.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d3) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r3 = h2.lane, y2 = h2.eventTime;
      if ((d3 & r3) === r3) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t3 = h2;
          r3 = b2;
          y2 = c2;
          switch (t3.tag) {
            case 1:
              n2 = t3.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r3);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t3.payload;
              r3 = "function" === typeof n2 ? n2.call(y2, q2, r3) : n2;
              if (null === r3 || void 0 === r3)
                break a;
              q2 = A$3({}, q2, r3);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r3 = e2.effects, null === r3 ? e2.effects = [h2] : r3.push(h2));
      } else
        y2 = { eventTime: y2, lane: r3, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r3;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r3 = h2, h2 = r3.next, r3.next = null, e2.lastBaseUpdate = r3, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d3 = a2[b2], e2 = d3.callback;
      if (null !== e2) {
        d3.callback = null;
        d3 = c2;
        if ("function" !== typeof e2)
          throw Error(p$4(191, e2));
        e2.call(d3);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d3) {
  b2 = a2.memoizedState;
  c2 = c2(d3, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$3({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d3 = L$1(), e2 = lh(a2), f2 = ch(d3, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d3), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d3 = L$1(), e2 = lh(a2), f2 = ch(d3, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d3), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$1(), d3 = lh(a2), e2 = ch(c2, d3);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d3);
  null !== b2 && (mh(b2, a2, d3, c2), eh(b2, a2, d3));
} };
function oh(a2, b2, c2, d3, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d3, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d3) || !Ie(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d3 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d3 = b2.contextTypes, f2 = (d3 = null !== d3 && void 0 !== d3) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d3 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d3) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d3);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d3);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d3) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d3), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$4(309));
        var d3 = c2.stateNode;
      }
      if (!d3)
        throw Error(p$4(147, a2));
      var e2 = d3, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$4(284));
    if (!c2._owner)
      throw Error(p$4(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$4(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d4 = b3.deletions;
      null === d4 ? (b3.deletions = [c3], b3.flags |= 16) : d4.push(c3);
    }
  }
  function c2(c3, d4) {
    if (!a2)
      return null;
    for (; null !== d4; )
      b2(c3, d4), d4 = d4.sibling;
    return null;
  }
  function d3(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d4) {
    b3.index = d4;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d4 = b3.alternate;
    if (null !== d4)
      return d4 = d4.index, d4 < c3 ? (b3.flags |= 2, c3) : d4;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d4) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d4), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d4) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d4, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d4 = e2(b3, c3.props), d4.ref = sh(a3, b3, c3), d4.return = a3, d4;
    d4 = yh(c3.type, c3.key, c3.props, null, a3.mode, d4);
    d4.ref = sh(a3, b3, c3);
    d4.return = a3;
    return d4;
  }
  function l2(a3, b3, c3, d4) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d4), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d4, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d4, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d4 = b3._init;
          return q2(a3, d4(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r3(a3, b3, c3, d4) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d4);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d4) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d4) : null;
        case Ha:
          return e3 = c3._init, r3(
            a3,
            b3,
            e3(c3._payload),
            d4
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d4, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d4, e3) {
    if ("string" === typeof d4 && "" !== d4 || "number" === typeof d4)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d4, e3);
    if ("object" === typeof d4 && null !== d4) {
      switch (d4.$$typeof) {
        case va:
          return a3 = a3.get(null === d4.key ? c3 : d4.key) || null, k2(b3, a3, d4, e3);
        case wa:
          return a3 = a3.get(null === d4.key ? c3 : d4.key) || null, l2(b3, a3, d4, e3);
        case Ha:
          var f3 = d4._init;
          return y2(a3, b3, c3, f3(d4._payload), e3);
      }
      if (eb(d4) || Ka(d4))
        return a3 = a3.get(c3) || null, m2(b3, a3, d4, e3, null);
      th(b3, d4);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x = u2, u2 = null) : x = u2.sibling;
      var n3 = r3(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$2 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (u2 = d3(e3, u2); w2 < h3.length; w2++)
      x = y2(u2, e3, w2, h3[w2], k3), null !== x && (a2 && null !== x.alternate && u2.delete(null === x.key ? w2 : x.key), g3 = f2(x, g3, w2), null === m3 ? l3 = x : m3.sibling = x, m3 = x);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function t3(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$4(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$4(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x = m3, m3 = null) : x = m3.sibling;
      var t4 = r3(e3, m3, n3.value, k3);
      if (null === t4) {
        null === m3 && (m3 = x);
        break;
      }
      a2 && m3 && null === t4.alternate && b2(e3, m3);
      g3 = f2(t4, g3, w2);
      null === u2 ? l3 = t4 : u2.sibling = t4;
      u2 = t4;
      m3 = x;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$2 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (m3 = d3(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d4, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d4; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d4 = e2(l3, f3.props.children);
                    d4.return = a3;
                    a3 = d4;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d4 = e2(l3, f3.props);
                  d4.ref = sh(a3, l3, f3);
                  d4.return = a3;
                  a3 = d4;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d4 = Ah(f3.props.children, a3.mode, h3, f3.key), d4.return = a3, a3 = d4) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d4, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d4; ) {
              if (d4.key === l3)
                if (4 === d4.tag && d4.stateNode.containerInfo === f3.containerInfo && d4.stateNode.implementation === f3.implementation) {
                  c2(a3, d4.sibling);
                  d4 = e2(d4, f3.children || []);
                  d4.return = a3;
                  a3 = d4;
                  break a;
                } else {
                  c2(a3, d4);
                  break;
                }
              else
                b2(a3, d4);
              d4 = d4.sibling;
            }
            d4 = zh(f3, a3.mode, h3);
            d4.return = a3;
            a3 = d4;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d4, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d4, f3, h3);
      if (Ka(f3))
        return t3(a3, d4, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d4 && 6 === d4.tag ? (c2(a3, d4.sibling), d4 = e2(d4, f3), d4.return = a3, a3 = d4) : (c2(a3, d4), d4 = xh(f3, a3.mode, h3), d4.return = a3, a3 = d4), g2(a3)) : c2(a3, d4);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$4(174));
  return a2;
}
function Ih(a2, b2) {
  G$2(Gh, b2);
  G$2(Fh, a2);
  G$2(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$2(Eh);
  G$2(Eh, b2);
}
function Jh() {
  E$2(Eh);
  E$2(Fh);
  E$2(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$2(Fh, a2), G$2(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$2(Eh), E$2(Fh));
}
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$1 = null, O = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$1() {
  throw Error(p$4(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d3, e2, f2) {
  Rh = f2;
  N$1 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d3, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$4(301));
      f2 += 1;
      P$1 = O = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d3, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O && null !== O.next;
  Rh = 0;
  P$1 = O = N$1 = null;
  Sh = false;
  if (b2)
    throw Error(p$4(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N$1.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di() {
  if (null === O) {
    var a2 = N$1.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O.next;
  var b2 = null === P$1 ? N$1.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O = a2;
  else {
    if (null === a2)
      throw Error(p$4(310));
    O = a2;
    a2 = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P$1 ? N$1.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$4(311));
  c2.lastRenderedReducer = a2;
  var d3 = O, e2 = d3.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d3.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d3 = d3.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d3 = l2.hasEagerState ? l2.eagerState : a2(d3, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d3) : k2 = k2.next = q2;
        N$1.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d3 : k2.next = h2;
    He$1(d3, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d3;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d3;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$1.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$4(311));
  c2.lastRenderedReducer = a2;
  var d3 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$1(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d3];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N$1, d3 = di(), e2 = b2(), f2 = !He$1(d3.memoizedState, e2);
  f2 && (d3.memoizedState = e2, Ug = true);
  d3 = d3.queue;
  ji(ki.bind(null, c2, d3, a2), [a2]);
  if (d3.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d3, e2, b2), void 0, null);
    if (null === R)
      throw Error(p$4(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d3) {
  b2.value = c2;
  b2.getSnapshot = d3;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch (d3) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$1, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d3) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d3, next: null };
  b2 = N$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d3 = c2.next, c2.next = a2, a2.next = d3, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d3) {
  var e2 = ci();
  N$1.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d3 ? null : d3);
}
function ui(a2, b2, c2, d3) {
  var e2 = di();
  d3 = void 0 === d3 ? null : d3;
  var f2 = void 0;
  if (null !== O) {
    var g2 = O.memoizedState;
    f2 = g2.destroy;
    if (null !== d3 && Wh(d3, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d3);
      return;
    }
  }
  N$1.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d3);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d3 = c2.memoizedState;
  if (null !== d3 && null !== b2 && Wh(b2, d3[1]))
    return d3[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d3 = c2.memoizedState;
  if (null !== d3 && null !== b2 && Wh(b2, d3[1]))
    return d3[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$1(c2, b2) || (c2 = yc(), N$1.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C$1;
  C$1 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d3 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$1 = c2, Qh.transition = d3;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d3 = lh(a2);
  c2 = { lane: d3, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d3), null !== c2) {
    var e2 = L$1();
    mh(c2, a2, d3, e2);
    Ji(c2, b2, d3);
  }
}
function ri(a2, b2, c2) {
  var d3 = lh(a2), e2 = { lane: d3, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He$1(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d3);
    null !== c2 && (e2 = L$1(), mh(c2, a2, d3, e2), Ji(c2, b2, d3));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$1 || null !== b2 && b2 === N$1;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d3 = b2.lanes;
    d3 &= a2.pendingLanes;
    c2 |= d3;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d3 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d3.memoizedState = d3.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d3.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$1, a2);
  return [d3.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d3 = N$1, e2 = ci();
  if (I$2) {
    if (void 0 === c2)
      throw Error(p$4(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R)
      throw Error(p$4(349));
    0 !== (Rh & 30) || ni(d3, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d3,
    f2,
    a2
  ), [a2]);
  d3.flags |= 2048;
  li(9, mi.bind(null, d3, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R.identifierPrefix;
  if (I$2) {
    var c2 = sg;
    var d3 = rg;
    c2 = (d3 & ~(1 << 32 - oc(d3) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O ? b2.memoizedState = a2 : Di(b2, O.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d3 = b2;
    do
      c2 += Pa(d3), d3 = d3.return;
    while (d3);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d3 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d3);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d3 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d3) {
    var e2 = b2.value;
    c2.payload = function() {
      return d3(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d3 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d3 = a2.pingCache;
  if (null === d3) {
    d3 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d3.set(b2, e2);
  } else
    e2 = d3.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d3.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d3, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d3) {
  b2.child = null === a2 ? Ch(b2, null, c2, d3) : Bh(b2, a2.child, c2, d3);
}
function Zi(a2, b2, c2, d3, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d3 = Xh(a2, b2, c2, d3, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$2 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d3, e2);
  return b2.child;
}
function aj(a2, b2, c2, d3, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d3, e2);
    a2 = yh(c2.type, null, d3, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d3) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d3);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d3, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d3) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d3 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d3, e2);
}
function ej(a2, b2, c2) {
  var d3 = b2.pendingProps, e2 = d3.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d3.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$2(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$2(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d3 = null !== f2 ? f2.baseLanes : c2;
      G$2(fj, gj);
      gj |= d3;
    }
  else
    null !== f2 ? (d3 = f2.baseLanes | c2, b2.memoizedState = null) : d3 = c2, G$2(fj, gj), gj |= d3;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d3, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d3, f2, e2);
  d3 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$2 && d3 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d3, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d3), rh(b2, c2, d3, e2), d3 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d3 || k2 !== l2) && qh(b2, g2, d3, l2);
    $g = false;
    var r3 = b2.memoizedState;
    g2.state = r3;
    gh(b2, d3, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d3 || r3 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d3), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d3, r3, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d3, b2.memoizedState = k2), g2.props = d3, g2.state = k2, g2.context = l2, d3 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d3 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r3 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r3 !== k2) && qh(b2, g2, d3, k2);
    $g = false;
    r3 = b2.memoizedState;
    g2.state = r3;
    gh(b2, d3, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r3 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d3), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d3, r3, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d3, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d3, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r3 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r3 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d3, b2.memoizedState = n2), g2.props = d3, g2.state = n2, g2.context = k2, d3 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r3 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r3 === a2.memoizedState || (b2.flags |= 1024), d3 = false);
  }
  return kj(a2, b2, c2, d3, f2, e2);
}
function kj(a2, b2, c2, d3, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d3 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d3 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d3.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d3.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d3, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d3);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d3 = b2.pendingProps, e2 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$2(M$1, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d3.children;
    a2 = d3.fallback;
    return f2 ? (d3 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d3 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d3, 0, null), a2 = Ah(a2, d3, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d3, h2, e2, c2);
  if (f2) {
    f2 = d3.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d3.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d3 = b2.child, d3.childLanes = 0, d3.pendingProps = k2, b2.deletions = null) : (d3 = wh(e2, k2), d3.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d3.return = b2;
    d3.sibling = f2;
    b2.child = d3;
    d3 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d3;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d3 = wh(f2, { mode: "visible", children: d3.children });
  0 === (b2.mode & 1) && (d3.lanes = c2);
  d3.return = b2;
  d3.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d3;
  b2.memoizedState = null;
  return d3;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d3) {
  null !== d3 && Jg(d3);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d3, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d3 = Li(Error(p$4(422))), tj(a2, b2, g2, d3);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d3.fallback;
    e2 = b2.mode;
    d3 = qj({ mode: "visible", children: d3.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d3.return = b2;
    f2.return = b2;
    d3.sibling = f2;
    b2.child = d3;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d3 = e2.nextSibling && e2.nextSibling.dataset;
    if (d3)
      var h2 = d3.dgst;
    d3 = h2;
    f2 = Error(p$4(419));
    d3 = Li(f2, d3, void 0);
    return tj(a2, b2, g2, d3);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d3 = R;
    if (null !== d3) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d3.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d3, a2, e2, -1));
    }
    uj();
    d3 = Li(Error(p$4(421)));
    return tj(a2, b2, g2, d3);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$2 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d3.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d3 = a2.alternate;
  null !== d3 && (d3.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d3, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d3, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d3, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d3 = b2.pendingProps, e2 = d3.revealOrder, f2 = d3.tail;
  Yi(a2, b2, d3.children, c2);
  d3 = M$1.current;
  if (0 !== (d3 & 2))
    d3 = d3 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d3 &= 1;
  }
  G$2(M$1, d3);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$4(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d3 = b2.type._context, e2 = b2.memoizedProps.value;
      G$2(Mg, d3._currentValue);
      d3._currentValue = e2;
      break;
    case 13:
      d3 = b2.memoizedState;
      if (null !== d3) {
        if (null !== d3.dehydrated)
          return G$2(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$2(M$1, M$1.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$2(M$1, M$1.current & 1);
      break;
    case 19:
      d3 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d3)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$2(M$1, M$1.current);
      if (d3)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d3) {
  var e2 = a2.memoizedProps;
  if (e2 !== d3) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d3 = Ya(a2, d3);
        f2 = [];
        break;
      case "select":
        e2 = A$3({}, e2, { value: void 0 });
        d3 = A$3({}, d3, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d3 = gb(a2, d3);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d3.onClick && (a2.onclick = Bf);
    }
    ub(c2, d3);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d3.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d3) {
      var k2 = d3[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d3.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d3) {
  c2 !== d3 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$2)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d3 = null; null !== c2; )
          null !== c2.alternate && (d3 = c2), c2 = c2.sibling;
        null === d3 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d3.sibling = null;
    }
}
function S$1(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d3 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags & 14680064, d3 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags, d3 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d3;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d3 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d3 = b2.stateNode;
      Jh();
      E$2(Wf);
      E$2(H$2);
      Oh();
      d3.pendingContext && (d3.context = d3.pendingContext, d3.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$1(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d3, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d3) {
          if (null === b2.stateNode)
            throw Error(p$4(166));
          S$1(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d3 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d3[Of] = b2;
          d3[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$1("cancel", d3);
              D$1("close", d3);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d3);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$1(lf[e2], d3);
              break;
            case "source":
              D$1("error", d3);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d3
              );
              D$1("load", d3);
              break;
            case "details":
              D$1("toggle", d3);
              break;
            case "input":
              Za(d3, f2);
              D$1("invalid", d3);
              break;
            case "select":
              d3._wrapperState = { wasMultiple: !!f2.multiple };
              D$1("invalid", d3);
              break;
            case "textarea":
              hb(d3, f2), D$1("invalid", d3);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d3.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d3.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d3.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d3.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d3);
            }
          switch (c2) {
            case "input":
              Va(d3);
              db(d3, f2, true);
              break;
            case "textarea":
              Va(d3);
              jb(d3);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d3.onclick = Bf);
          }
          d3 = e2;
          b2.updateQueue = d3;
          null !== d3 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d3.is ? a2 = g2.createElement(c2, { is: d3.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d3.multiple ? g2.multiple = true : d3.size && (g2.size = d3.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d3;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d3);
            switch (c2) {
              case "dialog":
                D$1("cancel", a2);
                D$1("close", a2);
                e2 = d3;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a2);
                e2 = d3;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$1(lf[e2], a2);
                e2 = d3;
                break;
              case "source":
                D$1("error", a2);
                e2 = d3;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a2
                );
                D$1("load", a2);
                e2 = d3;
                break;
              case "details":
                D$1("toggle", a2);
                e2 = d3;
                break;
              case "input":
                Za(a2, d3);
                e2 = Ya(a2, d3);
                D$1("invalid", a2);
                break;
              case "option":
                e2 = d3;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d3.multiple };
                e2 = A$3({}, d3, { value: void 0 });
                D$1("invalid", a2);
                break;
              case "textarea":
                hb(a2, d3);
                e2 = gb(a2, d3);
                D$1("invalid", a2);
                break;
              default:
                e2 = d3;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d3, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d3.value && a2.setAttribute("value", "" + Sa(d3.value));
                break;
              case "select":
                a2.multiple = !!d3.multiple;
                f2 = d3.value;
                null != f2 ? fb(a2, !!d3.multiple, f2, false) : null != d3.defaultValue && fb(
                  a2,
                  !!d3.multiple,
                  d3.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d3 = !!d3.autoFocus;
                break a;
              case "img":
                d3 = true;
                break a;
              default:
                d3 = false;
            }
          }
          d3 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d3);
      else {
        if ("string" !== typeof d3 && null === b2.stateNode)
          throw Error(p$4(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d3 = b2.stateNode;
          c2 = b2.memoizedProps;
          d3[Of] = b2;
          if (f2 = d3.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d3.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d3.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d3 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d3), d3[Of] = b2, b2.stateNode = d3;
      }
      S$1(b2);
      return null;
    case 13:
      E$2(M$1);
      d3 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d3 && null !== d3.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$4(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$4(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d3 = null !== d3;
      d3 !== (null !== a2 && null !== a2.memoizedState) && d3 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$1.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return Rg(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E$2(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$1(b2), null;
      d3 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d3)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d3 = g2.updateQueue;
                null !== d3 && (b2.updateQueue = d3, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d3 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d3, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$2(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$2() > Hj && (b2.flags |= 128, d3 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d3)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d3 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$2)
              return S$1(b2), null;
          } else
            2 * B$2() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d3 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = M$1.current, G$2(M$1, d3 ? c2 & 1 | 2 : c2 & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d3 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d3 && (b2.flags |= 8192), d3 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$4(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$2(Wf), E$2(H$2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$2(M$1);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$4(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$2(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d3) {
        W$1(a2, b2, d3);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d3) {
    W$1(a2, b2, d3);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$1();
  if (Ne$1(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d3 = c2.getSelection && c2.getSelection();
        if (d3 && 0 !== d3.rangeCount) {
          c2 = d3.anchorNode;
          var e2 = d3.anchorOffset, f2 = d3.focusNode;
          d3 = d3.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r3 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d3 && 3 !== q2.nodeType || (k2 = g2 + d3);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r3 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r3 === c2 && ++l2 === e2 && (h2 = g2);
                r3 === f2 && ++m2 === d3 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r3;
                r3 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$1 = a2;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t3 = n2.memoizedProps, J2 = n2.memoizedState, x = b2.stateNode, w2 = x.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t3 : Lg(b2.type, t3), J2);
                  x.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$4(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$1 = a2;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d3 = b2.updateQueue;
  d3 = null !== d3 ? d3.lastEffect : null;
  if (null !== d3) {
    var e2 = d3 = d3.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d3);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d3 = c2.create;
        c2.destroy = d3();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d3 = a2.tag;
  if (5 === d3 || 6 === d3)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d3 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d3 = a2.tag;
  if (5 === d3 || 6 === d3)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d3 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$1 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$1 || Mj(c2, b2);
    case 6:
      var d3 = X$1, e2 = Yj;
      X$1 = null;
      Zj(a2, b2, c2);
      X$1 = d3;
      Yj = e2;
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d3 = X$1;
      e2 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$1 = d3;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d3 = c2.updateQueue, null !== d3 && (d3 = d3.lastEffect, null !== d3))) {
        e2 = d3 = d3.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d3);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$1 && (Mj(c2, b2), d3 = c2.stateNode, "function" === typeof d3.componentWillUnmount))
        try {
          d3.props = c2.memoizedProps, d3.state = c2.memoizedState, d3.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d3 = U$1) || null !== c2.memoizedState, Zj(a2, b2, c2), U$1 = d3) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d3 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d3, d3));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d3 = 0; d3 < c2.length; d3++) {
      var e2 = c2[d3];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$4(160));
        ak(f2, g2, e2);
        X$1 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d3 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d3 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t3) {
          W$1(a2, a2.return, t3);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t3) {
          W$1(a2, a2.return, t3);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d3 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d3 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t3) {
          W$1(a2, a2.return, t3);
        }
      }
      if (d3 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r3 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r3 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t3) {
            W$1(a2, a2.return, t3);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d3 & 4) {
        if (null === a2.stateNode)
          throw Error(p$4(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t3) {
          W$1(a2, a2.return, t3);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d3 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t3) {
          W$1(a2, a2.return, t3);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$2()));
      d3 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a2), U$1 = l2) : dk(b2, a2);
      fk(a2);
      if (d3 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$1 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r3 = V$1;
              y2 = r3.child;
              switch (r3.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r3, r3.return);
                  break;
                case 1:
                  Mj(r3, r3.return);
                  var n2 = r3.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d3 = r3;
                    c2 = r3.return;
                    try {
                      b2 = d3, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t3) {
                      W$1(d3, c2, t3);
                    }
                  }
                  break;
                case 5:
                  Mj(r3, r3.return);
                  break;
                case 22:
                  if (null !== r3.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r3, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t3) {
                  W$1(a2, a2.return, t3);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t3) {
                  W$1(a2, a2.return, t3);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d3 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d3 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$4(160));
      }
      switch (d3.tag) {
        case 5:
          var e2 = d3.stateNode;
          d3.flags & 32 && (ob(e2, ""), d3.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d3.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$4(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$1 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d3 = 0 !== (a2.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d3) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k2) && !l2)
          for (V$1 = e2; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e2);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e2;
        Kj = h2;
        U$1 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b2);
              break;
            case 1:
              var d3 = b2.stateNode;
              if (b2.flags & 4 && !U$1)
                if (null === c2)
                  d3.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d3.componentDidUpdate(e2, c2.memoizedState, d3.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d3);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$4(163));
          }
        U$1 || b2.flags & 512 && Sj(b2);
      } catch (r3) {
        W$1(b2, b2.return, r3);
      }
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d3 = b2.stateNode;
          if ("function" === typeof d3.componentDidMount) {
            var e2 = b2.return;
            try {
              d3.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$1() {
  return 0 !== (K$1 & 6) ? B$2() : -1 !== Bk ? Bk : Bk = B$2();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$1;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d3) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$4(185));
  Ac(a2, c2, d3);
  if (0 === (K$1 & 2) || a2 !== R)
    a2 === R && (0 === (K$1 & 2) && (rk |= c2), 4 === T$1 && Dk(a2, Z$1)), Ek(a2, d3), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B$2() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d3 = uc(a2, a2 === R ? Z$1 : 0);
  if (0 === d3)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d3 & -d3, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d3)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$4(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d3 = uc(a2, a2 === R ? Z$1 : 0);
  if (0 === d3)
    return null;
  if (0 !== (d3 & 30) || 0 !== (d3 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d3);
  else {
    b2 = d3;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R !== a2 || Z$1 !== b2)
      vk = null, Hj = B$2() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e2;
    null !== Y$1 ? b2 = 0 : (R = null, Z$1 = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d3 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d3), Ek(a2, B$2()), c2;
    if (6 === b2)
      Dk(a2, d3);
    else {
      e2 = a2.current.alternate;
      if (0 === (d3 & 30) && !Pk(e2) && (b2 = Jk(a2, d3), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d3 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d3), Ek(a2, B$2()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d3;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$4(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d3);
          if ((d3 & 130023424) === d3 && (b2 = gk + 500 - B$2(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d3) !== d3) {
              L$1();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d3);
          if ((d3 & 4194240) === d3)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d3; ) {
            var g2 = 31 - oc(d3);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d3 &= ~f2;
          }
          d3 = e2;
          d3 = B$2() - d3;
          d3 = (120 > d3 ? 120 : 480 > d3 ? 480 : 1080 > d3 ? 1080 : 1920 > d3 ? 1920 : 3e3 > d3 ? 3e3 : 4320 > d3 ? 4320 : 1960 * mk(d3 / 1960)) - d3;
          if (10 < d3) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d3);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$4(329));
      }
    }
  }
  Ek(a2, B$2());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d3 = 0; d3 < c2.length; d3++) {
          var e2 = c2[d3], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d3 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d3;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$4(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$2()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d3 = xc(a2);
    0 !== d3 && (b2 = d3, c2 = Ok(a2, d3));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$2()), c2;
  if (6 === c2)
    throw Error(p$4(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$2());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B$2() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d3 = C$1;
  try {
    if (pk.transition = null, C$1 = 1, a2)
      return a2();
  } finally {
    C$1 = d3, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$2(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d3 = c2;
      wg(d3);
      switch (d3.tag) {
        case 1:
          d3 = d3.type.childContextTypes;
          null !== d3 && void 0 !== d3 && $f();
          break;
        case 3:
          Jh();
          E$2(Wf);
          E$2(H$2);
          Oh();
          break;
        case 5:
          Lh(d3);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$1);
          break;
        case 19:
          E$2(M$1);
          break;
        case 10:
          Rg(d3.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$1 = gj = b2;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d3 = c2.interleaved, null !== d3) {
        c2.interleaved = null;
        var e2 = d3.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d3.next = g2;
        }
        c2.pending = d3;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d3 = N$1.memoizedState; null !== d3; ) {
          var e2 = d3.queue;
          null !== e2 && (e2.pending = null);
          d3 = d3.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O = N$1 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$1 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r3 = m2.alternate;
            r3 ? (m2.updateQueue = r3.updateQueue, m2.memoizedState = r3.memoizedState, m2.lanes = r3.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t3 = /* @__PURE__ */ new Set();
              t3.add(k2);
              b2.updateQueue = t3;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$4(426));
          }
        } else if (I$2 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x = Oi(f2, k2, b2);
              fh(f2, x);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z$1);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d3 = Kk();
  if (R !== a2 || Z$1 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d3;
  if (null !== Y$1)
    throw Error(p$4(261));
  R = null;
  Z$1 = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$1 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Qk(a2, b2, c2) {
  var d3 = C$1, e2 = pk.transition;
  try {
    pk.transition = null, C$1 = 1, Xk(a2, b2, c2, d3);
  } finally {
    pk.transition = e2, C$1 = d3;
  }
  return null;
}
function Xk(a2, b2, c2, d3) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$4(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$4(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R && (Y$1 = R = null, Z$1 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$1 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$2());
  if (null !== b2)
    for (d3 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d3(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$1;
    try {
      pk.transition = null;
      C$1 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d3 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$4(331));
        var e2 = K$1;
        K$1 |= 4;
        for (V$1 = a2.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r3 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r3) {
                        r3.return = y2;
                        V$1 = r3;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t3 = n2.child;
                if (null !== t3) {
                  n2.child = null;
                  do {
                    var J2 = t3.sibling;
                    t3.sibling = null;
                    t3 = J2;
                  } while (null !== t3);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x = f2.sibling;
                if (null !== x) {
                  x.return = f2.return;
                  V$1 = x;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K$1 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d3 = true;
      }
      return d3;
    } finally {
      C$1 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$1();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d3 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d3.componentDidCatch && (null === Si || !Si.has(d3))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$1();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d3 = a2.pingCache;
  null !== d3 && d3.delete(b2);
  b2 = L$1();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R === a2 && (Z$1 & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B$2() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$1();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d3 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d3 = a2.stateNode;
      break;
    default:
      throw Error(p$4(314));
  }
  null !== d3 && d3.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d3 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d3, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d3) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d3, a2, c2), b2 = kj(null, b2, d3, true, f2, c2)) : (b2.tag = 0, I$2 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d3 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d3._init;
        d3 = e2(d3._payload);
        b2.type = d3;
        e2 = b2.tag = $k(d3);
        a2 = Lg(d3, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d3, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d3, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d3, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d3, Lg(d3.type, a2), c2);
            break a;
        }
        throw Error(p$4(
          306,
          d3,
          ""
        ));
      }
      return b2;
    case 0:
      return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Lg(d3, e2), dj(a2, b2, d3, e2, c2);
    case 1:
      return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Lg(d3, e2), ij(a2, b2, d3, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$4(387));
        d3 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d3, null, c2);
        var g2 = b2.memoizedState;
        d3 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d3, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$4(423)), b2);
            b2 = mj(a2, b2, d3, c2, e2);
            break a;
          } else if (d3 !== e2) {
            e2 = Ki(Error(p$4(424)), b2);
            b2 = mj(a2, b2, d3, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$2 = true, zg = null, c2 = Ch(b2, null, d3, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d3 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d3, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d3 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d3, e2) ? g2 = null : null !== f2 && Ef(d3, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d3 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d3, c2) : Yi(a2, b2, d3, c2), b2.child;
    case 11:
      return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Lg(d3, e2), Zi(a2, b2, d3, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d3 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$2(Mg, d3._currentValue);
        d3._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d3) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$4(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d3 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d3 = d3(e2), b2.flags |= 1, Yi(a2, b2, d3, c2), b2.child;
    case 14:
      return d3 = b2.type, e2 = Lg(d3, b2.pendingProps), e2 = Lg(d3.type, e2), aj(a2, b2, d3, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Lg(d3, e2), jj(a2, b2), b2.tag = 1, Zf(d3) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d3, e2), rh(b2, d3, e2, c2), kj(null, b2, d3, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$4(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d3) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d3;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d3) {
  return new al(a2, b2, c2, d3);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d3, e2, f2) {
  var g2 = 2;
  d3 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d3 = null;
                break a;
            }
          throw Error(p$4(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d3;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d3) {
  a2 = Bg(7, a2, d3, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d3) {
  a2 = Bg(22, a2, d3, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d3, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d3;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d3, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d3 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d3 ? null : "" + d3, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$4(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$4(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d3, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d3, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d3 = L$1();
  e2 = lh(c2);
  f2 = ch(d3, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d3);
  Ek(a2, d3);
  return a2;
}
function gl(a2, b2, c2, d3) {
  var e2 = b2.current, f2 = L$1(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d3 = void 0 === d3 ? null : d3;
  null !== d3 && (b2.callback = d3);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$4(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d3, e2) {
  if (e2) {
    if ("function" === typeof d3) {
      var f2 = d3;
      d3 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d3, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d3) {
    var h2 = d3;
    d3 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d3);
  });
  return k2;
}
function sl(a2, b2, c2, d3, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d3);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$2()), 0 === (K$1 & 6) && (Hj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$1();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$1();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d3 = L$1();
      mh(c2, a2, b2, d3);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a2, b2) {
  var c2 = C$1;
  try {
    return C$1 = a2, b2();
  } finally {
    C$1 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d3 = c2[b2];
          if (d3 !== a2 && d3.form === a2.form) {
            var e2 = Db(d3);
            if (!e2)
              throw Error(p$4(90));
            Wa(d3);
            bb(d3, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$4(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$4(299));
  var c2 = false, d3 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d3 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d3, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$4(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$4(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$4(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$4(405));
  var d3 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d3)
    for (a2 = 0; a2 < d3.length; a2++)
      c2 = d3[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$4(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$4(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d3) {
  if (!pl(c2))
    throw Error(p$4(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$4(38));
  return sl(a2, b2, c2, false, d3);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
(function(module) {
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    module.exports = reactDom_production_min;
  }
})(reactDom);
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var createRoot;
var m$4 = reactDomExports;
{
  createRoot = m$4.createRoot;
  m$4.hydrateRoot;
}
const index = "";
const aspectRatio = "";
class Subscribable {
  constructor() {
    this.listeners = [];
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.push(listener);
    this.onSubscribe();
    return () => {
      this.listeners = this.listeners.filter((x) => x !== listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.length > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}
const isServer$1 = typeof window === "undefined" || "Deno" in window;
function noop$8() {
  return void 0;
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
  if (!isQueryKey(arg1)) {
    return arg1;
  }
  if (typeof arg2 === "function") {
    return {
      ...arg3,
      queryKey: arg1,
      queryFn: arg2
    };
  }
  return {
    ...arg2,
    queryKey: arg1
  };
}
function parseMutationArgs(arg1, arg2, arg3) {
  if (isQueryKey(arg1)) {
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        mutationKey: arg1,
        mutationFn: arg2
      };
    }
    return {
      ...arg2,
      mutationKey: arg1
    };
  }
  if (typeof arg1 === "function") {
    return {
      ...arg2,
      mutationFn: arg1
    };
  }
  return {
    ...arg1
  };
}
function parseFilterArgs(arg1, arg2, arg3) {
  return isQueryKey(arg1) ? [{
    ...arg2,
    queryKey: arg1
  }, arg3] : [arg1 || {}, arg2];
}
function matchQuery(filters, query) {
  const {
    type: type2 = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (isQueryKey(queryKey)) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type2 !== "all") {
    const isActive = query.isActive();
    if (type2 === "active" && !isActive) {
      return false;
    }
    if (type2 === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const {
    exact,
    fetching,
    predicate,
    mutationKey
  } = filters;
  if (isQueryKey(mutationKey)) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
  return hashFn(queryKey);
}
function hashQueryKey(queryKey) {
  return JSON.stringify(queryKey, (_2, val) => isPlainObject$4(val) ? Object.keys(val).sort().reduce((result, key) => {
    result[key] = val[key];
    return result;
  }, {}) : val);
}
function partialMatchKey(a2, b2) {
  return partialDeepEqual(a2, b2);
}
function partialDeepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    return !Object.keys(b2).some((key) => !partialDeepEqual(a2[key], b2[key]));
  }
  return false;
}
function replaceEqualDeep(a2, b2) {
  if (a2 === b2) {
    return a2;
  }
  const array = isPlainArray(a2) && isPlainArray(b2);
  if (array || isPlainObject$4(a2) && isPlainObject$4(b2)) {
    const aSize = array ? a2.length : Object.keys(a2).length;
    const bItems = array ? b2 : Object.keys(b2);
    const bSize = bItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      copy2[key] = replaceEqualDeep(a2[key], b2[key]);
      if (copy2[key] === a2[key]) {
        equalItems++;
      }
    }
    return aSize === bSize && equalItems === aSize ? a2 : copy2;
  }
  return b2;
}
function shallowEqualObjects(a2, b2) {
  if (a2 && !b2 || b2 && !a2) {
    return false;
  }
  for (const key in a2) {
    if (a2[key] !== b2[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject$4(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isQueryKey(value) {
  return Array.isArray(value);
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function scheduleMicrotask(callback2) {
  sleep(0).then(callback2);
}
function getAbortController() {
  if (typeof AbortController === "function") {
    return new AbortController();
  }
  return;
}
function replaceData(prevData, data, options) {
  if (options.isDataEqual != null && options.isDataEqual(prevData, data)) {
    return prevData;
  } else if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
class FocusManager extends Subscribable {
  constructor() {
    super();
    this.setup = (onFocus) => {
      if (!isServer$1 && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        window.addEventListener("focus", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
          window.removeEventListener("focus", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    this.focused = focused;
    if (focused) {
      this.onFocus();
    }
  }
  onFocus() {
    this.listeners.forEach((listener) => {
      listener();
    });
  }
  isFocused() {
    if (typeof this.focused === "boolean") {
      return this.focused;
    }
    if (typeof document === "undefined") {
      return true;
    }
    return [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const focusManager = new FocusManager();
class OnlineManager extends Subscribable {
  constructor() {
    super();
    this.setup = (onOnline) => {
      if (!isServer$1 && window.addEventListener) {
        const listener = () => onOnline();
        window.addEventListener("online", listener, false);
        window.addEventListener("offline", listener, false);
        return () => {
          window.removeEventListener("online", listener);
          window.removeEventListener("offline", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.cleanup) {
      this.setEventListener(this.setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var _this$cleanup;
      (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
      this.cleanup = void 0;
    }
  }
  setEventListener(setup) {
    var _this$cleanup2;
    this.setup = setup;
    (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
    this.cleanup = setup((online) => {
      if (typeof online === "boolean") {
        this.setOnline(online);
      } else {
        this.onOnline();
      }
    });
  }
  setOnline(online) {
    this.online = online;
    if (online) {
      this.onOnline();
    }
  }
  onOnline() {
    this.listeners.forEach((listener) => {
      listener();
    });
  }
  isOnline() {
    if (typeof this.online === "boolean") {
      return this.online;
    }
    if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
      return true;
    }
    return navigator.onLine;
  }
}
const onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
}
class CancelledError {
  constructor(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
}
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  let promiseResolve;
  let promiseReject;
  const promise = new Promise((outerResolve, outerReject) => {
    promiseResolve = outerResolve;
    promiseReject = outerReject;
  });
  const cancel = (cancelOptions) => {
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      config2.abort == null ? void 0 : config2.abort();
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const shouldPause = () => !focusManager.isFocused() || config2.networkMode !== "always" && !onlineManager.isOnline();
  const resolve = (value) => {
    if (!isResolved) {
      isResolved = true;
      config2.onSuccess == null ? void 0 : config2.onSuccess(value);
      continueFn == null ? void 0 : continueFn();
      promiseResolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved) {
      isResolved = true;
      config2.onError == null ? void 0 : config2.onError(value);
      continueFn == null ? void 0 : continueFn();
      promiseReject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        const canContinue = isResolved || !shouldPause();
        if (canContinue) {
          continueResolve(value);
        }
        return canContinue;
      };
      config2.onPause == null ? void 0 : config2.onPause();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved) {
        config2.onContinue == null ? void 0 : config2.onContinue();
      }
    });
  };
  const run6 = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    try {
      promiseOrValue = config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _config$retry, _config$retryDelay;
      if (isResolved) {
        return;
      }
      const retry = (_config$retry = config2.retry) != null ? _config$retry : 3;
      const retryDelay = (_config$retryDelay = config2.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config2.onFail == null ? void 0 : config2.onFail(failureCount, error);
      sleep(delay).then(() => {
        if (shouldPause()) {
          return pause();
        }
        return;
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run6();
        }
      });
    });
  };
  if (canFetch(config2.networkMode)) {
    run6();
  } else {
    pause().then(run6);
  }
  return {
    promise,
    cancel,
    continue: () => {
      const didContinue = continueFn == null ? void 0 : continueFn();
      return didContinue ? promise : Promise.resolve();
    },
    cancelRetry,
    continueRetry
  };
}
const defaultLogger = console;
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback2) => {
    callback2();
  };
  let batchNotifyFn = (callback2) => {
    callback2();
  };
  const batch2 = (callback2) => {
    let result;
    transactions++;
    try {
      result = callback2();
    } finally {
      transactions--;
      if (!transactions) {
        flush3();
      }
    }
    return result;
  };
  const schedule = (callback2) => {
    if (transactions) {
      queue.push(callback2);
    } else {
      scheduleMicrotask(() => {
        notifyFn(callback2);
      });
    }
  };
  const batchCalls = (callback2) => {
    return (...args) => {
      schedule(() => {
        callback2(...args);
      });
    };
  };
  const flush3 = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleMicrotask(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback2) => {
            notifyFn(callback2);
          });
        });
      });
    }
  };
  const setNotifyFunction = (fn2) => {
    notifyFn = fn2;
  };
  const setBatchNotifyFunction = (fn2) => {
    batchNotifyFn = fn2;
  };
  return {
    batch: batch2,
    batchCalls,
    schedule,
    setNotifyFunction,
    setBatchNotifyFunction
  };
}
const notifyManager = createNotifyManager();
class Removable {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.cacheTime)) {
      this.gcTimeout = setTimeout(() => {
        this.optionalRemove();
      }, this.cacheTime);
    }
  }
  updateCacheTime(newCacheTime) {
    this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer$1 ? Infinity : 5 * 60 * 1e3);
  }
  clearGcTimeout() {
    if (this.gcTimeout) {
      clearTimeout(this.gcTimeout);
      this.gcTimeout = void 0;
    }
  }
}
class Query extends Removable {
  constructor(config2) {
    super();
    this.abortSignalConsumed = false;
    this.defaultOptions = config2.defaultOptions;
    this.setOptions(config2.options);
    this.observers = [];
    this.cache = config2.cache;
    this.logger = config2.logger || defaultLogger;
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    this.initialState = config2.state || getDefaultState$1(this.options);
    this.state = this.initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options
    };
    this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.cache.remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    this.dispatch({
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.dispatch({
      type: "setState",
      state,
      setStateOptions
    });
  }
  cancel(options) {
    var _this$retryer;
    const promise = this.promise;
    (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options);
    return promise ? promise.then(noop$8).catch(noop$8) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({
      silent: true
    });
  }
  reset() {
    this.destroy();
    this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((observer) => observer.options.enabled !== false);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _this$retryer2;
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
  }
  onOnline() {
    var _this$retryer3;
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    if (observer) {
      observer.refetch({
        cancelRefetch: false
      });
    }
    (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
  }
  addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.cache.notify({
        type: "observerAdded",
        query: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    if (this.observers.indexOf(observer) !== -1) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (this.retryer) {
          if (this.abortSignalConsumed) {
            this.retryer.cancel({
              revert: true
            });
          } else {
            this.retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.cache.notify({
        type: "observerRemoved",
        query: this,
        observer
      });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.dispatch({
        type: "invalidate"
      });
    }
  }
  fetch(options, fetchOptions) {
    var _this$options$behavio, _context$fetchOptions;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
        this.cancel({
          silent: true
        });
      } else if (this.promise) {
        var _this$retryer4;
        (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
        return this.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (!Array.isArray(this.options.queryKey))
      ;
    const abortController = getAbortController();
    const queryFnContext = {
      queryKey: this.queryKey,
      pageParam: void 0,
      meta: this.meta
    };
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          if (abortController) {
            this.abortSignalConsumed = true;
            return abortController.signal;
          }
          return void 0;
        }
      });
    };
    addSignalProperty(queryFnContext);
    const fetchFn = () => {
      if (!this.options.queryFn) {
        return Promise.reject("Missing queryFn");
      }
      this.abortSignalConsumed = false;
      return this.options.queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
    this.revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
      var _context$fetchOptions2;
      this.dispatch({
        type: "fetch",
        meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
      });
    }
    const onError2 = (error) => {
      if (!(isCancelledError(error) && error.silent)) {
        this.dispatch({
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
        (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
        (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
      }
      if (!this.isFetchingOptimistic) {
        this.scheduleGc();
      }
      this.isFetchingOptimistic = false;
    };
    this.retryer = createRetryer({
      fn: context.fetchFn,
      abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
        if (typeof data === "undefined") {
          onError2(new Error("undefined"));
          return;
        }
        this.setData(data);
        (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data, this);
        (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data, this.state.error, this);
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      },
      onError: onError2,
      onFail: (failureCount, error) => {
        this.dispatch({
          type: "failed",
          failureCount,
          error
        });
      },
      onPause: () => {
        this.dispatch({
          type: "pause"
        });
      },
      onContinue: () => {
        this.dispatch({
          type: "continue"
        });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode
    });
    this.promise = this.retryer.promise;
    return this.promise;
  }
  dispatch(action) {
    const reducer2 = (state) => {
      var _action$meta, _action$dataUpdatedAt;
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
            fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
            ...!state.dataUpdatedAt && {
              error: null,
              status: "loading"
            }
          };
        case "success":
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && this.revertState) {
            return {
              ...this.revertState
            };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer2(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate(action);
      });
      this.cache.notify({
        query: this,
        type: "updated",
        action
      });
    });
  }
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = typeof data !== "undefined";
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "loading",
    fetchStatus: "idle"
  };
}
class QueryCache extends Subscribable {
  constructor(config2) {
    super();
    this.config = config2 || {};
    this.queries = [];
    this.queriesMap = {};
  }
  build(client, options, state) {
    var _options$queryHash;
    const queryKey = options.queryKey;
    const queryHash = (_options$queryHash = options.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        cache: this,
        logger: client.getLogger(),
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.queriesMap[query.queryHash]) {
      this.queriesMap[query.queryHash] = query;
      this.queries.push(query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.queriesMap[query.queryHash];
    if (queryInMap) {
      query.destroy();
      this.queries = this.queries.filter((x) => x !== query);
      if (queryInMap === query) {
        delete this.queriesMap[query.queryHash];
      }
      this.notify({
        type: "removed",
        query
      });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.queriesMap[queryHash];
  }
  getAll() {
    return this.queries;
  }
  find(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.queries.find((query) => matchQuery(filters, query));
  }
  findAll(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.queries.forEach((query) => {
        query.onOnline();
      });
    });
  }
}
class Mutation extends Removable {
  constructor(config2) {
    super();
    this.defaultOptions = config2.defaultOptions;
    this.mutationId = config2.mutationId;
    this.mutationCache = config2.mutationCache;
    this.logger = config2.logger || defaultLogger;
    this.observers = [];
    this.state = config2.state || getDefaultState();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = {
      ...this.defaultOptions,
      ...options
    };
    this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(state) {
    this.dispatch({
      type: "setState",
      state
    });
  }
  addObserver(observer) {
    if (this.observers.indexOf(observer) === -1) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.observers = this.observers.filter((x) => x !== observer);
    this.scheduleGc();
    this.mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.observers.length) {
      if (this.state.status === "loading") {
        this.scheduleGc();
      } else {
        this.mutationCache.remove(this);
      }
    }
  }
  continue() {
    var _this$retryer$continu, _this$retryer;
    return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
  }
  async execute() {
    const executeMutation = () => {
      var _this$options$retry;
      this.retryer = createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject("No mutationFn found");
          }
          return this.options.mutationFn(this.state.variables);
        },
        onFail: (failureCount, error) => {
          this.dispatch({
            type: "failed",
            failureCount,
            error
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode
      });
      return this.retryer.promise;
    };
    const restored = this.state.status === "loading";
    try {
      var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
      if (!restored) {
        var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
        this.dispatch({
          type: "loading",
          variables: this.options.variables
        });
        await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
        const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
        if (context !== this.state.context) {
          this.dispatch({
            type: "loading",
            context,
            variables: this.state.variables
          });
        }
      }
      const data = await executeMutation();
      await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data, this.state.variables, this.state.context, this));
      await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data, this.state.variables, this.state.context));
      await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data, null, this.state.variables, this.state.context, this));
      await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data, null, this.state.variables, this.state.context));
      this.dispatch({
        type: "success",
        data
      });
      return data;
    } catch (error) {
      try {
        var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
        await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
        if (false)
          ;
        await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
        await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
        await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
        throw error;
      } finally {
        this.dispatch({
          type: "error",
          error
        });
      }
    }
  }
  dispatch(action) {
    const reducer2 = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "loading":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !canFetch(this.options.networkMode),
            status: "loading",
            variables: action.variables
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer2(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
}
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0
  };
}
class MutationCache extends Subscribable {
  constructor(config2) {
    super();
    this.config = config2 || {};
    this.mutations = [];
    this.mutationId = 0;
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      logger: client.getLogger(),
      mutationId: ++this.mutationId,
      options: client.defaultMutationOptions(options),
      state,
      defaultOptions: options.mutationKey ? client.getMutationDefaults(options.mutationKey) : void 0
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.mutations.push(mutation);
    this.notify({
      type: "added",
      mutation
    });
  }
  remove(mutation) {
    this.mutations = this.mutations.filter((x) => x !== mutation);
    this.notify({
      type: "removed",
      mutation
    });
  }
  clear() {
    notifyManager.batch(() => {
      this.mutations.forEach((mutation) => {
        this.remove(mutation);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(filters) {
    if (typeof filters.exact === "undefined") {
      filters.exact = true;
    }
    return this.mutations.find((mutation) => matchMutation(filters, mutation));
  }
  findAll(filters) {
    return this.mutations.filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    var _this$resuming;
    this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
      const pausedMutations = this.mutations.filter((x) => x.state.isPaused);
      return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop$8)), Promise.resolve()));
    }).then(() => {
      this.resuming = void 0;
    });
    return this.resuming;
  }
}
function infiniteQueryBehavior() {
  return {
    onFetch: (context) => {
      context.fetchFn = () => {
        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
        const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
        const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
        const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
        const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
        const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
        const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
        const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
        let newPageParams = oldPageParams;
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              var _context$signal;
              if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                cancelled = true;
              } else {
                var _context$signal2;
                (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn"));
        const buildNewPages = (pages, param, page, previous) => {
          newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
          return previous ? [page, ...pages] : [...pages, page];
        };
        const fetchPage = (pages, manual, param, previous) => {
          if (cancelled) {
            return Promise.reject("Cancelled");
          }
          if (typeof param === "undefined" && !manual && pages.length) {
            return Promise.resolve(pages);
          }
          const queryFnContext = {
            queryKey: context.queryKey,
            pageParam: param,
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const queryFnResult = queryFn(queryFnContext);
          const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
          return promise2;
        };
        let promise;
        if (!oldPages.length) {
          promise = fetchPage([]);
        } else if (isFetchingNextPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param);
        } else if (isFetchingPreviousPage) {
          const manual = typeof pageParam !== "undefined";
          const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
          promise = fetchPage(oldPages, manual, param, true);
        } else {
          newPageParams = [];
          const manual = typeof context.options.getNextPageParam === "undefined";
          const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
          promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
          for (let i = 1; i < oldPages.length; i++) {
            promise = promise.then((pages) => {
              const shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;
              if (shouldFetchNextPage) {
                const param = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);
                return fetchPage(pages, manual, param);
              }
              return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));
            });
          }
        }
        const finalPromise = promise.then((pages) => ({
          pages,
          pageParams: newPageParams
        }));
        return finalPromise;
      };
    }
  };
}
function getNextPageParam(options, pages) {
  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);
}
function getPreviousPageParam(options, pages) {
  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);
}
function hasNextPage(options, pages) {
  if (options.getNextPageParam && Array.isArray(pages)) {
    const nextPageParam = getNextPageParam(options, pages);
    return typeof nextPageParam !== "undefined" && nextPageParam !== null && nextPageParam !== false;
  }
  return;
}
function hasPreviousPage(options, pages) {
  if (options.getPreviousPageParam && Array.isArray(pages)) {
    const previousPageParam = getPreviousPageParam(options, pages);
    return typeof previousPageParam !== "undefined" && previousPageParam !== null && previousPageParam !== false;
  }
  return;
}
class QueryClient {
  constructor(config2 = {}) {
    this.queryCache = config2.queryCache || new QueryCache();
    this.mutationCache = config2.mutationCache || new MutationCache();
    this.logger = config2.logger || defaultLogger;
    this.defaultOptions = config2.defaultOptions || {};
    this.queryDefaults = [];
    this.mutationDefaults = [];
    this.mountCount = 0;
  }
  mount() {
    this.mountCount++;
    if (this.mountCount !== 1)
      return;
    this.unsubscribeFocus = focusManager.subscribe(() => {
      if (focusManager.isFocused()) {
        this.resumePausedMutations();
        this.queryCache.onFocus();
      }
    });
    this.unsubscribeOnline = onlineManager.subscribe(() => {
      if (onlineManager.isOnline()) {
        this.resumePausedMutations();
        this.queryCache.onOnline();
      }
    });
  }
  unmount() {
    var _this$unsubscribeFocu, _this$unsubscribeOnli;
    this.mountCount--;
    if (this.mountCount !== 0)
      return;
    (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
    this.unsubscribeFocus = void 0;
    (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
    this.unsubscribeOnline = void 0;
  }
  isFetching(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    filters.fetchStatus = "fetching";
    return this.queryCache.findAll(filters).length;
  }
  isMutating(filters) {
    return this.mutationCache.findAll({
      ...filters,
      fetching: true
    }).length;
  }
  getQueryData(queryKey, filters) {
    var _this$queryCache$find;
    return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
  }
  ensureQueryData(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    const cachedData = this.getQueryData(parsedOptions.queryKey);
    return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
  }
  getQueriesData(queryKeyOrFilters) {
    return this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey,
      state
    }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const query = this.queryCache.find(queryKey);
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (typeof data === "undefined") {
      return void 0;
    }
    const parsedOptions = parseQueryArgs(queryKey);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    return this.queryCache.build(this, defaultedOptions).setData(data, {
      ...options,
      manual: true
    });
  }
  setQueriesData(queryKeyOrFilters, updater, options) {
    return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
      queryKey
    }) => [queryKey, this.setQueryData(queryKey, updater, options)]));
  }
  getQueryState(queryKey, filters) {
    var _this$queryCache$find2;
    return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
  }
  removeQueries(arg1, arg2) {
    const [filters] = parseFilterArgs(arg1, arg2);
    const queryCache = this.queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const queryCache = this.queryCache;
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(arg1, arg2, arg3) {
    const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
    if (typeof cancelOptions.revert === "undefined") {
      cancelOptions.revert = true;
    }
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
    return Promise.all(promises).then(noop$8).catch(noop$8);
  }
  invalidateQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    return notifyManager.batch(() => {
      var _ref, _filters$refetchType;
      this.queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(arg1, arg2, arg3) {
    const [filters, options] = parseFilterArgs(arg1, arg2, arg3);
    const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
      var _options$cancelRefetc;
      return query.fetch(void 0, {
        ...options,
        cancelRefetch: (_options$cancelRefetc = options == null ? void 0 : options.cancelRefetch) != null ? _options$cancelRefetc : true,
        meta: {
          refetchPage: filters.refetchPage
        }
      });
    }));
    let promise = Promise.all(promises).then(noop$8);
    if (!(options != null && options.throwOnError)) {
      promise = promise.catch(noop$8);
    }
    return promise;
  }
  fetchQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    const defaultedOptions = this.defaultQueryOptions(parsedOptions);
    if (typeof defaultedOptions.retry === "undefined") {
      defaultedOptions.retry = false;
    }
    const query = this.queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(arg1, arg2, arg3) {
    return this.fetchQuery(arg1, arg2, arg3).then(noop$8).catch(noop$8);
  }
  fetchInfiniteQuery(arg1, arg2, arg3) {
    const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
    parsedOptions.behavior = infiniteQueryBehavior();
    return this.fetchQuery(parsedOptions);
  }
  prefetchInfiniteQuery(arg1, arg2, arg3) {
    return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop$8).catch(noop$8);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(options) {
    this.defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    const result = this.queryDefaults.find((x) => hashQueryKey(queryKey) === hashQueryKey(x.queryKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.queryDefaults.push({
        queryKey,
        defaultOptions: options
      });
    }
  }
  getQueryDefaults(queryKey) {
    if (!queryKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.queryDefaults.find((x) => partialMatchKey(queryKey, x.queryKey));
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  setMutationDefaults(mutationKey, options) {
    const result = this.mutationDefaults.find((x) => hashQueryKey(mutationKey) === hashQueryKey(x.mutationKey));
    if (result) {
      result.defaultOptions = options;
    } else {
      this.mutationDefaults.push({
        mutationKey,
        defaultOptions: options
      });
    }
  }
  getMutationDefaults(mutationKey) {
    if (!mutationKey) {
      return void 0;
    }
    const firstMatchingDefaults = this.mutationDefaults.find((x) => partialMatchKey(mutationKey, x.mutationKey));
    return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
  }
  defaultQueryOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(options == null ? void 0 : options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
    }
    if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (typeof defaultedOptions.useErrorBoundary === "undefined") {
      defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options != null && options._defaulted) {
      return options;
    }
    return {
      ...this.defaultOptions.mutations,
      ...this.getMutationDefaults(options == null ? void 0 : options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.queryCache.clear();
    this.mutationCache.clear();
  }
}
class QueryObserver extends Subscribable {
  constructor(client, options) {
    super();
    this.client = client;
    this.options = options;
    this.trackedProps = /* @__PURE__ */ new Set();
    this.selectError = null;
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.remove = this.remove.bind(this);
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.length === 1) {
      this.currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.currentQuery, this.options)) {
        this.executeFetch();
      }
      this.updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
  }
  destroy() {
    this.listeners = [];
    this.clearStaleTimeout();
    this.clearRefetchInterval();
    this.currentQuery.removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = this.currentQuery;
    this.options = this.client.defaultQueryOptions(options);
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.currentQuery,
        observer: this
      });
    }
    if (typeof this.options.enabled !== "undefined" && typeof this.options.enabled !== "boolean") {
      throw new Error("Expected enabled to be a boolean");
    }
    if (!this.options.queryKey) {
      this.options.queryKey = prevOptions.queryKey;
    }
    this.updateQuery();
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
      this.executeFetch();
    }
    this.updateResult(notifyOptions);
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
      this.updateStaleTimeout();
    }
    const nextRefetchInterval = this.computeRefetchInterval();
    if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
      this.updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.client.getQueryCache().build(this.client, options);
    return this.createResult(query, options);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(result) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackedProps.add(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({
    refetchPage,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        refetchPage
      }
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.client.defaultQueryOptions(options);
    const query = this.client.getQueryCache().build(this.client, defaultedOptions);
    query.isFetchingOptimistic = true;
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    var _fetchOptions$cancelR;
    return this.executeFetch({
      ...fetchOptions,
      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) != null ? _fetchOptions$cancelR : true
    }).then(() => {
      this.updateResult();
      return this.currentResult;
    });
  }
  executeFetch(fetchOptions) {
    this.updateQuery();
    let promise = this.currentQuery.fetch(this.options, fetchOptions);
    if (!(fetchOptions != null && fetchOptions.throwOnError)) {
      promise = promise.catch(noop$8);
    }
    return promise;
  }
  updateStaleTimeout() {
    this.clearStaleTimeout();
    if (isServer$1 || this.currentResult.isStale || !isValidTimeout(this.options.staleTime)) {
      return;
    }
    const time2 = timeUntilStale(this.currentResult.dataUpdatedAt, this.options.staleTime);
    const timeout = time2 + 1;
    this.staleTimeoutId = setTimeout(() => {
      if (!this.currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  computeRefetchInterval() {
    var _this$options$refetch;
    return typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
  }
  updateRefetchInterval(nextInterval) {
    this.clearRefetchInterval();
    this.currentRefetchInterval = nextInterval;
    if (isServer$1 || this.options.enabled === false || !isValidTimeout(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
      return;
    }
    this.refetchIntervalId = setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.executeFetch();
      }
    }, this.currentRefetchInterval);
  }
  updateTimers() {
    this.updateStaleTimeout();
    this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    if (this.staleTimeoutId) {
      clearTimeout(this.staleTimeoutId);
      this.staleTimeoutId = void 0;
    }
  }
  clearRefetchInterval() {
    if (this.refetchIntervalId) {
      clearInterval(this.refetchIntervalId);
      this.refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.currentQuery;
    const prevOptions = this.options;
    const prevResult = this.currentResult;
    const prevResultState = this.currentResultState;
    const prevResultOptions = this.currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
    const prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
    const {
      state
    } = query;
    let {
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      fetchStatus,
      status
    } = state;
    let isPreviousData = false;
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        fetchStatus = canFetch(query.options.networkMode) ? "fetching" : "paused";
        if (!dataUpdatedAt) {
          status = "loading";
        }
      }
      if (options._optimisticResults === "isRestoring") {
        fetchStatus = "idle";
      }
    }
    if (options.keepPreviousData && !state.dataUpdatedAt && prevQueryResult != null && prevQueryResult.isSuccess && status !== "error") {
      data = prevQueryResult.data;
      dataUpdatedAt = prevQueryResult.dataUpdatedAt;
      status = prevQueryResult.status;
      isPreviousData = true;
    } else if (options.select && typeof state.data !== "undefined") {
      if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
        data = this.selectResult;
      } else {
        try {
          this.selectFn = options.select;
          data = options.select(state.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          this.selectResult = data;
          this.selectError = null;
        } catch (selectError) {
          this.selectError = selectError;
        }
      }
    } else {
      data = state.data;
    }
    if (typeof options.placeholderData !== "undefined" && typeof data === "undefined" && status === "loading") {
      let placeholderData;
      if (prevResult != null && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData() : options.placeholderData;
        if (options.select && typeof placeholderData !== "undefined") {
          try {
            placeholderData = options.select(placeholderData);
            this.selectError = null;
          } catch (selectError) {
            this.selectError = selectError;
          }
        }
      }
      if (typeof placeholderData !== "undefined") {
        status = "success";
        data = replaceData(prevResult == null ? void 0 : prevResult.data, placeholderData, options);
        isPlaceholderData = true;
      }
    }
    if (this.selectError) {
      error = this.selectError;
      data = this.selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = fetchStatus === "fetching";
    const isLoading = status === "loading";
    const isError = status === "error";
    const result = {
      status,
      fetchStatus,
      isLoading,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading && isFetching,
      data,
      dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: state.fetchFailureCount,
      failureReason: state.fetchFailureReason,
      errorUpdateCount: state.errorUpdateCount,
      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
      isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isLoading,
      isLoadingError: isError && state.dataUpdatedAt === 0,
      isPaused: fetchStatus === "paused",
      isPlaceholderData,
      isPreviousData,
      isRefetchError: isError && state.dataUpdatedAt !== 0,
      isStale: isStale(query, options),
      refetch: this.refetch,
      remove: this.remove
    };
    return result;
  }
  updateResult(notifyOptions) {
    const prevResult = this.currentResult;
    const nextResult = this.createResult(this.currentQuery, this.options);
    this.currentResultState = this.currentQuery.state;
    this.currentResultOptions = this.options;
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.currentResult = nextResult;
    const defaultNotifyOptions = {
      cache: true
    };
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const {
        notifyOnChangeProps
      } = this.options;
      if (notifyOnChangeProps === "all" || !notifyOnChangeProps && !this.trackedProps.size) {
        return true;
      }
      const includedProps = new Set(notifyOnChangeProps != null ? notifyOnChangeProps : this.trackedProps);
      if (this.options.useErrorBoundary) {
        includedProps.add("error");
      }
      return Object.keys(this.currentResult).some((key) => {
        const typedKey = key;
        const changed = this.currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    this.notify({
      ...defaultNotifyOptions,
      ...notifyOptions
    });
  }
  updateQuery() {
    const query = this.client.getQueryCache().build(this.client, this.options);
    if (query === this.currentQuery) {
      return;
    }
    const prevQuery = this.currentQuery;
    this.currentQuery = query;
    this.currentQueryInitialState = query.state;
    this.previousQueryResult = this.currentResult;
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate(action) {
    const notifyOptions = {};
    if (action.type === "success") {
      notifyOptions.onSuccess = !action.manual;
    } else if (action.type === "error" && !isCancelledError(action.error)) {
      notifyOptions.onError = true;
    }
    this.updateResult(notifyOptions);
    if (this.hasListeners()) {
      this.updateTimers();
    }
  }
  notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.onSuccess) {
        var _this$options$onSucce, _this$options, _this$options$onSettl, _this$options2;
        (_this$options$onSucce = (_this$options = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options, this.currentResult.data);
        (_this$options$onSettl = (_this$options2 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options2, this.currentResult.data, null);
      } else if (notifyOptions.onError) {
        var _this$options$onError, _this$options3, _this$options$onSettl2, _this$options4;
        (_this$options$onError = (_this$options3 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options3, this.currentResult.error);
        (_this$options$onSettl2 = (_this$options4 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options4, void 0, this.currentResult.error);
      }
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.currentResult);
        });
      }
      if (notifyOptions.cache) {
        this.client.getQueryCache().notify({
          query: this.currentQuery,
          type: "observerResultsUpdated"
        });
      }
    });
  }
}
function shouldLoadOnMount(query, options) {
  return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (options.enabled !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return query.isStaleByTime(options.staleTime);
}
class InfiniteQueryObserver extends QueryObserver {
  // Type override
  // Type override
  // Type override
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(client, options) {
    super(client, options);
  }
  bindMethods() {
    super.bindMethods();
    this.fetchNextPage = this.fetchNextPage.bind(this);
    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(options, notifyOptions) {
    super.setOptions({
      ...options,
      behavior: infiniteQueryBehavior()
    }, notifyOptions);
  }
  getOptimisticResult(options) {
    options.behavior = infiniteQueryBehavior();
    return super.getOptimisticResult(options);
  }
  fetchNextPage({
    pageParam,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: {
          direction: "forward",
          pageParam
        }
      }
    });
  }
  fetchPreviousPage({
    pageParam,
    ...options
  } = {}) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: {
          direction: "backward",
          pageParam
        }
      }
    });
  }
  createResult(query, options) {
    var _state$fetchMeta, _state$fetchMeta$fetc, _state$fetchMeta2, _state$fetchMeta2$fet, _state$data, _state$data2;
    const {
      state
    } = query;
    const result = super.createResult(query, options);
    const {
      isFetching,
      isRefetching
    } = result;
    const isFetchingNextPage = isFetching && ((_state$fetchMeta = state.fetchMeta) == null ? void 0 : (_state$fetchMeta$fetc = _state$fetchMeta.fetchMore) == null ? void 0 : _state$fetchMeta$fetc.direction) === "forward";
    const isFetchingPreviousPage = isFetching && ((_state$fetchMeta2 = state.fetchMeta) == null ? void 0 : (_state$fetchMeta2$fet = _state$fetchMeta2.fetchMore) == null ? void 0 : _state$fetchMeta2$fet.direction) === "backward";
    return {
      ...result,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: hasNextPage(options, (_state$data = state.data) == null ? void 0 : _state$data.pages),
      hasPreviousPage: hasPreviousPage(options, (_state$data2 = state.data) == null ? void 0 : _state$data2.pages),
      isFetchingNextPage,
      isFetchingPreviousPage,
      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
    };
  }
}
let MutationObserver$1 = class MutationObserver2 extends Subscribable {
  constructor(client, options) {
    super();
    this.client = client;
    this.setOptions(options);
    this.bindMethods();
    this.updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _this$currentMutation;
    const prevOptions = this.options;
    this.options = this.client.defaultMutationOptions(options);
    if (!shallowEqualObjects(prevOptions, this.options)) {
      this.client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.currentMutation,
        observer: this
      });
    }
    (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
  }
  onUnsubscribe() {
    if (!this.listeners.length) {
      var _this$currentMutation2;
      (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.updateResult();
    const notifyOptions = {
      listeners: true
    };
    if (action.type === "success") {
      notifyOptions.onSuccess = true;
    } else if (action.type === "error") {
      notifyOptions.onError = true;
    }
    this.notify(notifyOptions);
  }
  getCurrentResult() {
    return this.currentResult;
  }
  reset() {
    this.currentMutation = void 0;
    this.updateResult();
    this.notify({
      listeners: true
    });
  }
  mutate(variables, options) {
    this.mutateOptions = options;
    if (this.currentMutation) {
      this.currentMutation.removeObserver(this);
    }
    this.currentMutation = this.client.getMutationCache().build(this.client, {
      ...this.options,
      variables: typeof variables !== "undefined" ? variables : this.options.variables
    });
    this.currentMutation.addObserver(this);
    return this.currentMutation.execute();
  }
  updateResult() {
    const state = this.currentMutation ? this.currentMutation.state : getDefaultState();
    const result = {
      ...state,
      isLoading: state.status === "loading",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
    this.currentResult = result;
  }
  notify(options) {
    notifyManager.batch(() => {
      if (this.mutateOptions && this.hasListeners()) {
        if (options.onSuccess) {
          var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
          (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
        } else if (options.onError) {
          var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
          (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
        }
      }
      if (options.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.currentResult);
        });
      }
    });
  }
};
var shimExports = {};
var shim$1 = {
  get exports() {
    return shimExports;
  },
  set exports(v2) {
    shimExports = v2;
  }
};
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$4 = reactExports;
function h$3(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$4 = "function" === typeof Object.is ? Object.is : h$3, l$3 = e$4.useState, m$3 = e$4.useEffect, n$4 = e$4.useLayoutEffect, p$3 = e$4.useDebugValue;
function q$4(a2, b2) {
  var d3 = b2(), f2 = l$3({ inst: { value: d3, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$4(function() {
    c2.value = d3;
    c2.getSnapshot = b2;
    r$4(c2) && g2({ inst: c2 });
  }, [a2, d3, b2]);
  m$3(function() {
    r$4(c2) && g2({ inst: c2 });
    return a2(function() {
      r$4(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$3(d3);
  return d3;
}
function r$4(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d3 = b2();
    return !k$4(a2, d3);
  } catch (f2) {
    return true;
  }
}
function t$3(a2, b2) {
  return b2();
}
var u$2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$3 : q$4;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$4.useSyncExternalStore ? e$4.useSyncExternalStore : u$2;
(function(module) {
  {
    module.exports = useSyncExternalStoreShim_production_min;
  }
})(shim$1);
const useSyncExternalStore$3 = shimExports.useSyncExternalStore;
const defaultContext = /* @__PURE__ */ reactExports.createContext(void 0);
const QueryClientSharingContext = /* @__PURE__ */ reactExports.createContext(false);
function getQueryClientContext(context, contextSharing) {
  if (context) {
    return context;
  }
  if (contextSharing && typeof window !== "undefined") {
    if (!window.ReactQueryClientContext) {
      window.ReactQueryClientContext = defaultContext;
    }
    return window.ReactQueryClientContext;
  }
  return defaultContext;
}
const useQueryClient = ({
  context
} = {}) => {
  const queryClient2 = reactExports.useContext(getQueryClientContext(context, reactExports.useContext(QueryClientSharingContext)));
  if (!queryClient2) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return queryClient2;
};
const QueryClientProvider = ({
  client,
  children,
  context,
  contextSharing = false
}) => {
  reactExports.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  const Context = getQueryClientContext(context, contextSharing);
  return /* @__PURE__ */ reactExports.createElement(QueryClientSharingContext.Provider, {
    value: !context && contextSharing
  }, /* @__PURE__ */ reactExports.createElement(Context.Provider, {
    value: client
  }, children));
};
const IsRestoringContext = /* @__PURE__ */ reactExports.createContext(false);
const useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
const QueryErrorResetBoundaryContext = /* @__PURE__ */ reactExports.createContext(createValue());
const useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(_useErrorBoundary, params) {
  if (typeof _useErrorBoundary === "function") {
    return _useErrorBoundary(...params);
  }
  return !!_useErrorBoundary;
}
const ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.useErrorBoundary) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
const useClearResetErrorBoundary = (errorResetBoundary) => {
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
const getHasError = ({
  result,
  errorResetBoundary,
  useErrorBoundary,
  query
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && shouldThrowError(useErrorBoundary, [result.error, query]);
};
const ensureStaleTime = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    if (typeof defaultedOptions.staleTime !== "number") {
      defaultedOptions.staleTime = 1e3;
    }
  }
};
const willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
const shouldSuspend = (defaultedOptions, result, isRestoring) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && willFetch(result, isRestoring);
const fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).then(({
  data
}) => {
  defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
}).catch((error) => {
  errorResetBoundary.clearReset();
  defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
  defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(void 0, error);
});
function useBaseQuery(options, Observer) {
  const queryClient2 = useQueryClient({
    context: options.context
  });
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = queryClient2.defaultQueryOptions(options);
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  if (defaultedOptions.onError) {
    defaultedOptions.onError = notifyManager.batchCalls(defaultedOptions.onError);
  }
  if (defaultedOptions.onSuccess) {
    defaultedOptions.onSuccess = notifyManager.batchCalls(defaultedOptions.onSuccess);
  }
  if (defaultedOptions.onSettled) {
    defaultedOptions.onSettled = notifyManager.batchCalls(defaultedOptions.onSettled);
  }
  ensureStaleTime(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const [observer] = reactExports.useState(() => new Observer(queryClient2, defaultedOptions));
  const result = observer.getOptimisticResult(defaultedOptions);
  useSyncExternalStore$3(reactExports.useCallback((onStoreChange) => isRestoring ? () => void 0 : observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer, isRestoring]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions, {
      listeners: false
    });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result, isRestoring)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    useErrorBoundary: defaultedOptions.useErrorBoundary,
    query: observer.getCurrentQuery()
  })) {
    throw result.error;
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery(arg1, arg2, arg3) {
  const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(parsedOptions, QueryObserver);
}
function useMutation(arg1, arg2, arg3) {
  const options = parseMutationArgs(arg1, arg2, arg3);
  const queryClient2 = useQueryClient({
    context: options.context
  });
  const [observer] = reactExports.useState(() => new MutationObserver$1(queryClient2, options));
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = useSyncExternalStore$3(reactExports.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
  const mutate = reactExports.useCallback((variables, mutateOptions) => {
    observer.mutate(variables, mutateOptions).catch(noop$7);
  }, [observer]);
  if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
    throw result.error;
  }
  return {
    ...result,
    mutate,
    mutateAsync: result.mutate
  };
}
function noop$7() {
}
function useInfiniteQuery(arg1, arg2, arg3) {
  const options = parseQueryArgs(arg1, arg2, arg3);
  return useBaseQuery(options, InfiniteQueryObserver);
}
function bind$1(fn2, thisArg) {
  return function wrap() {
    return fn2.apply(thisArg, arguments);
  };
}
const { toString: toString$2 } = Object.prototype;
const { getPrototypeOf: getPrototypeOf$1 } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString$2.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray: isArray$2 } = Array;
const isUndefined$1 = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$4(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView$1(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$2 = typeOfTest("string");
const isFunction$4 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$3 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject$3 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf$1(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$3(val) && isFunction$4(val.pipe);
const isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString$2.call(thing) === pattern || isFunction$4(thing.toString) && thing.toString() === pattern);
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim$1 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$2(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn2.call(null, obj[i], i, obj);
    }
  } else {
    const keys3 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len2 = keys3.length;
    let key;
    for (i = 0; i < len2; i++) {
      key = keys3[i];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys3 = Object.keys(obj);
  let i = keys3.length;
  let _key;
  while (i-- > 0) {
    _key = keys3[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined$1(context) && context !== _global;
function merge$3() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject$3(result[targetKey]) && isPlainObject$3(val)) {
      result[targetKey] = merge$3(result[targetKey], val);
    } else if (isPlainObject$3(val)) {
      result[targetKey] = merge$3({}, val);
    } else if (isArray$2(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend$1 = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction$4(val)) {
      a2[key] = bind$1(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop3;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop3 = props[i];
      if ((!propFilter || propFilter(prop3, sourceObj, destObj)) && !merged[prop3]) {
        destObj[prop3] = sourceObj[prop3];
        merged[prop3] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf$1(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position3) => {
  str = String(str);
  if (position3 === void 0 || position3 > str.length) {
    position3 = str.length;
  }
  position3 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position3);
  return lastIndex !== -1 && lastIndex === position3;
};
const toArray$2 = (thing) => {
  if (!thing)
    return null;
  if (isArray$2(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray$1 = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf$1(Uint8Array));
const forEachEntry = (obj, fn2) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$1 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop3) => hasOwnProperty2.call(obj, prop3))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer2) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    if (reducer2(descriptor, name, obj) !== false) {
      reducedDescriptors[name] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction$4(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction$4(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop$6 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$4(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$3(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray$2(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined$1(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const utils$3 = {
  isArray: isArray$2,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView: isArrayBufferView$1,
  isString: isString$2,
  isNumber,
  isBoolean,
  isObject: isObject$3,
  isPlainObject: isPlainObject$3,
  isUndefined: isUndefined$1,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$4,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray$1,
  isFileList,
  forEach,
  merge: merge$3,
  extend: extend$1,
  trim: trim$1,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$2,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$1,
  hasOwnProp: hasOwnProperty$1,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$6,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
};
function AxiosError(message, code, config2, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils$3.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$3.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$3.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop3) => {
    return prop3 !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$3.isPlainObject(thing) || utils$3.isArray(thing);
}
function removeBrackets(key) {
  return utils$3.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each2(token2, i) {
    token2 = removeBrackets(token2);
    return !dots && i ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$3.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$3.toFlatObject(utils$3, {}, null, function filter(prop3) {
  return /^is[A-Z]/.test(prop3);
});
function toFormData(obj, formData, options) {
  if (!utils$3.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$3.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$3.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$3.isSpecCompliantForm(formData);
  if (!utils$3.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$3.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$3.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$3.isArrayBuffer(value) || utils$3.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$3.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$3.isArray(value) && isFlatArray(value) || (utils$3.isFileList(value) || utils$3.endsWith(key, "[]")) && (arr = utils$3.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el2, index2) {
          !(utils$3.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$3.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$3.forEach(value, function each2(el2, key) {
      const result = !(utils$3.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils$3.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$3.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$3.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn2) {
    utils$3.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$3.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$3.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys3 = Object.keys(arr);
  let i;
  const len2 = keys3.length;
  let key;
  for (i = 0; i < len2; i++) {
    key = keys3[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name = path[index2++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path.length;
    name = !name && utils$3.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$3.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$3.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index2);
    if (result && utils$3.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$3.isFormData(formData) && utils$3.isFunction(formData.entries)) {
    const obj = {};
    utils$3.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser2, encoder) {
  if (utils$3.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$3.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$3 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$3.isObject(data);
    if (isObjectPayload && utils$3.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$3.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$3.isArrayBuffer(data) || utils$3.isBuffer(data) || utils$3.isStream(data) || utils$3.isFile(data) || utils$3.isBlob(data)) {
      return data;
    }
    if (utils$3.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$3.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$3.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults$3.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils$3.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$3.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$3.headers[method] = {};
});
utils$3.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$3.headers[method] = utils$3.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$4 = defaults$3;
const ignoreDuplicateOf = utils$3.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders$1 = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser2(line2) {
    i = line2.indexOf(":");
    key = line2.substring(0, i).trim().toLowerCase();
    val = line2.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$3.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$3.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$3.isString(value))
    return;
  if (utils$3.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$3.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$3.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$3.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders2 = (headers, _rewrite) => utils$3.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$3.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders2(header, valueOrRewrite);
    } else if (utils$3.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders2(parseHeaders$1(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$3.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser2) {
          return value;
        }
        if (parser2 === true) {
          return parseTokens(value);
        }
        if (utils$3.isFunction(parser2)) {
          return parser2.call(this, value, key);
        }
        if (utils$3.isRegExp(parser2)) {
          return parser2.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$3.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$3.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$3.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys3 = Object.keys(this);
    let i = keys3.length;
    let deleted = false;
    while (i--) {
      const key = keys3[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$3.forEach(this, (value, header) => {
      const key = utils$3.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$3.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$3.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$3.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$3.freezeMethods(AxiosHeaders.prototype);
utils$3.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config2 = this || defaults$4;
  const context = response || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$3.forEach(fns, function transform3(fn2) {
    data = fn2.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config2, request2) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils$3.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write2(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils$3.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$3.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$3.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name) {
        const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove: function remove2(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$3.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils$3.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request2 = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitionalDefaults;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils$3.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils$3.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$3.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$3.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length2; i++) {
      nameOrAdapter = adapters2[i];
      if (adapter = utils$3.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils$3.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils$3.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$4.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils$3.isPlainObject(target) && utils$3.isPlainObject(source)) {
      return utils$3.merge.call({ caseless }, target, source);
    } else if (utils$3.isPlainObject(source)) {
      return utils$3.merge({}, source);
    } else if (utils$3.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils$3.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils$3.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$3.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$3.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$3.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop3) {
    if (prop3 in config2) {
      return getMergedValue(a2, b2);
    } else if (prop3 in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils$3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop3) {
    const merge3 = mergeMap[prop3] || mergeDeepProperties;
    const configValue = merge3(config1[prop3], config2[prop3], prop3);
    utils$3.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config3[prop3] = configValue);
  });
  return config3;
}
const VERSION = "1.3.4";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys3 = Object.keys(options);
  let i = keys3.length;
  while (i-- > 0) {
    const opt = keys3[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator.assertOptions(paramsSerializer, {
        encode: validators.function,
        serialize: validators.function
      }, true);
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils$3.merge(
      headers.common,
      headers[config2.method]
    );
    contextHeaders && utils$3.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len2;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len2 = chain.length;
      promise = Promise.resolve(config2);
      while (i < len2) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len2 = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len2) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len2 = responseInterceptorChain.length;
    while (i < len2) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils$3.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$3.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i = token2._listeners.length;
      while (i-- > 0) {
        token2._listeners[i](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config2, request2);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback2) {
  return function wrap(arr) {
    return callback2.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$3.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind$1(Axios$1.prototype.request, context);
  utils$3.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$3.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$4);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$3.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
function trimArrayEnd(arr) {
  let lastDefinedValueIndex = arr.length - 1;
  while (lastDefinedValueIndex >= 0) {
    if (arr[lastDefinedValueIndex] === void 0) {
      lastDefinedValueIndex--;
    } else {
      break;
    }
  }
  return lastDefinedValueIndex === arr.length - 1 ? arr : arr.slice(0, lastDefinedValueIndex + 1);
}
function addMetaToOptions(options, metaContext) {
  if (metaContext.metaFn) {
    options = options ?? {};
    options.meta = {
      ...metaContext.metaFn(),
      ...options.meta
    };
  }
  return options;
}
function isParameterObject(param) {
  if (param === null || param === void 0)
    return false;
  if (param instanceof Array)
    return false;
  const isObject3 = typeof param === "object";
  if (!isObject3)
    return false;
  if (param instanceof Date)
    return false;
  return true;
}
let _baseUrl = "";
function getBaseUrl() {
  return _baseUrl;
}
function setBaseUrl(baseUrl) {
  _baseUrl = baseUrl;
}
let _axiosFactory = () => void 0;
function getAxios() {
  return (_axiosFactory == null ? void 0 : _axiosFactory()) ?? axios$1;
}
function setAxiosFactory(factory3) {
  _axiosFactory = factory3;
}
function commentsAll(videoId, config2) {
  let url_ = getBaseUrl() + "/api/Comments/{videoId}";
  if (videoId === void 0 || videoId === null)
    throw new Error("The parameter 'videoId' must be defined.");
  url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigCommentsAll,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processCommentsAll(_response);
  });
}
function processCommentsAll(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(CommentDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function commentsDELETE(id2, config2) {
  let url_ = getBaseUrl() + "/api/Comments/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigCommentsDELETE,
    ...config2,
    method: "DELETE",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processCommentsDELETE(_response);
  });
}
function processCommentsDELETE(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function commentsPOST(body, config2) {
  let url_ = getBaseUrl() + "/api/Comments";
  url_ = url_.replace(/[?&]$/, "");
  const content_ = JSON.stringify(body);
  let options_ = {
    ..._requestConfigCommentsPOST,
    ...config2,
    data: content_,
    method: "POST",
    url: url_,
    headers: {
      "Content-Type": "application/json"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processCommentsPOST(_response);
  });
}
function processCommentsPOST(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function myChannels(config2) {
  let url_ = getBaseUrl() + "/api/Channels/my-channels";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigMyChannels,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processMyChannels(_response);
  });
}
function processMyChannels(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(ChannelDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelsAll(config2) {
  let url_ = getBaseUrl() + "/api/Channels";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigChannelsAll,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelsAll(_response);
  });
}
function processChannelsAll(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(ChannelDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelsPOST(name, poster, pinnedVideoId, avatar, description, relatedChannels, config2) {
  let url_ = getBaseUrl() + "/api/Channels";
  url_ = url_.replace(/[?&]$/, "");
  const content_ = new FormData();
  if (name !== null && name !== void 0)
    content_.append("Name", name.toString());
  if (poster !== null && poster !== void 0)
    content_.append("Poster", poster.data, poster.fileName ? poster.fileName : "Poster");
  if (pinnedVideoId !== null && pinnedVideoId !== void 0)
    content_.append("PinnedVideoId", pinnedVideoId.toString());
  if (avatar !== null && avatar !== void 0)
    content_.append("Avatar", avatar.data, avatar.fileName ? avatar.fileName : "Avatar");
  if (description !== null && description !== void 0)
    content_.append("Description", description.toString());
  if (relatedChannels !== null && relatedChannels !== void 0)
    relatedChannels.forEach((item_) => content_.append("RelatedChannels", item_.toString()));
  let options_ = {
    ..._requestConfigChannelsPOST,
    ...config2,
    data: content_,
    method: "POST",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelsPOST(_response);
  });
}
function processChannelsPOST(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = ChannelDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelsGET(id2, config2) {
  let url_ = getBaseUrl() + "/api/Channels/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigChannelsGET,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelsGET(_response);
  });
}
function processChannelsGET(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = ChannelDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelsPUT(id2, name, poster, pinnedVideoId, avatar, description, relatedChannels, config2) {
  let url_ = getBaseUrl() + "/api/Channels/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  const content_ = new FormData();
  if (name !== null && name !== void 0)
    content_.append("Name", name.toString());
  if (poster !== null && poster !== void 0)
    content_.append("Poster", poster.data, poster.fileName ? poster.fileName : "Poster");
  if (pinnedVideoId !== null && pinnedVideoId !== void 0)
    content_.append("PinnedVideoId", pinnedVideoId.toString());
  if (avatar !== null && avatar !== void 0)
    content_.append("Avatar", avatar.data, avatar.fileName ? avatar.fileName : "Avatar");
  if (description !== null && description !== void 0)
    content_.append("Description", description.toString());
  if (relatedChannels !== null && relatedChannels !== void 0)
    relatedChannels.forEach((item_) => content_.append("RelatedChannels", item_.toString()));
  let options_ = {
    ..._requestConfigChannelsPUT,
    ...config2,
    data: content_,
    method: "PUT",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelsPUT(_response);
  });
}
function processChannelsPUT(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelsDELETE(id2, config2) {
  let url_ = getBaseUrl() + "/api/Channels/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigChannelsDELETE,
    ...config2,
    method: "DELETE",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelsDELETE(_response);
  });
}
function processChannelsDELETE(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelVideos(id2, limit, offset3, config2) {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-videos?";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
  else if (limit !== void 0)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
  if (offset3 === null)
    throw new Error("The parameter 'offset' cannot be null.");
  else if (offset3 !== void 0)
    url_ += "offset=" + encodeURIComponent("" + offset3) + "&";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigChannelVideos,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelVideos(_response);
  });
}
function processChannelVideos(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = WithTotalCountOfVideoDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelPlaylists(id2, limit, offset3, config2) {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-playlists?";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
  else if (limit !== void 0)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
  if (offset3 === null)
    throw new Error("The parameter 'offset' cannot be null.");
  else if (offset3 !== void 0)
    url_ += "offset=" + encodeURIComponent("" + offset3) + "&";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigChannelPlaylists,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelPlaylists(_response);
  });
}
function processChannelPlaylists(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = WithTotalCountOfPlaylistDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelAdvancedInfo(id2, config2) {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-advanced-info";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigChannelAdvancedInfo,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelAdvancedInfo(_response);
  });
}
function processChannelAdvancedInfo(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = ChannelAdvancedInfoDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelUserInfoGET(id2, config2) {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-user-info";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigChannelUserInfoGET,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelUserInfoGET(_response);
  });
}
function processChannelUserInfoGET(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = ChannelUserSpecificInfoDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function channelUserInfoPUT(id2, body, config2) {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-user-info";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  const content_ = JSON.stringify(body);
  let options_ = {
    ..._requestConfigChannelUserInfoPUT,
    ...config2,
    data: content_,
    method: "PUT",
    url: url_,
    headers: {
      "Content-Type": "application/json"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processChannelUserInfoPUT(_response);
  });
}
function processChannelUserInfoPUT(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function myPlaylists(config2) {
  let url_ = getBaseUrl() + "/api/Playlists/my-playlists";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigMyPlaylists,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processMyPlaylists(_response);
  });
}
function processMyPlaylists(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(PlaylistDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function playlistsGET(id2, config2) {
  let url_ = getBaseUrl() + "/api/Playlists/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigPlaylistsGET,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processPlaylistsGET(_response);
  });
}
function processPlaylistsGET(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = PlaylistDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function playlistsPUT(id2, name, description, thumbnail, videos, channelId, config2) {
  let url_ = getBaseUrl() + "/api/Playlists/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  const content_ = new FormData();
  if (name !== null && name !== void 0)
    content_.append("Name", name.toString());
  if (description !== null && description !== void 0)
    content_.append("Description", description.toString());
  if (thumbnail !== null && thumbnail !== void 0)
    content_.append("Thumbnail", thumbnail.data, thumbnail.fileName ? thumbnail.fileName : "Thumbnail");
  if (videos !== null && videos !== void 0)
    videos.forEach((item_) => content_.append("Videos", item_.toString()));
  if (channelId !== null && channelId !== void 0)
    content_.append("ChannelId", channelId.toString());
  let options_ = {
    ..._requestConfigPlaylistsPUT,
    ...config2,
    data: content_,
    method: "PUT",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processPlaylistsPUT(_response);
  });
}
function processPlaylistsPUT(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function playlistsDELETE(id2, config2) {
  let url_ = getBaseUrl() + "/api/Playlists/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigPlaylistsDELETE,
    ...config2,
    method: "DELETE",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processPlaylistsDELETE(_response);
  });
}
function processPlaylistsDELETE(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function video$1(id2, videoId, add3, config2) {
  let url_ = getBaseUrl() + "/api/Playlists/{id}/video/{videoId}?";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  if (videoId === void 0 || videoId === null)
    throw new Error("The parameter 'videoId' must be defined.");
  url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  if (add3 === null)
    throw new Error("The parameter 'add' cannot be null.");
  else if (add3 !== void 0)
    url_ += "add=" + encodeURIComponent("" + add3) + "&";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigVideo,
    ...config2,
    method: "PUT",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processVideo(_response);
  });
}
function processVideo(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function playlistsPOST(name, description, thumbnail, videos, channelId, config2) {
  let url_ = getBaseUrl() + "/api/Playlists";
  url_ = url_.replace(/[?&]$/, "");
  const content_ = new FormData();
  if (name !== null && name !== void 0)
    content_.append("Name", name.toString());
  if (description !== null && description !== void 0)
    content_.append("Description", description.toString());
  if (thumbnail !== null && thumbnail !== void 0)
    content_.append("Thumbnail", thumbnail.data, thumbnail.fileName ? thumbnail.fileName : "Thumbnail");
  if (videos !== null && videos !== void 0)
    videos.forEach((item_) => content_.append("Videos", item_.toString()));
  if (channelId !== null && channelId !== void 0)
    content_.append("ChannelId", channelId.toString());
  let options_ = {
    ..._requestConfigPlaylistsPOST,
    ...config2,
    data: content_,
    method: "POST",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processPlaylistsPOST(_response);
  });
}
function processPlaylistsPOST(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function search(q2, limit, offset3, config2) {
  let url_ = getBaseUrl() + "/api/Search?";
  if (q2 === null)
    throw new Error("The parameter 'q' cannot be null.");
  else if (q2 !== void 0)
    url_ += "q=" + encodeURIComponent("" + q2) + "&";
  if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
  else if (limit !== void 0)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
  if (offset3 === null)
    throw new Error("The parameter 'offset' cannot be null.");
  else if (offset3 !== void 0)
    url_ += "offset=" + encodeURIComponent("" + offset3) + "&";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigSearch,
    ...config2,
    method: "PUT",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processSearch(_response);
  });
}
function processSearch(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = WithTotalCountOfVideoDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function tagsAll(config2) {
  let url_ = getBaseUrl() + "/api/Tags";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigTagsAll,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processTagsAll(_response);
  });
}
function processTagsAll(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(TagDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function tagsPOST(body, config2) {
  let url_ = getBaseUrl() + "/api/Tags";
  url_ = url_.replace(/[?&]$/, "");
  const content_ = JSON.stringify(body);
  let options_ = {
    ..._requestConfigTagsPOST,
    ...config2,
    data: content_,
    method: "POST",
    url: url_,
    headers: {
      "Content-Type": "application/json"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processTagsPOST(_response);
  });
}
function processTagsPOST(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function tagsWithVideos(config2) {
  let url_ = getBaseUrl() + "/api/Tags/tagsWithVideos";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigTagsWithVideos,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processTagsWithVideos(_response);
  });
}
function processTagsWithVideos(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(Tag.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function tagsDELETE(id2, config2) {
  let url_ = getBaseUrl() + "/api/Tags/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigTagsDELETE,
    ...config2,
    method: "DELETE",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processTagsDELETE(_response);
  });
}
function processTagsDELETE(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function login(body, config2) {
  let url_ = getBaseUrl() + "/api/users/login";
  url_ = url_.replace(/[?&]$/, "");
  const content_ = JSON.stringify(body);
  let options_ = {
    ..._requestConfigLogin,
    ...config2,
    data: content_,
    method: "POST",
    url: url_,
    headers: {
      "Content-Type": "application/json",
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processLogin(_response);
  });
}
function processLogin(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = resultData200 !== void 0 ? resultData200 : null;
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function register$1(body, config2) {
  let url_ = getBaseUrl() + "/api/users/register";
  url_ = url_.replace(/[?&]$/, "");
  const content_ = JSON.stringify(body);
  let options_ = {
    ..._requestConfigRegister,
    ...config2,
    data: content_,
    method: "POST",
    url: url_,
    headers: {
      "Content-Type": "application/json",
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processRegister(_response);
  });
}
function processRegister(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = resultData200 !== void 0 ? resultData200 : null;
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function me$1(config2) {
  let url_ = getBaseUrl() + "/api/users/me";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigMe,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processMe(_response);
  });
}
function processMe(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = UserDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function usersAll(config2) {
  let url_ = getBaseUrl() + "/api/users";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigUsersAll,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processUsersAll(_response);
  });
}
function processUsersAll(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(UserDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function usersPUT(id2, body, config2) {
  let url_ = getBaseUrl() + "/api/users/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  const content_ = JSON.stringify(body);
  let options_ = {
    ..._requestConfigUsersPUT,
    ...config2,
    data: content_,
    method: "PUT",
    url: url_,
    headers: {
      "Content-Type": "application/json"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processUsersPUT(_response);
  });
}
function processUsersPUT(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function usersDELETE(id2, config2) {
  let url_ = getBaseUrl() + "/api/users/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigUsersDELETE,
    ...config2,
    method: "DELETE",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processUsersDELETE(_response);
  });
}
function processUsersDELETE(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function usersGET(id2, config2) {
  let url_ = getBaseUrl() + "/api/users/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigUsersGET,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processUsersGET(_response);
  });
}
function processUsersGET(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = UserDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function userVideoStatsGET(videoId, config2) {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";
  if (videoId === void 0 || videoId === null)
    throw new Error("The parameter 'videoId' must be defined.");
  url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigUserVideoStatsGET,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processUserVideoStatsGET(_response);
  });
}
function processUserVideoStatsGET(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = UserVideoStats.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function userVideoStatsPUT(videoId, body, config2) {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";
  if (videoId === void 0 || videoId === null)
    throw new Error("The parameter 'videoId' must be defined.");
  url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  const content_ = JSON.stringify(body);
  let options_ = {
    ..._requestConfigUserVideoStatsPUT,
    ...config2,
    data: content_,
    method: "PUT",
    url: url_,
    headers: {
      "Content-Type": "application/json"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processUserVideoStatsPUT(_response);
  });
}
function processUserVideoStatsPUT(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function watched(videoId, body, config2) {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}/watched";
  if (videoId === void 0 || videoId === null)
    throw new Error("The parameter 'videoId' must be defined.");
  url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  const content_ = JSON.stringify(body);
  let options_ = {
    ..._requestConfigWatched,
    ...config2,
    data: content_,
    method: "PUT",
    url: url_,
    headers: {
      "Content-Type": "application/json"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processWatched(_response);
  });
}
function processWatched(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function videosAll(orderBy, limit, offset3, config2) {
  let url_ = getBaseUrl() + "/api/Videos?";
  if (orderBy === null)
    throw new Error("The parameter 'orderBy' cannot be null.");
  else if (orderBy !== void 0)
    url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
  if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
  else if (limit !== void 0)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
  if (offset3 === null)
    throw new Error("The parameter 'offset' cannot be null.");
  else if (offset3 !== void 0)
    url_ += "offset=" + encodeURIComponent("" + offset3) + "&";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigVideosAll,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processVideosAll(_response);
  });
}
function processVideosAll(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(VideoDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function videosPOST(fileName, name, description, durationSec, image, channelId, tags2, config2) {
  let url_ = getBaseUrl() + "/api/Videos";
  url_ = url_.replace(/[?&]$/, "");
  const content_ = new FormData();
  if (fileName !== null && fileName !== void 0)
    content_.append("FileName", fileName.toString());
  if (name !== null && name !== void 0)
    content_.append("Name", name.toString());
  if (description !== null && description !== void 0)
    content_.append("Description", description.toString());
  if (durationSec === null || durationSec === void 0)
    throw new Error("The parameter 'durationSec' cannot be null.");
  else
    content_.append("DurationSec", durationSec.toString());
  if (image !== null && image !== void 0)
    content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
  if (channelId === null || channelId === void 0)
    throw new Error("The parameter 'channelId' cannot be null.");
  else
    content_.append("ChannelId", channelId.toString());
  if (tags2 !== null && tags2 !== void 0)
    tags2.forEach((item_) => content_.append("Tags", item_.toString()));
  let options_ = {
    ..._requestConfigVideosPOST,
    ...config2,
    data: content_,
    method: "POST",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processVideosPOST(_response);
  });
}
function processVideosPOST(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = PostVideoResponse.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function videosGET(id2, config2) {
  let url_ = getBaseUrl() + "/api/Videos/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigVideosGET,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processVideosGET(_response);
  });
}
function processVideosGET(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    result200 = VideoDTO.fromJS(resultData200);
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function videosPUT(id2, name, description, image, channelId, tags2, config2) {
  let url_ = getBaseUrl() + "/api/Videos/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  const content_ = new FormData();
  if (name !== null && name !== void 0)
    content_.append("Name", name.toString());
  if (description !== null && description !== void 0)
    content_.append("Description", description.toString());
  if (image !== null && image !== void 0)
    content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
  if (channelId === null || channelId === void 0)
    throw new Error("The parameter 'channelId' cannot be null.");
  else
    content_.append("ChannelId", channelId.toString());
  if (tags2 !== null && tags2 !== void 0)
    tags2.forEach((item_) => content_.append("Tags", item_.toString()));
  let options_ = {
    ..._requestConfigVideosPUT,
    ...config2,
    data: content_,
    method: "PUT",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processVideosPUT(_response);
  });
}
function processVideosPUT(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function videosDELETE(id2, config2) {
  let url_ = getBaseUrl() + "/api/Videos/{id}";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigVideosDELETE,
    ...config2,
    method: "DELETE",
    url: url_,
    headers: {}
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processVideosDELETE(_response);
  });
}
function processVideosDELETE(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    response.data;
    return Promise.resolve(null);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function videoPlaylists(id2, config2) {
  let url_ = getBaseUrl() + "/api/Videos/{id}/video-playlists";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigVideoPlaylists,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processVideoPlaylists(_response);
  });
}
function processVideoPlaylists(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(item);
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function myVideos(config2) {
  let url_ = getBaseUrl() + "/api/Videos/my-videos";
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigMyVideos,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processMyVideos(_response);
  });
}
function processMyVideos(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(VideoDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
function relatedVideos(id2, config2) {
  let url_ = getBaseUrl() + "/api/Videos/{id}/related-videos";
  if (id2 === void 0 || id2 === null)
    throw new Error("The parameter 'id' must be defined.");
  url_ = url_.replace("{id}", encodeURIComponent("" + id2));
  url_ = url_.replace(/[?&]$/, "");
  let options_ = {
    ..._requestConfigRelatedVideos,
    ...config2,
    method: "GET",
    url: url_,
    headers: {
      "Accept": "text/plain"
    }
  };
  return getAxios().request(options_).catch((_error) => {
    if (isAxiosError(_error) && _error.response) {
      return _error.response;
    } else {
      throw _error;
    }
  }).then((_response) => {
    return processRelatedVideos(_response);
  });
}
function processRelatedVideos(response) {
  const status = response.status;
  let _headers = {};
  if (response.headers && typeof response.headers === "object") {
    for (let k2 in response.headers) {
      if (response.headers.hasOwnProperty(k2)) {
        _headers[k2] = response.headers[k2];
      }
    }
  }
  if (status === 200) {
    const _responseText = response.data;
    let result200 = null;
    let resultData200 = _responseText;
    if (Array.isArray(resultData200)) {
      result200 = [];
      for (let item of resultData200)
        result200.push(VideoDTO.fromJS(item));
    } else {
      result200 = null;
    }
    return Promise.resolve(result200);
  } else if (status !== 200 && status !== 204) {
    const _responseText = response.data;
    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
  }
  return Promise.resolve(null);
}
let _requestConfigCommentsAll;
let _requestConfigCommentsDELETE;
let _requestConfigCommentsPOST;
let _requestConfigMyChannels;
let _requestConfigChannelsAll;
let _requestConfigChannelsPOST;
let _requestConfigChannelsGET;
let _requestConfigChannelsPUT;
let _requestConfigChannelsDELETE;
let _requestConfigChannelVideos;
let _requestConfigChannelPlaylists;
let _requestConfigChannelAdvancedInfo;
let _requestConfigChannelUserInfoGET;
let _requestConfigChannelUserInfoPUT;
let _requestConfigMyPlaylists;
let _requestConfigPlaylistsGET;
let _requestConfigPlaylistsPUT;
let _requestConfigPlaylistsDELETE;
let _requestConfigVideo;
let _requestConfigPlaylistsPOST;
let _requestConfigSearch;
let _requestConfigTagsAll;
let _requestConfigTagsPOST;
let _requestConfigTagsWithVideos;
let _requestConfigTagsDELETE;
let _requestConfigLogin;
let _requestConfigRegister;
let _requestConfigMe;
let _requestConfigUsersAll;
let _requestConfigUsersPUT;
let _requestConfigUsersDELETE;
let _requestConfigUsersGET;
let _requestConfigUserVideoStatsGET;
let _requestConfigUserVideoStatsPUT;
let _requestConfigWatched;
let _requestConfigVideosAll;
let _requestConfigVideosPOST;
let _requestConfigVideosGET;
let _requestConfigVideosPUT;
let _requestConfigVideosDELETE;
let _requestConfigVideoPlaylists;
let _requestConfigMyVideos;
let _requestConfigRelatedVideos;
var distExports = {};
var dist = {
  get exports() {
    return distExports;
  },
  set exports(v2) {
    distExports = v2;
  }
};
var reactQuerySwagger_cjs_production_min = {};
Object.defineProperty(reactQuerySwagger_cjs_production_min, "__esModule", { value: true });
var e$3, t$2 = reactExports, r$3 = (e$3 = t$2) && "object" == typeof e$3 && "default" in e$3 ? e$3.default : e$3;
function n$3() {
  return (n$3 = Object.assign || function(e2) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var r3 = arguments[t3];
      for (var n2 in r3)
        Object.prototype.hasOwnProperty.call(r3, n2) && (e2[n2] = r3[n2]);
    }
    return e2;
  }).apply(this, arguments);
}
var a = r$3.createContext({});
reactQuerySwagger_cjs_production_min.QueryMetaContext = a, reactQuerySwagger_cjs_production_min.QueryMetaProvider = function(e2) {
  var o = t$2.useContext(a), u2 = t$2.useMemo(function() {
    return { metaFn: function() {
      var t3 = e2.metaFn ? e2.metaFn() : e2.meta;
      return n$3({}, e2.resetParentMeta || !o.metaFn ? {} : o.metaFn(), t3);
    } };
  }, [o.metaFn, e2.metaFn, e2.meta, e2.resetParentMeta]);
  return r$3.createElement(a.Provider, { value: u2 }, e2.children);
};
(function(module) {
  {
    module.exports = reactQuerySwagger_cjs_production_min;
  }
})(dist);
let commentsAllDefaultOptions = {
  queryFn: __commentsAll
};
function commentsAllQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { videoId } = params[0];
    return trimArrayEnd([
      "Client",
      "commentsAll",
      videoId
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "commentsAll",
      ...params
    ]);
  }
}
function __commentsAll(context) {
  return commentsAll(
    context.queryKey[2]
  );
}
function useCommentsAllQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let videoId = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ videoId } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [videoId, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __commentsAll,
    queryKey: commentsAllQueryKey(videoId),
    ...commentsAllDefaultOptions,
    ...options
  });
}
function commentsDELETEMutationKey(id2) {
  return trimArrayEnd([
    "Client",
    "commentsDELETE",
    id2
  ]);
}
function useCommentsDELETEMutation(id2, options) {
  const key = commentsDELETEMutationKey(id2);
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation(() => commentsDELETE(id2), { ...options, mutationKey: key });
}
function commentsPOSTMutationKey() {
  return trimArrayEnd([
    "Client",
    "commentsPOST"
  ]);
}
function useCommentsPOSTMutation(options) {
  const key = commentsPOSTMutationKey();
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((body) => commentsPOST(body), { ...options, mutationKey: key });
}
let myChannelsDefaultOptions = {
  queryFn: __myChannels
};
function myChannelsQueryKey(...params) {
  return trimArrayEnd([
    "Client",
    "myChannels"
  ]);
}
function __myChannels() {
  return myChannels();
}
function useMyChannelsQuery(...params) {
  let options = void 0;
  let axiosConfig;
  options = params[0];
  axiosConfig = params[1];
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __myChannels,
    queryKey: myChannelsQueryKey(),
    ...myChannelsDefaultOptions,
    ...options
  });
}
let channelsAllDefaultOptions = {
  queryFn: __channelsAll
};
function channelsAllQueryKey(...params) {
  return trimArrayEnd([
    "Client",
    "channelsAll"
  ]);
}
function __channelsAll() {
  return channelsAll();
}
function useChannelsAllQuery(...params) {
  let options = void 0;
  let axiosConfig;
  options = params[0];
  axiosConfig = params[1];
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __channelsAll,
    queryKey: channelsAllQueryKey(),
    ...channelsAllDefaultOptions,
    ...options
  });
}
function channelsPOSTMutationKey() {
  return trimArrayEnd([
    "Client",
    "channelsPOST"
  ]);
}
function useChannelsPOSTMutation(options) {
  const key = channelsPOSTMutationKey();
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((channelsPOSTMutationParameters) => channelsPOST(channelsPOSTMutationParameters.name, channelsPOSTMutationParameters.poster, channelsPOSTMutationParameters.pinnedVideoId, channelsPOSTMutationParameters.avatar, channelsPOSTMutationParameters.description, channelsPOSTMutationParameters.relatedChannels), { ...options, mutationKey: key });
}
function channelsPUTMutationKey(id2) {
  return trimArrayEnd([
    "Client",
    "channelsPUT",
    id2
  ]);
}
function useChannelsPUTMutation(id2, options) {
  const key = channelsPUTMutationKey(id2);
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((channelsPUTMutationParameters) => channelsPUT(id2, channelsPUTMutationParameters.name, channelsPUTMutationParameters.poster, channelsPUTMutationParameters.pinnedVideoId, channelsPUTMutationParameters.avatar, channelsPUTMutationParameters.description, channelsPUTMutationParameters.relatedChannels), { ...options, mutationKey: key });
}
let channelVideosDefaultOptions = {
  queryFn: __channelVideos
};
function channelVideosQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id: id2, limit, offset: offset3 } = params[0];
    return trimArrayEnd([
      "Client",
      "channelVideos",
      id2,
      limit,
      offset3
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "channelVideos",
      ...params
    ]);
  }
}
function __channelVideos(context) {
  return channelVideos(
    context.queryKey[2],
    context.queryKey[3],
    context.queryKey[4]
  );
}
function useChannelVideosQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let id2 = void 0;
  let limit = void 0;
  let offset3 = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id: id2, limit, offset: offset3 } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id2, limit, offset3, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __channelVideos,
    queryKey: channelVideosQueryKey(id2, limit, offset3),
    ...channelVideosDefaultOptions,
    ...options
  });
}
function channelPlaylistsQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id: id2, limit, offset: offset3 } = params[0];
    return trimArrayEnd([
      "Client",
      "channelPlaylists",
      id2,
      limit,
      offset3
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "channelPlaylists",
      ...params
    ]);
  }
}
let channelAdvancedInfoDefaultOptions = {
  queryFn: __channelAdvancedInfo
};
function channelAdvancedInfoQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id: id2 } = params[0];
    return trimArrayEnd([
      "Client",
      "channelAdvancedInfo",
      id2
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "channelAdvancedInfo",
      ...params
    ]);
  }
}
function __channelAdvancedInfo(context) {
  return channelAdvancedInfo(
    context.queryKey[2]
  );
}
function useChannelAdvancedInfoQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let id2 = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id: id2 } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id2, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __channelAdvancedInfo,
    queryKey: channelAdvancedInfoQueryKey(id2),
    ...channelAdvancedInfoDefaultOptions,
    ...options
  });
}
let channelUserInfoGETDefaultOptions = {
  queryFn: __channelUserInfoGET
};
function channelUserInfoGETQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id: id2 } = params[0];
    return trimArrayEnd([
      "Client",
      "channelUserInfoGET",
      id2
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "channelUserInfoGET",
      ...params
    ]);
  }
}
function __channelUserInfoGET(context) {
  return channelUserInfoGET(
    context.queryKey[2]
  );
}
function useChannelUserInfoGETQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let id2 = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id: id2 } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id2, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __channelUserInfoGET,
    queryKey: channelUserInfoGETQueryKey(id2),
    ...channelUserInfoGETDefaultOptions,
    ...options
  });
}
function channelUserInfoPUTMutationKey(id2) {
  return trimArrayEnd([
    "Client",
    "channelUserInfoPUT",
    id2
  ]);
}
function useChannelUserInfoPUTMutation(id2, options) {
  const key = channelUserInfoPUTMutationKey(id2);
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((body) => channelUserInfoPUT(id2, body), { ...options, mutationKey: key });
}
let myPlaylistsDefaultOptions = {
  queryFn: __myPlaylists
};
function myPlaylistsQueryKey(...params) {
  return trimArrayEnd([
    "Client",
    "myPlaylists"
  ]);
}
function __myPlaylists() {
  return myPlaylists();
}
function useMyPlaylistsQuery(...params) {
  let options = void 0;
  let axiosConfig;
  options = params[0];
  axiosConfig = params[1];
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __myPlaylists,
    queryKey: myPlaylistsQueryKey(),
    ...myPlaylistsDefaultOptions,
    ...options
  });
}
function playlistsPUTMutationKey(id2) {
  return trimArrayEnd([
    "Client",
    "playlistsPUT",
    id2
  ]);
}
function usePlaylistsPUTMutation(id2, options) {
  const key = playlistsPUTMutationKey(id2);
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((playlistsPUTMutationParameters) => playlistsPUT(id2, playlistsPUTMutationParameters.name, playlistsPUTMutationParameters.description, playlistsPUTMutationParameters.thumbnail, playlistsPUTMutationParameters.videos, playlistsPUTMutationParameters.channelId), { ...options, mutationKey: key });
}
function playlistsPOSTMutationKey() {
  return trimArrayEnd([
    "Client",
    "playlistsPOST"
  ]);
}
function usePlaylistsPOSTMutation(options) {
  const key = playlistsPOSTMutationKey();
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((playlistsPOSTMutationParameters) => playlistsPOST(playlistsPOSTMutationParameters.name, playlistsPOSTMutationParameters.description, playlistsPOSTMutationParameters.thumbnail, playlistsPOSTMutationParameters.videos, playlistsPOSTMutationParameters.channelId), { ...options, mutationKey: key });
}
function searchMutationKey(q2, limit, offset3) {
  return trimArrayEnd([
    "Client",
    "search",
    q2,
    limit,
    offset3
  ]);
}
let tagsAllDefaultOptions = {
  queryFn: __tagsAll
};
function tagsAllQueryKey(...params) {
  return trimArrayEnd([
    "Client",
    "tagsAll"
  ]);
}
function __tagsAll() {
  return tagsAll();
}
function useTagsAllQuery(...params) {
  let options = void 0;
  let axiosConfig;
  options = params[0];
  axiosConfig = params[1];
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __tagsAll,
    queryKey: tagsAllQueryKey(),
    ...tagsAllDefaultOptions,
    ...options
  });
}
function tagsPOSTMutationKey() {
  return trimArrayEnd([
    "Client",
    "tagsPOST"
  ]);
}
function useTagsPOSTMutation(options) {
  const key = tagsPOSTMutationKey();
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((body) => tagsPOST(body), { ...options, mutationKey: key });
}
let tagsWithVideosDefaultOptions = {
  queryFn: __tagsWithVideos
};
function tagsWithVideosQueryKey(...params) {
  return trimArrayEnd([
    "Client",
    "tagsWithVideos"
  ]);
}
function __tagsWithVideos() {
  return tagsWithVideos();
}
function useTagsWithVideosQuery(...params) {
  let options = void 0;
  let axiosConfig;
  options = params[0];
  axiosConfig = params[1];
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __tagsWithVideos,
    queryKey: tagsWithVideosQueryKey(),
    ...tagsWithVideosDefaultOptions,
    ...options
  });
}
function loginMutationKey() {
  return trimArrayEnd([
    "Client",
    "login"
  ]);
}
function useLoginMutation(options) {
  const key = loginMutationKey();
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((body) => login(body), { ...options, mutationKey: key });
}
function registerMutationKey() {
  return trimArrayEnd([
    "Client",
    "register"
  ]);
}
function useRegisterMutation(options) {
  const key = registerMutationKey();
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((body) => register$1(body), { ...options, mutationKey: key });
}
let meDefaultOptions = {
  queryFn: __me
};
function meQueryKey(...params) {
  return trimArrayEnd([
    "Client",
    "me"
  ]);
}
function __me() {
  return me$1();
}
function useMeQuery(...params) {
  let options = void 0;
  let axiosConfig;
  options = params[0];
  axiosConfig = params[1];
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __me,
    queryKey: meQueryKey(),
    ...meDefaultOptions,
    ...options
  });
}
let usersAllDefaultOptions = {
  queryFn: __usersAll
};
function usersAllQueryKey(...params) {
  return trimArrayEnd([
    "Client",
    "usersAll"
  ]);
}
function __usersAll() {
  return usersAll();
}
function useUsersAllQuery(...params) {
  let options = void 0;
  let axiosConfig;
  options = params[0];
  axiosConfig = params[1];
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __usersAll,
    queryKey: usersAllQueryKey(),
    ...usersAllDefaultOptions,
    ...options
  });
}
function usersPUTMutationKey(id2) {
  return trimArrayEnd([
    "Client",
    "usersPUT",
    id2
  ]);
}
function useUsersPUTMutation(id2, options) {
  const key = usersPUTMutationKey(id2);
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((body) => usersPUT(id2, body), { ...options, mutationKey: key });
}
let userVideoStatsGETDefaultOptions = {
  queryFn: __userVideoStatsGET
};
function userVideoStatsGETQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { videoId } = params[0];
    return trimArrayEnd([
      "Client",
      "userVideoStatsGET",
      videoId
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "userVideoStatsGET",
      ...params
    ]);
  }
}
function __userVideoStatsGET(context) {
  return userVideoStatsGET(
    context.queryKey[2]
  );
}
function useUserVideoStatsGETQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let videoId = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ videoId } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [videoId, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __userVideoStatsGET,
    queryKey: userVideoStatsGETQueryKey(videoId),
    ...userVideoStatsGETDefaultOptions,
    ...options
  });
}
function userVideoStatsPUTMutationKey(videoId) {
  return trimArrayEnd([
    "Client",
    "userVideoStatsPUT",
    videoId
  ]);
}
function useUserVideoStatsPUTMutation(videoId, options) {
  const key = userVideoStatsPUTMutationKey(videoId);
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((body) => userVideoStatsPUT(videoId, body), { ...options, mutationKey: key });
}
function watchedMutationKey(videoId) {
  return trimArrayEnd([
    "Client",
    "watched",
    videoId
  ]);
}
function useWatchedMutation(videoId, options) {
  const key = watchedMutationKey(videoId);
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((body) => watched(videoId, body), { ...options, mutationKey: key });
}
let videosAllDefaultOptions = {
  queryFn: __videosAll
};
function videosAllQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { orderBy, limit, offset: offset3 } = params[0];
    return trimArrayEnd([
      "Client",
      "videosAll",
      orderBy,
      limit,
      offset3
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "videosAll",
      ...params
    ]);
  }
}
function __videosAll(context) {
  return videosAll(
    context.queryKey[2],
    context.queryKey[3],
    context.queryKey[4]
  );
}
function useVideosAllQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let orderBy = void 0;
  let limit = void 0;
  let offset3 = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ orderBy, limit, offset: offset3 } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [orderBy, limit, offset3, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __videosAll,
    queryKey: videosAllQueryKey(orderBy, limit, offset3),
    ...videosAllDefaultOptions,
    ...options
  });
}
function videosPOSTMutationKey() {
  return trimArrayEnd([
    "Client",
    "videosPOST"
  ]);
}
function useVideosPOSTMutation(options) {
  const key = videosPOSTMutationKey();
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((videosPOSTMutationParameters) => videosPOST(videosPOSTMutationParameters.fileName, videosPOSTMutationParameters.name, videosPOSTMutationParameters.description, videosPOSTMutationParameters.durationSec, videosPOSTMutationParameters.image, videosPOSTMutationParameters.channelId, videosPOSTMutationParameters.tags), { ...options, mutationKey: key });
}
let videosGETDefaultOptions = {
  queryFn: __videosGET
};
function videosGETQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id: id2 } = params[0];
    return trimArrayEnd([
      "Client",
      "videosGET",
      id2
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "videosGET",
      ...params
    ]);
  }
}
function __videosGET(context) {
  return videosGET(
    context.queryKey[2]
  );
}
function useVideosGETQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let id2 = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id: id2 } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id2, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __videosGET,
    queryKey: videosGETQueryKey(id2),
    ...videosGETDefaultOptions,
    ...options
  });
}
function videosPUTMutationKey(id2) {
  return trimArrayEnd([
    "Client",
    "videosPUT",
    id2
  ]);
}
function useVideosPUTMutation(id2, options) {
  const key = videosPUTMutationKey(id2);
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  return useMutation((videosPUTMutationParameters) => videosPUT(id2, videosPUTMutationParameters.name, videosPUTMutationParameters.description, videosPUTMutationParameters.image, videosPUTMutationParameters.channelId, videosPUTMutationParameters.tags), { ...options, mutationKey: key });
}
let videoPlaylistsDefaultOptions = {
  queryFn: __videoPlaylists
};
function videoPlaylistsQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id: id2 } = params[0];
    return trimArrayEnd([
      "Client",
      "videoPlaylists",
      id2
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "videoPlaylists",
      ...params
    ]);
  }
}
function __videoPlaylists(context) {
  return videoPlaylists(
    context.queryKey[2]
  );
}
function useVideoPlaylistsQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let id2 = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id: id2 } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id2, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __videoPlaylists,
    queryKey: videoPlaylistsQueryKey(id2),
    ...videoPlaylistsDefaultOptions,
    ...options
  });
}
let myVideosDefaultOptions = {
  queryFn: __myVideos
};
function myVideosQueryKey(...params) {
  return trimArrayEnd([
    "Client",
    "myVideos"
  ]);
}
function __myVideos() {
  return myVideos();
}
function useMyVideosQuery(...params) {
  let options = void 0;
  let axiosConfig;
  options = params[0];
  axiosConfig = params[1];
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __myVideos,
    queryKey: myVideosQueryKey(),
    ...myVideosDefaultOptions,
    ...options
  });
}
let relatedVideosDefaultOptions = {
  queryFn: __relatedVideos
};
function relatedVideosQueryKey(...params) {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id: id2 } = params[0];
    return trimArrayEnd([
      "Client",
      "relatedVideos",
      id2
    ]);
  } else {
    return trimArrayEnd([
      "Client",
      "relatedVideos",
      ...params
    ]);
  }
}
function __relatedVideos(context) {
  return relatedVideos(
    context.queryKey[2]
  );
}
function useRelatedVideosQuery(...params) {
  let options = void 0;
  let axiosConfig;
  let id2 = void 0;
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id: id2 } = params[0]);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id2, options, axiosConfig] = params;
    }
  }
  const metaContext = reactExports.useContext(distExports.QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? {};
    options.meta = { ...options.meta, axiosConfig };
  }
  return useQuery({
    queryFn: __relatedVideos,
    queryKey: relatedVideosQueryKey(id2),
    ...relatedVideosDefaultOptions,
    ...options
  });
}
function uploadUrl() {
  let url_ = getBaseUrl() + "/api/Videos/upload";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}
let Channel$1 = class Channel {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.owner = new User();
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.subscribersCount = _data["subscribersCount"];
      this.posterUrl = _data["posterUrl"];
      this.pinnedVideoId = _data["pinnedVideoId"];
      this.pinnedVideo = _data["pinnedVideo"] ? Video.fromJS(_data["pinnedVideo"]) : void 0;
      this.avatarUrl = _data["avatarUrl"];
      this.owner = _data["owner"] ? User.fromJS(_data["owner"]) : new User();
      this.idOwner = _data["idOwner"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new Channel();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["subscribersCount"] = this.subscribersCount;
    data["posterUrl"] = this.posterUrl;
    data["pinnedVideoId"] = this.pinnedVideoId;
    data["pinnedVideo"] = this.pinnedVideo ? this.pinnedVideo.toJSON() : void 0;
    data["avatarUrl"] = this.avatarUrl;
    data["owner"] = this.owner ? this.owner.toJSON() : void 0;
    data["idOwner"] = this.idOwner;
    return data;
  }
};
class ChannelAdvancedInfoDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.channelId = _data["channelId"];
      this.description = _data["description"];
      this.dateOfRegistration = _data["dateOfRegistration"] ? new Date(_data["dateOfRegistration"].toString()) : void 0;
      this.email = _data["email"];
      if (Array.isArray(_data["relatedChannels"])) {
        this.relatedChannels = [];
        for (let item of _data["relatedChannels"])
          this.relatedChannels.push(ChannelDTO.fromJS(item));
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ChannelAdvancedInfoDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["channelId"] = this.channelId;
    data["description"] = this.description;
    data["dateOfRegistration"] = this.dateOfRegistration ? this.dateOfRegistration.toISOString() : void 0;
    data["email"] = this.email;
    if (Array.isArray(this.relatedChannels)) {
      data["relatedChannels"] = [];
      for (let item of this.relatedChannels)
        data["relatedChannels"].push(item.toJSON());
    }
    return data;
  }
}
class ChannelDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.subscribersCount = _data["subscribersCount"];
      this.posterUrl = _data["posterUrl"];
      this.pinnedVideoId = _data["pinnedVideoId"];
      this.pinnedVideo = _data["pinnedVideo"] ? Video.fromJS(_data["pinnedVideo"]) : void 0;
      this.avatarUrl = _data["avatarUrl"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ChannelDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["subscribersCount"] = this.subscribersCount;
    data["posterUrl"] = this.posterUrl;
    data["pinnedVideoId"] = this.pinnedVideoId;
    data["pinnedVideo"] = this.pinnedVideo ? this.pinnedVideo.toJSON() : void 0;
    data["avatarUrl"] = this.avatarUrl;
    return data;
  }
}
class ChannelUserSpecificInfoDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.subscribed = _data["subscribed"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new ChannelUserSpecificInfoDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["subscribed"] = this.subscribed;
    return data;
  }
}
class CommentDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.user = new UserDTO();
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.userId = _data["userId"];
      this.videoId = _data["videoId"];
      this.text = _data["text"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : void 0;
      this.user = _data["user"] ? UserDTO.fromJS(_data["user"]) : new UserDTO();
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new CommentDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["userId"] = this.userId;
    data["videoId"] = this.videoId;
    data["text"] = this.text;
    data["created"] = this.created ? this.created.toISOString() : void 0;
    data["user"] = this.user ? this.user.toJSON() : void 0;
    return data;
  }
}
class CommentPostDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.videoId = _data["videoId"];
      this.text = _data["text"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new CommentPostDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["videoId"] = this.videoId;
    data["text"] = this.text;
    return data;
  }
}
class LoginDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.email = _data["email"];
      this.password = _data["password"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new LoginDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["email"] = this.email;
    data["password"] = this.password;
    return data;
  }
}
let Playlist$1 = class Playlist {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.owner = new User();
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.createdTimestamp = _data["createdTimestamp"] ? new Date(_data["createdTimestamp"].toString()) : void 0;
      this.description = _data["description"];
      this.thumbnailUrl = _data["thumbnailUrl"];
      if (Array.isArray(_data["videos"])) {
        this.videos = [];
        for (let item of _data["videos"])
          this.videos.push(Video.fromJS(item));
      }
      this.owner = _data["owner"] ? User.fromJS(_data["owner"]) : new User();
      this.idOwner = _data["idOwner"];
      this.channel = _data["channel"] ? Channel$1.fromJS(_data["channel"]) : void 0;
      this.channelId = _data["channelId"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new Playlist();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["createdTimestamp"] = this.createdTimestamp ? this.createdTimestamp.toISOString() : void 0;
    data["description"] = this.description;
    data["thumbnailUrl"] = this.thumbnailUrl;
    if (Array.isArray(this.videos)) {
      data["videos"] = [];
      for (let item of this.videos)
        data["videos"].push(item.toJSON());
    }
    data["owner"] = this.owner ? this.owner.toJSON() : void 0;
    data["idOwner"] = this.idOwner;
    data["channel"] = this.channel ? this.channel.toJSON() : void 0;
    data["channelId"] = this.channelId;
    return data;
  }
};
class PlaylistDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.createdTimestamp = _data["createdTimestamp"] ? new Date(_data["createdTimestamp"].toString()) : void 0;
      this.description = _data["description"];
      this.thumbnailUrl = _data["thumbnailUrl"];
      if (Array.isArray(_data["videos"])) {
        this.videos = [];
        for (let item of _data["videos"])
          this.videos.push(VideoDTO.fromJS(item));
      }
      this.ownerId = _data["ownerId"];
      this.channel = _data["channel"] ? Channel$1.fromJS(_data["channel"]) : void 0;
      this.totalDuration = _data["totalDuration"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new PlaylistDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["createdTimestamp"] = this.createdTimestamp ? this.createdTimestamp.toISOString() : void 0;
    data["description"] = this.description;
    data["thumbnailUrl"] = this.thumbnailUrl;
    if (Array.isArray(this.videos)) {
      data["videos"] = [];
      for (let item of this.videos)
        data["videos"].push(item.toJSON());
    }
    data["ownerId"] = this.ownerId;
    data["channel"] = this.channel ? this.channel.toJSON() : void 0;
    data["totalDuration"] = this.totalDuration;
    return data;
  }
}
class PostVideoResponse {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.dataUrl = _data["dataUrl"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new PostVideoResponse();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["dataUrl"] = this.dataUrl;
    return data;
  }
}
class RegisterDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.name = _data["name"];
      this.email = _data["email"];
      this.password = _data["password"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new RegisterDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["name"] = this.name;
    data["email"] = this.email;
    data["password"] = this.password;
    return data;
  }
}
class Tag {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.videos = [];
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      if (Array.isArray(_data["videos"])) {
        this.videos = [];
        for (let item of _data["videos"])
          this.videos.push(Video.fromJS(item));
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new Tag();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    if (Array.isArray(this.videos)) {
      data["videos"] = [];
      for (let item of this.videos)
        data["videos"].push(item.toJSON());
    }
    return data;
  }
}
class TagDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new TagDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }
}
class User {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.roles = new UserRoles();
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.userName = _data["userName"];
      this.normalizedUserName = _data["normalizedUserName"];
      this.email = _data["email"];
      this.normalizedEmail = _data["normalizedEmail"];
      this.emailConfirmed = _data["emailConfirmed"];
      this.passwordHash = _data["passwordHash"];
      this.securityStamp = _data["securityStamp"];
      this.concurrencyStamp = _data["concurrencyStamp"];
      this.phoneNumber = _data["phoneNumber"];
      this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
      this.twoFactorEnabled = _data["twoFactorEnabled"];
      this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : void 0;
      this.lockoutEnabled = _data["lockoutEnabled"];
      this.accessFailedCount = _data["accessFailedCount"];
      this.name = _data["name"];
      this.initials = _data["initials"];
      this.roles = _data["roles"] ? UserRoles.fromJS(_data["roles"]) : new UserRoles();
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["userName"] = this.userName;
    data["normalizedUserName"] = this.normalizedUserName;
    data["email"] = this.email;
    data["normalizedEmail"] = this.normalizedEmail;
    data["emailConfirmed"] = this.emailConfirmed;
    data["passwordHash"] = this.passwordHash;
    data["securityStamp"] = this.securityStamp;
    data["concurrencyStamp"] = this.concurrencyStamp;
    data["phoneNumber"] = this.phoneNumber;
    data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
    data["twoFactorEnabled"] = this.twoFactorEnabled;
    data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : void 0;
    data["lockoutEnabled"] = this.lockoutEnabled;
    data["accessFailedCount"] = this.accessFailedCount;
    data["name"] = this.name;
    data["initials"] = this.initials;
    data["roles"] = this.roles ? this.roles.toJSON() : void 0;
    return data;
  }
}
class UserDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.roles = new UserRoles();
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.email = _data["email"];
      this.initials = _data["initials"];
      this.roles = _data["roles"] ? UserRoles.fromJS(_data["roles"]) : new UserRoles();
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new UserDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["email"] = this.email;
    data["initials"] = this.initials;
    data["roles"] = this.roles ? this.roles.toJSON() : void 0;
    return data;
  }
}
class UserRoles {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.user = _data["user"];
      this.videoEditor = _data["videoEditor"];
      this.administrator = _data["administrator"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new UserRoles();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["user"] = this.user;
    data["videoEditor"] = this.videoEditor;
    data["administrator"] = this.administrator;
    return data;
  }
}
class UserVideoStats {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
  }
  init(_data) {
    if (_data) {
      this.like = _data["like"];
      this.dislike = _data["dislike"];
      this.addedToPlaylist = _data["addedToPlaylist"];
      this.timeWatchedSec = _data["timeWatchedSec"];
      this.userId = _data["userId"];
      this.videoId = _data["videoId"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new UserVideoStats();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["like"] = this.like;
    data["dislike"] = this.dislike;
    data["addedToPlaylist"] = this.addedToPlaylist;
    data["timeWatchedSec"] = this.timeWatchedSec;
    data["userId"] = this.userId;
    data["videoId"] = this.videoId;
    return data;
  }
}
class Video {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.channel = new Channel$1();
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.imageUrl = _data["imageUrl"];
      this.duration = _data["duration"];
      this.description = _data["description"];
      this.dataUrl = _data["dataUrl"];
      this.likeCount = _data["likeCount"];
      this.dislikeCount = _data["dislikeCount"];
      this.views = _data["views"];
      this.uploadTimestamp = _data["uploadTimestamp"] ? new Date(_data["uploadTimestamp"].toString()) : void 0;
      if (Array.isArray(_data["tags"])) {
        this.tags = [];
        for (let item of _data["tags"])
          this.tags.push(Tag.fromJS(item));
      }
      this.channelId = _data["channelId"];
      this.channel = _data["channel"] ? Channel$1.fromJS(_data["channel"]) : new Channel$1();
      if (Array.isArray(_data["playlists"])) {
        this.playlists = [];
        for (let item of _data["playlists"])
          this.playlists.push(Playlist$1.fromJS(item));
      }
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new Video();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["imageUrl"] = this.imageUrl;
    data["duration"] = this.duration;
    data["description"] = this.description;
    data["dataUrl"] = this.dataUrl;
    data["likeCount"] = this.likeCount;
    data["dislikeCount"] = this.dislikeCount;
    data["views"] = this.views;
    data["uploadTimestamp"] = this.uploadTimestamp ? this.uploadTimestamp.toISOString() : void 0;
    if (Array.isArray(this.tags)) {
      data["tags"] = [];
      for (let item of this.tags)
        data["tags"].push(item.toJSON());
    }
    data["channelId"] = this.channelId;
    data["channel"] = this.channel ? this.channel.toJSON() : void 0;
    if (Array.isArray(this.playlists)) {
      data["playlists"] = [];
      for (let item of this.playlists)
        data["playlists"].push(item.toJSON());
    }
    return data;
  }
}
class VideoDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.channel = new Channel$1();
    }
  }
  init(_data) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.imageUrl = _data["imageUrl"];
      this.duration = _data["duration"];
      this.description = _data["description"];
      this.dataUrl = _data["dataUrl"];
      this.likeCount = _data["likeCount"];
      this.dislikeCount = _data["dislikeCount"];
      this.views = _data["views"];
      this.uploadTimestamp = _data["uploadTimestamp"] ? new Date(_data["uploadTimestamp"].toString()) : void 0;
      if (Array.isArray(_data["tags"])) {
        this.tags = [];
        for (let item of _data["tags"])
          this.tags.push(Tag.fromJS(item));
      }
      this.channelId = _data["channelId"];
      this.channel = _data["channel"] ? Channel$1.fromJS(_data["channel"]) : new Channel$1();
      if (Array.isArray(_data["playlists"])) {
        this.playlists = [];
        for (let item of _data["playlists"])
          this.playlists.push(Playlist$1.fromJS(item));
      }
      this.channelName = _data["channelName"];
      this.channelAvatarUrl = _data["channelAvatarUrl"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new VideoDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["imageUrl"] = this.imageUrl;
    data["duration"] = this.duration;
    data["description"] = this.description;
    data["dataUrl"] = this.dataUrl;
    data["likeCount"] = this.likeCount;
    data["dislikeCount"] = this.dislikeCount;
    data["views"] = this.views;
    data["uploadTimestamp"] = this.uploadTimestamp ? this.uploadTimestamp.toISOString() : void 0;
    if (Array.isArray(this.tags)) {
      data["tags"] = [];
      for (let item of this.tags)
        data["tags"].push(item.toJSON());
    }
    data["channelId"] = this.channelId;
    data["channel"] = this.channel ? this.channel.toJSON() : void 0;
    if (Array.isArray(this.playlists)) {
      data["playlists"] = [];
      for (let item of this.playlists)
        data["playlists"].push(item.toJSON());
    }
    data["channelName"] = this.channelName;
    data["channelAvatarUrl"] = this.channelAvatarUrl;
    return data;
  }
}
class WithTotalCountOfPlaylistDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.items = [];
    }
  }
  init(_data) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [];
        for (let item of _data["items"])
          this.items.push(PlaylistDTO.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new WithTotalCountOfPlaylistDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }
}
class WithTotalCountOfVideoDTO {
  constructor(data) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          this[property] = data[property];
      }
    }
    if (!data) {
      this.items = [];
    }
  }
  init(_data) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [];
        for (let item of _data["items"])
          this.items.push(VideoDTO.fromJS(item));
      }
      this.totalCount = _data["totalCount"];
    }
  }
  static fromJS(data) {
    data = typeof data === "object" ? data : {};
    let result = new WithTotalCountOfVideoDTO();
    result.init(data);
    return result;
  }
  toJSON(data) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    data["totalCount"] = this.totalCount;
    return data;
  }
}
class ApiException extends Error {
  constructor(message, status, response, headers, result) {
    super();
    this.isApiException = true;
    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }
  static isApiException(obj) {
    return obj.isApiException === true;
  }
}
function throwException(message, status, response, headers, result) {
  if (result !== null && result !== void 0)
    throw result;
  else
    throw new ApiException(message, status, response, headers, null);
}
function isAxiosError(obj) {
  return obj && obj.isAxiosError === true;
}
/**
 * @remix-run/router v1.0.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search: search2,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search: search2,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location2) {
  return {
    usr: location2.state,
    key: location2.key
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location2 = _extends$c({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location2;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search: search2 = "",
    hash: hash2 = ""
  } = _ref;
  if (search2 && search2 !== "?")
    pathname += search2.charAt(0) === "?" ? search2 : "?" + search2;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function createURL(location2) {
  let base = typeof window !== "undefined" && typeof window.location !== "undefined" && window.location.origin !== "null" ? window.location.origin : "unknown://unknown";
  let href = typeof location2 === "string" ? location2 : createPath(location2);
  return new URL(href, base);
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  function handlePop() {
    action = Action.Pop;
    if (listener) {
      listener({
        action,
        location: history2.location
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location2 = createLocation(history2.location, to, state);
    if (validateLocation)
      validateLocation(location2, to);
    let historyState = getHistoryState(location2);
    let url = history2.createHref(location2);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history2.location
      });
    }
  }
  function replace2(to, state) {
    action = Action.Replace;
    let location2 = createLocation(history2.location, to, state);
    if (validateLocation)
      validateLocation(location2, to);
    let historyState = getHistoryState(location2);
    let url = history2.createHref(location2);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history2.location
      });
    }
  }
  let history2 = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    encodeLocation(location2) {
      let url = createURL(createPath(location2));
      return _extends$c({}, location2, {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      });
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history2;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function isIndexRoute(route) {
  return route.index === true;
}
function convertRoutesToDataRoutes(routes, parentPath, allIds) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (allIds === void 0) {
    allIds = /* @__PURE__ */ new Set();
  }
  return routes.map((route, index2) => {
    let treePath = [...parentPath, index2];
    let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant$4(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant$4(!allIds.has(id2), 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
    allIds.add(id2);
    if (isIndexRoute(route)) {
      let indexRoute = _extends$c({}, route, {
        id: id2
      });
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends$c({}, route, {
        id: id2,
        children: route.children ? convertRoutesToDataRoutes(route.children, treePath, allIds) : void 0
      });
      return pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(
      branches[i],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route, index2) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant$4(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant$4(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i) => n2 === b2[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end2 = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function invariant$4(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search: search2 = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search2),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$c({}, toArg);
    invariant$4(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant$4(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant$4(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from3;
  if (isPathRelative || toPathname == null) {
    from3 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments3 = toPathname.split("/");
      while (toSegments3[0] === "..") {
        toSegments3.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments3.join("/");
    }
    from3 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from3);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search2) => !search2 || search2 === "?" ? "" : search2.startsWith("?") ? search2 : "?" + search2;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
class AbortedDeferredError extends Error {
}
class DeferredData {
  constructor(data) {
    this.pendingKeys = /* @__PURE__ */ new Set();
    this.subscriber = void 0;
    invariant$4(data && typeof data === "object" && !Array.isArray(data), "defer() only accepts plain objects");
    let reject;
    this.abortPromise = new Promise((_2, r3) => reject = r3);
    this.controller = new AbortController();
    let onAbort = () => reject(new AbortedDeferredError("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", onAbort);
    this.controller.signal.addEventListener("abort", onAbort);
    this.data = Object.entries(data).reduce((acc, _ref) => {
      let [key, value] = _ref;
      return Object.assign(acc, {
        [key]: this.trackPromise(key, value)
      });
    }, {});
  }
  trackPromise(key, value) {
    if (!(value instanceof Promise)) {
      return value;
    }
    this.pendingKeys.add(key);
    let promise = Promise.race([value, this.abortPromise]).then((data) => this.onSettle(promise, key, null, data), (error) => this.onSettle(promise, key, error));
    promise.catch(() => {
    });
    Object.defineProperty(promise, "_tracked", {
      get: () => true
    });
    return promise;
  }
  onSettle(promise, key, error, data) {
    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {
      this.unlistenAbortSignal();
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      return Promise.reject(error);
    }
    this.pendingKeys.delete(key);
    if (this.done) {
      this.unlistenAbortSignal();
    }
    const subscriber = this.subscriber;
    if (error) {
      Object.defineProperty(promise, "_error", {
        get: () => error
      });
      subscriber && subscriber(false);
      return Promise.reject(error);
    }
    Object.defineProperty(promise, "_data", {
      get: () => data
    });
    subscriber && subscriber(false);
    return data;
  }
  subscribe(fn2) {
    this.subscriber = fn2;
  }
  cancel() {
    this.controller.abort();
    this.pendingKeys.forEach((v2, k2) => this.pendingKeys.delete(k2));
    let subscriber = this.subscriber;
    subscriber && subscriber(true);
  }
  async resolveData(signal) {
    let aborted = false;
    if (!this.done) {
      let onAbort = () => this.cancel();
      signal.addEventListener("abort", onAbort);
      aborted = await new Promise((resolve) => {
        this.subscribe((aborted2) => {
          signal.removeEventListener("abort", onAbort);
          if (aborted2 || this.done) {
            resolve(aborted2);
          }
        });
      });
    }
    return aborted;
  }
  get done() {
    return this.pendingKeys.size === 0;
  }
  get unwrappedData() {
    invariant$4(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds");
    return Object.entries(this.data).reduce((acc, _ref2) => {
      let [key, value] = _ref2;
      return Object.assign(acc, {
        [key]: unwrapTrackedPromise(value)
      });
    }, {});
  }
}
function isTrackedPromise(value) {
  return value instanceof Promise && value._tracked === true;
}
function unwrapTrackedPromise(value) {
  if (!isTrackedPromise(value)) {
    return value;
  }
  if (value._error) {
    throw value._error;
  }
  return value._data;
}
class ErrorResponse {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText || "";
    this.data = data;
  }
}
function isRouteErrorResponse(e2) {
  return e2 instanceof ErrorResponse;
}
const IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0
};
const IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0
};
const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const isServer = !isBrowser$1;
function createRouter(init) {
  invariant$4(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let dataRoutes = convertRoutesToDataRoutes(init.routes);
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */ new Set();
  let savedScrollPositions = null;
  let getScrollRestorationKey = null;
  let getScrollPosition = null;
  let initialScrollRestored = false;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);
  let initialErrors = null;
  if (initialMatches == null) {
    let {
      matches,
      route,
      error
    } = getNotFoundMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  let initialized = !initialMatches.some((m2) => m2.route.loader) || init.hydrationData != null;
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    restoreScrollPosition: null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map()
  };
  let pendingAction = Action.Pop;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledDeferredRoutes = [];
  let cancelledFetcherLoads = [];
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let fetchRedirectIds = /* @__PURE__ */ new Set();
  let fetchLoadMatches = /* @__PURE__ */ new Map();
  let activeDeferreds = /* @__PURE__ */ new Map();
  function initialize2() {
    unlistenHistory = init.history.listen((_ref) => {
      let {
        action: historyAction,
        location: location2
      } = _ref;
      return startNavigation(historyAction, location2);
    });
    if (!state.initialized) {
      startNavigation(Action.Pop, state.location);
    }
    return router;
  }
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_2, key) => deleteFetcher(key));
  }
  function subscribe(fn2) {
    subscribers.add(fn2);
    return () => subscribers.delete(fn2);
  }
  function updateState(newState) {
    state = _extends$c({}, state, newState);
    subscribers.forEach((subscriber) => subscriber(state));
  }
  function completeNavigation(location2, newState) {
    var _state$navigation$for;
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && state.navigation.state === "loading" && ((_state$navigation$for = state.navigation.formAction) == null ? void 0 : _state$navigation$for.split("?")[0]) === location2.pathname;
    let newLoaderData = newState.loaderData ? {
      loaderData: mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [])
    } : {};
    updateState(_extends$c({}, isActionReload ? {} : {
      actionData: null
    }, newState, newLoaderData, {
      historyAction: pendingAction,
      location: location2,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      // Don't restore on submission navigations
      restoreScrollPosition: state.navigation.formData ? false : getSavedScrollPosition(location2, newState.matches || state.matches),
      preventScrollReset: pendingPreventScrollReset
    }));
    if (isUninterruptedRevalidation)
      ;
    else if (pendingAction === Action.Pop)
      ;
    else if (pendingAction === Action.Push) {
      init.history.push(location2, location2.state);
    } else if (pendingAction === Action.Replace) {
      init.history.replace(location2, location2.state);
    }
    pendingAction = Action.Pop;
    pendingPreventScrollReset = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
    cancelledFetcherLoads = [];
  }
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(to, opts);
    let location2 = createLocation(state.location, path, opts && opts.state);
    location2 = init.history.encodeLocation(location2);
    let historyAction = (opts && opts.replace) === true || submission != null ? Action.Replace : Action.Push;
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    return await startNavigation(historyAction, location2, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace
    });
  }
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    if (state.navigation.state === "submitting") {
      return;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation
    });
  }
  async function startNavigation(historyAction, location2, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = matchRoutes(dataRoutes, location2, init.basename);
    if (!matches) {
      let {
        matches: notFoundMatches,
        route,
        error
      } = getNotFoundMatches(dataRoutes);
      cancelActiveDeferreds();
      completeNavigation(location2, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      });
      return;
    }
    if (isHashChangeOnly(state.location, location2)) {
      completeNavigation(location2, {
        matches
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request2 = createRequest(location2, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionData;
    let pendingError;
    if (opts && opts.pendingError) {
      pendingError = {
        [findNearestBoundary(matches).route.id]: opts.pendingError
      };
    } else if (opts && opts.submission) {
      let actionOutput = await handleAction(request2, location2, opts.submission, matches, {
        replace: opts.replace
      });
      if (actionOutput.shortCircuited) {
        return;
      }
      pendingActionData = actionOutput.pendingActionData;
      pendingError = actionOutput.pendingActionError;
      let navigation = _extends$c({
        state: "loading",
        location: location2
      }, opts.submission);
      loadingNavigation = navigation;
    }
    let {
      shortCircuited,
      loaderData,
      errors: errors2
    } = await handleLoaders(request2, location2, matches, loadingNavigation, opts && opts.submission, opts && opts.replace, pendingActionData, pendingError);
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location2, {
      matches,
      loaderData,
      errors: errors2
    });
  }
  async function handleAction(request2, location2, submission, matches, opts) {
    interruptActiveLoads();
    let navigation = _extends$c({
      state: "submitting",
      location: location2
    }, submission);
    updateState({
      navigation
    });
    let result;
    let actionMatch = getTargetMatch(matches, location2);
    if (!actionMatch.route.action) {
      result = getMethodNotAllowedResult(location2);
    } else {
      result = await callLoaderOrAction("action", request2, actionMatch, matches, router.basename);
      if (request2.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let redirectNavigation = _extends$c({
        state: "loading",
        location: createLocation(state.location, result.location)
      }, submission);
      await startRedirectNavigation(result, redirectNavigation, opts && opts.replace);
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = Action.Push;
      }
      return {
        pendingActionError: {
          [boundaryMatch.route.id]: result.error
        }
      };
    }
    if (isDeferredResult(result)) {
      throw new Error("defer() is not supported in actions");
    }
    return {
      pendingActionData: {
        [actionMatch.route.id]: result.data
      }
    };
  }
  async function handleLoaders(request2, location2, matches, overrideNavigation, submission, replace2, pendingActionData, pendingError) {
    let loadingNavigation = overrideNavigation;
    if (!loadingNavigation) {
      let navigation = {
        state: "loading",
        location: location2,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0
      };
      loadingNavigation = navigation;
    }
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(state, matches, submission, location2, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches);
    cancelActiveDeferreds((routeId) => !(matches && matches.some((m2) => m2.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m2) => m2.route.id === routeId));
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      completeNavigation(location2, {
        matches,
        loaderData: mergeLoaderData(state.loaderData, {}, matches),
        // Commit pending error if we're short circuiting
        errors: pendingError || null,
        actionData: pendingActionData || null
      });
      return {
        shortCircuited: true
      };
    }
    if (!isUninterruptedRevalidation) {
      revalidatingFetchers.forEach((_ref2) => {
        let [key] = _ref2;
        let fetcher = state.fetchers.get(key);
        let revalidatingFetcher = {
          state: "loading",
          data: fetcher && fetcher.data,
          formMethod: void 0,
          formAction: void 0,
          formEncType: void 0,
          formData: void 0
        };
        state.fetchers.set(key, revalidatingFetcher);
      });
      updateState(_extends$c({
        navigation: loadingNavigation,
        actionData: pendingActionData || state.actionData || null
      }, revalidatingFetchers.length > 0 ? {
        fetchers: new Map(state.fetchers)
      } : {}));
    }
    pendingNavigationLoadId = ++incrementingLoadId;
    revalidatingFetchers.forEach((_ref3) => {
      let [key] = _ref3;
      return fetchControllers.set(key, pendingNavigationController);
    });
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request2);
    if (request2.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    revalidatingFetchers.forEach((_ref4) => {
      let [key] = _ref4;
      return fetchControllers.delete(key);
    });
    let redirect = findRedirect(results);
    if (redirect) {
      let redirectNavigation = getLoaderRedirect(state, redirect);
      await startRedirectNavigation(redirect, redirectNavigation, replace2);
      return {
        shortCircuited: true
      };
    }
    let {
      loaderData,
      errors: errors2
    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe((aborted) => {
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    return _extends$c({
      loaderData,
      errors: errors2
    }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function fetch2(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    }
    if (fetchControllers.has(key))
      abortFetcher(key);
    let matches = matchRoutes(dataRoutes, href, init.basename);
    if (!matches) {
      setFetcherError(key, routeId, new ErrorResponse(404, "Not Found", null));
      return;
    }
    let {
      path,
      submission
    } = normalizeNavigateOptions(href, opts, true);
    let match2 = getTargetMatch(matches, path);
    if (submission) {
      handleFetcherAction(key, routeId, path, match2, matches, submission);
      return;
    }
    fetchLoadMatches.set(key, [path, match2, matches]);
    handleFetcherLoader(key, routeId, path, match2, matches);
  }
  async function handleFetcherAction(key, routeId, path, match2, requestMatches, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    if (!match2.route.action) {
      let {
        error
      } = getMethodNotAllowedResult(path);
      setFetcherError(key, routeId, error);
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    let fetcher = _extends$c({
      state: "submitting"
    }, submission, {
      data: existingFetcher && existingFetcher.data
    });
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortController = new AbortController();
    let fetchRequest = createRequest(path, abortController.signal, submission);
    fetchControllers.set(key, abortController);
    let actionResult = await callLoaderOrAction("action", fetchRequest, match2, requestMatches, router.basename);
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (isRedirectResult(actionResult)) {
      fetchControllers.delete(key);
      fetchRedirectIds.add(key);
      let loadingFetcher = _extends$c({
        state: "loading"
      }, submission, {
        data: void 0
      });
      state.fetchers.set(key, loadingFetcher);
      updateState({
        fetchers: new Map(state.fetchers)
      });
      let redirectNavigation = _extends$c({
        state: "loading",
        location: createLocation(state.location, actionResult.location)
      }, submission);
      await startRedirectNavigation(actionResult, redirectNavigation);
      return;
    }
    if (isErrorResult(actionResult)) {
      setFetcherError(key, routeId, actionResult.error);
      return;
    }
    if (isDeferredResult(actionResult)) {
      invariant$4(false, "defer() is not supported in actions");
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createRequest(nextLocation, abortController.signal);
    let matches = state.navigation.state !== "idle" ? matchRoutes(dataRoutes, state.navigation.location, init.basename) : state.matches;
    invariant$4(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = _extends$c({
      state: "loading",
      data: actionResult.data
    }, submission);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(
      state,
      matches,
      submission,
      nextLocation,
      isRevalidationRequired,
      cancelledDeferredRoutes,
      cancelledFetcherLoads,
      {
        [match2.route.id]: actionResult.data
      },
      void 0,
      // No need to send through errors since we short circuit above
      fetchLoadMatches
    );
    revalidatingFetchers.filter((_ref5) => {
      let [staleKey] = _ref5;
      return staleKey !== key;
    }).forEach((_ref6) => {
      let [staleKey] = _ref6;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = {
        state: "loading",
        data: existingFetcher2 && existingFetcher2.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0
      };
      state.fetchers.set(staleKey, revalidatingFetcher);
      fetchControllers.set(staleKey, abortController);
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let {
      results,
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach((_ref7) => {
      let [staleKey] = _ref7;
      return fetchControllers.delete(staleKey);
    });
    let redirect = findRedirect(results);
    if (redirect) {
      let redirectNavigation = getLoaderRedirect(state, redirect);
      await startRedirectNavigation(redirect, redirectNavigation);
      return;
    }
    let {
      loaderData,
      errors: errors2
    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
    let doneFetcher = {
      state: "idle",
      data: actionResult.data,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    };
    state.fetchers.set(key, doneFetcher);
    let didAbortFetchLoads = abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant$4(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors: errors2,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState(_extends$c({
        errors: errors2,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches)
      }, didAbortFetchLoads ? {
        fetchers: new Map(state.fetchers)
      } : {}));
      isRevalidationRequired = false;
    }
  }
  async function handleFetcherLoader(key, routeId, path, match2, matches) {
    let existingFetcher = state.fetchers.get(key);
    let loadingFetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      data: existingFetcher && existingFetcher.data
    };
    state.fetchers.set(key, loadingFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortController = new AbortController();
    let fetchRequest = createRequest(path, abortController.signal);
    fetchControllers.set(key, abortController);
    let result = await callLoaderOrAction("loader", fetchRequest, match2, matches, router.basename);
    if (isDeferredResult(result)) {
      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
    }
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let redirectNavigation = getLoaderRedirect(state, result);
      await startRedirectNavigation(result, redirectNavigation);
      return;
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, routeId);
      state.fetchers.delete(key);
      updateState({
        fetchers: new Map(state.fetchers),
        errors: {
          [boundaryMatch.route.id]: result.error
        }
      });
      return;
    }
    invariant$4(!isDeferredResult(result), "Unhandled fetcher deferred data");
    let doneFetcher = {
      state: "idle",
      data: result.data,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0
    };
    state.fetchers.set(key, doneFetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  async function startRedirectNavigation(redirect, navigation, replace2) {
    if (redirect.revalidate) {
      isRevalidationRequired = true;
    }
    invariant$4(navigation.location, "Expected a location on the redirect navigation");
    pendingNavigationController = null;
    let redirectHistoryAction = replace2 === true ? Action.Replace : Action.Push;
    await startNavigation(redirectHistoryAction, navigation.location, {
      overrideNavigation: navigation
    });
  }
  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request2) {
    let results = await Promise.all([...matchesToLoad.map((match2) => callLoaderOrAction("loader", request2, match2, matches, router.basename)), ...fetchersToLoad.map((_ref8) => {
      let [, href, match2, fetchMatches] = _ref8;
      return callLoaderOrAction("loader", createRequest(href, request2.signal), match2, fetchMatches, router.basename);
    })]);
    let loaderResults = results.slice(0, matchesToLoad.length);
    let fetcherResults = results.slice(matchesToLoad.length);
    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request2.signal, false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map((_ref9) => {
      let [, , match2] = _ref9;
      return match2;
    }), fetcherResults, request2.signal, true)]);
    return {
      results,
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    fetchLoadMatches.forEach((_2, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.push(key);
        abortFetcher(key);
      }
    });
  }
  function setFetcherError(key, routeId, error) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    });
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key))
      abortFetcher(key);
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    state.fetchers.delete(key);
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant$4(controller, "Expected fetch controller: " + key);
    controller.abort();
    fetchControllers.delete(key);
  }
  function markFetchersDone(keys3) {
    for (let key of keys3) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        data: fetcher.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant$4(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
      }
    }
    markFetchersDone(doneKeys);
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id2] of fetchReloadIds) {
      if (id2 < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant$4(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  function enableScrollRestoration(positions2, getPosition, getKey) {
    savedScrollPositions = positions2;
    getScrollPosition = getPosition;
    getScrollRestorationKey = getKey || ((location2) => location2.key);
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y2 = getSavedScrollPosition(state.location, state.matches);
      if (y2 != null) {
        updateState({
          restoreScrollPosition: y2
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition = null;
      getScrollRestorationKey = null;
    };
  }
  function saveScrollPosition(location2, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map((m2) => createUseMatchesMatch(m2, state.loaderData));
      let key = getScrollRestorationKey(location2, userMatches) || location2.key;
      savedScrollPositions[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location2, matches) {
    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {
      let userMatches = matches.map((m2) => createUseMatchesMatch(m2, state.loaderData));
      let key = getScrollRestorationKey(location2, userMatches) || location2.key;
      let y2 = savedScrollPositions[key];
      if (typeof y2 === "number") {
        return y2;
      }
    }
    return null;
  }
  router = {
    get basename() {
      return init.basename;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    initialize: initialize2,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to) => init.history.createHref(to),
    getFetcher,
    deleteFetcher,
    dispose,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds
  };
  return router;
}
const validActionMethods = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH", "DELETE"]);
/* @__PURE__ */ new Set(["GET", "HEAD", ...validActionMethods]);
function normalizeNavigateOptions(to, opts, isFetcher) {
  if (isFetcher === void 0) {
    isFetcher = false;
  }
  let path = typeof to === "string" ? to : createPath(to);
  if (!opts || !("formMethod" in opts) && !("formData" in opts)) {
    return {
      path
    };
  }
  if (opts.formMethod != null && opts.formMethod !== "get") {
    return {
      path,
      submission: {
        formMethod: opts.formMethod,
        formAction: stripHashFromPath(path),
        formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
        formData: opts.formData
      }
    };
  }
  if (!opts.formData) {
    return {
      path
    };
  }
  let parsedPath = parsePath(path);
  try {
    let searchParams = convertFormDataToSearchParams(opts.formData);
    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
      searchParams.append("index", "");
    }
    parsedPath.search = "?" + searchParams;
  } catch (e2) {
    return {
      path,
      error: new ErrorResponse(400, "Bad Request", "Cannot submit binary form data using GET")
    };
  }
  return {
    path: createPath(parsedPath)
  };
}
function getLoaderRedirect(state, redirect) {
  let {
    formMethod,
    formAction,
    formEncType,
    formData
  } = state.navigation;
  let navigation = {
    state: "loading",
    location: createLocation(state.location, redirect.location),
    formMethod: formMethod || void 0,
    formAction: formAction || void 0,
    formEncType: formEncType || void 0,
    formData: formData || void 0
  };
  return navigation;
}
function getLoaderMatchesUntilBoundary(matches, boundaryId) {
  let boundaryMatches = matches;
  if (boundaryId) {
    let index2 = matches.findIndex((m2) => m2.route.id === boundaryId);
    if (index2 >= 0) {
      boundaryMatches = matches.slice(0, index2);
    }
  }
  return boundaryMatches;
}
function getMatchesToLoad(state, matches, submission, location2, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches) {
  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : null;
  let boundaryId = pendingError ? Object.keys(pendingError)[0] : void 0;
  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);
  let navigationMatches = boundaryMatches.filter((match2, index2) => match2.route.loader != null && (isNewLoader(state.loaderData, state.matches[index2], match2) || // If this route had a pending deferred cancelled it must be revalidated
  cancelledDeferredRoutes.some((id2) => id2 === match2.route.id) || shouldRevalidateLoader(state.location, state.matches[index2], submission, location2, match2, isRevalidationRequired, actionResult)));
  let revalidatingFetchers = [];
  fetchLoadMatches && fetchLoadMatches.forEach((_ref10, key) => {
    let [href, match2, fetchMatches] = _ref10;
    if (cancelledFetcherLoads.includes(key)) {
      revalidatingFetchers.push([key, href, match2, fetchMatches]);
    } else if (isRevalidationRequired) {
      let shouldRevalidate = shouldRevalidateLoader(href, match2, submission, href, match2, isRevalidationRequired, actionResult);
      if (shouldRevalidate) {
        revalidatingFetchers.push([key, href, match2, fetchMatches]);
      }
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function isNewLoader(currentLoaderData, currentMatch, match2) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match2.route.id !== currentMatch.route.id
  );
  let isMissingData = currentLoaderData[match2.route.id] === void 0;
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match2) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match2.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath && currentPath.endsWith("*") && currentMatch.params["*"] !== match2.params["*"]
  );
}
function shouldRevalidateLoader(currentLocation, currentMatch, submission, location2, match2, isRevalidationRequired, actionResult) {
  let currentUrl = createURL(currentLocation);
  let currentParams = currentMatch.params;
  let nextUrl = createURL(location2);
  let nextParams = match2.params;
  let defaultShouldRevalidate = isNewRouteInstance(currentMatch, match2) || // Clicked the same link, resubmitted a GET form
  currentUrl.toString() === nextUrl.toString() || // Search params affect all loaders
  currentUrl.search !== nextUrl.search || // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate
  isRevalidationRequired;
  if (match2.route.shouldRevalidate) {
    let routeChoice = match2.route.shouldRevalidate(_extends$c({
      currentUrl,
      currentParams,
      nextUrl,
      nextParams
    }, submission, {
      actionResult,
      defaultShouldRevalidate
    }));
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return defaultShouldRevalidate;
}
async function callLoaderOrAction(type2, request2, match2, matches, basename, isStaticRequest, isRouteRequest) {
  if (isStaticRequest === void 0) {
    isStaticRequest = false;
  }
  if (isRouteRequest === void 0) {
    isRouteRequest = false;
  }
  let resultType;
  let result;
  let reject;
  let abortPromise = new Promise((_2, r3) => reject = r3);
  let onReject = () => reject();
  request2.signal.addEventListener("abort", onReject);
  try {
    let handler = match2.route[type2];
    invariant$4(handler, "Could not find the " + type2 + ' to run on the "' + match2.route.id + '" route');
    result = await Promise.race([handler({
      request: request2,
      params: match2.params
    }), abortPromise]);
  } catch (e2) {
    resultType = ResultType.error;
    result = e2;
  } finally {
    request2.signal.removeEventListener("abort", onReject);
  }
  if (result instanceof Response) {
    let status = result.status;
    if (status >= 300 && status <= 399) {
      let location2 = result.headers.get("Location");
      invariant$4(location2, "Redirects returned/thrown from loaders/actions must have a Location header");
      let activeMatches = matches.slice(0, matches.indexOf(match2) + 1);
      let routePathnames = getPathContributingMatches(activeMatches).map((match3) => match3.pathnameBase);
      let requestPath = createURL(request2.url).pathname;
      let resolvedLocation = resolveTo(location2, routePathnames, requestPath);
      invariant$4(createPath(resolvedLocation), "Unable to resolve redirect location: " + result.headers.get("Location"));
      if (basename) {
        let path = resolvedLocation.pathname;
        resolvedLocation.pathname = path === "/" ? basename : joinPaths([basename, path]);
      }
      location2 = createPath(resolvedLocation);
      if (isStaticRequest) {
        result.headers.set("Location", location2);
        throw result;
      }
      return {
        type: ResultType.redirect,
        status,
        location: location2,
        revalidate: result.headers.get("X-Remix-Revalidate") !== null
      };
    }
    if (isRouteRequest) {
      throw {
        type: resultType || ResultType.data,
        response: result
      };
    }
    let data;
    let contentType = result.headers.get("Content-Type");
    if (contentType && contentType.startsWith("application/json")) {
      data = await result.json();
    } else {
      data = await result.text();
    }
    if (resultType === ResultType.error) {
      return {
        type: resultType,
        error: new ErrorResponse(status, result.statusText, data),
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (resultType === ResultType.error) {
    return {
      type: resultType,
      error: result
    };
  }
  if (result instanceof DeferredData) {
    return {
      type: ResultType.deferred,
      deferredData: result
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
}
function createRequest(location2, signal, submission) {
  let url = createURL(stripHashFromPath(location2)).toString();
  let init = {
    signal
  };
  if (submission) {
    let {
      formMethod,
      formEncType,
      formData
    } = submission;
    init.method = formMethod.toUpperCase();
    init.body = formEncType === "application/x-www-form-urlencoded" ? convertFormDataToSearchParams(formData) : formData;
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    invariant$4(typeof value === "string", 'File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.');
    searchParams.append(key, value);
  }
  return searchParams;
}
function processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {
  let loaderData = {};
  let errors2 = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  results.forEach((result, index2) => {
    let id2 = matchesToLoad[index2].route.id;
    invariant$4(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, id2);
      let error = result.error;
      if (pendingError) {
        error = Object.values(pendingError)[0];
        pendingError = void 0;
      }
      errors2 = Object.assign(errors2 || {}, {
        [boundaryMatch.route.id]: error
      });
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    } else if (isDeferredResult(result)) {
      activeDeferreds && activeDeferreds.set(id2, result.deferredData);
      loaderData[id2] = result.deferredData.data;
    } else {
      loaderData[id2] = result.data;
      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    }
  });
  if (pendingError) {
    errors2 = pendingError;
  }
  return {
    loaderData,
    errors: errors2,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors: errors2
  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);
  for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
    let [key, , match2] = revalidatingFetchers[index2];
    invariant$4(fetcherResults !== void 0 && fetcherResults[index2] !== void 0, "Did not find corresponding fetcher result");
    let result = fetcherResults[index2];
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match2.route.id);
      if (!(errors2 && errors2[boundaryMatch.route.id])) {
        errors2 = _extends$c({}, errors2, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      throw new Error("Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      throw new Error("Unhandled fetcher deferred data");
    } else {
      let doneFetcher = {
        state: "idle",
        data: result.data,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  return {
    loaderData,
    errors: errors2
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches) {
  let mergedLoaderData = _extends$c({}, newLoaderData);
  matches.forEach((match2) => {
    let id2 = match2.route.id;
    if (newLoaderData[id2] === void 0 && loaderData[id2] !== void 0) {
      mergedLoaderData[id2] = loaderData[id2];
    }
  });
  return mergedLoaderData;
}
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m2) => m2.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find((m2) => m2.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes, status, statusText) {
  let route = routes.find((r3) => r3.index || !r3.path || r3.path === "/") || {
    id: "__shim-" + status + "-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route,
    error: new ErrorResponse(status, statusText, null)
  };
}
function getNotFoundMatches(routes) {
  return getShortCircuitMatches(routes, 404, "Not Found");
}
function getMethodNotAllowedResult(path) {
  let href = typeof path === "string" ? path : createPath(path);
  console.warn("You're trying to submit to a route that does not have an action.  To fix this, please add an `action` function to the route for " + ("[" + href + "]"));
  return {
    type: ResultType.error,
    error: new ErrorResponse(405, "Method Not Allowed", "")
  };
}
function findRedirect(results) {
  for (let i = results.length - 1; i >= 0; i--) {
    let result = results[i];
    if (isRedirectResult(result)) {
      return result;
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends$c({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a2, b2) {
  return a2.pathname === b2.pathname && a2.search === b2.search && a2.hash !== b2.hash;
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
async function resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) {
  for (let index2 = 0; index2 < results.length; index2++) {
    let result = results[index2];
    let match2 = matchesToLoad[index2];
    let currentMatch = currentMatches.find((m2) => m2.route.id === match2.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match2) && (currentLoaderData && currentLoaderData[match2.route.id]) !== void 0;
    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {
      await resolveDeferredData(result, signal, isFetcher).then((result2) => {
        if (result2) {
          results[index2] = result2 || results[index2];
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e2) {
      return {
        type: ResultType.error,
        error: e2
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search2) {
  return new URLSearchParams(search2).getAll("index").some((v2) => v2 === "");
}
function createUseMatchesMatch(match2, loaderData) {
  let {
    route,
    pathname,
    params
  } = match2;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function getTargetMatch(matches, location2) {
  let search2 = typeof location2 === "string" ? parsePath(location2).search : location2.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search2 || "")) {
    return matches[matches.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
/**
 * React Router v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
function isPolyfill(x, y2) {
  return x === y2 && (x !== 0 || 1 / x === 1 / y2) || x !== x && y2 !== y2;
}
const is$1 = typeof Object.is === "function" ? Object.is : isPolyfill;
const {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = React$1;
function useSyncExternalStore$2(subscribe, getSnapshot, getServerSnapshot) {
  const value = getSnapshot();
  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  });
  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot;
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
  }, [subscribe, value, getSnapshot]);
  useEffect(() => {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({
          inst
        });
      }
    };
    return subscribe(handleStoreChange);
  }, [subscribe]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is$1(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
const useSyncExternalStore = "useSyncExternalStore" in React$1 ? ((module) => module.useSyncExternalStore)(React$1) : shim;
const DataStaticRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext$1 = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: []
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant$4(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext$1);
  let {
    hash: hash2,
    pathname,
    search: search2
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search: search2,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant$4(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? invariant$4(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext$1);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /* @__PURE__ */ reactExports.createContext(null);
function useOutlet(context) {
  let outlet = reactExports.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ reactExports.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant$4(false) : void 0;
  let dataRouterStateContext = reactExports.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant$4(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([parentPathnameBase, match2.pathname]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match2.pathnameBase])
  })), parentMatches, dataRouterStateContext || void 0);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$b({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location2),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unhandled Thrown Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "errorElement"), " props on", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "<Route>")));
}
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataStaticRouterContext = reactExports.useContext(DataStaticRouterContext);
  if (dataStaticRouterContext && match2.route.errorElement) {
    dataStaticRouterContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors2 = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors2 != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors2 == null ? void 0 : errors2[m2.route.id]));
    !(errorIndex >= 0) ? invariant$4(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error = match2.route.id ? errors2 == null ? void 0 : errors2[match2.route.id] : null;
    let errorElement = dataRouterState ? match2.route.errorElement || /* @__PURE__ */ reactExports.createElement(DefaultErrorElement, null) : null;
    let getChildren = () => /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
      match: match2,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index2 + 1))
      }
    }, error ? errorElement : match2.route.element !== void 0 ? match2.route.element : outlet);
    return dataRouterState && (match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error,
      children: getChildren()
    }) : getChildren();
  }, null);
}
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant$4(false) : void 0;
  return state;
}
function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook$1.UseNavigation);
  return state.navigation;
}
function useLoaderData() {
  let state = useDataRouterState(DataRouterStateHook$1.UseLoaderData);
  let route = reactExports.useContext(RouteContext);
  !route ? invariant$4(false) : void 0;
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant$4(false) : void 0;
  return state.loaderData[thisRoute.route.id];
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let route = reactExports.useContext(RouteContext);
  let thisRoute = route.matches[route.matches.length - 1];
  if (error) {
    return error;
  }
  !route ? invariant$4(false) : void 0;
  !thisRoute.route.id ? invariant$4(false) : void 0;
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];
}
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router
  } = _ref;
  let state = useSyncExternalStore(
    router.subscribe,
    () => router.state,
    // We have to provide this so React@18 doesn't complain during hydration,
    // but we pass our serialized hydration data into the router so state here
    // is already synced with what the server saw
    () => router.state
  );
  let navigator2 = reactExports.useMemo(() => {
    return {
      createHref: router.createHref,
      go: (n2) => router.navigate(n2),
      push: (to, state2, opts) => router.navigate(to, {
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state2, opts) => router.navigate(to, {
        replace: true,
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  return /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
    value: {
      router,
      navigator: navigator2,
      static: false,
      // Do we need this?
      basename
    }
  }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */ reactExports.createElement(Router, {
    basename: router.basename,
    location: router.state.location,
    navigationType: router.state.historyAction,
    navigator: navigator2
  }, router.state.initialized ? /* @__PURE__ */ reactExports.createElement(Routes, null) : fallbackElement)));
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route$1(_props) {
  invariant$4(false);
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? invariant$4(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search: search2 = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let location2 = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search: search2,
      hash: hash2,
      state,
      key
    };
  }, [basename, pathname, search2, hash2, state, key]);
  if (location2 == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext$1.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: {
      location: location2,
      navigationType
    }
  }));
}
function Routes(_ref5) {
  let {
    children,
    location: location2
  } = _ref5;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location2);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route$1) ? invariant$4(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant$4(false) : void 0;
    let treePath = [...parentPath, index2];
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
function enhanceManualRouteObjects(routes) {
  return routes.map((route) => {
    let routeClone = _extends$b({}, route);
    if (routeClone.hasErrorBoundary == null) {
      routeClone.hasErrorBoundary = routeClone.errorElement != null;
    }
    if (routeClone.children) {
      routeClone.children = enhanceManualRouteObjects(routeClone.children);
    }
    return routeClone;
  });
}
/**
 * React Router DOM v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map((v2) => [key, v2]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  for (let key of defaultSearchParams.keys()) {
    if (!searchParams.has(key)) {
      defaultSearchParams.getAll(key).forEach((value) => {
        searchParams.append(key, value);
      });
    }
  }
  return searchParams;
}
const _excluded$1y = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2$8 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function createBrowserRouter(routes, opts) {
  var _window;
  return createRouter({
    basename: opts == null ? void 0 : opts.basename,
    history: createBrowserHistory({
      window: opts == null ? void 0 : opts.window
    }),
    hydrationData: (opts == null ? void 0 : opts.hydrationData) || ((_window = window) == null ? void 0 : _window.__staticRouterHydrationData),
    routes: enhanceManualRouteObjects(routes)
  }).initialize();
}
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose$1(_ref4, _excluded$1y);
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$a({}, rest, {
      href,
      onClick: reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
const NavLink = /* @__PURE__ */ reactExports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end: end2 = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose$1(_ref5, _excluded2$8);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location2 = useLocation();
  let routerState = reactExports.useContext(DataRouterStateContext);
  let toPathname = path.pathname;
  let locationPathname = location2.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style2 = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link, _extends$a({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location2) === createPath(path);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location2, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
function useSearchParams(defaultInit) {
  let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
  let location2 = useLocation();
  let searchParams = reactExports.useMemo(() => getSearchParamsForLocation(location2.search, defaultSearchParamsRef.current), [location2.search]);
  let navigate = useNavigate();
  let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
const _extends$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _extends$8
}, Symbol.toStringTag, { value: "Module" }));
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function memoize$1(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop3) {
    return reactPropsRegex.test(prop3) || prop3.charCodeAt(0) === 111 && prop3.charCodeAt(1) === 110 && prop3.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement$1(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement$1(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush3() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs = Math.abs;
var from$1 = String.fromCharCode;
var assign$2 = Object.assign;
function hash$2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match$1(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search2) {
  return value.indexOf(search2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append2(value, array) {
  return array.push(value), value;
}
function combine$1(array, callback2) {
  return array.map(callback2).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position$3 = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type2, props, children, length2) {
  return { value, root: root2, parent, type: type2, props, children, line, column, length: length2, return: "" };
}
function copy$1(root2, props) {
  return assign$2(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position$3 > 0 ? charat(characters, --position$3) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position$3 < length ? charat(characters, position$3++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position$3);
}
function caret() {
  return position$3;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position$3 = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice(position$3 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position$3;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position$3;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position$3 - 1) + "*" + from$1(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position$3);
}
function compile(value) {
  return dealloc(parse$3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$3(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset3 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append2(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset3:
            if (property > 0 && strlen(characters2) - length2)
              append2(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append2(reference2 = ruleset(characters2, root2, parent, index2, offset3, rules, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset3 === 0)
                parse$3(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse$3(value, reference2, reference2, rule && append2(ruleset(value, reference2, reference2, 0, 0, rules, points, type2, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$3(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset3 = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset3 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset3 = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset3, rules, points, type2, props, children, length2) {
  var post = offset3 - 1;
  var rule = offset3 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index2; ++i)
    for (var x = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x < size; ++x)
      if (z2 = trim(j2 > 0 ? rule[x] + " " + y2 : replace$1(y2, /&\f/g, rule[x])))
        props[k2++] = z2;
  return node(value, root2, parent, offset3 === 0 ? RULESET : type2, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback2) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback2(children[i], i, children, callback2) || "";
  return output;
}
function stringify(element, index2, children, callback2) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback2) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback2)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback2) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback2) || "";
    return output;
  };
}
function rulesheet(callback2) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback2(element);
    }
  };
}
var weakMemoize = function weakMemoize2(func) {
  var cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    var ret = func(arg);
    cache.set(arg, ret);
    return ret;
  };
};
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position$3);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position$3 - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from$1(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix$3(value, length2) {
  switch (hash$2(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$1(value, "-grow", "") + WEBKIT + value + MS + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix$3(replace$1(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback2) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix$3(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy$1(element, {
            value: replace$1(element.value, "@", "@" + WEBKIT)
          })], callback2);
        case RULESET:
          if (element.length)
            return combine$1(element.props, function(value) {
              switch (match$1(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy$1(element, {
                    props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback2);
                case "::placeholder":
                  return serialize([copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback2);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container2;
  var nodesToHydrate = [];
  {
    container2 = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container: container2,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIsExports$2 = {};
var reactIs$3 = {
  get exports() {
    return reactIsExports$2;
  },
  set exports(v2) {
    reactIsExports$2 = v2;
  }
};
var reactIs_production_min$2 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$3 = "function" === typeof Symbol && Symbol.for, c$2 = b$3 ? Symbol.for("react.element") : 60103, d$2 = b$3 ? Symbol.for("react.portal") : 60106, e$2 = b$3 ? Symbol.for("react.fragment") : 60107, f$2 = b$3 ? Symbol.for("react.strict_mode") : 60108, g$3 = b$3 ? Symbol.for("react.profiler") : 60114, h$2 = b$3 ? Symbol.for("react.provider") : 60109, k$3 = b$3 ? Symbol.for("react.context") : 60110, l$2 = b$3 ? Symbol.for("react.async_mode") : 60111, m$2 = b$3 ? Symbol.for("react.concurrent_mode") : 60111, n$2 = b$3 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$3 ? Symbol.for("react.suspense") : 60113, q$3 = b$3 ? Symbol.for("react.suspense_list") : 60120, r$2 = b$3 ? Symbol.for("react.memo") : 60115, t$1 = b$3 ? Symbol.for("react.lazy") : 60116, v$3 = b$3 ? Symbol.for("react.block") : 60121, w$2 = b$3 ? Symbol.for("react.fundamental") : 60117, x$2 = b$3 ? Symbol.for("react.responder") : 60118, y$1 = b$3 ? Symbol.for("react.scope") : 60119;
function z$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$2:
        switch (a2 = a2.type, a2) {
          case l$2:
          case m$2:
          case e$2:
          case g$3:
          case f$2:
          case p$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$3:
              case n$2:
              case t$1:
              case r$2:
              case h$2:
                return a2;
              default:
                return u2;
            }
        }
      case d$2:
        return u2;
    }
  }
}
function A$2(a2) {
  return z$2(a2) === m$2;
}
reactIs_production_min$2.AsyncMode = l$2;
reactIs_production_min$2.ConcurrentMode = m$2;
reactIs_production_min$2.ContextConsumer = k$3;
reactIs_production_min$2.ContextProvider = h$2;
reactIs_production_min$2.Element = c$2;
reactIs_production_min$2.ForwardRef = n$2;
reactIs_production_min$2.Fragment = e$2;
reactIs_production_min$2.Lazy = t$1;
reactIs_production_min$2.Memo = r$2;
reactIs_production_min$2.Portal = d$2;
reactIs_production_min$2.Profiler = g$3;
reactIs_production_min$2.StrictMode = f$2;
reactIs_production_min$2.Suspense = p$2;
reactIs_production_min$2.isAsyncMode = function(a2) {
  return A$2(a2) || z$2(a2) === l$2;
};
reactIs_production_min$2.isConcurrentMode = A$2;
reactIs_production_min$2.isContextConsumer = function(a2) {
  return z$2(a2) === k$3;
};
reactIs_production_min$2.isContextProvider = function(a2) {
  return z$2(a2) === h$2;
};
reactIs_production_min$2.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
};
reactIs_production_min$2.isForwardRef = function(a2) {
  return z$2(a2) === n$2;
};
reactIs_production_min$2.isFragment = function(a2) {
  return z$2(a2) === e$2;
};
reactIs_production_min$2.isLazy = function(a2) {
  return z$2(a2) === t$1;
};
reactIs_production_min$2.isMemo = function(a2) {
  return z$2(a2) === r$2;
};
reactIs_production_min$2.isPortal = function(a2) {
  return z$2(a2) === d$2;
};
reactIs_production_min$2.isProfiler = function(a2) {
  return z$2(a2) === g$3;
};
reactIs_production_min$2.isStrictMode = function(a2) {
  return z$2(a2) === f$2;
};
reactIs_production_min$2.isSuspense = function(a2) {
  return z$2(a2) === p$2;
};
reactIs_production_min$2.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$2 || a2 === g$3 || a2 === f$2 || a2 === p$2 || a2 === q$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$1 || a2.$$typeof === r$2 || a2.$$typeof === h$2 || a2.$$typeof === k$3 || a2.$$typeof === n$2 || a2.$$typeof === w$2 || a2.$$typeof === x$2 || a2.$$typeof === y$1 || a2.$$typeof === v$3);
};
reactIs_production_min$2.typeOf = z$2;
(function(module) {
  {
    module.exports = reactIs_production_min$2;
  }
})(reactIs$3);
var reactIs$2 = reactIsExports$2;
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$2.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$2.Memo] = MEMO_STATICS;
function getStatics(component) {
  if (reactIs$2.isMemo(component)) {
    return MEMO_STATICS;
  }
  return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
}
var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== "string") {
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);
      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }
    var keys3 = getOwnPropertyNames(sourceComponent);
    if (getOwnPropertySymbols) {
      keys3 = keys3.concat(getOwnPropertySymbols(sourceComponent));
    }
    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);
    for (var i = 0; i < keys3.length; ++i) {
      var key = keys3[i];
      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
        try {
          defineProperty(targetComponent, key, descriptor);
        } catch (e2) {
        }
      }
    }
  }
  return targetComponent;
}
var hoistNonReactStatics_cjs = hoistNonReactStatics;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len2 = str.length;
  for (; len2 >= 4; ++i, len2 -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len2) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys$1 = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys$1[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      styles2 += strings[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext$2 = /* @__PURE__ */ reactExports.createContext({});
var getTheme = function getTheme2(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    return mergedTheme;
  }
  return _extends$8({}, outerTheme, theme2);
};
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme(outerTheme, theme2);
  });
});
var ThemeProvider = function ThemeProvider2(props) {
  var theme2 = reactExports.useContext(ThemeContext$2);
  if (props.theme !== theme2) {
    theme2 = createCacheWithTheme(theme2)(props.theme);
  }
  return /* @__PURE__ */ reactExports.createElement(ThemeContext$2.Provider, {
    value: theme2
  }, props.children);
};
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext$2));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString4() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal2) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal2) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal2 = tag.__emotion_real === tag;
  var baseTag = isReal2 && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal2);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal2 && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len2 = args.length;
      var i = 1;
      for (; i < len2; i++) {
        styles2.push(args[i], args[0][i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext$2);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled(nextTag, _extends$8({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
const emStyled = newStyled;
var propTypesExports = {};
var propTypes = {
  get exports() {
    return propTypesExports;
  },
  set exports(v2) {
    propTypesExports = v2;
  }
};
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location2, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
function isEmpty$6(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$1(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$6(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsx(Global, {
    styles: globalStyles
  });
}
/** @license MUI v5.10.8
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$5(tag, options) {
  const stylesFactory = emStyled(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
function isPlainObject$2(item) {
  return item !== null && typeof item === "object" && item.constructor === Object;
}
function deepClone(source) {
  if (!isPlainObject$2(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends$8({}, target) : target;
  if (isPlainObject$2(target) && isPlainObject$2(source)) {
    Object.keys(source).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isPlainObject$2(source[key]) && key in target && isPlainObject$2(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject$2(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
function formatMuiErrorMessage(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i = 1; i < arguments.length; i += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
var reactIsExports$1 = {};
var reactIs$1 = {
  get exports() {
    return reactIsExports$1;
  },
  set exports(v2) {
    reactIsExports$1 = v2;
  }
};
var reactIs_production_min$1 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$2 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$1 = Symbol.for("react.fragment"), e$1 = Symbol.for("react.strict_mode"), f$1 = Symbol.for("react.profiler"), g$2 = Symbol.for("react.provider"), h$1 = Symbol.for("react.context"), k$2 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$1 = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q$2 = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u$1;
u$1 = Symbol.for("react.module.reference");
function v$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r3 = a2.$$typeof;
    switch (r3) {
      case b$2:
        switch (a2 = a2.type, a2) {
          case d$1:
          case f$1:
          case e$1:
          case m$1:
          case n$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case h$1:
              case l$1:
              case q$2:
              case p$1:
              case g$2:
                return a2;
              default:
                return r3;
            }
        }
      case c$1:
        return r3;
    }
  }
}
reactIs_production_min$1.ContextConsumer = h$1;
reactIs_production_min$1.ContextProvider = g$2;
reactIs_production_min$1.Element = b$2;
reactIs_production_min$1.ForwardRef = l$1;
reactIs_production_min$1.Fragment = d$1;
reactIs_production_min$1.Lazy = q$2;
reactIs_production_min$1.Memo = p$1;
reactIs_production_min$1.Portal = c$1;
reactIs_production_min$1.Profiler = f$1;
reactIs_production_min$1.StrictMode = e$1;
reactIs_production_min$1.Suspense = m$1;
reactIs_production_min$1.SuspenseList = n$1;
reactIs_production_min$1.isAsyncMode = function() {
  return false;
};
reactIs_production_min$1.isConcurrentMode = function() {
  return false;
};
reactIs_production_min$1.isContextConsumer = function(a2) {
  return v$2(a2) === h$1;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return v$2(a2) === g$2;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$2;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return v$2(a2) === l$1;
};
reactIs_production_min$1.isFragment = function(a2) {
  return v$2(a2) === d$1;
};
reactIs_production_min$1.isLazy = function(a2) {
  return v$2(a2) === q$2;
};
reactIs_production_min$1.isMemo = function(a2) {
  return v$2(a2) === p$1;
};
reactIs_production_min$1.isPortal = function(a2) {
  return v$2(a2) === c$1;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return v$2(a2) === f$1;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return v$2(a2) === e$1;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return v$2(a2) === m$1;
};
reactIs_production_min$1.isSuspenseList = function(a2) {
  return v$2(a2) === n$1;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d$1 || a2 === f$1 || a2 === e$1 || a2 === m$1 || a2 === n$1 || a2 === t || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$2 || a2.$$typeof === p$1 || a2.$$typeof === g$2 || a2.$$typeof === h$1 || a2.$$typeof === l$1 || a2.$$typeof === u$1 || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min$1.typeOf = v$2;
(function(module) {
  {
    module.exports = reactIs_production_min$1;
  }
})(reactIs$1);
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function debounce$2(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function deprecatedPropType(validator2, reason) {
  {
    return () => null;
  }
}
function isMuiElement(element, muiNames) {
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function requirePropFactory(componentNameInError, Component2) {
  {
    return () => null;
  }
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
const useEnhancedEffect$1 = useEnhancedEffect;
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React$1["useId"];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function unsupportedProp(props, propName, componentName, location2, propFullName) {
  {
    return null;
  }
}
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback(fn2) {
  const ref = reactExports.useRef(fn2);
  useEnhancedEffect$1(() => {
    ref.current = fn2;
  });
  return reactExports.useCallback((...args) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, ref.current)(...args)
  ), []);
}
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type: type2,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type2] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref = reactExports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = reactExports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
function getScrollbarSize(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
let cachedType;
function detectScrollType() {
  if (cachedType) {
    return cachedType;
  }
  const dummy = document.createElement("div");
  const container2 = document.createElement("div");
  container2.style.width = "10px";
  container2.style.height = "1px";
  dummy.appendChild(container2);
  dummy.dir = "rtl";
  dummy.style.fontSize = "14px";
  dummy.style.width = "4px";
  dummy.style.height = "1px";
  dummy.style.position = "absolute";
  dummy.style.top = "-1000px";
  dummy.style.overflow = "scroll";
  document.body.appendChild(dummy);
  cachedType = "reverse";
  if (dummy.scrollLeft > 0) {
    cachedType = "default";
  } else {
    dummy.scrollLeft = 1;
    if (dummy.scrollLeft === 0) {
      cachedType = "negative";
    }
  }
  document.body.removeChild(dummy);
  return cachedType;
}
function getNormalizedScrollLeft(element, direction) {
  const scrollLeft = element.scrollLeft;
  if (direction !== "rtl") {
    return scrollLeft;
  }
  const type2 = detectScrollType();
  switch (type2) {
    case "negative":
      return element.scrollWidth - element.clientWidth + scrollLeft;
    case "reverse":
      return element.scrollWidth - element.clientWidth - scrollLeft;
    default:
      return scrollLeft;
  }
}
const visuallyHidden$1 = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: -1,
  overflow: "hidden",
  padding: 0,
  position: "absolute",
  whiteSpace: "nowrap",
  width: "1px"
};
const visuallyHidden$2 = visuallyHidden$1;
function resolveProps(defaultProps2, props) {
  const output = _extends$8({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output[propName] = _extends$8({}, defaultProps2[propName], output[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps2[propName] || {};
      const slotProps = props[propName];
      output[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        output[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        output[propName] = slotProps;
      } else {
        output[propName] = _extends$8({}, slotProps);
        Object.keys(defaultSlotProps).forEach((slotPropName) => {
          output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output[propName] === void 0) {
      output[propName] = defaultProps2[propName];
    }
  });
  return output;
}
function composeClasses(slots, getUtilityClass, classes) {
  const output = {};
  Object.keys(slots).forEach(
    // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          acc.push(getUtilityClass(key));
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const ClassNameGenerator$1 = ClassNameGenerator;
const globalStateClassesMapping = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
function merge$2(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$3 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$3[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme2 = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index2) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index2])] = styleFromPropValue(propValue[index2]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme2.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values$3).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
  const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
  const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
  return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
}
function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
  if (typeof breakpointValues !== "object") {
    return {};
  }
  const base = {};
  const breakpointsKeys = Object.keys(themeBreakpoints);
  if (Array.isArray(breakpointValues)) {
    breakpointsKeys.forEach((breakpoint, i) => {
      if (i < breakpointValues.length) {
        base[breakpoint] = true;
      }
    });
  } else {
    breakpointsKeys.forEach((breakpoint) => {
      if (breakpointValues[breakpoint] != null) {
        base[breakpoint] = true;
      }
    });
  }
  return base;
}
function resolveBreakpointValues({
  values: breakpointValues,
  breakpoints: themeBreakpoints,
  base: customBase
}) {
  const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
  const keys3 = Object.keys(base);
  if (keys3.length === 0) {
    return breakpointValues;
  }
  let previous;
  return keys3.reduce((acc, breakpoint, i) => {
    if (Array.isArray(breakpointValues)) {
      acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
      previous = i;
    } else if (typeof breakpointValues === "object") {
      acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
      previous = breakpoint;
    } else {
      acc[breakpoint] = breakpointValues;
    }
    return acc;
  }, {});
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getValue$2(themeMapping, transform3, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform3) {
    value = transform3(value, userValue);
  }
  return value;
}
function style$5(options) {
  const {
    prop: prop3,
    cssProperty = options.prop,
    themeKey,
    transform: transform3
  } = options;
  const fn2 = (props) => {
    if (props[prop3] == null) {
      return null;
    }
    const propValue = props[prop3];
    const theme2 = props.theme;
    const themeMapping = getPath(theme2, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getValue$2(themeMapping, transform3, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getValue$2(themeMapping, transform3, `${prop3}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = {};
  fn2.filterProps = [prop3];
  return fn2;
}
function compose$1(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop3) => {
      acc[prop3] = style2;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop3) => {
      if (handlers[prop3]) {
        return merge$2(acc, handlers[prop3](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
function memoize(fn2) {
  const cache = {};
  return (arg) => {
    if (cache[arg] === void 0) {
      cache[arg] = fn2(arg);
    }
    return cache[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases$1 = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop3) => {
  if (prop3.length > 2) {
    if (aliases$1[prop3]) {
      prop3 = aliases$1[prop3];
    } else {
      return [prop3];
    }
  }
  const [a2, b2] = prop3.split("");
  const property = properties[a2];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
const spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(theme2, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme2, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme2) {
  return createUnaryUnit(theme2, "spacing", 8);
}
function getValue$1(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue$1(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys3, prop3, transformer) {
  if (keys3.indexOf(prop3) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop3);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop3];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style$4(props, keys3) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop3) => resolveCssProperty(props, keys3, prop3, transformer)).reduce(merge$2, {});
}
function spacing(props) {
  return style$4(props, spacingKeys);
}
spacing.propTypes = {};
spacing.filterProps = spacingKeys;
function getBorder(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
const border = style$5({
  prop: "border",
  themeKey: "borders",
  transform: getBorder
});
const borderTop = style$5({
  prop: "borderTop",
  themeKey: "borders",
  transform: getBorder
});
const borderRight = style$5({
  prop: "borderRight",
  themeKey: "borders",
  transform: getBorder
});
const borderBottom = style$5({
  prop: "borderBottom",
  themeKey: "borders",
  transform: getBorder
});
const borderLeft = style$5({
  prop: "borderLeft",
  themeKey: "borders",
  transform: getBorder
});
const borderColor = style$5({
  prop: "borderColor",
  themeKey: "palette"
});
const borderTopColor = style$5({
  prop: "borderTopColor",
  themeKey: "palette"
});
const borderRightColor = style$5({
  prop: "borderRightColor",
  themeKey: "palette"
});
const borderBottomColor = style$5({
  prop: "borderBottomColor",
  themeKey: "palette"
});
const borderLeftColor = style$5({
  prop: "borderLeftColor",
  themeKey: "palette"
});
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue$1(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
const borders = compose$1(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
const borders$1 = borders;
const displayPrint = style$5({
  prop: "displayPrint",
  cssProperty: false,
  transform: (value) => ({
    "@media print": {
      display: value
    }
  })
});
const displayRaw = style$5({
  prop: "display"
});
const overflow = style$5({
  prop: "overflow"
});
const textOverflow = style$5({
  prop: "textOverflow"
});
const visibility = style$5({
  prop: "visibility"
});
const whiteSpace = style$5({
  prop: "whiteSpace"
});
const display = compose$1(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);
const flexBasis = style$5({
  prop: "flexBasis"
});
const flexDirection = style$5({
  prop: "flexDirection"
});
const flexWrap = style$5({
  prop: "flexWrap"
});
const justifyContent = style$5({
  prop: "justifyContent"
});
const alignItems = style$5({
  prop: "alignItems"
});
const alignContent = style$5({
  prop: "alignContent"
});
const order$1 = style$5({
  prop: "order"
});
const flex = style$5({
  prop: "flex"
});
const flexGrow = style$5({
  prop: "flexGrow"
});
const flexShrink = style$5({
  prop: "flexShrink"
});
const alignSelf = style$5({
  prop: "alignSelf"
});
const justifyItems = style$5({
  prop: "justifyItems"
});
const justifySelf = style$5({
  prop: "justifySelf"
});
const flexbox = compose$1(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order$1, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf);
const flexbox$1 = flexbox;
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue$1(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue$1(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue$1(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$5({
  prop: "gridColumn"
});
const gridRow = style$5({
  prop: "gridRow"
});
const gridAutoFlow = style$5({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$5({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$5({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$5({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$5({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$5({
  prop: "gridTemplateAreas"
});
const gridArea = style$5({
  prop: "gridArea"
});
const grid = compose$1(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
const grid$1 = grid;
function transform$2(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$5({
  prop: "color",
  themeKey: "palette",
  transform: transform$2
});
const bgcolor = style$5({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: transform$2
});
const backgroundColor = style$5({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: transform$2
});
const palette = compose$1(color, bgcolor, backgroundColor);
const palette$1 = palette;
const position$2 = style$5({
  prop: "position"
});
const zIndex$2 = style$5({
  prop: "zIndex",
  themeKey: "zIndex"
});
const top$1 = style$5({
  prop: "top"
});
const right$1 = style$5({
  prop: "right"
});
const bottom$1 = style$5({
  prop: "bottom"
});
const left$1 = style$5({
  prop: "left"
});
const positions = compose$1(position$2, zIndex$2, top$1, right$1, bottom$1, left$1);
const boxShadow = style$5({
  prop: "boxShadow",
  themeKey: "shadows"
});
const shadows$2 = boxShadow;
function transform$1(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$5({
  prop: "width",
  transform: transform$1
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;
      const breakpoint = ((_props$theme = props.theme) == null ? void 0 : (_props$theme$breakpoi = _props$theme.breakpoints) == null ? void 0 : (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values$3[propValue];
      return {
        maxWidth: breakpoint || transform$1(propValue)
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$5({
  prop: "minWidth",
  transform: transform$1
});
const height = style$5({
  prop: "height",
  transform: transform$1
});
const maxHeight = style$5({
  prop: "maxHeight",
  transform: transform$1
});
const minHeight = style$5({
  prop: "minHeight",
  transform: transform$1
});
style$5({
  prop: "size",
  cssProperty: "width",
  transform: transform$1
});
style$5({
  prop: "size",
  cssProperty: "height",
  transform: transform$1
});
const boxSizing = style$5({
  prop: "boxSizing"
});
const sizing = compose$1(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const sizing$1 = sizing;
const fontFamily = style$5({
  prop: "fontFamily",
  themeKey: "typography"
});
const fontSize = style$5({
  prop: "fontSize",
  themeKey: "typography"
});
const fontStyle = style$5({
  prop: "fontStyle",
  themeKey: "typography"
});
const fontWeight = style$5({
  prop: "fontWeight",
  themeKey: "typography"
});
const letterSpacing = style$5({
  prop: "letterSpacing"
});
const textTransform = style$5({
  prop: "textTransform"
});
const lineHeight = style$5({
  prop: "lineHeight"
});
const textAlign = style$5({
  prop: "textAlign"
});
const typographyVariant = style$5({
  prop: "typography",
  cssProperty: false,
  themeKey: "typography"
});
const typography = compose$1(typographyVariant, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign, textTransform);
const typography$1 = typography;
const filterPropsMapping = {
  borders: borders$1.filterProps,
  display: display.filterProps,
  flexbox: flexbox$1.filterProps,
  grid: grid$1.filterProps,
  positions: positions.filterProps,
  palette: palette$1.filterProps,
  shadows: shadows$2.filterProps,
  sizing: sizing$1.filterProps,
  spacing: spacing.filterProps,
  typography: typography$1.filterProps
};
const styleFunctionMapping = {
  borders: borders$1,
  display,
  flexbox: flexbox$1,
  grid: grid$1,
  positions,
  palette: palette$1,
  shadows: shadows$2,
  sizing: sizing$1,
  spacing,
  typography: typography$1
};
const propToStyleFunction = Object.keys(filterPropsMapping).reduce((acc, styleFnName) => {
  filterPropsMapping[styleFnName].forEach((propName) => {
    acc[propName] = styleFunctionMapping[styleFnName];
  });
  return acc;
}, {});
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys3, object) => keys3.concat(Object.keys(object)), []);
  const union3 = new Set(allKeys);
  return objects.every((object) => union3.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx(styleFunctionMapping$1 = styleFunctionMapping) {
  const propToStyleFunction2 = Object.keys(styleFunctionMapping$1).reduce((acc, styleFnName) => {
    styleFunctionMapping$1[styleFnName].filterProps.forEach((propName) => {
      acc[propName] = styleFunctionMapping$1[styleFnName];
    });
    return acc;
  }, {});
  function getThemeValue(prop3, value, theme2) {
    const inputProps = {
      [prop3]: value,
      theme: theme2
    };
    const styleFunction = propToStyleFunction2[prop3];
    return styleFunction ? styleFunction(inputProps) : {
      [prop3]: value
    };
  }
  function styleFunctionSx2(props) {
    const {
      sx,
      theme: theme2 = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme2);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme2.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme2);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (propToStyleFunction2[styleKey]) {
              css2 = merge$2(css2, getThemeValue(styleKey, value, theme2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme: theme2
              }, value, (x) => ({
                [styleKey]: x
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme: theme2
                });
              } else {
                css2 = merge$2(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$2(css2, getThemeValue(styleKey, value, theme2));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const defaultStyleFunctionSx = styleFunctionSx;
const _excluded$1x = ["sx"];
const splitProps = (props) => {
  const result = {
    systemProps: {},
    otherProps: {}
  };
  Object.keys(props).forEach((prop3) => {
    if (propToStyleFunction[prop3]) {
      result.systemProps[prop3] = props[prop3];
    } else {
      result.otherProps[prop3] = props[prop3];
    }
  });
  return result;
};
function extendSxProp(props) {
  const {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1x);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject$2(result)) {
        return systemProps;
      }
      return _extends$8({}, systemProps, result);
    };
  } else {
    finalSx = _extends$8({}, systemProps, inSx);
  }
  return _extends$8({}, otherProps, {
    sx: finalSx
  });
}
function r$1(e2) {
  var t3, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t3 = 0; t3 < e2.length; t3++)
        e2[t3] && (f2 = r$1(e2[t3])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t3 in e2)
        e2[t3] && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
function clsx() {
  for (var e2, t3, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t3 = r$1(e2)) && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
const _excluded$1w = ["values", "unit", "step"];
const sortBreakpointsValues = (values3) => {
  const breakpointsAsArray = Object.keys(values3).map((key) => ({
    key,
    val: values3[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends$8({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values3 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose(breakpoints, _excluded$1w);
  const sortedValues = sortBreakpointsValues(values3);
  const keys3 = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values3[key] === "number" ? values3[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values3[key] === "number" ? values3[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start3, end2) {
    const endIndex = keys3.indexOf(end2);
    return `@media (min-width:${typeof values3[start3] === "number" ? values3[start3] : start3}${unit}) and (max-width:${(endIndex !== -1 && typeof values3[keys3[endIndex]] === "number" ? values3[keys3[endIndex]] : end2) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys3.indexOf(key) + 1 < keys3.length) {
      return between(key, keys3[keys3.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys3.indexOf(key);
    if (keyIndex === 0) {
      return up(keys3[1]);
    }
    if (keyIndex === keys3.length - 1) {
      return down(keys3[keyIndex]);
    }
    return between(key, keys3[keys3.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return _extends$8({
    keys: keys3,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
const shape = {
  borderRadius: 4
};
const shape$1 = shape;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform3 = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing2 = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform3(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing2.mui = true;
  return spacing2;
}
const _excluded$1v = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$1v);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing2 = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$8({
      mode: "light"
    }, paletteInput),
    spacing: spacing2,
    shape: _extends$8({}, shape$1, shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  return muiTheme;
}
const ThemeContext = /* @__PURE__ */ reactExports.createContext(null);
const ThemeContext$1 = ThemeContext;
function useTheme$3() {
  const theme2 = reactExports.useContext(ThemeContext$1);
  return theme2;
}
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = useTheme$3();
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
const _excluded$1u = ["className", "component"];
function createBox$1(options = {}) {
  const {
    defaultTheme: defaultTheme2,
    defaultClassName = "MuiBox-root",
    generateClassName,
    styleFunctionSx: styleFunctionSx2 = defaultStyleFunctionSx
  } = options;
  const BoxRoot = styled$5("div", {
    shouldForwardProp: (prop3) => prop3 !== "theme" && prop3 !== "sx" && prop3 !== "as"
  })(styleFunctionSx2);
  const Box2 = /* @__PURE__ */ reactExports.forwardRef(function Box3(inProps, ref) {
    const theme2 = useTheme$1(defaultTheme2);
    const _extendSxProp = extendSxProp(inProps), {
      className,
      component = "div"
    } = _extendSxProp, other = _objectWithoutPropertiesLoose(_extendSxProp, _excluded$1u);
    return /* @__PURE__ */ jsx(BoxRoot, _extends$8({
      as: component,
      ref,
      className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
      theme: theme2
    }, other));
  });
  return Box2;
}
const Box$2 = createBox$1();
const Box$3 = Box$2;
const _excluded$1t = ["variant"];
function isEmpty$5(string) {
  return string.length === 0;
}
function propsToClassKey(props) {
  const {
    variant
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1t);
  let classKey = variant || "";
  Object.keys(other).sort().forEach((key) => {
    if (key === "color") {
      classKey += isEmpty$5(classKey) ? props[key] : capitalize(props[key]);
    } else {
      classKey += `${isEmpty$5(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
    }
  });
  return classKey;
}
const _excluded$1s = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"], _excluded2$7 = ["theme"], _excluded3 = ["theme"];
function isEmpty$4(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
const getStyleOverrides = (name, theme2) => {
  if (theme2.components && theme2.components[name] && theme2.components[name].styleOverrides) {
    return theme2.components[name].styleOverrides;
  }
  return null;
};
const getVariantStyles = (name, theme2) => {
  let variants = [];
  if (theme2 && theme2.components && theme2.components[name] && theme2.components[name].variants) {
    variants = theme2.components[name].variants;
  }
  const variantsStyles = {};
  variants.forEach((definition) => {
    const key = propsToClassKey(definition.props);
    variantsStyles[key] = definition.style;
  });
  return variantsStyles;
};
const variantsResolver = (props, styles2, theme2, name) => {
  var _theme$components, _theme$components$nam;
  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  const themeVariants = theme2 == null ? void 0 : (_theme$components = theme2.components) == null ? void 0 : (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;
  if (themeVariants) {
    themeVariants.forEach((themeVariant) => {
      let isMatch = true;
      Object.keys(themeVariant.props).forEach((key) => {
        if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
          isMatch = false;
        }
      });
      if (isMatch) {
        variantsStyles.push(styles2[propsToClassKey(themeVariant.props)]);
      }
    });
  }
  return variantsStyles;
};
function shouldForwardProp(prop3) {
  return prop3 !== "ownerState" && prop3 !== "theme" && prop3 !== "sx" && prop3 !== "as";
}
const systemDefaultTheme = createTheme$1();
function createStyled2(input = {}) {
  const {
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp,
    styleFunctionSx: styleFunctionSx2 = defaultStyleFunctionSx
  } = input;
  const systemSx = (props) => {
    const theme2 = isEmpty$4(props.theme) ? defaultTheme2 : props.theme;
    return styleFunctionSx2(_extends$8({}, props, {
      theme: theme2
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      overridesResolver: overridesResolver2
    } = inputOptions, options = _objectWithoutPropertiesLoose(inputOptions, _excluded$1s);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : componentSlot && componentSlot !== "Root" || false;
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$5(tag, _extends$8({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const muiStyledResolver = (styleArg, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
        return typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg ? (_ref) => {
          let {
            theme: themeInput
          } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded2$7);
          return stylesArg(_extends$8({
            theme: isEmpty$4(themeInput) ? defaultTheme2 : themeInput
          }, other));
        } : stylesArg;
      }) : [];
      let transformedStyleArg = styleArg;
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme2 = isEmpty$4(props.theme) ? defaultTheme2 : props.theme;
          const styleOverrides = getStyleOverrides(componentName, theme2);
          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends$8({}, props, {
                theme: theme2
              })) : slotStyle;
            });
            return overridesResolver2(props, resolvedStyleOverrides);
          }
          return null;
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme2 = isEmpty$4(props.theme) ? defaultTheme2 : props.theme;
          return variantsResolver(props, getVariantStyles(componentName, theme2), theme2, componentName);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      } else if (typeof styleArg === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
      // component stays as a function. This condition makes sure that we do not interpolate functions
      // which are basically components used as a selectors.
      styleArg.__emotion_real !== styleArg) {
        transformedStyleArg = (_ref2) => {
          let {
            theme: themeInput
          } = _ref2, other = _objectWithoutPropertiesLoose(_ref2, _excluded3);
          return styleArg(_extends$8({
            theme: isEmpty$4(themeInput) ? defaultTheme2 : themeInput
          }, other));
        };
      }
      const Component2 = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      return Component2;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
const styled$3 = createStyled2();
const styled$4 = styled$3;
function getThemeProps(params) {
  const {
    theme: theme2,
    name,
    props
  } = params;
  if (!theme2 || !theme2.components || !theme2.components[name] || !theme2.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme2.components[name].defaultProps, props);
}
function useThemeProps$1({
  props,
  name,
  defaultTheme: defaultTheme2
}) {
  const theme2 = useTheme$1(defaultTheme2);
  const mergedProps = getThemeProps({
    theme: theme2,
    name,
    props
  });
  return mergedProps;
}
function clamp$1(value, min2 = 0, max2 = 1) {
  return Math.min(Math.max(min2, value), max2);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors2 = color2.match(re2);
  if (colors2 && colors2[0].length === 1) {
    colors2 = colors2.map((n2) => n2 + n2);
  }
  return colors2 ? `rgb${colors2.length === 4 ? "a" : ""}(${colors2.map((n2, index2) => {
    return index2 < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type2 = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type2) === -1) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values3 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type2 === "color") {
    values3 = values3.split(" ");
    colorSpace = values3.shift();
    if (values3.length === 4 && values3[3].charAt(0) === "/") {
      values3[3] = values3[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values3 = values3.split(",");
  }
  values3 = values3.map((value) => parseFloat(value));
  return {
    type: type2,
    values: values3,
    colorSpace
  };
}
function recomposeColor(color2) {
  const {
    type: type2,
    colorSpace
  } = color2;
  let {
    values: values3
  } = color2;
  if (type2.indexOf("rgb") !== -1) {
    values3 = values3.map((n2, i) => i < 3 ? parseInt(n2, 10) : n2);
  } else if (type2.indexOf("hsl") !== -1) {
    values3[1] = `${values3[1]}%`;
    values3[2] = `${values3[2]}%`;
  }
  if (type2.indexOf("color") !== -1) {
    values3 = `${colorSpace} ${values3.join(" ")}`;
  } else {
    values3 = `${values3.join(", ")}`;
  }
  return `${type2}(${values3})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values3
  } = color2;
  const h2 = values3[0];
  const s = values3[1] / 100;
  const l2 = values3[2] / 100;
  const a2 = s * Math.min(l2, 1 - l2);
  const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type2 = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type2 += "a";
    rgb.push(values3[3]);
  }
  return recomposeColor({
    type: type2,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clamp$1(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clamp$1(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clamp$1(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (255 - color2.values[i]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i = 0; i < 3; i += 1) {
      color2.values[i] += (1 - color2.values[i]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function emphasize(color2, coefficient = 0.15) {
  return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
}
const _excluded$1r = ["className", "component", "disableGutters", "fixed", "maxWidth", "classes"];
const defaultTheme$3 = createTheme$1();
const defaultCreateStyledComponent = styled$4("div", {
  name: "MuiContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
  }
});
const useThemePropsDefault = (inProps) => useThemeProps$1({
  props: inProps,
  name: "MuiContainer",
  defaultTheme: defaultTheme$3
});
const useUtilityClasses$16 = (ownerState, componentName) => {
  const getContainerUtilityClass = (slot) => {
    return generateUtilityClass(componentName, slot);
  };
  const {
    classes,
    fixed,
    disableGutters,
    maxWidth: maxWidth2
  } = ownerState;
  const slots = {
    root: ["root", maxWidth2 && `maxWidth${capitalize(String(maxWidth2))}`, fixed && "fixed", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getContainerUtilityClass, classes);
};
function createContainer(options = {}) {
  const {
    // This will allow adding custom styled fn (for example for custom sx style function)
    createStyledComponent = defaultCreateStyledComponent,
    useThemeProps: useThemeProps2 = useThemePropsDefault,
    componentName = "MuiContainer"
  } = options;
  const ContainerRoot = createStyledComponent(({
    theme: theme2,
    ownerState
  }) => _extends$8({
    width: "100%",
    marginLeft: "auto",
    boxSizing: "border-box",
    marginRight: "auto",
    display: "block"
  }, !ownerState.disableGutters && {
    paddingLeft: theme2.spacing(2),
    paddingRight: theme2.spacing(2),
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up("sm")]: {
      paddingLeft: theme2.spacing(3),
      paddingRight: theme2.spacing(3)
    }
  }), ({
    theme: theme2,
    ownerState
  }) => ownerState.fixed && Object.keys(theme2.breakpoints.values).reduce((acc, breakpointValueKey) => {
    const breakpoint = breakpointValueKey;
    const value = theme2.breakpoints.values[breakpoint];
    if (value !== 0) {
      acc[theme2.breakpoints.up(breakpoint)] = {
        maxWidth: `${value}${theme2.breakpoints.unit}`
      };
    }
    return acc;
  }, {}), ({
    theme: theme2,
    ownerState
  }) => _extends$8({}, ownerState.maxWidth === "xs" && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up("xs")]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: Math.max(theme2.breakpoints.values.xs, 444)
    }
  }, ownerState.maxWidth && // @ts-ignore module augmentation fails if custom breakpoints are used
  ownerState.maxWidth !== "xs" && {
    // @ts-ignore module augmentation fails if custom breakpoints are used
    [theme2.breakpoints.up(ownerState.maxWidth)]: {
      // @ts-ignore module augmentation fails if custom breakpoints are used
      maxWidth: `${theme2.breakpoints.values[ownerState.maxWidth]}${theme2.breakpoints.unit}`
    }
  }));
  const Container2 = /* @__PURE__ */ reactExports.forwardRef(function Container3(inProps, ref) {
    const props = useThemeProps2(inProps);
    const {
      className,
      component = "div",
      disableGutters = false,
      fixed = false,
      maxWidth: maxWidth2 = "lg"
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1r);
    const ownerState = _extends$8({}, props, {
      component,
      disableGutters,
      fixed,
      maxWidth: maxWidth2
    });
    const classes = useUtilityClasses$16(ownerState, componentName);
    return (
      // @ts-ignore theme is injected by the styled util
      /* @__PURE__ */ jsx(ContainerRoot, _extends$8({
        as: component,
        ownerState,
        className: clsx(classes.root, className),
        ref
      }, other))
    );
  });
  return Container2;
}
function createMixins(breakpoints, mixins) {
  return _extends$8({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
const common = {
  black: "#000",
  white: "#fff"
};
const common$1 = common;
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const grey$1 = grey;
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const purple$1 = purple;
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const red$1 = red;
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const orange$1 = orange;
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const blue$1 = blue;
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const lightBlue$1 = lightBlue;
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const green$1 = green;
const _excluded$1q = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$1.white,
    default: common$1.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common$1.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common$1.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue$1[200],
      light: blue$1[50],
      dark: blue$1[400]
    };
  }
  return {
    main: blue$1[700],
    light: blue$1[400],
    dark: blue$1[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple$1[200],
      light: purple$1[50],
      dark: purple$1[400]
    };
  }
  return {
    main: purple$1[500],
    light: purple$1[300],
    dark: purple$1[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red$1[500],
      light: red$1[300],
      dark: red$1[700]
    };
  }
  return {
    main: red$1[700],
    light: red$1[400],
    dark: red$1[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue$1[400],
      light: lightBlue$1[300],
      dark: lightBlue$1[700]
    };
  }
  return {
    main: lightBlue$1[700],
    light: lightBlue$1[500],
    dark: lightBlue$1[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green$1[400],
      light: green$1[300],
      dark: green$1[700]
    };
  }
  return {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange$1[400],
      light: orange$1[300],
      dark: orange$1[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange$1[500],
    dark: orange$1[900]
  };
}
function createPalette(palette2) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette2, other = _objectWithoutPropertiesLoose(palette2, _excluded$1q);
  const primary = palette2.primary || getDefaultPrimary(mode);
  const secondary = palette2.secondary || getDefaultSecondary(mode);
  const error = palette2.error || getDefaultError(mode);
  const info = palette2.info || getDefaultInfo(mode);
  const success = palette2.success || getDefaultSuccess(mode);
  const warning2 = palette2.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends$8({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge(_extends$8({
    // A collection of common colors.
    common: _extends$8({}, common$1),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
const _excluded$1p = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round$1(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette2, typography2) {
  const _ref = typeof typography2 === "function" ? typography2(palette2) : typography2, {
    fontFamily: fontFamily2 = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize: fontSize2 = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$1p);
  const coef = fontSize2 / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight2, size, lineHeight2, letterSpacing2, casing) => _extends$8({
    fontFamily: fontFamily2,
    fontWeight: fontWeight2,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: lineHeight2
  }, fontFamily2 === defaultFontFamily ? {
    letterSpacing: `${round$1(letterSpacing2 / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends$8({
    htmlFontSize,
    pxToRem,
    fontFamily: fontFamily2,
    fontSize: fontSize2,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const shadows$1 = shadows;
const _excluded$1o = ["duration", "easing", "delay"];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration$2 = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height3) {
  if (!height3) {
    return 0;
  }
  const constant = height3 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends$8({}, easing, inputTransitions.easing);
  const mergedDuration = _extends$8({}, duration$2, inputTransitions.duration);
  const create2 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options;
    _objectWithoutPropertiesLoose(options, _excluded$1o);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends$8({
    getAutoHeightDuration,
    create: create2
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const zIndex$1 = zIndex;
const _excluded$1n = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$1n);
  if (options.vars) {
    throw new Error(formatMuiErrorMessage(18));
  }
  const palette2 = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette: palette2,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows$1.slice(),
    typography: createTypography(palette2, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends$8({}, zIndex$1)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  return muiTheme;
}
function getUnit(input) {
  return String(input).match(/[\d.\-+]*\s*(.*)/)[1] || "";
}
function toUnitless(length2) {
  return parseFloat(length2);
}
const defaultTheme$1 = createTheme();
const defaultTheme$2 = defaultTheme$1;
function useTheme() {
  const theme2 = useTheme$1(defaultTheme$2);
  return theme2;
}
function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme$2
  });
}
const rootShouldForwardProp = (prop3) => shouldForwardProp(prop3) && prop3 !== "classes";
const slotShouldForwardProp = shouldForwardProp;
const styled$1 = createStyled2({
  defaultTheme: defaultTheme$2,
  rootShouldForwardProp
});
const styled$2 = styled$1;
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends$8({}, otherProps, {
    ownerState: _extends$8({}, otherProps.ownerState, ownerState)
  });
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop3) => prop3.match(/^on[A-Z]/) && typeof object[prop3] === "function" && !excludeKeys.includes(prop3)).forEach((prop3) => {
    result[prop3] = object[prop3];
  });
  return result;
}
function resolveComponentProps(componentProps, ownerState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState);
  }
  return componentProps;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop3) => !(prop3.match(/^on[A-Z]/) && typeof object[prop3] === "function")).forEach((prop3) => {
    result[prop3] = object[prop3];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
    const mergedStyle2 = _extends$8({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends$8({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends$8({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends$8({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends$8({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
const _excluded$1m = ["elementType", "externalSlotProps", "ownerState"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState
  } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded$1m);
  const resolvedComponentsProps = resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends$8({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends$8({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
function stripDiacritics(string) {
  return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
}
function createFilterOptions(config2 = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify: stringify2,
    trim: trim2 = false
  } = config2;
  return (options, {
    inputValue,
    getOptionLabel
  }) => {
    let input = trim2 ? inputValue.trim() : inputValue;
    if (ignoreCase) {
      input = input.toLowerCase();
    }
    if (ignoreAccents) {
      input = stripDiacritics(input);
    }
    const filteredOptions = !input ? options : options.filter((option) => {
      let candidate = (stringify2 || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
function findIndex$2(array, comp) {
  for (let i = 0; i < array.length; i += 1) {
    if (comp(array[i])) {
      return i;
    }
  }
  return -1;
}
const defaultFilterOptions = createFilterOptions();
const pageSize$3 = 5;
function useAutocomplete(props) {
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    componentName = "useAutocomplete",
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled: disabledProp,
    disabledItemsFocusable = false,
    disableListWrap = false,
    filterOptions = defaultFilterOptions,
    filterSelectedOptions = false,
    freeSolo = false,
    getOptionDisabled,
    getOptionLabel: getOptionLabelProp = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    },
    groupBy,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    isOptionEqualToValue = (option, value2) => option === value2,
    multiple = false,
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open: openProp,
    openOnFocus = false,
    options,
    readOnly = false,
    selectOnFocus = !props.freeSolo,
    value: valueProp
  } = props;
  const id2 = useId(idProp);
  let getOptionLabel = getOptionLabelProp;
  getOptionLabel = (option) => {
    const optionLabel = getOptionLabelProp(option);
    if (typeof optionLabel !== "string") {
      return String(optionLabel);
    }
    return optionLabel;
  };
  const ignoreFocus = reactExports.useRef(false);
  const firstFocus = reactExports.useRef(true);
  const inputRef = reactExports.useRef(null);
  const listboxRef = reactExports.useRef(null);
  const [anchorEl, setAnchorEl] = reactExports.useState(null);
  const [focusedTag, setFocusedTag] = reactExports.useState(-1);
  const defaultHighlighted = autoHighlight ? 0 : -1;
  const highlightedIndexRef = reactExports.useRef(defaultHighlighted);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: componentName
  });
  const [inputValue, setInputValueState] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: componentName,
    state: "inputValue"
  });
  const [focused, setFocused] = reactExports.useState(false);
  const resetInputValue = reactExports.useCallback((event, newValue) => {
    const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
    if (!isOptionSelected && !clearOnBlur) {
      return;
    }
    let newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      const optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue === newInputValue) {
      return;
    }
    setInputValueState(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, "reset");
    }
  }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
  const prevValue = reactExports.useRef();
  reactExports.useEffect(() => {
    const valueChange = value !== prevValue.current;
    prevValue.current = value;
    if (focused && !valueChange) {
      return;
    }
    if (freeSolo && !valueChange) {
      return;
    }
    resetInputValue(null, value);
  }, [value, resetInputValue, focused, prevValue, freeSolo]);
  const [open, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: componentName,
    state: "open"
  });
  const [inputPristine, setInputPristine] = reactExports.useState(true);
  const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
  const popupOpen = open && !readOnly;
  const filteredOptions = popupOpen ? filterOptions(
    options.filter((option) => {
      if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
        return false;
      }
      return true;
    }),
    // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
      getOptionLabel
    }
  ) : [];
  const listboxAvailable = open && filteredOptions.length > 0 && !readOnly;
  const focusTag = useEventCallback((tagToFocus) => {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
    }
  });
  reactExports.useEffect(() => {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index2, direction) {
    if (!listboxRef.current || index2 === -1) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      if (direction === "next" && nextFocus === filteredOptions.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
      const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
      if (option && !option.hasAttribute("tabindex") || nextFocusDisabled) {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const setHighlightedIndex = useEventCallback(({
    event,
    index: index2,
    reason = "auto"
  }) => {
    highlightedIndexRef.current = index2;
    if (index2 === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", `${id2}-option-${index2}`);
    }
    if (onHighlightChange) {
      onHighlightChange(event, index2 === -1 ? null : filteredOptions[index2], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    const prev2 = listboxRef.current.querySelector('[role="option"].Mui-focused');
    if (prev2) {
      prev2.classList.remove("Mui-focused");
      prev2.classList.remove("Mui-focusVisible");
    }
    const listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    if (!listboxNode) {
      return;
    }
    if (index2 === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    const option = listboxRef.current.querySelector(`[data-option-index="${index2}"]`);
    if (!option) {
      return;
    }
    option.classList.add("Mui-focused");
    if (reason === "keyboard") {
      option.classList.add("Mui-focusVisible");
    }
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse") {
      const element = option;
      const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
      }
    }
  });
  const changeHighlightedIndex = useEventCallback(({
    event,
    diff,
    direction = "next",
    reason = "auto"
  }) => {
    if (!popupOpen) {
      return;
    }
    const getNextIndex = () => {
      const maxIndex = filteredOptions.length - 1;
      if (diff === "reset") {
        return defaultHighlighted;
      }
      if (diff === "start") {
        return 0;
      }
      if (diff === "end") {
        return maxIndex;
      }
      const newIndex = highlightedIndexRef.current + diff;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    };
    const nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue;
      } else {
        const option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        const index2 = option.toLowerCase().indexOf(inputValue.toLowerCase());
        if (index2 === 0 && inputValue.length > 0) {
          inputRef.current.setSelectionRange(inputValue.length, option.length);
        }
      }
    }
  });
  const syncHighlightedIndex = reactExports.useCallback(() => {
    if (!popupOpen) {
      return;
    }
    const valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (valueItem != null) {
      const currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && findIndex$2(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
        return;
      }
      const itemIndex = findIndex$2(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    // Only sync the highlighted index when the option switch between empty and not
    filteredOptions.length,
    // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue,
    multiple
  ]);
  const handleListboxRef = useEventCallback((node2) => {
    setRef(listboxRef, node2);
    if (!node2) {
      return;
    }
    syncHighlightedIndex();
  });
  reactExports.useEffect(() => {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  const handleOpen = (event) => {
    if (open) {
      return;
    }
    setOpenState(true);
    setInputPristine(true);
    if (onOpen) {
      onOpen(event);
    }
  };
  const handleClose = (event, reason) => {
    if (!open) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  };
  const handleValue = (event, newValue, reason, details) => {
    if (multiple) {
      if (value.length === newValue.length && value.every((val, i) => val === newValue[i])) {
        return;
      }
    } else if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValueState(newValue);
  };
  const isTouch = reactExports.useRef(false);
  const selectNewValue = (event, option, reasonProp = "selectOption", origin2 = "options") => {
    let reason = reasonProp;
    let newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = findIndex$2(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin2 !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "removeOption";
      }
    }
    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect && (!event || !event.ctrlKey && !event.metaKey)) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  };
  function validTagIndex(index2, direction) {
    if (index2 === -1) {
      return -1;
    }
    let nextFocus = index2;
    while (true) {
      if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
      if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const handleFocusTag = (event, direction) => {
    if (!multiple) {
      return;
    }
    if (inputValue === "") {
      handleClose(event, "toggleInput");
    }
    let nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue === "" && direction === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };
  const handleClear = (event) => {
    ignoreFocus.current = true;
    setInputValueState("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  };
  const handleKeyDown2 = (other) => (event) => {
    if (other.onKeyDown) {
      other.onKeyDown(event);
    }
    if (event.defaultMuiPrevented) {
      return;
    }
    if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
    if (event.which !== 229) {
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize$3,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize$3,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            const option = filteredOptions[highlightedIndexRef.current];
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "selectOption");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue, "createOption", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && !readOnly && inputValue === "" && value.length > 0) {
            const index2 = focusedTag === -1 ? value.length - 1 : focusedTag;
            const newValue = value.slice();
            newValue.splice(index2, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index2]
            });
          }
          break;
      }
    }
  };
  const handleFocus = (event) => {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };
  const handleBlur = (event) => {
    if (listboxRef.current !== null && listboxRef.current.parentElement.contains(document.activeElement)) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue !== "") {
      selectNewValue(event, inputValue, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }
    handleClose(event, "blur");
  };
  const handleInputChange = (event) => {
    const newValue = event.target.value;
    if (inputValue !== newValue) {
      setInputValueState(newValue);
      setInputPristine(false);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  };
  const handleOptionMouseOver = (event) => {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "mouse"
    });
  };
  const handleOptionTouchStart = () => {
    isTouch.current = true;
  };
  const handleOptionClick = (event) => {
    const index2 = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index2], "selectOption");
    isTouch.current = false;
  };
  const handleTagDelete = (index2) => (event) => {
    const newValue = value.slice();
    newValue.splice(index2, 1);
    handleValue(event, newValue, "removeOption", {
      option: value[index2]
    });
  };
  const handlePopupIndicator = (event) => {
    if (open) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  };
  const handleMouseDown = (event) => {
    if (event.target.getAttribute("id") !== id2) {
      event.preventDefault();
    }
  };
  const handleClick = () => {
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  };
  const handleInputMouseDown = (event) => {
    if (inputValue === "" || !open) {
      handlePopupIndicator(event);
    }
  };
  let dirty = freeSolo && inputValue.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  let groupedOptions = filteredOptions;
  if (groupBy) {
    groupedOptions = filteredOptions.reduce((acc, option, index2) => {
      const group = groupBy(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group) {
        acc[acc.length - 1].options.push(option);
      } else {
        acc.push({
          key: index2,
          index: index2,
          group,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  if (disabledProp && focused) {
    handleBlur();
  }
  return {
    getRootProps: (other = {}) => _extends$8({
      "aria-owns": listboxAvailable ? `${id2}-listbox` : null
    }, other, {
      onKeyDown: handleKeyDown2(other),
      onMouseDown: handleMouseDown,
      onClick: handleClick
    }),
    getInputLabelProps: () => ({
      id: `${id2}-label`,
      htmlFor: id2
    }),
    getInputProps: () => ({
      id: id2,
      value: inputValue,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onChange: handleInputChange,
      onMouseDown: handleInputMouseDown,
      // if open then this is handled imperativeley so don't let react override
      // only have an opinion about this when closed
      "aria-activedescendant": popupOpen ? "" : null,
      "aria-autocomplete": autoComplete ? "both" : "list",
      "aria-controls": listboxAvailable ? `${id2}-listbox` : void 0,
      "aria-expanded": listboxAvailable,
      // Disable browser's suggestion that might overlap with the popup.
      // Handle autocomplete but not autofill.
      autoComplete: "off",
      ref: inputRef,
      autoCapitalize: "none",
      spellCheck: "false",
      role: "combobox"
    }),
    getClearProps: () => ({
      tabIndex: -1,
      onClick: handleClear
    }),
    getPopupIndicatorProps: () => ({
      tabIndex: -1,
      onClick: handlePopupIndicator
    }),
    getTagProps: ({
      index: index2
    }) => _extends$8({
      key: index2,
      "data-tag-index": index2,
      tabIndex: -1
    }, !readOnly && {
      onDelete: handleTagDelete(index2)
    }),
    getListboxProps: () => ({
      role: "listbox",
      id: `${id2}-listbox`,
      "aria-labelledby": `${id2}-label`,
      ref: handleListboxRef,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }),
    getOptionProps: ({
      index: index2,
      option
    }) => {
      const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
      const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: getOptionLabel(option),
        tabIndex: -1,
        role: "option",
        id: `${id2}-option-${index2}`,
        onMouseOver: handleOptionMouseOver,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index2,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id: id2,
    inputValue,
    value,
    dirty,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}
function mapEventPropToEvent(eventProp) {
  return eventProp.substring(2).toLowerCase();
}
function clickedRootScrollbar(event, doc) {
  return doc.documentElement.clientWidth < event.clientX || doc.documentElement.clientHeight < event.clientY;
}
function ClickAwayListener(props) {
  const {
    children,
    disableReactTree = false,
    mouseEvent = "onClick",
    onClickAway,
    touchEvent = "onTouchEnd"
  } = props;
  const movedRef = reactExports.useRef(false);
  const nodeRef = reactExports.useRef(null);
  const activatedRef = reactExports.useRef(false);
  const syntheticEventRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    setTimeout(() => {
      activatedRef.current = true;
    }, 0);
    return () => {
      activatedRef.current = false;
    };
  }, []);
  const handleRef = useForkRef(
    // @ts-expect-error TODO upstream fix
    children.ref,
    nodeRef
  );
  const handleClickAway = useEventCallback((event) => {
    const insideReactTree = syntheticEventRef.current;
    syntheticEventRef.current = false;
    const doc = ownerDocument(nodeRef.current);
    if (!activatedRef.current || !nodeRef.current || "clientX" in event && clickedRootScrollbar(event, doc)) {
      return;
    }
    if (movedRef.current) {
      movedRef.current = false;
      return;
    }
    let insideDOM;
    if (event.composedPath) {
      insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
    } else {
      insideDOM = !doc.documentElement.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      ) || nodeRef.current.contains(
        // @ts-expect-error returns `false` as intended when not dispatched from a Node
        event.target
      );
    }
    if (!insideDOM && (disableReactTree || !insideReactTree)) {
      onClickAway(event);
    }
  });
  const createHandleSynthetic = (handlerName) => (event) => {
    syntheticEventRef.current = true;
    const childrenPropsHandler = children.props[handlerName];
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const childrenProps = {
    ref: handleRef
  };
  if (touchEvent !== false) {
    childrenProps[touchEvent] = createHandleSynthetic(touchEvent);
  }
  reactExports.useEffect(() => {
    if (touchEvent !== false) {
      const mappedTouchEvent = mapEventPropToEvent(touchEvent);
      const doc = ownerDocument(nodeRef.current);
      const handleTouchMove = () => {
        movedRef.current = true;
      };
      doc.addEventListener(mappedTouchEvent, handleClickAway);
      doc.addEventListener("touchmove", handleTouchMove);
      return () => {
        doc.removeEventListener(mappedTouchEvent, handleClickAway);
        doc.removeEventListener("touchmove", handleTouchMove);
      };
    }
    return void 0;
  }, [handleClickAway, touchEvent]);
  if (mouseEvent !== false) {
    childrenProps[mouseEvent] = createHandleSynthetic(mouseEvent);
  }
  reactExports.useEffect(() => {
    if (mouseEvent !== false) {
      const mappedMouseEvent = mapEventPropToEvent(mouseEvent);
      const doc = ownerDocument(nodeRef.current);
      doc.addEventListener(mappedMouseEvent, handleClickAway);
      return () => {
        doc.removeEventListener(mappedMouseEvent, handleClickAway);
      };
    }
    return void 0;
  }, [handleClickAway, mouseEvent]);
  return /* @__PURE__ */ jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(children, childrenProps)
  });
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex"), 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root2) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a2, b2) => a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled: isEnabled3 = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef();
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", -1);
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const contain = (nativeEvent) => {
      const {
        current: rootElement
      } = rootRef;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled3() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (!rootElement.contains(doc.activeElement)) {
        if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
          reactFocusEventTarget.current = null;
        } else if (reactFocusEventTarget.current !== null) {
          return;
        }
        if (!activated.current) {
          return;
        }
        let tabbable = [];
        if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
          tabbable = getTabbable(rootRef.current);
        }
        if (tabbable.length > 0) {
          var _lastKeydown$current, _lastKeydown$current2;
          const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
          const focusNext = tabbable[0];
          const focusPrevious = tabbable[tabbable.length - 1];
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        } else {
          rootElement.focus();
        }
      }
    };
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled3() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        sentinelEnd.current.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled3, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), /* @__PURE__ */ jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end$1 = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end$1]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end$1]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument2 = node2.ownerDocument;
    return ownerDocument2 ? ownerDocument2.defaultView || window : window;
  }
  return node2;
}
function isElement$1(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width3 = clientRect.width / scaleX;
  var height3 = clientRect.height / scaleY;
  return {
    width: width3,
    height: height3,
    top: y2,
    right: x + width3,
    bottom: y2 + height3,
    left: x,
    x,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect$1(element);
  var width3 = element.offsetWidth;
  var height3 = element.offsetHeight;
  if (Math.abs(clientRect.width - width3) <= 1) {
    width3 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height3) <= 1) {
    height3 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width3,
    height: height3
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement$1(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement$1(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys3) {
  return keys3.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len2 = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len2] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len2];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len2] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len2] / 2 + centerToReference;
  var offset3 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y2 = _ref.y;
  var win2 = window;
  var dpr = win2.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position3 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y: y2
  }) : {
    x,
    y: y2
  };
  x = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win2 = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement$1(popper2);
      if (getComputedStyle(offsetParent).position !== "static" && position3 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end$1) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win2 && win2.visualViewport ? win2.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end$1) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win2 && win2.visualViewport ? win2.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position3
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y: y2
  }) : {
    x,
    y: y2
  };
  x = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win2.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y2 + "px)" : "translate3d(" + x + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll3 = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll3) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll3) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll$2(node2) {
  var win2 = getWindow(node2);
  var scrollLeft = win2.pageXOffset;
  var scrollTop = win2.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll$2(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win2 = getWindow(element);
  var html = getDocumentElement$1(element);
  var visualViewport = win2.visualViewport;
  var width3 = html.clientWidth;
  var height3 = html.clientHeight;
  var x = 0;
  var y2 = 0;
  if (visualViewport) {
    width3 = visualViewport.width;
    height3 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width: width3,
    height: height3,
    x: x + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement$1(element);
  var winScroll = getWindowScroll$2(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width3 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height3 = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width3;
  }
  return {
    width: width3,
    height: height3,
    x,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow2 = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow2 + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win2 = getWindow(scrollParent);
  var target = isBody ? [win2].concat(win2.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect$1(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement$1(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len2 = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len2] / 2 - element[len2] / 2);
        break;
      case end$1:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len2] / 2 - element[len2] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset3 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset3[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len2 = isVertical ? "width" : "height";
    var overflow2 = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len2] > popperRect[len2]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow2[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow2[mainVariationSide] <= 0, overflow2[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow2, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow2.top - rect.height - preventedOffsets.y,
    right: overflow2.right - rect.width + preventedOffsets.x,
    bottom: overflow2.bottom - rect.height + preventedOffsets.y,
    left: overflow2.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow2) {
  return [top, right, bottom, left].some(function(side) {
    return overflow2[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset3) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
    placement
  })) : offset3, skidding = _ref[0], distance3 = _ref[1];
  skidding = skidding || 0;
  distance3 = (distance3 || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance3,
    y: skidding
  } : {
    x: skidding,
    y: distance3
  };
}
function offset$1(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset3);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
const offset$2 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset$1
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow2 = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len2 = mainAxis === "y" ? "height" : "width";
    var offset3 = popperOffsets2[mainAxis];
    var min$1 = offset3 + overflow2[mainSide];
    var max$1 = offset3 - overflow2[altSide];
    var additive = tether ? -popperRect[len2] / 2 : 0;
    var minLen = variation === start ? referenceRect[len2] : popperRect[len2];
    var maxLen = variation === start ? -popperRect[len2] : -referenceRect[len2];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len2], arrowRect[len2]);
    var minOffset = isBasePlacement ? referenceRect[len2] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len2] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset3 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset3, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset3;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow2[_mainSide];
    var _max = _offset - overflow2[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
    return getWindowScroll$2(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement$1(offsetParent);
  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll3 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll3 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect$1(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll3.scrollLeft - offsets.x,
    y: rect.top + scroll3.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS$2 = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$2 : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS$2, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
function getContainer$1(container2) {
  return typeof container2 === "function" ? container2() : container2;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, ref) {
  const {
    children,
    container: container2,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, ref);
  useEnhancedEffect$1(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container2) || document.body);
    }
  }, [container2, disablePortal]);
  useEnhancedEffect$1(() => {
    if (mountNode && !disablePortal) {
      setRef(ref, mountNode);
      return () => {
        setRef(ref, null);
      };
    }
    return void 0;
  }, [ref, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      return /* @__PURE__ */ reactExports.cloneElement(children, {
        ref: handleRef
      });
    }
    return children;
  }
  return /* @__PURE__ */ jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
});
const Portal$1 = Portal;
function getPopperUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiPopperUnstyled", slot);
}
generateUtilityClasses("MuiPopperUnstyled", ["root"]);
const _excluded$1l = ["anchorEl", "children", "component", "direction", "disablePortal", "modifiers", "open", "ownerState", "placement", "popperOptions", "popperRef", "slotProps", "slots", "TransitionProps"], _excluded2$6 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition"];
function flipPlacement(placement, direction) {
  if (direction === "ltr") {
    return placement;
  }
  switch (placement) {
    case "bottom-end":
      return "bottom-start";
    case "bottom-start":
      return "bottom-end";
    case "top-end":
      return "top-start";
    case "top-start":
      return "top-end";
    default:
      return placement;
  }
}
function resolveAnchorEl$1(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$15 = () => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getPopperUnstyledUtilityClass, {});
};
const defaultPopperOptions = {};
const PopperTooltip = /* @__PURE__ */ reactExports.forwardRef(function PopperTooltip2(props, ref) {
  var _ref;
  const {
    anchorEl,
    children,
    component,
    direction,
    disablePortal,
    modifiers,
    open,
    ownerState,
    placement: initialPlacement,
    popperOptions,
    popperRef: popperRefProp,
    slotProps = {},
    slots = {},
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1l);
  const tooltipRef = reactExports.useRef(null);
  const ownRef = useForkRef(tooltipRef, ref);
  const popperRef = reactExports.useRef(null);
  const handlePopperRef = useForkRef(popperRef, popperRefProp);
  const handlePopperRefRef = reactExports.useRef(handlePopperRef);
  useEnhancedEffect$1(() => {
    handlePopperRefRef.current = handlePopperRef;
  }, [handlePopperRef]);
  reactExports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
  const rtlPlacement = flipPlacement(initialPlacement, direction);
  const [placement, setPlacement] = reactExports.useState(rtlPlacement);
  reactExports.useEffect(() => {
    if (popperRef.current) {
      popperRef.current.forceUpdate();
    }
  });
  useEnhancedEffect$1(() => {
    if (!anchorEl || !open) {
      return void 0;
    }
    const handlePopperUpdate = (data) => {
      setPlacement(data.placement);
    };
    resolveAnchorEl$1(anchorEl);
    let popperModifiers = [{
      name: "preventOverflow",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "flip",
      options: {
        altBoundary: disablePortal
      }
    }, {
      name: "onUpdate",
      enabled: true,
      phase: "afterWrite",
      fn: ({
        state
      }) => {
        handlePopperUpdate(state);
      }
    }];
    if (modifiers != null) {
      popperModifiers = popperModifiers.concat(modifiers);
    }
    if (popperOptions && popperOptions.modifiers != null) {
      popperModifiers = popperModifiers.concat(popperOptions.modifiers);
    }
    const popper2 = createPopper(resolveAnchorEl$1(anchorEl), tooltipRef.current, _extends$8({
      placement: rtlPlacement
    }, popperOptions, {
      modifiers: popperModifiers
    }));
    handlePopperRefRef.current(popper2);
    return () => {
      popper2.destroy();
      handlePopperRefRef.current(null);
    };
  }, [anchorEl, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
  const childProps = {
    placement
  };
  if (TransitionProps !== null) {
    childProps.TransitionProps = TransitionProps;
  }
  const classes = useUtilityClasses$15();
  const Root2 = (_ref = component != null ? component : slots.root) != null ? _ref : "div";
  const rootProps = useSlotProps({
    elementType: Root2,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      role: "tooltip",
      ref: ownRef
    },
    ownerState: _extends$8({}, props, ownerState),
    className: classes.root
  });
  return /* @__PURE__ */ jsx(Root2, _extends$8({}, rootProps, {
    children: typeof children === "function" ? children(childProps) : children
  }));
});
const PopperUnstyled = /* @__PURE__ */ reactExports.forwardRef(function PopperUnstyled2(props, ref) {
  const {
    anchorEl,
    children,
    container: containerProp,
    direction = "ltr",
    disablePortal = false,
    keepMounted = false,
    modifiers,
    open,
    placement = "bottom",
    popperOptions = defaultPopperOptions,
    popperRef,
    style: style2,
    transition = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2$6);
  const [exited, setExited] = reactExports.useState(true);
  const handleEnter = () => {
    setExited(false);
  };
  const handleExited = () => {
    setExited(true);
  };
  if (!keepMounted && !open && (!transition || exited)) {
    return null;
  }
  const container2 = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl$1(anchorEl)).body : void 0);
  return /* @__PURE__ */ jsx(Portal$1, {
    disablePortal,
    container: container2,
    children: /* @__PURE__ */ jsx(PopperTooltip, _extends$8({
      anchorEl,
      direction,
      disablePortal,
      modifiers,
      ref,
      open: transition ? !exited : open,
      placement,
      popperOptions,
      popperRef
    }, other, {
      style: _extends$8({
        // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
        position: "fixed",
        // Fix Popper.js display issue
        top: 0,
        left: 0,
        display: !open && keepMounted && (!transition || exited) ? "none" : null
      }, style2),
      TransitionProps: transition ? {
        in: open,
        onEnter: handleEnter,
        onExited: handleExited
      } : null,
      children
    }))
  });
});
const PopperUnstyled$1 = PopperUnstyled;
function isOverflowing(container2) {
  const doc = ownerDocument(container2);
  if (doc.body === container2) {
    return ownerWindow(container2).innerWidth > doc.documentElement.clientWidth;
  }
  return container2.scrollHeight > container2.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container2, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container2.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback2) {
  let idx = -1;
  items.some((item, index2) => {
    if (callback2(item)) {
      idx = index2;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container2 = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container2)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container2));
      restoreStyle.push({
        value: container2.style.paddingRight,
        property: "padding-right",
        el: container2
      });
      container2.style.paddingRight = `${getPaddingRight(container2) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container2).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer2;
    if (container2.parentNode instanceof DocumentFragment) {
      scrollContainer2 = ownerDocument(container2).body;
    } else {
      const parent = container2.parentElement;
      const containerWindow = ownerWindow(container2);
      scrollContainer2 = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container2;
    }
    restoreStyle.push({
      value: scrollContainer2.style.overflow,
      property: "overflow",
      el: scrollContainer2
    }, {
      value: scrollContainer2.style.overflowX,
      property: "overflow-x",
      el: scrollContainer2
    }, {
      value: scrollContainer2.style.overflowY,
      property: "overflow-y",
      el: scrollContainer2
    });
    scrollContainer2.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property
    }) => {
      if (value) {
        el2.style.setProperty(property, value);
      } else {
        el2.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container2) {
  const hiddenSiblings = [];
  [].forEach.call(container2.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container2) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container2);
    ariaHiddenSiblings(container2, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container2);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container: container2,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden"]);
const _excluded$1k = ["children", "classes", "closeAfterTransition", "component", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "onTransitionEnter", "onTransitionExited", "slotProps", "slots"];
const useUtilityClasses$14 = (ownerState) => {
  const {
    open,
    exited,
    classes
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"]
  };
  return composeClasses(slots, getModalUtilityClass, classes);
};
function getContainer(container2) {
  return typeof container2 === "function" ? container2() : container2;
}
function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty("in") : false;
}
const defaultManager = new ModalManager();
const ModalUnstyled = /* @__PURE__ */ reactExports.forwardRef(function ModalUnstyled2(props, ref) {
  var _props$ariaHidden, _ref;
  const {
    children,
    classes: classesProp,
    closeAfterTransition = false,
    component,
    container: container2,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    // private
    // eslint-disable-next-line react/prop-types
    manager = defaultManager,
    onBackdropClick,
    onClose,
    onKeyDown,
    open,
    /* eslint-disable react/prop-types */
    onTransitionEnter,
    onTransitionExited,
    slotProps = {},
    slots = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1k);
  const [exited, setExited] = reactExports.useState(true);
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, ref);
  const hasTransition = getHasTransition(props);
  const ariaHiddenProp = (_props$ariaHidden = props["aria-hidden"]) != null ? _props$ariaHidden : true;
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mountNode = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    modalRef.current.scrollTop = 0;
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container2) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [manager, ariaHiddenProp]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const ownerState = _extends$8({}, props, {
    classes: classesProp,
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    exited,
    hideBackdrop,
    keepMounted
  });
  const classes = useUtilityClasses$14(ownerState);
  const handleEnter = () => {
    setExited(false);
    if (onTransitionEnter) {
      onTransitionEnter();
    }
  };
  const handleExited = () => {
    setExited(true);
    if (onTransitionExited) {
      onTransitionExited();
    }
    if (closeAfterTransition) {
      handleClose();
    }
  };
  const handleBackdropClick = (event) => {
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const handleKeyDown2 = (event) => {
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.key !== "Escape" || !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
    childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
  }
  const Root2 = (_ref = component != null ? component : slots.root) != null ? _ref : "div";
  const rootProps = useSlotProps({
    elementType: Root2,
    externalSlotProps: slotProps.root,
    externalForwardedProps: other,
    additionalProps: {
      ref: handleRef,
      role: "presentation",
      onKeyDown: handleKeyDown2
    },
    className: classes.root,
    ownerState
  });
  const BackdropComponent = slots.backdrop;
  const backdropProps = useSlotProps({
    elementType: BackdropComponent,
    externalSlotProps: slotProps.backdrop,
    additionalProps: {
      "aria-hidden": true,
      onClick: handleBackdropClick,
      open
    },
    className: classes.backdrop,
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsx(Portal$1, {
    ref: handlePortalRef,
    container: container2,
    disablePortal,
    children: /* @__PURE__ */ jsxs(Root2, _extends$8({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsx(BackdropComponent, _extends$8({}, backdropProps)) : null, /* @__PURE__ */ jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
});
const ModalUnstyled$1 = ModalUnstyled;
const _excluded$1j = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(computedStyle2, property) {
  return parseInt(computedStyle2[property], 10) || 0;
}
const styles$3 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isEmpty$3(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, ref) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1j);
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, inputRef);
  const shadowRef = reactExports.useRef(null);
  const renders = reactExports.useRef(0);
  const [state, setState2] = reactExports.useState({});
  const getUpdatedState = reactExports.useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle2 = containerWindow.getComputedStyle(input);
    if (computedStyle2.width === "0px") {
      return {};
    }
    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle2.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    const boxSizing2 = computedStyle2["box-sizing"];
    const padding = getStyleValue(computedStyle2, "padding-bottom") + getStyleValue(computedStyle2, "padding-top");
    const border2 = getStyleValue(computedStyle2, "border-bottom-width") + getStyleValue(computedStyle2, "border-top-width");
    const innerHeight = inputShallow.scrollHeight;
    inputShallow.value = "x";
    const singleRowHeight = inputShallow.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding + border2 : 0);
    const overflow2 = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflow: overflow2
    };
  }, [maxRows, minRows, props.placeholder]);
  const updateState = (prevState, newState) => {
    const {
      outerHeightStyle,
      overflow: overflow2
    } = newState;
    if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow2)) {
      renders.current += 1;
      return {
        overflow: overflow2,
        outerHeightStyle
      };
    }
    return prevState;
  };
  const syncHeight = reactExports.useCallback(() => {
    const newState = getUpdatedState();
    if (isEmpty$3(newState)) {
      return;
    }
    setState2((prevState) => {
      return updateState(prevState, newState);
    });
  }, [getUpdatedState]);
  const syncHeightWithFlushSycn = () => {
    const newState = getUpdatedState();
    if (isEmpty$3(newState)) {
      return;
    }
    reactDomExports.flushSync(() => {
      setState2((prevState) => {
        return updateState(prevState, newState);
      });
    });
  };
  reactExports.useEffect(() => {
    const handleResize = debounce$2(() => {
      renders.current = 0;
      if (inputRef.current) {
        syncHeightWithFlushSycn();
      }
    });
    const containerWindow = ownerWindow(inputRef.current);
    containerWindow.addEventListener("resize", handleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(inputRef.current);
    }
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  });
  useEnhancedEffect$1(() => {
    syncHeight();
  });
  reactExports.useEffect(() => {
    renders.current = 0;
  }, [value]);
  const handleChange = (event) => {
    renders.current = 0;
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsx("textarea", _extends$8({
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: _extends$8({
        height: state.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: state.overflow ? "hidden" : null
      }, style2)
    }, other)), /* @__PURE__ */ jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends$8({}, styles$3.shadow, style2, {
        padding: 0
      })
    })]
  });
});
const TextareaAutosize$1 = TextareaAutosize;
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$1i = ["className", "component", "elevation", "square", "variant"];
const getOverlayAlpha = (elevation) => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
};
const useUtilityClasses$13 = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes);
};
const PaperRoot = styled$2("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends$8({
    backgroundColor: (theme2.vars || theme2).palette.background.paper,
    color: (theme2.vars || theme2).palette.text.primary,
    transition: theme2.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme2.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme2.vars || theme2).palette.divider}`
  }, ownerState.variant === "elevation" && _extends$8({
    boxShadow: (theme2.vars || theme2).shadows[ownerState.elevation]
  }, !theme2.vars && theme2.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha(ownerState.elevation))})`
  }, theme2.vars && {
    backgroundImage: (_theme$vars$overlays = theme2.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPaper"
  });
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1i);
  const ownerState = _extends$8({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes = useUtilityClasses$13(ownerState);
  return /* @__PURE__ */ jsx(PaperRoot, _extends$8({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other));
});
const Paper$1 = Paper;
const themePalette = createTheme({
  palette: {
    primary: {
      main: "#30BCED",
      contrastText: "#ffffff"
    },
    secondary: {
      main: "#FC5130"
    }
  }
});
const themeComponents = createTheme({
  components: {
    MuiListItemButton: {
      styleOverrides: {
        root: {
          "&.Mui-selected": {
            color: themePalette.palette.primary.main,
            "& .MuiListItemIcon-root": {
              color: themePalette.palette.primary.main
            }
          }
        }
      }
    },
    MuiLink: {
      styleOverrides: {
        button: {
          color: "rgba(0, 0, 0, 0.87)"
        }
      }
    },
    MuiTypography: {
      styleOverrides: {
        subtitle2: {
          lineHeight: "normal"
        },
        caption: {
          lineHeight: "normal"
        }
      }
    }
  }
});
const theme = createTheme({ ...themePalette, components: themeComponents.components });
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$1h = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$12 = (ownerState) => {
  const {
    color: color2,
    fontSize: fontSize2,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize2)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled$2("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$transitions2$d, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette$ownerState$c2, _palette2, _palette2$action, _palette3, _palette3$action;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    fill: "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme2.transitions) == null ? void 0 : (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme2.transitions) == null ? void 0 : (_theme$transitions2$d = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2$d.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme2.typography) == null ? void 0 : (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme2.typography) == null ? void 0 : (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme2.typography) == null ? void 0 : (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme2.vars || theme2).palette) == null ? void 0 : (_palette$ownerState$c2 = _palette[ownerState.color]) == null ? void 0 : _palette$ownerState$c2.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme2.vars || theme2).palette) == null ? void 0 : (_palette2$action = _palette2.action) == null ? void 0 : _palette2$action.active,
      disabled: (_palette3 = (theme2.vars || theme2).palette) == null ? void 0 : (_palette3$action = _palette3.action) == null ? void 0 : _palette3$action.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize: fontSize2 = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1h);
  const ownerState = _extends$8({}, props, {
    color: color2,
    component,
    fontSize: fontSize2,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$12(ownerState);
  return /* @__PURE__ */ jsxs(SvgIconRoot, _extends$8({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more, other, {
    ownerState,
    children: [children, titleAccess ? /* @__PURE__ */ jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
const SvgIcon$1 = SvgIcon;
function createSvgIcon$1(path, displayName) {
  function Component2(props, ref) {
    return /* @__PURE__ */ jsx(SvgIcon$1, _extends$8({
      "data-testid": `${displayName}Icon`,
      ref
    }, props, {
      children: path
    }));
  }
  Component2.muiName = SvgIcon$1.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component2));
}
const unstable_ClassNameGenerator = {
  configure: (generator) => {
    console.warn(["MUI: `ClassNameGenerator` import from `@mui/material/utils` is outdated and might cause unexpected issues.", "", "You should use `import { unstable_ClassNameGenerator } from '@mui/material/className'` instead", "", "The detail of the issue: https://github.com/mui/material-ui/issues/30011#issuecomment-1024993401", "", "The updated documentation: https://mui.com/guides/classname-generator/"].join("\n"));
    ClassNameGenerator$1.configure(generator);
  }
};
const utils$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  capitalize,
  createChainedFunction,
  createSvgIcon: createSvgIcon$1,
  debounce: debounce$2,
  deprecatedPropType,
  isMuiElement,
  ownerDocument,
  ownerWindow,
  requirePropFactory,
  setRef,
  unstable_ClassNameGenerator,
  unstable_useEnhancedEffect: useEnhancedEffect$1,
  unstable_useId: useId,
  unsupportedProp,
  useControlled,
  useEventCallback,
  useForkRef,
  useIsFocusVisible
}, Symbol.toStringTag, { value: "Module" }));
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
const config$1 = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter2, appear;
    exit = enter2 = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter2 = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter2;
    }
    return {
      exit,
      enter: enter2,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2)
            forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter2 = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter2 || config$1.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config$1.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback2) {
    callback2 = this.setNextCallback(callback2);
    this.setState(nextState, callback2);
  };
  _proto.setNextCallback = function setNextCallback(callback2) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback2(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition$1.contextType = TransitionGroupContext;
Transition$1.propTypes = {};
function noop$5() {
}
Transition$1.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$5,
  onEntering: noop$5,
  onEntered: noop$5,
  onExit: noop$5,
  onExiting: noop$5,
  onExited: noop$5
};
Transition$1.UNMOUNTED = UNMOUNTED;
Transition$1.EXITED = EXITED;
Transition$1.ENTERING = ENTERING;
Transition$1.ENTERED = ENTERED;
Transition$1.EXITING = EXITING;
const Transition$2 = Transition$1;
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop3, props) {
  return props[prop3] != null ? props[prop3] : child.props[prop3];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values$2 = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps$1 = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends$8({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component2 = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values$2(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component2 === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component2, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps$1;
const TransitionGroup$1 = TransitionGroup;
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
function getCollapseUtilityClass(slot) {
  return generateUtilityClass("MuiCollapse", slot);
}
generateUtilityClasses("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const _excluded$1g = ["addEndListener", "children", "className", "collapsedSize", "component", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "orientation", "style", "timeout", "TransitionComponent"];
const useUtilityClasses$11 = (ownerState) => {
  const {
    orientation,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `${orientation}`],
    entered: ["entered"],
    hidden: ["hidden"],
    wrapper: ["wrapper", `${orientation}`],
    wrapperInner: ["wrapperInner", `${orientation}`]
  };
  return composeClasses(slots, getCollapseUtilityClass, classes);
};
const CollapseRoot = styled$2("div", {
  name: "MuiCollapse",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.state === "entered" && styles2.entered, ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && styles2.hidden];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  height: 0,
  overflow: "hidden",
  transition: theme2.transitions.create("height")
}, ownerState.orientation === "horizontal" && {
  height: "auto",
  width: 0,
  transition: theme2.transitions.create("width")
}, ownerState.state === "entered" && _extends$8({
  height: "auto",
  overflow: "visible"
}, ownerState.orientation === "horizontal" && {
  width: "auto"
}), ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && {
  visibility: "hidden"
}));
const CollapseWrapper = styled$2("div", {
  name: "MuiCollapse",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => styles2.wrapper
})(({
  ownerState
}) => _extends$8({
  // Hack to get children with a negative margin to not falsify the height computation.
  display: "flex",
  width: "100%"
}, ownerState.orientation === "horizontal" && {
  width: "auto",
  height: "100%"
}));
const CollapseWrapperInner = styled$2("div", {
  name: "MuiCollapse",
  slot: "WrapperInner",
  overridesResolver: (props, styles2) => styles2.wrapperInner
})(({
  ownerState
}) => _extends$8({
  width: "100%"
}, ownerState.orientation === "horizontal" && {
  width: "auto",
  height: "100%"
}));
const Collapse = /* @__PURE__ */ reactExports.forwardRef(function Collapse2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCollapse"
  });
  const {
    addEndListener,
    children,
    className,
    collapsedSize: collapsedSizeProp = "0px",
    component,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    orientation = "vertical",
    style: style2,
    timeout = duration$2.standard,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1g);
  const ownerState = _extends$8({}, props, {
    orientation,
    collapsedSize: collapsedSizeProp
  });
  const classes = useUtilityClasses$11(ownerState);
  const theme2 = useTheme();
  const timer = reactExports.useRef();
  const wrapperRef = reactExports.useRef(null);
  const autoTransitionDuration = reactExports.useRef();
  const collapsedSize = typeof collapsedSizeProp === "number" ? `${collapsedSizeProp}px` : collapsedSizeProp;
  const isHorizontal2 = orientation === "horizontal";
  const size = isHorizontal2 ? "width" : "height";
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(timer.current);
    };
  }, []);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, nodeRef);
  const normalizedTransitionCallback = (callback2) => (maybeIsAppearing) => {
    if (callback2) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback2(node2);
      } else {
        callback2(node2, maybeIsAppearing);
      }
    }
  };
  const getWrapperSize = () => wrapperRef.current ? wrapperRef.current[isHorizontal2 ? "clientWidth" : "clientHeight"] : 0;
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    if (wrapperRef.current && isHorizontal2) {
      wrapperRef.current.style.position = "absolute";
    }
    node2.style[size] = collapsedSize;
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
    const wrapperSize = getWrapperSize();
    if (wrapperRef.current && isHorizontal2) {
      wrapperRef.current.style.position = "";
    }
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    if (timeout === "auto") {
      const duration22 = theme2.transitions.getAutoHeightDuration(wrapperSize);
      node2.style.transitionDuration = `${duration22}ms`;
      autoTransitionDuration.current = duration22;
    } else {
      node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node2.style[size] = `${wrapperSize}px`;
    node2.style.transitionTimingFunction = transitionTimingFunction;
    if (onEntering) {
      onEntering(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback((node2, isAppearing) => {
    node2.style[size] = "auto";
    if (onEntered) {
      onEntered(node2, isAppearing);
    }
  });
  const handleExit = normalizedTransitionCallback((node2) => {
    node2.style[size] = `${getWrapperSize()}px`;
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleExiting = normalizedTransitionCallback((node2) => {
    const wrapperSize = getWrapperSize();
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    if (timeout === "auto") {
      const duration22 = theme2.transitions.getAutoHeightDuration(wrapperSize);
      node2.style.transitionDuration = `${duration22}ms`;
      autoTransitionDuration.current = duration22;
    } else {
      node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node2.style[size] = collapsedSize;
    node2.style.transitionTimingFunction = transitionTimingFunction;
    if (onExiting) {
      onExiting(node2);
    }
  });
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.current = setTimeout(next2, autoTransitionDuration.current || 0);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
    in: inProp,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    nodeRef,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state, childProps) => /* @__PURE__ */ jsx(CollapseRoot, _extends$8({
      as: component,
      className: clsx(classes.root, className, {
        "entered": classes.entered,
        "exited": !inProp && collapsedSize === "0px" && classes.hidden
      }[state]),
      style: _extends$8({
        [isHorizontal2 ? "minWidth" : "minHeight"]: collapsedSize
      }, style2),
      ownerState: _extends$8({}, ownerState, {
        state
      }),
      ref: handleRef
    }, childProps, {
      children: /* @__PURE__ */ jsx(CollapseWrapper, {
        ownerState: _extends$8({}, ownerState, {
          state
        }),
        className: classes.wrapper,
        ref: wrapperRef,
        children: /* @__PURE__ */ jsx(CollapseWrapperInner, {
          ownerState: _extends$8({}, ownerState, {
            state
          }),
          className: classes.wrapperInner,
          children
        })
      })
    }))
  }));
});
Collapse.muiSupportAuto = true;
const Collapse$1 = Collapse;
function Ripple(props) {
  const {
    className,
    classes,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const touchRippleClasses$1 = touchRippleClasses;
const _excluded$1f = ["center", "classes", "className"];
let _$3 = (t3) => t3, _t$2, _t2$2, _t3$2, _t4$2;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(_t$2 || (_t$2 = _$3`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes(_t2$2 || (_t2$2 = _$3`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes(_t3$2 || (_t3$2 = _$3`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled$2("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled$2(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4$2 || (_t4$2 = _$3`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
  theme: theme2
}) => theme2.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
  theme: theme2
}) => theme2.transitions.easing.easeInOut);
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes = {},
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1f);
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = reactExports.useRef(null);
  const startTimerCommit = reactExports.useRef(null);
  const container2 = reactExports.useRef(null);
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(startTimer.current);
    };
  }, []);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes.ripple, touchRippleClasses$1.ripple),
        rippleVisible: clsx(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
        ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
        child: clsx(classes.child, touchRippleClasses$1.child),
        childLeaving: clsx(classes.childLeaving, touchRippleClasses$1.childLeaving),
        childPulsate: clsx(classes.childPulsate, touchRippleClasses$1.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes]);
  const start3 = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container2.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.current = setTimeout(() => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        }, DELAY_RIPPLE);
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit]);
  const pulsate = reactExports.useCallback(() => {
    start3({}, {
      pulsate: true
    });
  }, [start3]);
  const stop = reactExports.useCallback((event, cb2) => {
    clearTimeout(startTimer.current);
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(() => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, []);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start: start3,
    stop
  }), [pulsate, start3, stop]);
  return /* @__PURE__ */ jsx(TouchRippleRoot, _extends$8({
    className: clsx(touchRippleClasses$1.root, classes.root, className),
    ref: container2
  }, other, {
    children: /* @__PURE__ */ jsx(TransitionGroup$1, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
const TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const buttonBaseClasses$1 = buttonBaseClasses;
const _excluded$1e = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$10 = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled$2("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses$1.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick,
    onContextMenu,
    onDragLeave,
    onFocus,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd,
    onTouchMove,
    onTouchStart,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type: type2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1e);
  const buttonRef = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd);
  const handleTouchMove = useRippleHandler("stop", onTouchMove);
  const handleBlur = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus) {
      onFocus(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const keydownRef = reactExports.useRef(false);
  const handleKeyDown2 = useEventCallback((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick) {
        onClick(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type2 === void 0 ? "button" : type2;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
  const ownerState = _extends$8({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes = useUtilityClasses$10(ownerState);
  return /* @__PURE__ */ jsxs(ButtonBaseRoot, _extends$8({
    as: ComponentProp,
    className: clsx(classes.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type: type2
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ jsx(TouchRipple$1, _extends$8({
        ref: handleRippleRef,
        center: centerRipple
      }, TouchRippleProps))
    ) : null]
  }));
});
const ButtonBase$1 = ButtonBase;
function getAlertUtilityClass(slot) {
  return generateUtilityClass("MuiAlert", slot);
}
const alertClasses = generateUtilityClasses("MuiAlert", ["root", "action", "icon", "message", "filled", "filledSuccess", "filledInfo", "filledWarning", "filledError", "outlined", "outlinedSuccess", "outlinedInfo", "outlinedWarning", "outlinedError", "standard", "standardSuccess", "standardInfo", "standardWarning", "standardError"]);
const alertClasses$1 = alertClasses;
function getIconButtonUtilityClass(slot) {
  return generateUtilityClass("MuiIconButton", slot);
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge"]);
const iconButtonClasses$1 = iconButtonClasses;
const _excluded$1d = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];
const useUtilityClasses$$ = (ownerState) => {
  const {
    classes,
    disabled,
    color: color2,
    edge,
    size
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", color2 !== "default" && `color${capitalize(color2)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`]
  };
  return composeClasses(slots, getIconButtonUtilityClass, classes);
};
const IconButtonRoot = styled$2(ButtonBase$1, {
  name: "MuiIconButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize(ownerState.edge)}`], styles2[`size${capitalize(ownerState.size)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  textAlign: "center",
  flex: "0 0 auto",
  fontSize: theme2.typography.pxToRem(24),
  padding: 8,
  borderRadius: "50%",
  overflow: "visible",
  // Explicitly set the default value to solve a bug on IE11.
  color: (theme2.vars || theme2).palette.action.active,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  })
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.activeChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.action.active, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}), ({
  theme: theme2,
  ownerState
}) => _extends$8({}, ownerState.color === "inherit" && {
  color: "inherit"
}, ownerState.color !== "inherit" && ownerState.color !== "default" && _extends$8({
  color: (theme2.vars || theme2).palette[ownerState.color].main
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}), ownerState.size === "small" && {
  padding: 5,
  fontSize: theme2.typography.pxToRem(18)
}, ownerState.size === "large" && {
  padding: 12,
  fontSize: theme2.typography.pxToRem(28)
}, {
  [`&.${iconButtonClasses$1.disabled}`]: {
    backgroundColor: "transparent",
    color: (theme2.vars || theme2).palette.action.disabled
  }
}));
const IconButton = /* @__PURE__ */ reactExports.forwardRef(function IconButton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiIconButton"
  });
  const {
    edge = false,
    children,
    className,
    color: color2 = "default",
    disabled = false,
    disableFocusRipple = false,
    size = "medium"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1d);
  const ownerState = _extends$8({}, props, {
    edge,
    color: color2,
    disabled,
    disableFocusRipple,
    size
  });
  const classes = useUtilityClasses$$(ownerState);
  return /* @__PURE__ */ jsx(IconButtonRoot, _extends$8({
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    ref,
    ownerState
  }, other, {
    children
  }));
});
const IconButton$1 = IconButton;
const SuccessOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z"
}), "SuccessOutlined");
const ReportProblemOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z"
}), "ReportProblemOutlined");
const ErrorOutlineIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
}), "ErrorOutline");
const InfoOutlinedIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z"
}), "InfoOutlined");
const ClearIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const _excluded$1c = ["action", "children", "className", "closeText", "color", "components", "componentsProps", "icon", "iconMapping", "onClose", "role", "severity", "slotProps", "slots", "variant"];
const useUtilityClasses$_ = (ownerState) => {
  const {
    variant,
    color: color2,
    severity,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `${variant}${capitalize(color2 || severity)}`, `${variant}`],
    icon: ["icon"],
    message: ["message"],
    action: ["action"]
  };
  return composeClasses(slots, getAlertUtilityClass, classes);
};
const AlertRoot = styled$2(Paper$1, {
  name: "MuiAlert",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color || ownerState.severity)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const getColor = theme2.palette.mode === "light" ? darken : lighten;
  const getBackgroundColor = theme2.palette.mode === "light" ? lighten : darken;
  const color2 = ownerState.color || ownerState.severity;
  return _extends$8({}, theme2.typography.body2, {
    backgroundColor: "transparent",
    display: "flex",
    padding: "6px 16px"
  }, color2 && ownerState.variant === "standard" && {
    color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
    backgroundColor: theme2.vars ? theme2.vars.palette.Alert[`${color2}StandardBg`] : getBackgroundColor(theme2.palette[color2].light, 0.9),
    [`& .${alertClasses$1.icon}`]: theme2.vars ? {
      color: theme2.vars.palette.Alert[`${color2}IconColor`]
    } : {
      color: theme2.palette.mode === "dark" ? theme2.palette[color2].main : theme2.palette[color2].light
    }
  }, color2 && ownerState.variant === "outlined" && {
    color: theme2.vars ? theme2.vars.palette.Alert[`${color2}Color`] : getColor(theme2.palette[color2].light, 0.6),
    border: `1px solid ${(theme2.vars || theme2).palette[color2].light}`,
    [`& .${alertClasses$1.icon}`]: theme2.vars ? {
      color: theme2.vars.palette.Alert[`${color2}IconColor`]
    } : {
      color: theme2.palette.mode === "dark" ? theme2.palette[color2].main : theme2.palette[color2].light
    }
  }, color2 && ownerState.variant === "filled" && _extends$8({
    fontWeight: theme2.typography.fontWeightMedium
  }, theme2.vars ? {
    color: theme2.vars.palette.Alert[`${color2}FilledColor`],
    backgroundColor: theme2.vars.palette.Alert[`${color2}FilledBg`]
  } : {
    backgroundColor: theme2.palette.mode === "dark" ? theme2.palette[color2].dark : theme2.palette[color2].main,
    color: theme2.palette.getContrastText(theme2.palette.mode === "dark" ? theme2.palette[color2].dark : theme2.palette[color2].main)
  }));
});
const AlertIcon = styled$2("div", {
  name: "MuiAlert",
  slot: "Icon",
  overridesResolver: (props, styles2) => styles2.icon
})({
  marginRight: 12,
  padding: "7px 0",
  display: "flex",
  fontSize: 22,
  opacity: 0.9
});
const AlertMessage = styled$2("div", {
  name: "MuiAlert",
  slot: "Message",
  overridesResolver: (props, styles2) => styles2.message
})({
  padding: "8px 0",
  minWidth: 0,
  overflow: "auto"
});
const AlertAction = styled$2("div", {
  name: "MuiAlert",
  slot: "Action",
  overridesResolver: (props, styles2) => styles2.action
})({
  display: "flex",
  alignItems: "flex-start",
  padding: "4px 0 0 16px",
  marginLeft: "auto",
  marginRight: -8
});
const defaultIconMapping = {
  success: /* @__PURE__ */ jsx(SuccessOutlinedIcon, {
    fontSize: "inherit"
  }),
  warning: /* @__PURE__ */ jsx(ReportProblemOutlinedIcon, {
    fontSize: "inherit"
  }),
  error: /* @__PURE__ */ jsx(ErrorOutlineIcon, {
    fontSize: "inherit"
  }),
  info: /* @__PURE__ */ jsx(InfoOutlinedIcon, {
    fontSize: "inherit"
  })
};
const Alert = /* @__PURE__ */ reactExports.forwardRef(function Alert2(inProps, ref) {
  var _ref, _slots$closeButton, _ref2, _slots$closeIcon, _slotProps$closeButto, _slotProps$closeIcon;
  const props = useThemeProps({
    props: inProps,
    name: "MuiAlert"
  });
  const {
    action,
    children,
    className,
    closeText = "Close",
    color: color2,
    components = {},
    componentsProps = {},
    icon,
    iconMapping = defaultIconMapping,
    onClose,
    role = "alert",
    severity = "success",
    slotProps = {},
    slots = {},
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1c);
  const ownerState = _extends$8({}, props, {
    color: color2,
    severity,
    variant
  });
  const classes = useUtilityClasses$_(ownerState);
  const AlertCloseButton = (_ref = (_slots$closeButton = slots.closeButton) != null ? _slots$closeButton : components.CloseButton) != null ? _ref : IconButton$1;
  const AlertCloseIcon = (_ref2 = (_slots$closeIcon = slots.closeIcon) != null ? _slots$closeIcon : components.CloseIcon) != null ? _ref2 : ClearIcon;
  const closeButtonProps = (_slotProps$closeButto = slotProps.closeButton) != null ? _slotProps$closeButto : componentsProps.closeButton;
  const closeIconProps = (_slotProps$closeIcon = slotProps.closeIcon) != null ? _slotProps$closeIcon : componentsProps.closeIcon;
  return /* @__PURE__ */ jsxs(AlertRoot, _extends$8({
    role,
    elevation: 0,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other, {
    children: [icon !== false ? /* @__PURE__ */ jsx(AlertIcon, {
      ownerState,
      className: classes.icon,
      children: icon || iconMapping[severity] || defaultIconMapping[severity]
    }) : null, /* @__PURE__ */ jsx(AlertMessage, {
      ownerState,
      className: classes.message,
      children
    }), action != null ? /* @__PURE__ */ jsx(AlertAction, {
      ownerState,
      className: classes.action,
      children: action
    }) : null, action == null && onClose ? /* @__PURE__ */ jsx(AlertAction, {
      ownerState,
      className: classes.action,
      children: /* @__PURE__ */ jsx(AlertCloseButton, _extends$8({
        size: "small",
        "aria-label": closeText,
        title: closeText,
        color: "inherit",
        onClick: onClose
      }, closeButtonProps, {
        children: /* @__PURE__ */ jsx(AlertCloseIcon, _extends$8({
          fontSize: "small"
        }, closeIconProps))
      }))
    }) : null]
  }));
});
const Alert$1 = Alert;
function getTypographyUtilityClass(slot) {
  return generateUtilityClass("MuiTypography", slot);
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const _excluded$1b = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];
const useUtilityClasses$Z = (ownerState) => {
  const {
    align,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
  };
  return composeClasses(slots, getTypographyUtilityClass, classes);
};
const TypographyRoot = styled$2("span", {
  name: "MuiTypography",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  margin: 0
}, ownerState.variant && theme2.typography[ownerState.variant], ownerState.align !== "inherit" && {
  textAlign: ownerState.align
}, ownerState.noWrap && {
  overflow: "hidden",
  textOverflow: "ellipsis",
  whiteSpace: "nowrap"
}, ownerState.gutterBottom && {
  marginBottom: "0.35em"
}, ownerState.paragraph && {
  marginBottom: 16
}));
const defaultVariantMapping = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  h5: "h5",
  h6: "h6",
  subtitle1: "h6",
  subtitle2: "h6",
  body1: "p",
  body2: "p",
  inherit: "p"
};
const colorTransformations = {
  primary: "primary.main",
  textPrimary: "text.primary",
  secondary: "secondary.main",
  textSecondary: "text.secondary",
  error: "error.main"
};
const transformDeprecatedColors = (color2) => {
  return colorTransformations[color2] || color2;
};
const Typography = /* @__PURE__ */ reactExports.forwardRef(function Typography2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiTypography"
  });
  const color2 = transformDeprecatedColors(themeProps.color);
  const props = extendSxProp(_extends$8({}, themeProps, {
    color: color2
  }));
  const {
    align = "inherit",
    className,
    component,
    gutterBottom = false,
    noWrap = false,
    paragraph = false,
    variant = "body1",
    variantMapping = defaultVariantMapping
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1b);
  const ownerState = _extends$8({}, props, {
    align,
    color: color2,
    className,
    component,
    gutterBottom,
    noWrap,
    paragraph,
    variant,
    variantMapping
  });
  const Component2 = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
  const classes = useUtilityClasses$Z(ownerState);
  return /* @__PURE__ */ jsx(TypographyRoot, _extends$8({
    as: Component2,
    ref,
    ownerState,
    className: clsx(classes.root, className)
  }, other));
});
const Typography$1 = Typography;
function getAppBarUtilityClass(slot) {
  return generateUtilityClass("MuiAppBar", slot);
}
generateUtilityClasses("MuiAppBar", ["root", "positionFixed", "positionAbsolute", "positionSticky", "positionStatic", "positionRelative", "colorDefault", "colorPrimary", "colorSecondary", "colorInherit", "colorTransparent"]);
const _excluded$1a = ["className", "color", "enableColorOnDark", "position"];
const useUtilityClasses$Y = (ownerState) => {
  const {
    color: color2,
    position: position3,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, `position${capitalize(position3)}`]
  };
  return composeClasses(slots, getAppBarUtilityClass, classes);
};
const joinVars = (var1, var2) => `${var1 == null ? void 0 : var1.replace(")", "")}, ${var2})`;
const AppBarRoot = styled$2(Paper$1, {
  name: "MuiAppBar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`position${capitalize(ownerState.position)}`], styles2[`color${capitalize(ownerState.color)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const backgroundColorDefault = theme2.palette.mode === "light" ? theme2.palette.grey[100] : theme2.palette.grey[900];
  return _extends$8({
    display: "flex",
    flexDirection: "column",
    width: "100%",
    boxSizing: "border-box",
    // Prevent padding issue with the Modal and fixed positioned AppBar.
    flexShrink: 0
  }, ownerState.position === "fixed" && {
    position: "fixed",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0,
    "@media print": {
      // Prevent the app bar to be visible on each printed page.
      position: "absolute"
    }
  }, ownerState.position === "absolute" && {
    position: "absolute",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0
  }, ownerState.position === "sticky" && {
    //  sticky is not supported by IE11.
    position: "sticky",
    zIndex: (theme2.vars || theme2).zIndex.appBar,
    top: 0,
    left: "auto",
    right: 0
  }, ownerState.position === "static" && {
    position: "static"
  }, ownerState.position === "relative" && {
    position: "relative"
  }, !theme2.vars && _extends$8({}, ownerState.color === "default" && {
    backgroundColor: backgroundColorDefault,
    color: theme2.palette.getContrastText(backgroundColorDefault)
  }, ownerState.color && ownerState.color !== "default" && ownerState.color !== "inherit" && ownerState.color !== "transparent" && {
    backgroundColor: theme2.palette[ownerState.color].main,
    color: theme2.palette[ownerState.color].contrastText
  }, ownerState.color === "inherit" && {
    color: "inherit"
  }, theme2.palette.mode === "dark" && !ownerState.enableColorOnDark && {
    backgroundColor: null,
    color: null
  }, ownerState.color === "transparent" && _extends$8({
    backgroundColor: "transparent",
    color: "inherit"
  }, theme2.palette.mode === "dark" && {
    backgroundImage: "none"
  })), theme2.vars && _extends$8({}, ownerState.color === "default" && {
    "--AppBar-background": ownerState.enableColorOnDark ? theme2.vars.palette.AppBar.defaultBg : joinVars(theme2.vars.palette.AppBar.darkBg, theme2.vars.palette.AppBar.defaultBg),
    "--AppBar-color": ownerState.enableColorOnDark ? theme2.vars.palette.text.primary : joinVars(theme2.vars.palette.AppBar.darkColor, theme2.vars.palette.text.primary)
  }, ownerState.color && !ownerState.color.match(/^(default|inherit|transparent)$/) && {
    "--AppBar-background": ownerState.enableColorOnDark ? theme2.vars.palette[ownerState.color].main : joinVars(theme2.vars.palette.AppBar.darkBg, theme2.vars.palette[ownerState.color].main),
    "--AppBar-color": ownerState.enableColorOnDark ? theme2.vars.palette[ownerState.color].contrastText : joinVars(theme2.vars.palette.AppBar.darkColor, theme2.vars.palette[ownerState.color].contrastText)
  }, {
    backgroundColor: "var(--AppBar-background)",
    color: ownerState.color === "inherit" ? "inherit" : "var(--AppBar-color)"
  }, ownerState.color === "transparent" && {
    backgroundImage: "none",
    backgroundColor: "transparent",
    color: "inherit"
  }));
});
const AppBar = /* @__PURE__ */ reactExports.forwardRef(function AppBar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAppBar"
  });
  const {
    className,
    color: color2 = "primary",
    enableColorOnDark = false,
    position: position3 = "fixed"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1a);
  const ownerState = _extends$8({}, props, {
    color: color2,
    position: position3,
    enableColorOnDark
  });
  const classes = useUtilityClasses$Y(ownerState);
  return /* @__PURE__ */ jsx(AppBarRoot, _extends$8({
    square: true,
    component: "header",
    ownerState,
    elevation: 4,
    className: clsx(classes.root, className, position3 === "fixed" && "mui-fixed"),
    ref
  }, other));
});
const AppBar$1 = AppBar;
const _excluded$19 = ["components", "componentsProps", "slots", "slotProps"];
const PopperRoot = styled$2(PopperUnstyled$1, {
  name: "MuiPopper",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const Popper = /* @__PURE__ */ reactExports.forwardRef(function Popper2(inProps, ref) {
  var _slots$root;
  const theme2 = useTheme$2();
  const _useThemeProps = useThemeProps({
    props: inProps,
    name: "MuiPopper"
  }), {
    components,
    componentsProps,
    slots,
    slotProps
  } = _useThemeProps, other = _objectWithoutPropertiesLoose(_useThemeProps, _excluded$19);
  const RootComponent = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components == null ? void 0 : components.Root;
  return /* @__PURE__ */ jsx(PopperRoot, _extends$8({
    direction: theme2 == null ? void 0 : theme2.direction,
    slots: {
      root: RootComponent
    },
    slotProps: slotProps != null ? slotProps : componentsProps
  }, other, {
    ref
  }));
});
const Popper$1 = Popper;
function getListSubheaderUtilityClass(slot) {
  return generateUtilityClass("MuiListSubheader", slot);
}
generateUtilityClasses("MuiListSubheader", ["root", "colorPrimary", "colorInherit", "gutters", "inset", "sticky"]);
const _excluded$18 = ["className", "color", "component", "disableGutters", "disableSticky", "inset"];
const useUtilityClasses$X = (ownerState) => {
  const {
    classes,
    color: color2,
    disableGutters,
    inset,
    disableSticky
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "default" && `color${capitalize(color2)}`, !disableGutters && "gutters", inset && "inset", !disableSticky && "sticky"]
  };
  return composeClasses(slots, getListSubheaderUtilityClass, classes);
};
const ListSubheaderRoot = styled$2("li", {
  name: "MuiListSubheader",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`], !ownerState.disableGutters && styles2.gutters, ownerState.inset && styles2.inset, !ownerState.disableSticky && styles2.sticky];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  boxSizing: "border-box",
  lineHeight: "48px",
  listStyle: "none",
  color: (theme2.vars || theme2).palette.text.secondary,
  fontFamily: theme2.typography.fontFamily,
  fontWeight: theme2.typography.fontWeightMedium,
  fontSize: theme2.typography.pxToRem(14)
}, ownerState.color === "primary" && {
  color: (theme2.vars || theme2).palette.primary.main
}, ownerState.color === "inherit" && {
  color: "inherit"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.inset && {
  paddingLeft: 72
}, !ownerState.disableSticky && {
  position: "sticky",
  top: 0,
  zIndex: 1,
  backgroundColor: (theme2.vars || theme2).palette.background.paper
}));
const ListSubheader = /* @__PURE__ */ reactExports.forwardRef(function ListSubheader2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListSubheader"
  });
  const {
    className,
    color: color2 = "default",
    component = "li",
    disableGutters = false,
    disableSticky = false,
    inset = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$18);
  const ownerState = _extends$8({}, props, {
    color: color2,
    component,
    disableGutters,
    disableSticky,
    inset
  });
  const classes = useUtilityClasses$X(ownerState);
  return /* @__PURE__ */ jsx(ListSubheaderRoot, _extends$8({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other));
});
const ListSubheader$1 = ListSubheader;
const CancelIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"
}), "Cancel");
function getChipUtilityClass(slot) {
  return generateUtilityClass("MuiChip", slot);
}
const chipClasses = generateUtilityClasses("MuiChip", ["root", "sizeSmall", "sizeMedium", "colorError", "colorInfo", "colorPrimary", "colorSecondary", "colorSuccess", "colorWarning", "disabled", "clickable", "clickableColorPrimary", "clickableColorSecondary", "deletable", "deletableColorPrimary", "deletableColorSecondary", "outlined", "filled", "outlinedPrimary", "outlinedSecondary", "filledPrimary", "filledSecondary", "avatar", "avatarSmall", "avatarMedium", "avatarColorPrimary", "avatarColorSecondary", "icon", "iconSmall", "iconMedium", "iconColorPrimary", "iconColorSecondary", "label", "labelSmall", "labelMedium", "deleteIcon", "deleteIconSmall", "deleteIconMedium", "deleteIconColorPrimary", "deleteIconColorSecondary", "deleteIconOutlinedColorPrimary", "deleteIconOutlinedColorSecondary", "deleteIconFilledColorPrimary", "deleteIconFilledColorSecondary", "focusVisible"]);
const chipClasses$1 = chipClasses;
const _excluded$17 = ["avatar", "className", "clickable", "color", "component", "deleteIcon", "disabled", "icon", "label", "onClick", "onDelete", "onKeyDown", "onKeyUp", "size", "variant"];
const useUtilityClasses$W = (ownerState) => {
  const {
    classes,
    disabled,
    size,
    color: color2,
    iconColor,
    onDelete,
    clickable,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant, disabled && "disabled", `size${capitalize(size)}`, `color${capitalize(color2)}`, clickable && "clickable", clickable && `clickableColor${capitalize(color2)}`, onDelete && "deletable", onDelete && `deletableColor${capitalize(color2)}`, `${variant}${capitalize(color2)}`],
    label: ["label", `label${capitalize(size)}`],
    avatar: ["avatar", `avatar${capitalize(size)}`, `avatarColor${capitalize(color2)}`],
    icon: ["icon", `icon${capitalize(size)}`, `iconColor${capitalize(iconColor)}`],
    deleteIcon: ["deleteIcon", `deleteIcon${capitalize(size)}`, `deleteIconColor${capitalize(color2)}`, `deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
  };
  return composeClasses(slots, getChipUtilityClass, classes);
};
const ChipRoot = styled$2("div", {
  name: "MuiChip",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      color: color2,
      iconColor,
      clickable,
      onDelete,
      size,
      variant
    } = ownerState;
    return [{
      [`& .${chipClasses$1.avatar}`]: styles2.avatar
    }, {
      [`& .${chipClasses$1.avatar}`]: styles2[`avatar${capitalize(size)}`]
    }, {
      [`& .${chipClasses$1.avatar}`]: styles2[`avatarColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses$1.icon}`]: styles2.icon
    }, {
      [`& .${chipClasses$1.icon}`]: styles2[`icon${capitalize(size)}`]
    }, {
      [`& .${chipClasses$1.icon}`]: styles2[`iconColor${capitalize(iconColor)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2.deleteIcon
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(size)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIconColor${capitalize(color2)}`]
    }, {
      [`& .${chipClasses$1.deleteIcon}`]: styles2[`deleteIcon${capitalize(variant)}Color${capitalize(color2)}`]
    }, styles2.root, styles2[`size${capitalize(size)}`], styles2[`color${capitalize(color2)}`], clickable && styles2.clickable, clickable && color2 !== "default" && styles2[`clickableColor${capitalize(color2)})`], onDelete && styles2.deletable, onDelete && color2 !== "default" && styles2[`deletableColor${capitalize(color2)}`], styles2[variant], styles2[`${variant}${capitalize(color2)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const deleteIconColor = alpha(theme2.palette.text.primary, 0.26);
  const textColor = theme2.palette.mode === "light" ? theme2.palette.grey[700] : theme2.palette.grey[300];
  return _extends$8({
    maxWidth: "100%",
    fontFamily: theme2.typography.fontFamily,
    fontSize: theme2.typography.pxToRem(13),
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    height: 32,
    color: (theme2.vars || theme2).palette.text.primary,
    backgroundColor: (theme2.vars || theme2).palette.action.selected,
    borderRadius: 32 / 2,
    whiteSpace: "nowrap",
    transition: theme2.transitions.create(["background-color", "box-shadow"]),
    // label will inherit this from root, then `clickable` class overrides this for both
    cursor: "default",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    textDecoration: "none",
    border: 0,
    // Remove `button` border
    padding: 0,
    // Remove `button` padding
    verticalAlign: "middle",
    boxSizing: "border-box",
    [`&.${chipClasses$1.disabled}`]: {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`& .${chipClasses$1.avatar}`]: {
      marginLeft: 5,
      marginRight: -6,
      width: 24,
      height: 24,
      color: theme2.vars ? theme2.vars.palette.Chip.defaultAvatarColor : textColor,
      fontSize: theme2.typography.pxToRem(12)
    },
    [`& .${chipClasses$1.avatarColorPrimary}`]: {
      color: (theme2.vars || theme2).palette.primary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.primary.dark
    },
    [`& .${chipClasses$1.avatarColorSecondary}`]: {
      color: (theme2.vars || theme2).palette.secondary.contrastText,
      backgroundColor: (theme2.vars || theme2).palette.secondary.dark
    },
    [`& .${chipClasses$1.avatarSmall}`]: {
      marginLeft: 4,
      marginRight: -4,
      width: 18,
      height: 18,
      fontSize: theme2.typography.pxToRem(10)
    },
    [`& .${chipClasses$1.icon}`]: _extends$8({
      marginLeft: 5,
      marginRight: -6
    }, ownerState.size === "small" && {
      fontSize: 18,
      marginLeft: 4,
      marginRight: -4
    }, ownerState.iconColor === ownerState.color && _extends$8({
      color: theme2.vars ? theme2.vars.palette.Chip.defaultIconColor : textColor
    }, ownerState.color !== "default" && {
      color: "inherit"
    })),
    [`& .${chipClasses$1.deleteIcon}`]: _extends$8({
      WebkitTapHighlightColor: "transparent",
      color: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / 0.26)` : deleteIconColor,
      fontSize: 22,
      cursor: "pointer",
      margin: "0 5px 0 -6px",
      "&:hover": {
        color: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / 0.4)` : alpha(deleteIconColor, 0.4)
      }
    }, ownerState.size === "small" && {
      fontSize: 16,
      marginRight: 4,
      marginLeft: -4
    }, ownerState.color !== "default" && {
      color: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].contrastTextChannel} / 0.7)` : alpha(theme2.palette[ownerState.color].contrastText, 0.7),
      "&:hover, &:active": {
        color: (theme2.vars || theme2).palette[ownerState.color].contrastText
      }
    })
  }, ownerState.size === "small" && {
    height: 24
  }, ownerState.color !== "default" && {
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main,
    color: (theme2.vars || theme2).palette[ownerState.color].contrastText
  }, ownerState.onDelete && {
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity + theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  }, ownerState.onDelete && ownerState.color !== "default" && {
    [`&.${chipClasses$1.focusVisible}`]: {
      backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark
    }
  });
}, ({
  theme: theme2,
  ownerState
}) => _extends$8({}, ownerState.clickable && {
  userSelect: "none",
  WebkitTapHighlightColor: "transparent",
  cursor: "pointer",
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity + theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity)
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.action.selectedChannel} / calc(${theme2.vars.palette.action.selectedOpacity + theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.action.selected, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
  },
  "&:active": {
    boxShadow: (theme2.vars || theme2).shadows[1]
  }
}, ownerState.clickable && ownerState.color !== "default" && {
  [`&:hover, &.${chipClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$8({}, ownerState.variant === "outlined" && {
  backgroundColor: "transparent",
  border: theme2.vars ? `1px solid ${theme2.vars.palette.Chip.defaultBorder}` : `1px solid ${theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[700]}`,
  [`&.${chipClasses$1.clickable}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`& .${chipClasses$1.avatar}`]: {
    marginLeft: 4
  },
  [`& .${chipClasses$1.avatarSmall}`]: {
    marginLeft: 2
  },
  [`& .${chipClasses$1.icon}`]: {
    marginLeft: 4
  },
  [`& .${chipClasses$1.iconSmall}`]: {
    marginLeft: 2
  },
  [`& .${chipClasses$1.deleteIcon}`]: {
    marginRight: 5
  },
  [`& .${chipClasses$1.deleteIconSmall}`]: {
    marginRight: 3
  }
}, ownerState.variant === "outlined" && ownerState.color !== "default" && {
  color: (theme2.vars || theme2).palette[ownerState.color].main,
  border: `1px solid ${theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme2.palette[ownerState.color].main, 0.7)}`,
  [`&.${chipClasses$1.clickable}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity)
  },
  [`&.${chipClasses$1.focusVisible}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.focusOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.focusOpacity)
  },
  [`& .${chipClasses$1.deleteIcon}`]: {
    color: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.7)` : alpha(theme2.palette[ownerState.color].main, 0.7),
    "&:hover, &:active": {
      color: (theme2.vars || theme2).palette[ownerState.color].main
    }
  }
}));
const ChipLabel = styled$2("span", {
  name: "MuiChip",
  slot: "Label",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      size
    } = ownerState;
    return [styles2.label, styles2[`label${capitalize(size)}`]];
  }
})(({
  ownerState
}) => _extends$8({
  overflow: "hidden",
  textOverflow: "ellipsis",
  paddingLeft: 12,
  paddingRight: 12,
  whiteSpace: "nowrap"
}, ownerState.size === "small" && {
  paddingLeft: 8,
  paddingRight: 8
}));
function isDeleteKeyboardEvent(keyboardEvent) {
  return keyboardEvent.key === "Backspace" || keyboardEvent.key === "Delete";
}
const Chip = /* @__PURE__ */ reactExports.forwardRef(function Chip2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChip"
  });
  const {
    avatar: avatarProp,
    className,
    clickable: clickableProp,
    color: color2 = "default",
    component: ComponentProp,
    deleteIcon: deleteIconProp,
    disabled = false,
    icon: iconProp,
    label,
    onClick,
    onDelete,
    onKeyDown,
    onKeyUp,
    size = "medium",
    variant = "filled"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$17);
  const chipRef = reactExports.useRef(null);
  const handleRef = useForkRef(chipRef, ref);
  const handleDeleteIconClick = (event) => {
    event.stopPropagation();
    if (onDelete) {
      onDelete(event);
    }
  };
  const handleKeyDown2 = (event) => {
    if (event.currentTarget === event.target && isDeleteKeyboardEvent(event)) {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleKeyUp = (event) => {
    if (event.currentTarget === event.target) {
      if (onDelete && isDeleteKeyboardEvent(event)) {
        onDelete(event);
      } else if (event.key === "Escape" && chipRef.current) {
        chipRef.current.blur();
      }
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
  };
  const clickable = clickableProp !== false && onClick ? true : clickableProp;
  const component = clickable || onDelete ? ButtonBase$1 : ComponentProp || "div";
  const ownerState = _extends$8({}, props, {
    component,
    disabled,
    size,
    color: color2,
    iconColor: /* @__PURE__ */ reactExports.isValidElement(iconProp) ? iconProp.props.color || color2 : color2,
    onDelete: !!onDelete,
    clickable,
    variant
  });
  const classes = useUtilityClasses$W(ownerState);
  const moreProps = component === ButtonBase$1 ? _extends$8({
    component: ComponentProp || "div",
    focusVisibleClassName: classes.focusVisible
  }, onDelete && {
    disableRipple: true
  }) : {};
  let deleteIcon = null;
  if (onDelete) {
    deleteIcon = deleteIconProp && /* @__PURE__ */ reactExports.isValidElement(deleteIconProp) ? /* @__PURE__ */ reactExports.cloneElement(deleteIconProp, {
      className: clsx(deleteIconProp.props.className, classes.deleteIcon),
      onClick: handleDeleteIconClick
    }) : /* @__PURE__ */ jsx(CancelIcon, {
      className: clsx(classes.deleteIcon),
      onClick: handleDeleteIconClick
    });
  }
  let avatar = null;
  if (avatarProp && /* @__PURE__ */ reactExports.isValidElement(avatarProp)) {
    avatar = /* @__PURE__ */ reactExports.cloneElement(avatarProp, {
      className: clsx(classes.avatar, avatarProp.props.className)
    });
  }
  let icon = null;
  if (iconProp && /* @__PURE__ */ reactExports.isValidElement(iconProp)) {
    icon = /* @__PURE__ */ reactExports.cloneElement(iconProp, {
      className: clsx(classes.icon, iconProp.props.className)
    });
  }
  return /* @__PURE__ */ jsxs(ChipRoot, _extends$8({
    as: component,
    className: clsx(classes.root, className),
    disabled: clickable && disabled ? true : void 0,
    onClick,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    ref: handleRef,
    ownerState
  }, moreProps, other, {
    children: [avatar || icon, /* @__PURE__ */ jsx(ChipLabel, {
      className: clsx(classes.label),
      ownerState,
      children: label
    }), deleteIcon]
  }));
});
const Chip$1 = Chip;
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === "undefined") {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}
const FormControlContext = /* @__PURE__ */ reactExports.createContext();
const FormControlContext$1 = FormControlContext;
function useFormControl() {
  return reactExports.useContext(FormControlContext$1);
}
function GlobalStyles(props) {
  return /* @__PURE__ */ jsx(GlobalStyles$1, _extends$8({}, props, {
    defaultTheme: defaultTheme$2
  }));
}
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function isAdornedStart(obj) {
  return obj.startAdornment;
}
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
const inputBaseClasses$1 = inputBaseClasses;
const _excluded$16 = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
const rootOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
};
const inputOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
};
const useUtilityClasses$V = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size,
    startAdornment,
    type: type2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size === "small" && "sizeSmall", multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type2 === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes);
};
const InputBaseRoot = styled$2("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$8({}, theme2.typography.body1, {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled,
    cursor: "default"
  }
}, ownerState.multiline && _extends$8({
  padding: "4px 0 5px"
}, ownerState.size === "small" && {
  paddingTop: 1
}), ownerState.fullWidth && {
  width: "100%"
}));
const InputBaseComponent = styled$2("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => {
  const light2 = theme2.palette.mode === "light";
  const placeholder = _extends$8({
    color: "currentColor"
  }, theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  }, {
    transition: theme2.transitions.create("opacity", {
      duration: theme2.transitions.duration.shorter
    })
  });
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme2.vars ? {
    opacity: theme2.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return _extends$8({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&:-ms-input-placeholder": placeholder,
    // IE11
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&:-ms-input-placeholder": placeholderHidden,
      // IE11
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": placeholderVisible,
      // IE11
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses$1.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme2.vars || theme2).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, ownerState.size === "small" && {
    paddingTop: 1
  }, ownerState.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, ownerState.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
});
const inputGlobalStyles = /* @__PURE__ */ jsx(GlobalStyles, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
  var _slotProps$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    fullWidth = false,
    id: id2,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onClick,
    onFocus,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    slotProps = {},
    slots = {},
    startAdornment,
    type: type2 = "text",
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$16);
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef();
  const handleInputRefWarning = reactExports.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = reactExports.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  reactExports.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = reactExports.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect$1(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = (event) => {
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    if (onFocus) {
      onFocus(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  };
  reactExports.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = (event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick) {
      onClick(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows) {
      inputProps = _extends$8({
        type: void 0,
        minRows: rows,
        maxRows: rows
      }, inputProps);
    } else {
      inputProps = _extends$8({
        type: void 0,
        maxRows,
        minRows
      }, inputProps);
    }
    InputComponent = TextareaAutosize$1;
  }
  const handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = _extends$8({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type: type2
  });
  const classes = useUtilityClasses$V(ownerState);
  const Root2 = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseComponent;
  inputProps = _extends$8({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
  return /* @__PURE__ */ jsxs(reactExports.Fragment, {
    children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxs(Root2, _extends$8({}, rootProps, !isHostComponent(Root2) && {
      ownerState: _extends$8({}, ownerState, rootProps.ownerState)
    }, {
      ref,
      onClick: handleClick
    }, other, {
      className: clsx(classes.root, rootProps.className, className),
      children: [startAdornment, /* @__PURE__ */ jsx(FormControlContext$1.Provider, {
        value: null,
        children: /* @__PURE__ */ jsx(Input3, _extends$8({
          ownerState,
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id: id2,
          onAnimationStart: handleAutoFill,
          name,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type: type2
        }, inputProps, !isHostComponent(Input3) && {
          as: InputComponent,
          ownerState: _extends$8({}, ownerState, inputProps.ownerState)
        }, {
          ref: handleInputRef,
          className: clsx(classes.input, inputProps.className),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(_extends$8({}, fcs, {
        startAdornment
      })) : null]
    }))]
  });
});
const InputBase$1 = InputBase;
function getInputUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
const inputClasses = _extends$8({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
const inputClasses$1 = inputClasses;
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiOutlinedInput", slot);
}
const outlinedInputClasses = _extends$8({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
const outlinedInputClasses$1 = outlinedInputClasses;
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiFilledInput", slot);
}
const filledInputClasses = _extends$8({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
const filledInputClasses$1 = filledInputClasses;
const ArrowDropDownIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
function getAutocompleteUtilityClass(slot) {
  return generateUtilityClass("MuiAutocomplete", slot);
}
const autocompleteClasses = generateUtilityClasses("MuiAutocomplete", ["root", "fullWidth", "focused", "focusVisible", "tag", "tagSizeSmall", "tagSizeMedium", "hasPopupIcon", "hasClearIcon", "inputRoot", "input", "inputFocused", "endAdornment", "clearIndicator", "popupIndicator", "popupIndicatorOpen", "popper", "popperDisablePortal", "paper", "listbox", "loading", "noOptions", "option", "groupLabel", "groupUl"]);
const autocompleteClasses$1 = autocompleteClasses;
var _ClearIcon, _ArrowDropDownIcon;
const _excluded$15 = ["autoComplete", "autoHighlight", "autoSelect", "blurOnSelect", "ChipProps", "className", "clearIcon", "clearOnBlur", "clearOnEscape", "clearText", "closeText", "componentsProps", "defaultValue", "disableClearable", "disableCloseOnSelect", "disabled", "disabledItemsFocusable", "disableListWrap", "disablePortal", "filterOptions", "filterSelectedOptions", "forcePopupIcon", "freeSolo", "fullWidth", "getLimitTagsText", "getOptionDisabled", "getOptionLabel", "isOptionEqualToValue", "groupBy", "handleHomeEndKeys", "id", "includeInputInList", "inputValue", "limitTags", "ListboxComponent", "ListboxProps", "loading", "loadingText", "multiple", "noOptionsText", "onChange", "onClose", "onHighlightChange", "onInputChange", "onOpen", "open", "openOnFocus", "openText", "options", "PaperComponent", "PopperComponent", "popupIcon", "readOnly", "renderGroup", "renderInput", "renderOption", "renderTags", "selectOnFocus", "size", "slotProps", "value"];
const useUtilityClasses$U = (ownerState) => {
  const {
    classes,
    disablePortal,
    focused,
    fullWidth,
    hasClearIcon,
    hasPopupIcon,
    inputFocused,
    popupOpen,
    size
  } = ownerState;
  const slots = {
    root: ["root", focused && "focused", fullWidth && "fullWidth", hasClearIcon && "hasClearIcon", hasPopupIcon && "hasPopupIcon"],
    inputRoot: ["inputRoot"],
    input: ["input", inputFocused && "inputFocused"],
    tag: ["tag", `tagSize${capitalize(size)}`],
    endAdornment: ["endAdornment"],
    clearIndicator: ["clearIndicator"],
    popupIndicator: ["popupIndicator", popupOpen && "popupIndicatorOpen"],
    popper: ["popper", disablePortal && "popperDisablePortal"],
    paper: ["paper"],
    listbox: ["listbox"],
    loading: ["loading"],
    noOptions: ["noOptions"],
    option: ["option"],
    groupLabel: ["groupLabel"],
    groupUl: ["groupUl"]
  };
  return composeClasses(slots, getAutocompleteUtilityClass, classes);
};
const AutocompleteRoot = styled$2("div", {
  name: "MuiAutocomplete",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      fullWidth,
      hasClearIcon,
      hasPopupIcon,
      inputFocused,
      size
    } = ownerState;
    return [{
      [`& .${autocompleteClasses$1.tag}`]: styles2.tag
    }, {
      [`& .${autocompleteClasses$1.tag}`]: styles2[`tagSize${capitalize(size)}`]
    }, {
      [`& .${autocompleteClasses$1.inputRoot}`]: styles2.inputRoot
    }, {
      [`& .${autocompleteClasses$1.input}`]: styles2.input
    }, {
      [`& .${autocompleteClasses$1.input}`]: inputFocused && styles2.inputFocused
    }, styles2.root, fullWidth && styles2.fullWidth, hasPopupIcon && styles2.hasPopupIcon, hasClearIcon && styles2.hasClearIcon];
  }
})(({
  ownerState
}) => _extends$8({
  [`&.${autocompleteClasses$1.focused} .${autocompleteClasses$1.clearIndicator}`]: {
    visibility: "visible"
  },
  /* Avoid double tap issue on iOS */
  "@media (pointer: fine)": {
    [`&:hover .${autocompleteClasses$1.clearIndicator}`]: {
      visibility: "visible"
    }
  }
}, ownerState.fullWidth && {
  width: "100%"
}, {
  [`& .${autocompleteClasses$1.tag}`]: _extends$8({
    margin: 3,
    maxWidth: "calc(100% - 6px)"
  }, ownerState.size === "small" && {
    margin: 2,
    maxWidth: "calc(100% - 4px)"
  }),
  [`& .${autocompleteClasses$1.inputRoot}`]: {
    flexWrap: "wrap",
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4
    },
    [`& .${autocompleteClasses$1.input}`]: {
      width: 0,
      minWidth: 30
    }
  },
  [`& .${inputClasses$1.root}`]: {
    paddingBottom: 1,
    "& .MuiInput-input": {
      padding: "4px 4px 4px 0px"
    }
  },
  [`& .${inputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
    [`& .${inputClasses$1.input}`]: {
      padding: "2px 4px 3px 0"
    }
  },
  [`& .${outlinedInputClasses$1.root}`]: {
    padding: 9,
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${autocompleteClasses$1.input}`]: {
      padding: "7.5px 4px 7.5px 6px"
    },
    [`& .${autocompleteClasses$1.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${outlinedInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
    // Don't specify paddingRight, as it overrides the default value set when there is only
    // one of the popup or clear icon as the specificity is equal so the latter one wins
    paddingTop: 6,
    paddingBottom: 6,
    paddingLeft: 6,
    [`& .${autocompleteClasses$1.input}`]: {
      padding: "2.5px 4px 2.5px 6px"
    }
  },
  [`& .${filledInputClasses$1.root}`]: {
    paddingTop: 19,
    paddingLeft: 8,
    [`.${autocompleteClasses$1.hasPopupIcon}&, .${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 26 + 4 + 9
    },
    [`.${autocompleteClasses$1.hasPopupIcon}.${autocompleteClasses$1.hasClearIcon}&`]: {
      paddingRight: 52 + 4 + 9
    },
    [`& .${filledInputClasses$1.input}`]: {
      padding: "7px 4px"
    },
    [`& .${autocompleteClasses$1.endAdornment}`]: {
      right: 9
    }
  },
  [`& .${filledInputClasses$1.root}.${inputBaseClasses$1.sizeSmall}`]: {
    paddingBottom: 1,
    [`& .${filledInputClasses$1.input}`]: {
      padding: "2.5px 4px"
    }
  },
  [`& .${inputBaseClasses$1.hiddenLabel}`]: {
    paddingTop: 8
  },
  [`& .${autocompleteClasses$1.input}`]: _extends$8({
    flexGrow: 1,
    textOverflow: "ellipsis",
    opacity: 0
  }, ownerState.inputFocused && {
    opacity: 1
  })
}));
const AutocompleteEndAdornment = styled$2("div", {
  name: "MuiAutocomplete",
  slot: "EndAdornment",
  overridesResolver: (props, styles2) => styles2.endAdornment
})({
  // We use a position absolute to support wrapping tags.
  position: "absolute",
  right: 0,
  top: "calc(50% - 14px)"
  // Center vertically
});
const AutocompleteClearIndicator = styled$2(IconButton$1, {
  name: "MuiAutocomplete",
  slot: "ClearIndicator",
  overridesResolver: (props, styles2) => styles2.clearIndicator
})({
  marginRight: -2,
  padding: 4,
  visibility: "hidden"
});
const AutocompletePopupIndicator = styled$2(IconButton$1, {
  name: "MuiAutocomplete",
  slot: "PopupIndicator",
  overridesResolver: ({
    ownerState
  }, styles2) => _extends$8({}, styles2.popupIndicator, ownerState.popupOpen && styles2.popupIndicatorOpen)
})(({
  ownerState
}) => _extends$8({
  padding: 2,
  marginRight: -2
}, ownerState.popupOpen && {
  transform: "rotate(180deg)"
}));
const AutocompletePopper = styled$2(Popper$1, {
  name: "MuiAutocomplete",
  slot: "Popper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${autocompleteClasses$1.option}`]: styles2.option
    }, styles2.popper, ownerState.disablePortal && styles2.popperDisablePortal];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  zIndex: (theme2.vars || theme2).zIndex.modal
}, ownerState.disablePortal && {
  position: "absolute"
}));
const AutocompletePaper = styled$2(Paper$1, {
  name: "MuiAutocomplete",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})(({
  theme: theme2
}) => _extends$8({}, theme2.typography.body1, {
  overflow: "auto"
}));
const AutocompleteLoading = styled$2("div", {
  name: "MuiAutocomplete",
  slot: "Loading",
  overridesResolver: (props, styles2) => styles2.loading
})(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteNoOptions = styled$2("div", {
  name: "MuiAutocomplete",
  slot: "NoOptions",
  overridesResolver: (props, styles2) => styles2.noOptions
})(({
  theme: theme2
}) => ({
  color: (theme2.vars || theme2).palette.text.secondary,
  padding: "14px 16px"
}));
const AutocompleteListbox = styled$2("div", {
  name: "MuiAutocomplete",
  slot: "Listbox",
  overridesResolver: (props, styles2) => styles2.listbox
})(({
  theme: theme2
}) => ({
  listStyle: "none",
  margin: 0,
  padding: "8px 0",
  maxHeight: "40vh",
  overflow: "auto",
  [`& .${autocompleteClasses$1.option}`]: {
    minHeight: 48,
    display: "flex",
    overflow: "hidden",
    justifyContent: "flex-start",
    alignItems: "center",
    cursor: "pointer",
    paddingTop: 6,
    boxSizing: "border-box",
    outline: "0",
    WebkitTapHighlightColor: "transparent",
    paddingBottom: 6,
    paddingLeft: 16,
    paddingRight: 16,
    [theme2.breakpoints.up("sm")]: {
      minHeight: "auto"
    },
    [`&.${autocompleteClasses$1.focused}`]: {
      backgroundColor: (theme2.vars || theme2).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    '&[aria-disabled="true"]': {
      opacity: (theme2.vars || theme2).palette.action.disabledOpacity,
      pointerEvents: "none"
    },
    [`&.${autocompleteClasses$1.focusVisible}`]: {
      backgroundColor: (theme2.vars || theme2).palette.action.focus
    },
    '&[aria-selected="true"]': {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
      [`&.${autocompleteClasses$1.focused}`]: {
        backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: (theme2.vars || theme2).palette.action.selected
        }
      },
      [`&.${autocompleteClasses$1.focusVisible}`]: {
        backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
      }
    }
  }
}));
const AutocompleteGroupLabel = styled$2(ListSubheader$1, {
  name: "MuiAutocomplete",
  slot: "GroupLabel",
  overridesResolver: (props, styles2) => styles2.groupLabel
})(({
  theme: theme2
}) => ({
  backgroundColor: (theme2.vars || theme2).palette.background.paper,
  top: -8
}));
const AutocompleteGroupUl = styled$2("ul", {
  name: "MuiAutocomplete",
  slot: "GroupUl",
  overridesResolver: (props, styles2) => styles2.groupUl
})({
  padding: 0,
  [`& .${autocompleteClasses$1.option}`]: {
    paddingLeft: 24
  }
});
const Autocomplete = /* @__PURE__ */ reactExports.forwardRef(function Autocomplete2(inProps, ref) {
  var _slotProps$clearIndic, _slotProps$paper, _slotProps$popper, _slotProps$popupIndic;
  const props = useThemeProps({
    props: inProps,
    name: "MuiAutocomplete"
  });
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    ChipProps,
    className,
    clearIcon = _ClearIcon || (_ClearIcon = /* @__PURE__ */ jsx(ClearIcon, {
      fontSize: "small"
    })),
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    clearText = "Clear",
    closeText = "Close",
    componentsProps = {},
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabled = false,
    disabledItemsFocusable = false,
    disableListWrap = false,
    disablePortal = false,
    filterSelectedOptions = false,
    forcePopupIcon = "auto",
    freeSolo = false,
    fullWidth = false,
    getLimitTagsText = (more) => `+${more}`,
    getOptionLabel = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    },
    groupBy,
    handleHomeEndKeys = !props.freeSolo,
    includeInputInList = false,
    limitTags = -1,
    ListboxComponent = "ul",
    ListboxProps,
    loading = false,
    loadingText = "Loading",
    multiple = false,
    noOptionsText = "No options",
    openOnFocus = false,
    openText = "Open",
    PaperComponent = Paper$1,
    PopperComponent = Popper$1,
    popupIcon = _ArrowDropDownIcon || (_ArrowDropDownIcon = /* @__PURE__ */ jsx(ArrowDropDownIcon, {})),
    readOnly = false,
    renderGroup: renderGroupProp,
    renderInput: renderInput2,
    renderOption: renderOptionProp,
    renderTags,
    selectOnFocus = !props.freeSolo,
    size = "medium",
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$15);
  const {
    getRootProps,
    getInputProps,
    getInputLabelProps,
    getPopupIndicatorProps,
    getClearProps,
    getTagProps,
    getListboxProps,
    getOptionProps,
    value,
    dirty,
    id: id2,
    popupOpen,
    focused,
    focusedTag,
    anchorEl,
    setAnchorEl,
    inputValue,
    groupedOptions
  } = useAutocomplete(_extends$8({}, props, {
    componentName: "Autocomplete"
  }));
  const hasClearIcon = !disableClearable && !disabled && dirty && !readOnly;
  const hasPopupIcon = (!freeSolo || forcePopupIcon === true) && forcePopupIcon !== false;
  const ownerState = _extends$8({}, props, {
    disablePortal,
    focused,
    fullWidth,
    hasClearIcon,
    hasPopupIcon,
    inputFocused: focusedTag === -1,
    popupOpen,
    size
  });
  const classes = useUtilityClasses$U(ownerState);
  let startAdornment;
  if (multiple && value.length > 0) {
    const getCustomizedTagProps = (params) => _extends$8({
      className: classes.tag,
      disabled
    }, getTagProps(params));
    if (renderTags) {
      startAdornment = renderTags(value, getCustomizedTagProps, ownerState);
    } else {
      startAdornment = value.map((option, index2) => /* @__PURE__ */ jsx(Chip$1, _extends$8({
        label: getOptionLabel(option),
        size
      }, getCustomizedTagProps({
        index: index2
      }), ChipProps)));
    }
  }
  if (limitTags > -1 && Array.isArray(startAdornment)) {
    const more = startAdornment.length - limitTags;
    if (!focused && more > 0) {
      startAdornment = startAdornment.splice(0, limitTags);
      startAdornment.push(/* @__PURE__ */ jsx("span", {
        className: classes.tag,
        children: getLimitTagsText(more)
      }, startAdornment.length));
    }
  }
  const defaultRenderGroup = (params) => /* @__PURE__ */ jsxs("li", {
    children: [/* @__PURE__ */ jsx(AutocompleteGroupLabel, {
      className: classes.groupLabel,
      ownerState,
      component: "div",
      children: params.group
    }), /* @__PURE__ */ jsx(AutocompleteGroupUl, {
      className: classes.groupUl,
      ownerState,
      children: params.children
    })]
  }, params.key);
  const renderGroup = renderGroupProp || defaultRenderGroup;
  const defaultRenderOption = (props2, option) => /* @__PURE__ */ jsx("li", _extends$8({}, props2, {
    children: getOptionLabel(option)
  }));
  const renderOption = renderOptionProp || defaultRenderOption;
  const renderListOption = (option, index2) => {
    const optionProps = getOptionProps({
      option,
      index: index2
    });
    return renderOption(_extends$8({}, optionProps, {
      className: classes.option
    }), option, {
      selected: optionProps["aria-selected"],
      inputValue
    });
  };
  const clearIndicatorSlotProps = (_slotProps$clearIndic = slotProps.clearIndicator) != null ? _slotProps$clearIndic : componentsProps.clearIndicator;
  const paperSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : componentsProps.paper;
  const popperSlotProps = (_slotProps$popper = slotProps.popper) != null ? _slotProps$popper : componentsProps.popper;
  const popupIndicatorSlotProps = (_slotProps$popupIndic = slotProps.popupIndicator) != null ? _slotProps$popupIndic : componentsProps.popupIndicator;
  return /* @__PURE__ */ jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsx(AutocompleteRoot, _extends$8({
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, getRootProps(other), {
      children: renderInput2({
        id: id2,
        disabled,
        fullWidth: true,
        size: size === "small" ? "small" : void 0,
        InputLabelProps: getInputLabelProps(),
        InputProps: _extends$8({
          ref: setAnchorEl,
          className: classes.inputRoot,
          startAdornment
        }, (hasClearIcon || hasPopupIcon) && {
          endAdornment: /* @__PURE__ */ jsxs(AutocompleteEndAdornment, {
            className: classes.endAdornment,
            ownerState,
            children: [hasClearIcon ? /* @__PURE__ */ jsx(AutocompleteClearIndicator, _extends$8({}, getClearProps(), {
              "aria-label": clearText,
              title: clearText,
              ownerState
            }, clearIndicatorSlotProps, {
              className: clsx(classes.clearIndicator, clearIndicatorSlotProps == null ? void 0 : clearIndicatorSlotProps.className),
              children: clearIcon
            })) : null, hasPopupIcon ? /* @__PURE__ */ jsx(AutocompletePopupIndicator, _extends$8({}, getPopupIndicatorProps(), {
              disabled,
              "aria-label": popupOpen ? closeText : openText,
              title: popupOpen ? closeText : openText,
              ownerState
            }, popupIndicatorSlotProps, {
              className: clsx(classes.popupIndicator, popupIndicatorSlotProps == null ? void 0 : popupIndicatorSlotProps.className),
              children: popupIcon
            })) : null]
          })
        }),
        inputProps: _extends$8({
          className: classes.input,
          disabled,
          readOnly
        }, getInputProps())
      })
    })), anchorEl ? /* @__PURE__ */ jsx(AutocompletePopper, _extends$8({
      as: PopperComponent,
      disablePortal,
      style: {
        width: anchorEl ? anchorEl.clientWidth : null
      },
      ownerState,
      role: "presentation",
      anchorEl,
      open: popupOpen
    }, popperSlotProps, {
      className: clsx(classes.popper, popperSlotProps == null ? void 0 : popperSlotProps.className),
      children: /* @__PURE__ */ jsxs(AutocompletePaper, _extends$8({
        ownerState,
        as: PaperComponent
      }, paperSlotProps, {
        className: clsx(classes.paper, paperSlotProps == null ? void 0 : paperSlotProps.className),
        children: [loading && groupedOptions.length === 0 ? /* @__PURE__ */ jsx(AutocompleteLoading, {
          className: classes.loading,
          ownerState,
          children: loadingText
        }) : null, groupedOptions.length === 0 && !freeSolo && !loading ? /* @__PURE__ */ jsx(AutocompleteNoOptions, {
          className: classes.noOptions,
          ownerState,
          role: "presentation",
          onMouseDown: (event) => {
            event.preventDefault();
          },
          children: noOptionsText
        }) : null, groupedOptions.length > 0 ? /* @__PURE__ */ jsx(AutocompleteListbox, _extends$8({
          as: ListboxComponent,
          className: classes.listbox,
          ownerState
        }, getListboxProps(), ListboxProps, {
          children: groupedOptions.map((option, index2) => {
            if (groupBy) {
              return renderGroup({
                key: option.key,
                group: option.group,
                children: option.options.map((option2, index22) => renderListOption(option2, option.index + index22))
              });
            }
            return renderListOption(option, index2);
          })
        })) : null]
      }))
    })) : null]
  });
});
const Autocomplete$1 = Autocomplete;
const Person = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}), "Person");
function getAvatarUtilityClass(slot) {
  return generateUtilityClass("MuiAvatar", slot);
}
generateUtilityClasses("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const _excluded$14 = ["alt", "children", "className", "component", "imgProps", "sizes", "src", "srcSet", "variant"];
const useUtilityClasses$T = (ownerState) => {
  const {
    classes,
    variant,
    colorDefault
  } = ownerState;
  const slots = {
    root: ["root", variant, colorDefault && "colorDefault"],
    img: ["img"],
    fallback: ["fallback"]
  };
  return composeClasses(slots, getAvatarUtilityClass, classes);
};
const AvatarRoot = styled$2("div", {
  name: "MuiAvatar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.colorDefault && styles2.colorDefault];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  position: "relative",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  flexShrink: 0,
  width: 40,
  height: 40,
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(20),
  lineHeight: 1,
  borderRadius: "50%",
  overflow: "hidden",
  userSelect: "none"
}, ownerState.variant === "rounded" && {
  borderRadius: (theme2.vars || theme2).shape.borderRadius
}, ownerState.variant === "square" && {
  borderRadius: 0
}, ownerState.colorDefault && _extends$8({
  color: (theme2.vars || theme2).palette.background.default
}, theme2.vars ? {
  backgroundColor: theme2.vars.palette.Avatar.defaultBg
} : {
  backgroundColor: theme2.palette.mode === "light" ? theme2.palette.grey[400] : theme2.palette.grey[600]
})));
const AvatarImg = styled$2("img", {
  name: "MuiAvatar",
  slot: "Img",
  overridesResolver: (props, styles2) => styles2.img
})({
  width: "100%",
  height: "100%",
  textAlign: "center",
  // Handle non-square image. The property isn't supported by IE11.
  objectFit: "cover",
  // Hide alt text.
  color: "transparent",
  // Hide the image broken icon, only works on Chrome.
  textIndent: 1e4
});
const AvatarFallback = styled$2(Person, {
  name: "MuiAvatar",
  slot: "Fallback",
  overridesResolver: (props, styles2) => styles2.fallback
})({
  width: "75%",
  height: "75%"
});
function useLoaded({
  crossOrigin,
  referrerPolicy,
  src,
  srcSet
}) {
  const [loaded, setLoaded] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (!src && !srcSet) {
      return void 0;
    }
    setLoaded(false);
    let active = true;
    const image = new Image();
    image.onload = () => {
      if (!active) {
        return;
      }
      setLoaded("loaded");
    };
    image.onerror = () => {
      if (!active) {
        return;
      }
      setLoaded("error");
    };
    image.crossOrigin = crossOrigin;
    image.referrerPolicy = referrerPolicy;
    image.src = src;
    if (srcSet) {
      image.srcset = srcSet;
    }
    return () => {
      active = false;
    };
  }, [crossOrigin, referrerPolicy, src, srcSet]);
  return loaded;
}
const Avatar$1 = /* @__PURE__ */ reactExports.forwardRef(function Avatar(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAvatar"
  });
  const {
    alt,
    children: childrenProp,
    className,
    component = "div",
    imgProps,
    sizes,
    src,
    srcSet,
    variant = "circular"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$14);
  let children = null;
  const loaded = useLoaded(_extends$8({}, imgProps, {
    src,
    srcSet
  }));
  const hasImg = src || srcSet;
  const hasImgNotFailing = hasImg && loaded !== "error";
  const ownerState = _extends$8({}, props, {
    colorDefault: !hasImgNotFailing,
    component,
    variant
  });
  const classes = useUtilityClasses$T(ownerState);
  if (hasImgNotFailing) {
    children = /* @__PURE__ */ jsx(AvatarImg, _extends$8({
      alt,
      src,
      srcSet,
      sizes,
      ownerState,
      className: classes.img
    }, imgProps));
  } else if (childrenProp != null) {
    children = childrenProp;
  } else if (hasImg && alt) {
    children = alt[0];
  } else {
    children = /* @__PURE__ */ jsx(AvatarFallback, {
      className: classes.fallback
    });
  }
  return /* @__PURE__ */ jsx(AvatarRoot, _extends$8({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other, {
    children
  }));
});
const Avatar$2 = Avatar$1;
const _excluded$13 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$2 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
  const theme2 = useTheme();
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$13);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = (callback2) => (maybeIsAppearing) => {
    if (callback2) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback2(node2);
      } else {
        callback2(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("opacity", transitionProps);
    node2.style.transition = theme2.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$8({
        style: _extends$8({
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$2[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
const Fade$1 = Fade;
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$12 = ["children", "component", "components", "componentsProps", "className", "invisible", "open", "slotProps", "slots", "transitionDuration", "TransitionComponent"];
const useUtilityClasses$S = (ownerState) => {
  const {
    classes,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes);
};
const BackdropRoot = styled$2("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})(({
  ownerState
}) => _extends$8({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, ownerState.invisible && {
  backgroundColor: "transparent"
}));
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
  var _slotProps$root, _ref, _slots$root;
  const props = useThemeProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    component = "div",
    components = {},
    componentsProps = {},
    className,
    invisible = false,
    open,
    slotProps = {},
    slots = {},
    transitionDuration,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Fade$1
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$12);
  const ownerState = _extends$8({}, props, {
    component,
    invisible
  });
  const classes = useUtilityClasses$S(ownerState);
  const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
  return /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
    in: open,
    timeout: transitionDuration
  }, other, {
    children: /* @__PURE__ */ jsx(BackdropRoot, _extends$8({
      "aria-hidden": true
    }, rootSlotProps, {
      as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
      className: clsx(classes.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
      ownerState: _extends$8({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
      classes,
      ref,
      children
    }))
  }));
});
const Backdrop$1 = Backdrop;
function getBottomNavigationUtilityClass(slot) {
  return generateUtilityClass("MuiBottomNavigation", slot);
}
generateUtilityClasses("MuiBottomNavigation", ["root"]);
const _excluded$11 = ["children", "className", "component", "onChange", "showLabels", "value"];
const useUtilityClasses$R = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getBottomNavigationUtilityClass, classes);
};
const BottomNavigationRoot = styled$2("div", {
  name: "MuiBottomNavigation",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => ({
  display: "flex",
  justifyContent: "center",
  height: 56,
  backgroundColor: (theme2.vars || theme2).palette.background.paper
}));
const BottomNavigation = /* @__PURE__ */ reactExports.forwardRef(function BottomNavigation2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiBottomNavigation"
  });
  const {
    children,
    className,
    component = "div",
    onChange,
    showLabels = false,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$11);
  const ownerState = _extends$8({}, props, {
    component,
    showLabels
  });
  const classes = useUtilityClasses$R(ownerState);
  return /* @__PURE__ */ jsx(BottomNavigationRoot, _extends$8({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other, {
    children: reactExports.Children.map(children, (child, childIndex) => {
      if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
        return null;
      }
      const childValue = child.props.value === void 0 ? childIndex : child.props.value;
      return /* @__PURE__ */ reactExports.cloneElement(child, {
        selected: childValue === value,
        showLabel: child.props.showLabel !== void 0 ? child.props.showLabel : showLabels,
        value: childValue,
        onChange
      });
    })
  }));
});
const BottomNavigation$1 = BottomNavigation;
function getBottomNavigationActionUtilityClass(slot) {
  return generateUtilityClass("MuiBottomNavigationAction", slot);
}
const bottomNavigationActionClasses = generateUtilityClasses("MuiBottomNavigationAction", ["root", "iconOnly", "selected", "label"]);
const bottomNavigationActionClasses$1 = bottomNavigationActionClasses;
const _excluded$10 = ["className", "icon", "label", "onChange", "onClick", "selected", "showLabel", "value"];
const useUtilityClasses$Q = (ownerState) => {
  const {
    classes,
    showLabel,
    selected
  } = ownerState;
  const slots = {
    root: ["root", !showLabel && !selected && "iconOnly", selected && "selected"],
    label: ["label", !showLabel && !selected && "iconOnly", selected && "selected"]
  };
  return composeClasses(slots, getBottomNavigationActionUtilityClass, classes);
};
const BottomNavigationActionRoot = styled$2(ButtonBase$1, {
  name: "MuiBottomNavigationAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.showLabel && !ownerState.selected && styles2.iconOnly];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  transition: theme2.transitions.create(["color", "padding-top"], {
    duration: theme2.transitions.duration.short
  }),
  padding: "0px 12px",
  minWidth: 80,
  maxWidth: 168,
  color: (theme2.vars || theme2).palette.text.secondary,
  flexDirection: "column",
  flex: "1"
}, !ownerState.showLabel && !ownerState.selected && {
  paddingTop: 14
}, !ownerState.showLabel && !ownerState.selected && !ownerState.label && {
  paddingTop: 0
}, {
  [`&.${bottomNavigationActionClasses$1.selected}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  }
}));
const BottomNavigationActionLabel = styled$2("span", {
  name: "MuiBottomNavigationAction",
  slot: "Label",
  overridesResolver: (props, styles2) => styles2.label
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  fontFamily: theme2.typography.fontFamily,
  fontSize: theme2.typography.pxToRem(12),
  opacity: 1,
  transition: "font-size 0.2s, opacity 0.2s",
  transitionDelay: "0.1s"
}, !ownerState.showLabel && !ownerState.selected && {
  opacity: 0,
  transitionDelay: "0s"
}, {
  [`&.${bottomNavigationActionClasses$1.selected}`]: {
    fontSize: theme2.typography.pxToRem(14)
  }
}));
const BottomNavigationAction = /* @__PURE__ */ reactExports.forwardRef(function BottomNavigationAction2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiBottomNavigationAction"
  });
  const {
    className,
    icon,
    label,
    onChange,
    onClick,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$10);
  const ownerState = props;
  const classes = useUtilityClasses$Q(ownerState);
  const handleChange = (event) => {
    if (onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  return /* @__PURE__ */ jsxs(BottomNavigationActionRoot, _extends$8({
    ref,
    className: clsx(classes.root, className),
    focusRipple: true,
    onClick: handleChange,
    ownerState
  }, other, {
    children: [icon, /* @__PURE__ */ jsx(BottomNavigationActionLabel, {
      className: classes.label,
      ownerState,
      children: label
    })]
  }));
});
const BottomNavigationAction$1 = BottomNavigationAction;
const defaultTheme = createTheme();
const Box = createBox$1({
  defaultTheme,
  defaultClassName: "MuiBox-root",
  generateClassName: ClassNameGenerator$1.generate
});
const Box$1 = Box;
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
const buttonClasses$1 = buttonClasses;
const ButtonGroupContext = /* @__PURE__ */ reactExports.createContext({});
const ButtonGroupContext$1 = ButtonGroupContext;
const _excluded$$ = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
const useUtilityClasses$P = (ownerState) => {
  const {
    color: color2,
    disableElevation,
    fullWidth,
    size,
    variant,
    classes
  } = ownerState;
  const slots = {
    root: ["root", variant, `${variant}${capitalize(color2)}`, `size${capitalize(size)}`, `${variant}Size${capitalize(size)}`, color2 === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
    label: ["label"],
    startIcon: ["startIcon", `iconSize${capitalize(size)}`],
    endIcon: ["endIcon", `iconSize${capitalize(size)}`]
  };
  const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
  return _extends$8({}, classes, composedClasses);
};
const commonIconStyles = (ownerState) => _extends$8({}, ownerState.size === "small" && {
  "& > *:nth-of-type(1)": {
    fontSize: 18
  }
}, ownerState.size === "medium" && {
  "& > *:nth-of-type(1)": {
    fontSize: 20
  }
}, ownerState.size === "large" && {
  "& > *:nth-of-type(1)": {
    fontSize: 22
  }
});
const ButtonRoot = styled$2(ButtonBase$1, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize(ownerState.color)}`], styles2[`size${capitalize(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _theme$palette$getCon, _theme$palette;
  return _extends$8({}, theme2.typography.button, {
    minWidth: 64,
    padding: "6px 16px",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
      duration: theme2.transitions.duration.short
    }),
    "&:hover": _extends$8({
      textDecoration: "none",
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.text.primaryChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette.text.primary, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
      border: `1px solid ${(theme2.vars || theme2).palette[ownerState.color].main}`,
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette[ownerState.color].mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    }, ownerState.variant === "contained" && {
      backgroundColor: (theme2.vars || theme2).palette.grey.A100,
      boxShadow: (theme2.vars || theme2).shadows[4],
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        boxShadow: (theme2.vars || theme2).shadows[2],
        backgroundColor: (theme2.vars || theme2).palette.grey[300]
      }
    }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
      backgroundColor: (theme2.vars || theme2).palette[ownerState.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
      }
    }),
    "&:active": _extends$8({}, ownerState.variant === "contained" && {
      boxShadow: (theme2.vars || theme2).shadows[8]
    }),
    [`&.${buttonClasses$1.focusVisible}`]: _extends$8({}, ownerState.variant === "contained" && {
      boxShadow: (theme2.vars || theme2).shadows[6]
    }),
    [`&.${buttonClasses$1.disabled}`]: _extends$8({
      color: (theme2.vars || theme2).palette.action.disabled
    }, ownerState.variant === "outlined" && {
      border: `1px solid ${(theme2.vars || theme2).palette.action.disabledBackground}`
    }, ownerState.variant === "outlined" && ownerState.color === "secondary" && {
      border: `1px solid ${(theme2.vars || theme2).palette.action.disabled}`
    }, ownerState.variant === "contained" && {
      color: (theme2.vars || theme2).palette.action.disabled,
      boxShadow: (theme2.vars || theme2).shadows[0],
      backgroundColor: (theme2.vars || theme2).palette.action.disabledBackground
    })
  }, ownerState.variant === "text" && {
    padding: "6px 8px"
  }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  }, ownerState.variant === "outlined" && {
    padding: "5px 15px",
    border: "1px solid currentColor"
  }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].main,
    border: theme2.vars ? `1px solid rgba(${theme2.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme2.palette[ownerState.color].main, 0.5)}`
  }, ownerState.variant === "contained" && {
    color: theme2.vars ? (
      // this is safe because grey does not change between default light/dark mode
      theme2.vars.palette.text.primary
    ) : (_theme$palette$getCon = (_theme$palette = theme2.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme2.palette.grey[300]),
    backgroundColor: (theme2.vars || theme2).palette.grey[300],
    boxShadow: (theme2.vars || theme2).shadows[2]
  }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
    color: (theme2.vars || theme2).palette[ownerState.color].contrastText,
    backgroundColor: (theme2.vars || theme2).palette[ownerState.color].main
  }, ownerState.color === "inherit" && {
    color: "inherit",
    borderColor: "currentColor"
  }, ownerState.size === "small" && ownerState.variant === "text" && {
    padding: "4px 5px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "text" && {
    padding: "8px 11px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "outlined" && {
    padding: "3px 9px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "outlined" && {
    padding: "7px 21px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.size === "small" && ownerState.variant === "contained" && {
    padding: "4px 10px",
    fontSize: theme2.typography.pxToRem(13)
  }, ownerState.size === "large" && ownerState.variant === "contained" && {
    padding: "8px 22px",
    fontSize: theme2.typography.pxToRem(15)
  }, ownerState.fullWidth && {
    width: "100%"
  });
}, ({
  ownerState
}) => ownerState.disableElevation && {
  boxShadow: "none",
  "&:hover": {
    boxShadow: "none"
  },
  [`&.${buttonClasses$1.focusVisible}`]: {
    boxShadow: "none"
  },
  "&:active": {
    boxShadow: "none"
  },
  [`&.${buttonClasses$1.disabled}`]: {
    boxShadow: "none"
  }
});
const ButtonStartIcon = styled$2("span", {
  name: "MuiButton",
  slot: "StartIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.startIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$8({
  display: "inherit",
  marginRight: 8,
  marginLeft: -4
}, ownerState.size === "small" && {
  marginLeft: -2
}, commonIconStyles(ownerState)));
const ButtonEndIcon = styled$2("span", {
  name: "MuiButton",
  slot: "EndIcon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.endIcon, styles2[`iconSize${capitalize(ownerState.size)}`]];
  }
})(({
  ownerState
}) => _extends$8({
  display: "inherit",
  marginRight: -4,
  marginLeft: 8
}, ownerState.size === "small" && {
  marginRight: -2
}, commonIconStyles(ownerState)));
const Button$1 = /* @__PURE__ */ reactExports.forwardRef(function Button(inProps, ref) {
  const contextProps = reactExports.useContext(ButtonGroupContext$1);
  const resolvedProps = resolveProps(contextProps, inProps);
  const props = useThemeProps({
    props: resolvedProps,
    name: "MuiButton"
  });
  const {
    children,
    color: color2 = "primary",
    component = "button",
    className,
    disabled = false,
    disableElevation = false,
    disableFocusRipple = false,
    endIcon: endIconProp,
    focusVisibleClassName,
    fullWidth = false,
    size = "medium",
    startIcon: startIconProp,
    type: type2,
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$$);
  const ownerState = _extends$8({}, props, {
    color: color2,
    component,
    disabled,
    disableElevation,
    disableFocusRipple,
    fullWidth,
    size,
    type: type2,
    variant
  });
  const classes = useUtilityClasses$P(ownerState);
  const startIcon = startIconProp && /* @__PURE__ */ jsx(ButtonStartIcon, {
    className: classes.startIcon,
    ownerState,
    children: startIconProp
  });
  const endIcon = endIconProp && /* @__PURE__ */ jsx(ButtonEndIcon, {
    className: classes.endIcon,
    ownerState,
    children: endIconProp
  });
  return /* @__PURE__ */ jsxs(ButtonRoot, _extends$8({
    ownerState,
    className: clsx(contextProps.className, classes.root, className),
    component,
    disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    ref,
    type: type2
  }, other, {
    classes,
    children: [startIcon, children, endIcon]
  }));
});
const Button$2 = Button$1;
function getCardUtilityClass(slot) {
  return generateUtilityClass("MuiCard", slot);
}
generateUtilityClasses("MuiCard", ["root"]);
const _excluded$_ = ["className", "raised"];
const useUtilityClasses$O = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardUtilityClass, classes);
};
const CardRoot = styled$2(Paper$1, {
  name: "MuiCard",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(() => {
  return {
    overflow: "hidden"
  };
});
const Card = /* @__PURE__ */ reactExports.forwardRef(function Card2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCard"
  });
  const {
    className,
    raised = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$_);
  const ownerState = _extends$8({}, props, {
    raised
  });
  const classes = useUtilityClasses$O(ownerState);
  return /* @__PURE__ */ jsx(CardRoot, _extends$8({
    className: clsx(classes.root, className),
    elevation: raised ? 8 : void 0,
    ref,
    ownerState
  }, other));
});
const Card$1 = Card;
function getCardContentUtilityClass(slot) {
  return generateUtilityClass("MuiCardContent", slot);
}
generateUtilityClasses("MuiCardContent", ["root"]);
const _excluded$Z = ["className", "component"];
const useUtilityClasses$N = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getCardContentUtilityClass, classes);
};
const CardContentRoot = styled$2("div", {
  name: "MuiCardContent",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(() => {
  return {
    padding: 16,
    "&:last-child": {
      paddingBottom: 24
    }
  };
});
const CardContent = /* @__PURE__ */ reactExports.forwardRef(function CardContent2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCardContent"
  });
  const {
    className,
    component = "div"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Z);
  const ownerState = _extends$8({}, props, {
    component
  });
  const classes = useUtilityClasses$N(ownerState);
  return /* @__PURE__ */ jsx(CardContentRoot, _extends$8({
    as: component,
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const CardContent$1 = CardContent;
function getCardMediaUtilityClass(slot) {
  return generateUtilityClass("MuiCardMedia", slot);
}
generateUtilityClasses("MuiCardMedia", ["root", "media", "img"]);
const _excluded$Y = ["children", "className", "component", "image", "src", "style"];
const useUtilityClasses$M = (ownerState) => {
  const {
    classes,
    isMediaComponent,
    isImageComponent
  } = ownerState;
  const slots = {
    root: ["root", isMediaComponent && "media", isImageComponent && "img"]
  };
  return composeClasses(slots, getCardMediaUtilityClass, classes);
};
const CardMediaRoot = styled$2("div", {
  name: "MuiCardMedia",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      isMediaComponent,
      isImageComponent
    } = ownerState;
    return [styles2.root, isMediaComponent && styles2.media, isImageComponent && styles2.img];
  }
})(({
  ownerState
}) => _extends$8({
  display: "block",
  backgroundSize: "cover",
  backgroundRepeat: "no-repeat",
  backgroundPosition: "center"
}, ownerState.isMediaComponent && {
  width: "100%"
}, ownerState.isImageComponent && {
  //  object-fit is not supported by IE11.
  objectFit: "cover"
}));
const MEDIA_COMPONENTS = ["video", "audio", "picture", "iframe", "img"];
const IMAGE_COMPONENTS = ["picture", "img"];
const CardMedia = /* @__PURE__ */ reactExports.forwardRef(function CardMedia2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCardMedia"
  });
  const {
    children,
    className,
    component = "div",
    image,
    src,
    style: style2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Y);
  const isMediaComponent = MEDIA_COMPONENTS.indexOf(component) !== -1;
  const composedStyle = !isMediaComponent && image ? _extends$8({
    backgroundImage: `url("${image}")`
  }, style2) : style2;
  const ownerState = _extends$8({}, props, {
    component,
    isMediaComponent,
    isImageComponent: IMAGE_COMPONENTS.indexOf(component) !== -1
  });
  const classes = useUtilityClasses$M(ownerState);
  return /* @__PURE__ */ jsx(CardMediaRoot, _extends$8({
    className: clsx(classes.root, className),
    as: component,
    role: !isMediaComponent && image ? "img" : void 0,
    ref,
    style: composedStyle,
    ownerState,
    src: isMediaComponent ? image || src : void 0
  }, other, {
    children
  }));
});
const CardMedia$1 = CardMedia;
function getSwitchBaseUtilityClass(slot) {
  return generateUtilityClass("PrivateSwitchBase", slot);
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const _excluded$X = ["autoFocus", "checked", "checkedIcon", "className", "defaultChecked", "disabled", "disableFocusRipple", "edge", "icon", "id", "inputProps", "inputRef", "name", "onBlur", "onChange", "onFocus", "readOnly", "required", "tabIndex", "type", "value"];
const useUtilityClasses$L = (ownerState) => {
  const {
    classes,
    checked,
    disabled,
    edge
  } = ownerState;
  const slots = {
    root: ["root", checked && "checked", disabled && "disabled", edge && `edge${capitalize(edge)}`],
    input: ["input"]
  };
  return composeClasses(slots, getSwitchBaseUtilityClass, classes);
};
const SwitchBaseRoot = styled$2(ButtonBase$1)(({
  ownerState
}) => _extends$8({
  padding: 9,
  borderRadius: "50%"
}, ownerState.edge === "start" && {
  marginLeft: ownerState.size === "small" ? -3 : -12
}, ownerState.edge === "end" && {
  marginRight: ownerState.size === "small" ? -3 : -12
}));
const SwitchBaseInput = styled$2("input")({
  cursor: "inherit",
  position: "absolute",
  opacity: 0,
  width: "100%",
  height: "100%",
  top: 0,
  left: 0,
  margin: 0,
  padding: 0,
  zIndex: 1
});
const SwitchBase = /* @__PURE__ */ reactExports.forwardRef(function SwitchBase2(props, ref) {
  const {
    autoFocus,
    checked: checkedProp,
    checkedIcon,
    className,
    defaultChecked,
    disabled: disabledProp,
    disableFocusRipple = false,
    edge = false,
    icon,
    id: id2,
    inputProps,
    inputRef,
    name,
    onBlur,
    onChange,
    onFocus,
    readOnly,
    required,
    tabIndex,
    type: type2,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$X);
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "SwitchBase",
    state: "checked"
  });
  const muiFormControl = useFormControl();
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    }
  };
  const handleInputChange = (event) => {
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    const newChecked = event.target.checked;
    setCheckedState(newChecked);
    if (onChange) {
      onChange(event, newChecked);
    }
  };
  let disabled = disabledProp;
  if (muiFormControl) {
    if (typeof disabled === "undefined") {
      disabled = muiFormControl.disabled;
    }
  }
  const hasLabelFor = type2 === "checkbox" || type2 === "radio";
  const ownerState = _extends$8({}, props, {
    checked,
    disabled,
    disableFocusRipple,
    edge
  });
  const classes = useUtilityClasses$L(ownerState);
  return /* @__PURE__ */ jsxs(SwitchBaseRoot, _extends$8({
    component: "span",
    className: clsx(classes.root, className),
    centerRipple: true,
    focusRipple: !disableFocusRipple,
    disabled,
    tabIndex: null,
    role: void 0,
    onFocus: handleFocus,
    onBlur: handleBlur,
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ jsx(SwitchBaseInput, _extends$8({
      autoFocus,
      checked: checkedProp,
      defaultChecked,
      className: classes.input,
      disabled,
      id: hasLabelFor && id2,
      name,
      onChange: handleInputChange,
      readOnly,
      ref: inputRef,
      required,
      ownerState,
      tabIndex,
      type: type2
    }, type2 === "checkbox" && value === void 0 ? {} : {
      value
    }, inputProps)), checked ? checkedIcon : icon]
  }));
});
const SwitchBase$1 = SwitchBase;
const CheckBoxOutlineBlankIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank");
const CheckBoxIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox");
const IndeterminateCheckBoxIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");
function getCheckboxUtilityClass(slot) {
  return generateUtilityClass("MuiCheckbox", slot);
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary"]);
const checkboxClasses$1 = checkboxClasses;
const _excluded$W = ["checkedIcon", "color", "icon", "indeterminate", "indeterminateIcon", "inputProps", "size", "className"];
const useUtilityClasses$K = (ownerState) => {
  const {
    classes,
    indeterminate,
    color: color2
  } = ownerState;
  const slots = {
    root: ["root", indeterminate && "indeterminate", `color${capitalize(color2)}`]
  };
  const composedClasses = composeClasses(slots, getCheckboxUtilityClass, classes);
  return _extends$8({}, classes, composedClasses);
};
const CheckboxRoot = styled$2(SwitchBase$1, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiCheckbox",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.indeterminate && styles2.indeterminate, ownerState.color !== "default" && styles2[`color${capitalize(ownerState.color)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  color: (theme2.vars || theme2).palette.text.secondary
}, !ownerState.disableRipple && {
  "&:hover": {
    backgroundColor: theme2.vars ? `rgba(${ownerState.color === "default" ? theme2.vars.palette.action.activeChannel : theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.hoverOpacity})` : alpha(ownerState.color === "default" ? theme2.palette.action.active : theme2.palette[ownerState.color].main, theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  }
}, ownerState.color !== "default" && {
  [`&.${checkboxClasses$1.checked}, &.${checkboxClasses$1.indeterminate}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  },
  [`&.${checkboxClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  }
}));
const defaultCheckedIcon = /* @__PURE__ */ jsx(CheckBoxIcon, {});
const defaultIcon = /* @__PURE__ */ jsx(CheckBoxOutlineBlankIcon, {});
const defaultIndeterminateIcon = /* @__PURE__ */ jsx(IndeterminateCheckBoxIcon, {});
const Checkbox = /* @__PURE__ */ reactExports.forwardRef(function Checkbox2(inProps, ref) {
  var _icon$props$fontSize, _indeterminateIcon$pr;
  const props = useThemeProps({
    props: inProps,
    name: "MuiCheckbox"
  });
  const {
    checkedIcon = defaultCheckedIcon,
    color: color2 = "primary",
    icon: iconProp = defaultIcon,
    indeterminate = false,
    indeterminateIcon: indeterminateIconProp = defaultIndeterminateIcon,
    inputProps,
    size = "medium",
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$W);
  const icon = indeterminate ? indeterminateIconProp : iconProp;
  const indeterminateIcon = indeterminate ? indeterminateIconProp : checkedIcon;
  const ownerState = _extends$8({}, props, {
    color: color2,
    indeterminate,
    size
  });
  const classes = useUtilityClasses$K(ownerState);
  return /* @__PURE__ */ jsx(CheckboxRoot, _extends$8({
    type: "checkbox",
    inputProps: _extends$8({
      "data-indeterminate": indeterminate
    }, inputProps),
    icon: /* @__PURE__ */ reactExports.cloneElement(icon, {
      fontSize: (_icon$props$fontSize = icon.props.fontSize) != null ? _icon$props$fontSize : size
    }),
    checkedIcon: /* @__PURE__ */ reactExports.cloneElement(indeterminateIcon, {
      fontSize: (_indeterminateIcon$pr = indeterminateIcon.props.fontSize) != null ? _indeterminateIcon$pr : size
    }),
    ownerState,
    ref,
    className: clsx(classes.root, className)
  }, other, {
    classes
  }));
});
const Checkbox$1 = Checkbox;
const Container = createContainer({
  createStyledComponent: styled$2("div", {
    name: "MuiContainer",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[`maxWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fixed && styles2.fixed, ownerState.disableGutters && styles2.disableGutters];
    }
  }),
  useThemeProps: (inProps) => useThemeProps({
    props: inProps,
    name: "MuiContainer"
  })
});
const Container$1 = Container;
const _excluded$V = ["BackdropComponent", "BackdropProps", "closeAfterTransition", "children", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "slotProps", "slots", "theme"];
const extendUtilityClasses = (ownerState) => {
  return ownerState.classes;
};
const ModalRoot = styled$2("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  position: "fixed",
  zIndex: (theme2.vars || theme2).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: "hidden"
}));
const ModalBackdrop = styled$2(Backdrop$1, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
  const props = useThemeProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    closeAfterTransition = false,
    children,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    slotProps,
    slots,
    // eslint-disable-next-line react/prop-types
    theme: theme2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$V);
  const [exited, setExited] = reactExports.useState(true);
  const commonProps = {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  };
  const ownerState = _extends$8({}, props, commonProps, {
    exited
  });
  const classes = extendUtilityClasses(ownerState);
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
  const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
  return /* @__PURE__ */ jsx(ModalUnstyled$1, _extends$8({
    slots: {
      root: RootSlot,
      backdrop: BackdropSlot
    },
    slotProps: {
      root: () => _extends$8({}, resolveComponentProps(rootSlotProps, ownerState), !isHostComponent(RootSlot) && {
        as: component,
        theme: theme2
      }),
      backdrop: () => _extends$8({}, BackdropProps, resolveComponentProps(backdropSlotProps, ownerState))
    },
    onTransitionEnter: () => setExited(false),
    onTransitionExited: () => setExited(true),
    ref
  }, other, {
    classes
  }, commonProps, {
    children
  }));
});
const Modal$1 = Modal;
function getDialogUtilityClass(slot) {
  return generateUtilityClass("MuiDialog", slot);
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const dialogClasses$1 = dialogClasses;
const DialogContext = /* @__PURE__ */ reactExports.createContext({});
const DialogContext$1 = DialogContext;
const _excluded$U = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
const DialogBackdrop = styled$2(Backdrop$1, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles2) => styles2.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$J = (ownerState) => {
  const {
    classes,
    scroll: scroll3,
    maxWidth: maxWidth2,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize(scroll3)}`],
    paper: ["paper", `paperScroll${capitalize(scroll3)}`, `paperWidth${capitalize(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled$2(Modal$1, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled$2("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.container, styles2[`scroll${capitalize(ownerState.scroll)}`]];
  }
})(({
  ownerState
}) => _extends$8({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, ownerState.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, ownerState.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&:after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
}));
const DialogPaper = styled$2(Paper$1, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`scrollPaper${capitalize(ownerState.scroll)}`], styles2[`paperWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, ownerState.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, ownerState.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !ownerState.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, ownerState.maxWidth === "xs" && {
  maxWidth: theme2.breakpoints.unit === "px" ? Math.max(theme2.breakpoints.values.xs, 444) : `${theme2.breakpoints.values.xs}${theme2.breakpoints.unit}`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme2.breakpoints.down(Math.max(theme2.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
  maxWidth: `${theme2.breakpoints.values[ownerState.maxWidth]}${theme2.breakpoints.unit}`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme2.breakpoints.down(theme2.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.fullWidth && {
  width: "calc(100% - 64px)"
}, ownerState.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
}));
const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialog"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth: maxWidth2 = "sm",
    onBackdropClick,
    onClose,
    open,
    PaperComponent = Paper$1,
    PaperProps = {},
    scroll: scroll3 = "paper",
    TransitionComponent = Fade$1,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$U);
  const ownerState = _extends$8({}, props, {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth: maxWidth2,
    scroll: scroll3
  });
  const classes = useUtilityClasses$J(ownerState);
  const backdropClick = reactExports.useRef();
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = (event) => {
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = reactExports.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  return /* @__PURE__ */ jsx(DialogRoot, _extends$8({
    className: clsx(classes.root, className),
    closeAfterTransition: true,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: _extends$8({
        transitionDuration,
        as: BackdropComponent
      }, BackdropProps)
    },
    disableEscapeKeyDown,
    onClose,
    open,
    ref,
    onClick: handleBackdropClick,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
      appear: true,
      in: open,
      timeout: transitionDuration,
      role: "presentation"
    }, TransitionProps, {
      children: /* @__PURE__ */ jsx(DialogContainer, {
        className: clsx(classes.container),
        onMouseDown: handleMouseDown,
        ownerState,
        children: /* @__PURE__ */ jsx(DialogPaper, _extends$8({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby
        }, PaperProps, {
          className: clsx(classes.paper, PaperProps.className),
          ownerState,
          children: /* @__PURE__ */ jsx(DialogContext$1.Provider, {
            value: dialogContextValue,
            children
          })
        }))
      })
    }))
  }));
});
const Dialog$1 = Dialog;
function getDialogActionsUtilityClass(slot) {
  return generateUtilityClass("MuiDialogActions", slot);
}
generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
const _excluded$T = ["className", "disableSpacing"];
const useUtilityClasses$I = (ownerState) => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses(slots, getDialogActionsUtilityClass, classes);
};
const DialogActionsRoot = styled$2("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
  }
})(({
  ownerState
}) => _extends$8({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto"
}, !ownerState.disableSpacing && {
  "& > :not(:first-of-type)": {
    marginLeft: 8
  }
}));
const DialogActions = /* @__PURE__ */ reactExports.forwardRef(function DialogActions2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialogActions"
  });
  const {
    className,
    disableSpacing = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$T);
  const ownerState = _extends$8({}, props, {
    disableSpacing
  });
  const classes = useUtilityClasses$I(ownerState);
  return /* @__PURE__ */ jsx(DialogActionsRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const DialogActions$1 = DialogActions;
function getDialogContentUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContent", slot);
}
generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
function getDialogTitleUtilityClass(slot) {
  return generateUtilityClass("MuiDialogTitle", slot);
}
const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
const dialogTitleClasses$1 = dialogTitleClasses;
const _excluded$S = ["className", "dividers"];
const useUtilityClasses$H = (ownerState) => {
  const {
    classes,
    dividers
  } = ownerState;
  const slots = {
    root: ["root", dividers && "dividers"]
  };
  return composeClasses(slots, getDialogContentUtilityClass, classes);
};
const DialogContentRoot = styled$2("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.dividers && styles2.dividers];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px"
}, ownerState.dividers ? {
  padding: "16px 24px",
  borderTop: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`
} : {
  [`.${dialogTitleClasses$1.root} + &`]: {
    paddingTop: 0
  }
}));
const DialogContent = /* @__PURE__ */ reactExports.forwardRef(function DialogContent2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialogContent"
  });
  const {
    className,
    dividers = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$S);
  const ownerState = _extends$8({}, props, {
    dividers
  });
  const classes = useUtilityClasses$H(ownerState);
  return /* @__PURE__ */ jsx(DialogContentRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const DialogContent$1 = DialogContent;
const _excluded$R = ["className", "id"];
const useUtilityClasses$G = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getDialogTitleUtilityClass, classes);
};
const DialogTitleRoot = styled$2(Typography$1, {
  name: "MuiDialogTitle",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  padding: "16px 24px",
  flex: "0 0 auto"
});
const DialogTitle = /* @__PURE__ */ reactExports.forwardRef(function DialogTitle2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDialogTitle"
  });
  const {
    className,
    id: idProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$R);
  const ownerState = props;
  const classes = useUtilityClasses$G(ownerState);
  const {
    titleId: id2 = idProp
  } = reactExports.useContext(DialogContext$1);
  return /* @__PURE__ */ jsx(DialogTitleRoot, _extends$8({
    component: "h2",
    className: clsx(classes.root, className),
    ownerState,
    ref,
    variant: "h6",
    id: id2
  }, other));
});
const DialogTitle$1 = DialogTitle;
function getDividerUtilityClass(slot) {
  return generateUtilityClass("MuiDivider", slot);
}
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const dividerClasses$1 = dividerClasses;
const _excluded$Q = ["absolute", "children", "className", "component", "flexItem", "light", "orientation", "role", "textAlign", "variant"];
const useUtilityClasses$F = (ownerState) => {
  const {
    absolute,
    children,
    classes,
    flexItem,
    light: light2,
    orientation,
    textAlign: textAlign2,
    variant
  } = ownerState;
  const slots = {
    root: ["root", absolute && "absolute", variant, light2 && "light", orientation === "vertical" && "vertical", flexItem && "flexItem", children && "withChildren", children && orientation === "vertical" && "withChildrenVertical", textAlign2 === "right" && orientation !== "vertical" && "textAlignRight", textAlign2 === "left" && orientation !== "vertical" && "textAlignLeft"],
    wrapper: ["wrapper", orientation === "vertical" && "wrapperVertical"]
  };
  return composeClasses(slots, getDividerUtilityClass, classes);
};
const DividerRoot = styled$2("div", {
  name: "MuiDivider",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.absolute && styles2.absolute, styles2[ownerState.variant], ownerState.light && styles2.light, ownerState.orientation === "vertical" && styles2.vertical, ownerState.flexItem && styles2.flexItem, ownerState.children && styles2.withChildren, ownerState.children && ownerState.orientation === "vertical" && styles2.withChildrenVertical, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && styles2.textAlignRight, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && styles2.textAlignLeft];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  margin: 0,
  // Reset browser default style.
  flexShrink: 0,
  borderWidth: 0,
  borderStyle: "solid",
  borderColor: (theme2.vars || theme2).palette.divider,
  borderBottomWidth: "thin"
}, ownerState.absolute && {
  position: "absolute",
  bottom: 0,
  left: 0,
  width: "100%"
}, ownerState.light && {
  borderColor: theme2.vars ? `rgba(${theme2.vars.palette.dividerChannel} / 0.08)` : alpha(theme2.palette.divider, 0.08)
}, ownerState.variant === "inset" && {
  marginLeft: 72
}, ownerState.variant === "middle" && ownerState.orientation === "horizontal" && {
  marginLeft: theme2.spacing(2),
  marginRight: theme2.spacing(2)
}, ownerState.variant === "middle" && ownerState.orientation === "vertical" && {
  marginTop: theme2.spacing(1),
  marginBottom: theme2.spacing(1)
}, ownerState.orientation === "vertical" && {
  height: "100%",
  borderBottomWidth: 0,
  borderRightWidth: "thin"
}, ownerState.flexItem && {
  alignSelf: "stretch",
  height: "auto"
}), ({
  theme: theme2,
  ownerState
}) => _extends$8({}, ownerState.children && {
  display: "flex",
  whiteSpace: "nowrap",
  textAlign: "center",
  border: 0,
  "&::before, &::after": {
    position: "relative",
    width: "100%",
    borderTop: `thin solid ${(theme2.vars || theme2).palette.divider}`,
    top: "50%",
    content: '""',
    transform: "translateY(50%)"
  }
}), ({
  theme: theme2,
  ownerState
}) => _extends$8({}, ownerState.children && ownerState.orientation === "vertical" && {
  flexDirection: "column",
  "&::before, &::after": {
    height: "100%",
    top: "0%",
    left: "50%",
    borderTop: 0,
    borderLeft: `thin solid ${(theme2.vars || theme2).palette.divider}`,
    transform: "translateX(0%)"
  }
}), ({
  ownerState
}) => _extends$8({}, ownerState.textAlign === "right" && ownerState.orientation !== "vertical" && {
  "&::before": {
    width: "90%"
  },
  "&::after": {
    width: "10%"
  }
}, ownerState.textAlign === "left" && ownerState.orientation !== "vertical" && {
  "&::before": {
    width: "10%"
  },
  "&::after": {
    width: "90%"
  }
}));
const DividerWrapper = styled$2("span", {
  name: "MuiDivider",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.wrapper, ownerState.orientation === "vertical" && styles2.wrapperVertical];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  display: "inline-block",
  paddingLeft: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingRight: `calc(${theme2.spacing(1)} * 1.2)`
}, ownerState.orientation === "vertical" && {
  paddingTop: `calc(${theme2.spacing(1)} * 1.2)`,
  paddingBottom: `calc(${theme2.spacing(1)} * 1.2)`
}));
const Divider = /* @__PURE__ */ reactExports.forwardRef(function Divider2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDivider"
  });
  const {
    absolute = false,
    children,
    className,
    component = children ? "div" : "hr",
    flexItem = false,
    light: light2 = false,
    orientation = "horizontal",
    role = component !== "hr" ? "separator" : void 0,
    textAlign: textAlign2 = "center",
    variant = "fullWidth"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$Q);
  const ownerState = _extends$8({}, props, {
    absolute,
    component,
    flexItem,
    light: light2,
    orientation,
    role,
    textAlign: textAlign2,
    variant
  });
  const classes = useUtilityClasses$F(ownerState);
  return /* @__PURE__ */ jsx(DividerRoot, _extends$8({
    as: component,
    className: clsx(classes.root, className),
    role,
    ref,
    ownerState
  }, other, {
    children: children ? /* @__PURE__ */ jsx(DividerWrapper, {
      className: classes.wrapper,
      ownerState,
      children
    }) : null
  }));
});
const Divider$1 = Divider;
const _excluded$P = ["addEndListener", "appear", "children", "container", "direction", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getTranslateValue(direction, node2, resolvedContainer) {
  const rect = node2.getBoundingClientRect();
  const containerRect = resolvedContainer && resolvedContainer.getBoundingClientRect();
  const containerWindow = ownerWindow(node2);
  let transform3;
  if (node2.fakeTransform) {
    transform3 = node2.fakeTransform;
  } else {
    const computedStyle2 = containerWindow.getComputedStyle(node2);
    transform3 = computedStyle2.getPropertyValue("-webkit-transform") || computedStyle2.getPropertyValue("transform");
  }
  let offsetX = 0;
  let offsetY = 0;
  if (transform3 && transform3 !== "none" && typeof transform3 === "string") {
    const transformValues = transform3.split("(")[1].split(")")[0].split(",");
    offsetX = parseInt(transformValues[4], 10);
    offsetY = parseInt(transformValues[5], 10);
  }
  if (direction === "left") {
    if (containerRect) {
      return `translateX(${containerRect.right + offsetX - rect.left}px)`;
    }
    return `translateX(${containerWindow.innerWidth + offsetX - rect.left}px)`;
  }
  if (direction === "right") {
    if (containerRect) {
      return `translateX(-${rect.right - containerRect.left - offsetX}px)`;
    }
    return `translateX(-${rect.left + rect.width - offsetX}px)`;
  }
  if (direction === "up") {
    if (containerRect) {
      return `translateY(${containerRect.bottom + offsetY - rect.top}px)`;
    }
    return `translateY(${containerWindow.innerHeight + offsetY - rect.top}px)`;
  }
  if (containerRect) {
    return `translateY(-${rect.top - containerRect.top + rect.height - offsetY}px)`;
  }
  return `translateY(-${rect.top + rect.height - offsetY}px)`;
}
function resolveContainer(containerPropProp) {
  return typeof containerPropProp === "function" ? containerPropProp() : containerPropProp;
}
function setTranslateValue(direction, node2, containerProp) {
  const resolvedContainer = resolveContainer(containerProp);
  const transform3 = getTranslateValue(direction, node2, resolvedContainer);
  if (transform3) {
    node2.style.webkitTransform = transform3;
    node2.style.transform = transform3;
  }
}
const Slide = /* @__PURE__ */ reactExports.forwardRef(function Slide2(props, ref) {
  const theme2 = useTheme();
  const defaultEasing = {
    enter: theme2.transitions.easing.easeOut,
    exit: theme2.transitions.easing.sharp
  };
  const defaultTimeout = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    container: containerProp,
    direction = "down",
    easing: easingProp = defaultEasing,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$P);
  const childrenRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, childrenRef, ref);
  const normalizedTransitionCallback = (callback2) => (isAppearing) => {
    if (callback2) {
      if (isAppearing === void 0) {
        callback2(childrenRef.current);
      } else {
        callback2(childrenRef.current, isAppearing);
      }
    }
  };
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    setTranslateValue(direction, node2, containerProp);
    reflow(node2);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
    const transitionProps = getTransitionProps({
      timeout,
      style: style2,
      easing: easingProp
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme2.transitions.create("-webkit-transform", _extends$8({}, transitionProps));
    node2.style.transition = theme2.transitions.create("transform", _extends$8({}, transitionProps));
    node2.style.webkitTransform = "none";
    node2.style.transform = "none";
    if (onEntering) {
      onEntering(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      timeout,
      style: style2,
      easing: easingProp
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme2.transitions.create("-webkit-transform", transitionProps);
    node2.style.transition = theme2.transitions.create("transform", transitionProps);
    setTranslateValue(direction, node2, containerProp);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback((node2) => {
    node2.style.webkitTransition = "";
    node2.style.transition = "";
    if (onExited) {
      onExited(node2);
    }
  });
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(childrenRef.current, next2);
    }
  };
  const updatePosition = reactExports.useCallback(() => {
    if (childrenRef.current) {
      setTranslateValue(direction, childrenRef.current, containerProp);
    }
  }, [direction, containerProp]);
  reactExports.useEffect(() => {
    if (inProp || direction === "down" || direction === "right") {
      return void 0;
    }
    const handleResize = debounce$2(() => {
      if (childrenRef.current) {
        setTranslateValue(direction, childrenRef.current, containerProp);
      }
    });
    const containerWindow = ownerWindow(childrenRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [direction, inProp, containerProp]);
  reactExports.useEffect(() => {
    if (!inProp) {
      updatePosition();
    }
  }, [inProp, updatePosition]);
  return /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
    nodeRef: childrenRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    appear,
    in: inProp,
    timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$8({
        ref: handleRef,
        style: _extends$8({
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, style2, children.props.style)
      }, childProps));
    }
  }));
});
const Slide$1 = Slide;
function getDrawerUtilityClass(slot) {
  return generateUtilityClass("MuiDrawer", slot);
}
generateUtilityClasses("MuiDrawer", ["root", "docked", "paper", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const _excluded$O = ["BackdropProps"], _excluded2$5 = ["anchor", "BackdropProps", "children", "className", "elevation", "hideBackdrop", "ModalProps", "onClose", "open", "PaperProps", "SlideProps", "TransitionComponent", "transitionDuration", "variant"];
const overridesResolver$3 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, (ownerState.variant === "permanent" || ownerState.variant === "persistent") && styles2.docked, styles2.modal];
};
const useUtilityClasses$E = (ownerState) => {
  const {
    classes,
    anchor,
    variant
  } = ownerState;
  const slots = {
    root: ["root"],
    docked: [(variant === "permanent" || variant === "persistent") && "docked"],
    modal: ["modal"],
    paper: ["paper", `paperAnchor${capitalize(anchor)}`, variant !== "temporary" && `paperAnchorDocked${capitalize(anchor)}`]
  };
  return composeClasses(slots, getDrawerUtilityClass, classes);
};
const DrawerRoot = styled$2(Modal$1, {
  name: "MuiDrawer",
  slot: "Root",
  overridesResolver: overridesResolver$3
})(({
  theme: theme2
}) => ({
  zIndex: (theme2.vars || theme2).zIndex.drawer
}));
const DrawerDockedRoot = styled$2("div", {
  shouldForwardProp: rootShouldForwardProp,
  name: "MuiDrawer",
  slot: "Docked",
  skipVariantsResolver: false,
  overridesResolver: overridesResolver$3
})({
  flex: "0 0 auto"
});
const DrawerPaper = styled$2(Paper$1, {
  name: "MuiDrawer",
  slot: "Paper",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.paper, styles2[`paperAnchor${capitalize(ownerState.anchor)}`], ownerState.variant !== "temporary" && styles2[`paperAnchorDocked${capitalize(ownerState.anchor)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  overflowY: "auto",
  display: "flex",
  flexDirection: "column",
  height: "100%",
  flex: "1 0 auto",
  zIndex: (theme2.vars || theme2).zIndex.drawer,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  // temporary style
  position: "fixed",
  top: 0,
  // We disable the focus ring for mouse, touch and keyboard users.
  // At some point, it would be better to keep it for keyboard users.
  // :focus-ring CSS pseudo-class will help.
  outline: 0
}, ownerState.anchor === "left" && {
  left: 0
}, ownerState.anchor === "top" && {
  top: 0,
  left: 0,
  right: 0,
  height: "auto",
  maxHeight: "100%"
}, ownerState.anchor === "right" && {
  right: 0
}, ownerState.anchor === "bottom" && {
  top: "auto",
  left: 0,
  bottom: 0,
  right: 0,
  height: "auto",
  maxHeight: "100%"
}, ownerState.anchor === "left" && ownerState.variant !== "temporary" && {
  borderRight: `1px solid ${(theme2.vars || theme2).palette.divider}`
}, ownerState.anchor === "top" && ownerState.variant !== "temporary" && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`
}, ownerState.anchor === "right" && ownerState.variant !== "temporary" && {
  borderLeft: `1px solid ${(theme2.vars || theme2).palette.divider}`
}, ownerState.anchor === "bottom" && ownerState.variant !== "temporary" && {
  borderTop: `1px solid ${(theme2.vars || theme2).palette.divider}`
}));
const oppositeDirection = {
  left: "right",
  right: "left",
  top: "down",
  bottom: "up"
};
function isHorizontal(anchor) {
  return ["left", "right"].indexOf(anchor) !== -1;
}
function getAnchor(theme2, anchor) {
  return theme2.direction === "rtl" && isHorizontal(anchor) ? oppositeDirection[anchor] : anchor;
}
const Drawer = /* @__PURE__ */ reactExports.forwardRef(function Drawer2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiDrawer"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    anchor: anchorProp = "left",
    BackdropProps,
    children,
    className,
    elevation = 16,
    hideBackdrop = false,
    ModalProps: {
      BackdropProps: BackdropPropsProp
    } = {},
    onClose,
    open = false,
    PaperProps = {},
    SlideProps,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Slide$1,
    transitionDuration = defaultTransitionDuration,
    variant = "temporary"
  } = props, ModalProps = _objectWithoutPropertiesLoose(props.ModalProps, _excluded$O), other = _objectWithoutPropertiesLoose(props, _excluded2$5);
  const mounted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    mounted.current = true;
  }, []);
  const anchorInvariant = getAnchor(theme2, anchorProp);
  const anchor = anchorProp;
  const ownerState = _extends$8({}, props, {
    anchor,
    elevation,
    open,
    variant
  }, other);
  const classes = useUtilityClasses$E(ownerState);
  const drawer = /* @__PURE__ */ jsx(DrawerPaper, _extends$8({
    elevation: variant === "temporary" ? elevation : 0,
    square: true
  }, PaperProps, {
    className: clsx(classes.paper, PaperProps.className),
    ownerState,
    children
  }));
  if (variant === "permanent") {
    return /* @__PURE__ */ jsx(DrawerDockedRoot, _extends$8({
      className: clsx(classes.root, classes.docked, className),
      ownerState,
      ref
    }, other, {
      children: drawer
    }));
  }
  const slidingDrawer = /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
    in: open,
    direction: oppositeDirection[anchorInvariant],
    timeout: transitionDuration,
    appear: mounted.current
  }, SlideProps, {
    children: drawer
  }));
  if (variant === "persistent") {
    return /* @__PURE__ */ jsx(DrawerDockedRoot, _extends$8({
      className: clsx(classes.root, classes.docked, className),
      ownerState,
      ref
    }, other, {
      children: slidingDrawer
    }));
  }
  return /* @__PURE__ */ jsx(DrawerRoot, _extends$8({
    BackdropProps: _extends$8({}, BackdropProps, BackdropPropsProp, {
      transitionDuration
    }),
    className: clsx(classes.root, classes.modal, className),
    open,
    ownerState,
    onClose,
    hideBackdrop,
    ref
  }, other, ModalProps, {
    children: slidingDrawer
  }));
});
const Drawer$1 = Drawer;
const _excluded$N = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$D = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes);
  return _extends$8({}, classes, composedClasses);
};
const FilledInputRoot = styled$2(InputBaseRoot, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  var _palette;
  const light2 = theme2.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return _extends$8({
    position: "relative",
    backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme2.vars || theme2).shape.borderRadius,
    borderTopRightRadius: (theme2.vars || theme2).shape.borderRadius,
    transition: theme2.transitions.create("background-color", {
      duration: theme2.transitions.duration.shorter,
      easing: theme2.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses$1.focused}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses$1.disabled}`]: {
      backgroundColor: theme2.vars ? theme2.vars.palette.FilledInput.disabledBg : disabledBackground
    }
  }, !ownerState.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(_palette = (theme2.vars || theme2).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme2.transitions.create("transform", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${filledInputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${filledInputClasses$1.error}:after`]: {
      borderBottomColor: (theme2.vars || theme2).palette.error.main,
      transform: "scaleX(1)"
      // error is always underlined in red
    },
    "&:before": {
      borderBottom: `1px solid ${theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})` : bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme2.transitions.create("border-bottom-color", {
        duration: theme2.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${filledInputClasses$1.disabled}):before`]: {
      borderBottom: `1px solid ${(theme2.vars || theme2).palette.text.primary}`
    },
    [`&.${filledInputClasses$1.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, ownerState.startAdornment && {
    paddingLeft: 12
  }, ownerState.endAdornment && {
    paddingRight: 12
  }, ownerState.multiline && _extends$8({
    padding: "25px 12px 8px"
  }, ownerState.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
});
const FilledInputInput = styled$2(InputBaseComponent, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, theme2.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, ownerState.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, ownerState.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}, ownerState.hiddenLabel && ownerState.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
}));
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const {
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    // declare here to prevent spreading to DOM
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type: type2 = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$N);
  const ownerState = _extends$8({}, props, {
    fullWidth,
    inputComponent,
    multiline,
    type: type2
  });
  const classes = useUtilityClasses$D(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
  return /* @__PURE__ */ jsx(InputBase$1, _extends$8({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type: type2
  }, other, {
    classes
  }));
});
FilledInput.muiName = "Input";
const FilledInput$1 = FilledInput;
function getFormControlUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControl", slot);
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const _excluded$M = ["children", "className", "color", "component", "disabled", "error", "focused", "fullWidth", "hiddenLabel", "margin", "required", "size", "variant"];
const useUtilityClasses$C = (ownerState) => {
  const {
    classes,
    margin,
    fullWidth
  } = ownerState;
  const slots = {
    root: ["root", margin !== "none" && `margin${capitalize(margin)}`, fullWidth && "fullWidth"]
  };
  return composeClasses(slots, getFormControlUtilityClasses, classes);
};
const FormControlRoot = styled$2("div", {
  name: "MuiFormControl",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return _extends$8({}, styles2.root, styles2[`margin${capitalize(ownerState.margin)}`], ownerState.fullWidth && styles2.fullWidth);
  }
})(({
  ownerState
}) => _extends$8({
  display: "inline-flex",
  flexDirection: "column",
  position: "relative",
  // Reset fieldset default style.
  minWidth: 0,
  padding: 0,
  margin: 0,
  border: 0,
  verticalAlign: "top"
}, ownerState.margin === "normal" && {
  marginTop: 16,
  marginBottom: 8
}, ownerState.margin === "dense" && {
  marginTop: 8,
  marginBottom: 4
}, ownerState.fullWidth && {
  width: "100%"
}));
const FormControl = /* @__PURE__ */ reactExports.forwardRef(function FormControl2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormControl"
  });
  const {
    children,
    className,
    color: color2 = "primary",
    component = "div",
    disabled = false,
    error = false,
    focused: visuallyFocused,
    fullWidth = false,
    hiddenLabel = false,
    margin = "none",
    required = false,
    size = "medium",
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$M);
  const ownerState = _extends$8({}, props, {
    color: color2,
    component,
    disabled,
    error,
    fullWidth,
    hiddenLabel,
    margin,
    required,
    size,
    variant
  });
  const classes = useUtilityClasses$C(ownerState);
  const [adornedStart, setAdornedStart] = reactExports.useState(() => {
    let initialAdornedStart = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        const input = isMuiElement(child, ["Select"]) ? child.props.input : child;
        if (input && isAdornedStart(input.props)) {
          initialAdornedStart = true;
        }
      });
    }
    return initialAdornedStart;
  });
  const [filled, setFilled] = reactExports.useState(() => {
    let initialFilled = false;
    if (children) {
      reactExports.Children.forEach(children, (child) => {
        if (!isMuiElement(child, ["Input", "Select"])) {
          return;
        }
        if (isFilled(child.props, true)) {
          initialFilled = true;
        }
      });
    }
    return initialFilled;
  });
  const [focusedState, setFocused] = reactExports.useState(false);
  if (disabled && focusedState) {
    setFocused(false);
  }
  const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
  let registerEffect;
  const childContext = reactExports.useMemo(() => {
    return {
      adornedStart,
      setAdornedStart,
      color: color2,
      disabled,
      error,
      filled,
      focused,
      fullWidth,
      hiddenLabel,
      size,
      onBlur: () => {
        setFocused(false);
      },
      onEmpty: () => {
        setFilled(false);
      },
      onFilled: () => {
        setFilled(true);
      },
      onFocus: () => {
        setFocused(true);
      },
      registerEffect,
      required,
      variant
    };
  }, [adornedStart, color2, disabled, error, filled, focused, fullWidth, hiddenLabel, registerEffect, required, size, variant]);
  return /* @__PURE__ */ jsx(FormControlContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsx(FormControlRoot, _extends$8({
      as: component,
      ownerState,
      className: clsx(classes.root, className),
      ref
    }, other, {
      children
    }))
  });
});
const FormControl$1 = FormControl;
function getFormControlLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControlLabel", slot);
}
const formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error"]);
const formControlLabelClasses$1 = formControlLabelClasses;
const _excluded$L = ["checked", "className", "componentsProps", "control", "disabled", "disableTypography", "inputRef", "label", "labelPlacement", "name", "onChange", "slotProps", "value"];
const useUtilityClasses$B = (ownerState) => {
  const {
    classes,
    disabled,
    labelPlacement,
    error
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", `labelPlacement${capitalize(labelPlacement)}`, error && "error"],
    label: ["label", disabled && "disabled"]
  };
  return composeClasses(slots, getFormControlLabelUtilityClasses, classes);
};
const FormControlLabelRoot = styled$2("label", {
  name: "MuiFormControlLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formControlLabelClasses$1.label}`]: styles2.label
    }, styles2.root, styles2[`labelPlacement${capitalize(ownerState.labelPlacement)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  display: "inline-flex",
  alignItems: "center",
  cursor: "pointer",
  // For correct alignment with the text.
  verticalAlign: "middle",
  WebkitTapHighlightColor: "transparent",
  marginLeft: -11,
  marginRight: 16,
  // used for row presentation of radio/checkbox
  [`&.${formControlLabelClasses$1.disabled}`]: {
    cursor: "default"
  }
}, ownerState.labelPlacement === "start" && {
  flexDirection: "row-reverse",
  marginLeft: 16,
  // used for row presentation of radio/checkbox
  marginRight: -11
}, ownerState.labelPlacement === "top" && {
  flexDirection: "column-reverse",
  marginLeft: 16
}, ownerState.labelPlacement === "bottom" && {
  flexDirection: "column",
  marginLeft: 16
}, {
  [`& .${formControlLabelClasses$1.label}`]: {
    [`&.${formControlLabelClasses$1.disabled}`]: {
      color: (theme2.vars || theme2).palette.text.disabled
    }
  }
}));
const FormControlLabel = /* @__PURE__ */ reactExports.forwardRef(function FormControlLabel2(inProps, ref) {
  var _slotProps$typography;
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormControlLabel"
  });
  const {
    className,
    componentsProps = {},
    control,
    disabled: disabledProp,
    disableTypography,
    label: labelProp,
    labelPlacement = "end",
    slotProps = {}
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$L);
  const muiFormControl = useFormControl();
  let disabled = disabledProp;
  if (typeof disabled === "undefined" && typeof control.props.disabled !== "undefined") {
    disabled = control.props.disabled;
  }
  if (typeof disabled === "undefined" && muiFormControl) {
    disabled = muiFormControl.disabled;
  }
  const controlProps = {
    disabled
  };
  ["checked", "name", "onChange", "value", "inputRef"].forEach((key) => {
    if (typeof control.props[key] === "undefined" && typeof props[key] !== "undefined") {
      controlProps[key] = props[key];
    }
  });
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  });
  const ownerState = _extends$8({}, props, {
    disabled,
    labelPlacement,
    error: fcs.error
  });
  const classes = useUtilityClasses$B(ownerState);
  const typographySlotProps = (_slotProps$typography = slotProps.typography) != null ? _slotProps$typography : componentsProps.typography;
  let label = labelProp;
  if (label != null && label.type !== Typography$1 && !disableTypography) {
    label = /* @__PURE__ */ jsx(Typography$1, _extends$8({
      component: "span"
    }, typographySlotProps, {
      className: clsx(classes.label, typographySlotProps == null ? void 0 : typographySlotProps.className),
      children: label
    }));
  }
  return /* @__PURE__ */ jsxs(FormControlLabelRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ reactExports.cloneElement(control, controlProps), label]
  }));
});
const FormControlLabel$1 = FormControlLabel;
function getFormGroupUtilityClass(slot) {
  return generateUtilityClass("MuiFormGroup", slot);
}
generateUtilityClasses("MuiFormGroup", ["root", "row", "error"]);
const _excluded$K = ["className", "row"];
const useUtilityClasses$A = (ownerState) => {
  const {
    classes,
    row,
    error
  } = ownerState;
  const slots = {
    root: ["root", row && "row", error && "error"]
  };
  return composeClasses(slots, getFormGroupUtilityClass, classes);
};
const FormGroupRoot = styled$2("div", {
  name: "MuiFormGroup",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.row && styles2.row];
  }
})(({
  ownerState
}) => _extends$8({
  display: "flex",
  flexDirection: "column",
  flexWrap: "wrap"
}, ownerState.row && {
  flexDirection: "row"
}));
const FormGroup = /* @__PURE__ */ reactExports.forwardRef(function FormGroup2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormGroup"
  });
  const {
    className,
    row = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$K);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["error"]
  });
  const ownerState = _extends$8({}, props, {
    row,
    error: fcs.error
  });
  const classes = useUtilityClasses$A(ownerState);
  return /* @__PURE__ */ jsx(FormGroupRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const FormGroup$1 = FormGroup;
function getFormHelperTextUtilityClasses(slot) {
  return generateUtilityClass("MuiFormHelperText", slot);
}
const formHelperTextClasses = generateUtilityClasses("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
const formHelperTextClasses$1 = formHelperTextClasses;
var _span$2;
const _excluded$J = ["children", "className", "component", "disabled", "error", "filled", "focused", "margin", "required", "variant"];
const useUtilityClasses$z = (ownerState) => {
  const {
    classes,
    contained,
    size,
    disabled,
    error,
    filled,
    focused,
    required
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", error && "error", size && `size${capitalize(size)}`, contained && "contained", focused && "focused", filled && "filled", required && "required"]
  };
  return composeClasses(slots, getFormHelperTextUtilityClasses, classes);
};
const FormHelperTextRoot = styled$2("p", {
  name: "MuiFormHelperText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.size && styles2[`size${capitalize(ownerState.size)}`], ownerState.contained && styles2.contained, ownerState.filled && styles2.filled];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.caption, {
  textAlign: "left",
  marginTop: 3,
  marginRight: 0,
  marginBottom: 0,
  marginLeft: 0,
  [`&.${formHelperTextClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formHelperTextClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}, ownerState.size === "small" && {
  marginTop: 4
}, ownerState.contained && {
  marginLeft: 14,
  marginRight: 14
}));
const FormHelperText = /* @__PURE__ */ reactExports.forwardRef(function FormHelperText2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormHelperText"
  });
  const {
    children,
    className,
    component = "p"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$J);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
  });
  const ownerState = _extends$8({}, props, {
    component,
    contained: fcs.variant === "filled" || fcs.variant === "outlined",
    variant: fcs.variant,
    size: fcs.size,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$z(ownerState);
  return /* @__PURE__ */ jsx(FormHelperTextRoot, _extends$8({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other, {
    children: children === " " ? (
      // notranslate needed while Google Translate will not fix zero-width space issue
      _span$2 || (_span$2 = /* @__PURE__ */ jsx("span", {
        className: "notranslate",
        children: ""
      }))
    ) : children
  }));
});
const FormHelperText$1 = FormHelperText;
function getFormLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiFormLabel", slot);
}
const formLabelClasses = generateUtilityClasses("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]);
const formLabelClasses$1 = formLabelClasses;
const _excluded$I = ["children", "className", "color", "component", "disabled", "error", "filled", "focused", "required"];
const useUtilityClasses$y = (ownerState) => {
  const {
    classes,
    color: color2,
    focused,
    disabled,
    error,
    filled,
    required
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", filled && "filled", focused && "focused", required && "required"],
    asterisk: ["asterisk", error && "error"]
  };
  return composeClasses(slots, getFormLabelUtilityClasses, classes);
};
const FormLabelRoot = styled$2("label", {
  name: "MuiFormLabel",
  slot: "Root",
  overridesResolver: ({
    ownerState
  }, styles2) => {
    return _extends$8({}, styles2.root, ownerState.color === "secondary" && styles2.colorSecondary, ownerState.filled && styles2.filled);
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  color: (theme2.vars || theme2).palette.text.secondary
}, theme2.typography.body1, {
  lineHeight: "1.4375em",
  padding: 0,
  position: "relative",
  [`&.${formLabelClasses$1.focused}`]: {
    color: (theme2.vars || theme2).palette[ownerState.color].main
  },
  [`&.${formLabelClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  },
  [`&.${formLabelClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const AsteriskComponent = styled$2("span", {
  name: "MuiFormLabel",
  slot: "Asterisk",
  overridesResolver: (props, styles2) => styles2.asterisk
})(({
  theme: theme2
}) => ({
  [`&.${formLabelClasses$1.error}`]: {
    color: (theme2.vars || theme2).palette.error.main
  }
}));
const FormLabel = /* @__PURE__ */ reactExports.forwardRef(function FormLabel2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiFormLabel"
  });
  const {
    children,
    className,
    component = "label"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$I);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "required", "focused", "disabled", "error", "filled"]
  });
  const ownerState = _extends$8({}, props, {
    color: fcs.color || "primary",
    component,
    disabled: fcs.disabled,
    error: fcs.error,
    filled: fcs.filled,
    focused: fcs.focused,
    required: fcs.required
  });
  const classes = useUtilityClasses$y(ownerState);
  return /* @__PURE__ */ jsxs(FormLabelRoot, _extends$8({
    as: component,
    ownerState,
    className: clsx(classes.root, className),
    ref
  }, other, {
    children: [children, fcs.required && /* @__PURE__ */ jsxs(AsteriskComponent, {
      ownerState,
      "aria-hidden": true,
      className: classes.asterisk,
      children: ["", "*"]
    })]
  }));
});
const FormLabel$1 = FormLabel;
const GridContext = /* @__PURE__ */ reactExports.createContext();
const GridContext$1 = GridContext;
function getGridUtilityClass(slot) {
  return generateUtilityClass("MuiGrid", slot);
}
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const DIRECTIONS = ["column-reverse", "column", "row-reverse", "row"];
const WRAPS = ["nowrap", "wrap-reverse", "wrap"];
const GRID_SIZES = ["auto", true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const gridClasses = generateUtilityClasses("MuiGrid", [
  "root",
  "container",
  "item",
  "zeroMinWidth",
  // spacings
  ...SPACINGS.map((spacing2) => `spacing-xs-${spacing2}`),
  // direction values
  ...DIRECTIONS.map((direction) => `direction-xs-${direction}`),
  // wrap values
  ...WRAPS.map((wrap) => `wrap-xs-${wrap}`),
  // grid sizes for all breakpoints
  ...GRID_SIZES.map((size) => `grid-xs-${size}`),
  ...GRID_SIZES.map((size) => `grid-sm-${size}`),
  ...GRID_SIZES.map((size) => `grid-md-${size}`),
  ...GRID_SIZES.map((size) => `grid-lg-${size}`),
  ...GRID_SIZES.map((size) => `grid-xl-${size}`)
]);
const _excluded$H = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
function getOffset(val) {
  const parse4 = parseFloat(val);
  return `${parse4}${String(val).replace(String(parse4), "") || "px"}`;
}
function generateGrid({
  theme: theme2,
  ownerState
}) {
  let size;
  return theme2.breakpoints.keys.reduce((globalStyles, breakpoint) => {
    let styles2 = {};
    if (ownerState[breakpoint]) {
      size = ownerState[breakpoint];
    }
    if (!size) {
      return globalStyles;
    }
    if (size === true) {
      styles2 = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      };
    } else if (size === "auto") {
      styles2 = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      };
    } else {
      const columnsBreakpointValues = resolveBreakpointValues({
        values: ownerState.columns,
        breakpoints: theme2.breakpoints.values
      });
      const columnValue = typeof columnsBreakpointValues === "object" ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
      if (columnValue === void 0 || columnValue === null) {
        return globalStyles;
      }
      const width3 = `${Math.round(size / columnValue * 1e8) / 1e6}%`;
      let more = {};
      if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
        const themeSpacing = theme2.spacing(ownerState.columnSpacing);
        if (themeSpacing !== "0px") {
          const fullWidth = `calc(${width3} + ${getOffset(themeSpacing)})`;
          more = {
            flexBasis: fullWidth,
            maxWidth: fullWidth
          };
        }
      }
      styles2 = _extends$8({
        flexBasis: width3,
        flexGrow: 0,
        maxWidth: width3
      }, more);
    }
    if (theme2.breakpoints.values[breakpoint] === 0) {
      Object.assign(globalStyles, styles2);
    } else {
      globalStyles[theme2.breakpoints.up(breakpoint)] = styles2;
    }
    return globalStyles;
  }, {});
}
function generateDirection({
  theme: theme2,
  ownerState
}) {
  const directionValues = resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  });
  return handleBreakpoints({
    theme: theme2
  }, directionValues, (propValue) => {
    const output = {
      flexDirection: propValue
    };
    if (propValue.indexOf("column") === 0) {
      output[`& > .${gridClasses.item}`] = {
        maxWidth: "none"
      };
    }
    return output;
  });
}
function extractZeroValueBreakpointKeys({
  breakpoints,
  values: values3
}) {
  let nonZeroKey = "";
  Object.keys(values3).forEach((key) => {
    if (nonZeroKey !== "") {
      return;
    }
    if (values3[key] !== 0) {
      nonZeroKey = key;
    }
  });
  const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a2, b2) => {
    return breakpoints[a2] - breakpoints[b2];
  });
  return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
}
function generateRowGap({
  theme: theme2,
  ownerState
}) {
  const {
    container: container2,
    rowSpacing
  } = ownerState;
  let styles2 = {};
  if (container2 && rowSpacing !== 0) {
    const rowSpacingValues = resolveBreakpointValues({
      values: rowSpacing,
      breakpoints: theme2.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof rowSpacingValues === "object") {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme2.breakpoints.values,
        values: rowSpacingValues
      });
    }
    styles2 = handleBreakpoints({
      theme: theme2
    }, rowSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK;
      const themeSpacing = theme2.spacing(propValue);
      if (themeSpacing !== "0px") {
        return {
          marginTop: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses.item}`]: {
            paddingTop: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
        return {};
      }
      return {
        marginTop: 0,
        [`& > .${gridClasses.item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return styles2;
}
function generateColumnGap({
  theme: theme2,
  ownerState
}) {
  const {
    container: container2,
    columnSpacing
  } = ownerState;
  let styles2 = {};
  if (container2 && columnSpacing !== 0) {
    const columnSpacingValues = resolveBreakpointValues({
      values: columnSpacing,
      breakpoints: theme2.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof columnSpacingValues === "object") {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme2.breakpoints.values,
        values: columnSpacingValues
      });
    }
    styles2 = handleBreakpoints({
      theme: theme2
    }, columnSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK2;
      const themeSpacing = theme2.spacing(propValue);
      if (themeSpacing !== "0px") {
        return {
          width: `calc(100% + ${getOffset(themeSpacing)})`,
          marginLeft: `-${getOffset(themeSpacing)}`,
          [`& > .${gridClasses.item}`]: {
            paddingLeft: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
        return {};
      }
      return {
        width: "100%",
        marginLeft: 0,
        [`& > .${gridClasses.item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return styles2;
}
function resolveSpacingStyles(spacing2, breakpoints, styles2 = {}) {
  if (!spacing2 || spacing2 <= 0) {
    return [];
  }
  if (typeof spacing2 === "string" && !Number.isNaN(Number(spacing2)) || typeof spacing2 === "number") {
    return [styles2[`spacing-xs-${String(spacing2)}`]];
  }
  const spacingStyles = [];
  breakpoints.forEach((breakpoint) => {
    const value = spacing2[breakpoint];
    if (Number(value) > 0) {
      spacingStyles.push(styles2[`spacing-${breakpoint}-${String(value)}`]);
    }
  });
  return spacingStyles;
}
const GridRoot = styled$2("div", {
  name: "MuiGrid",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    const {
      container: container2,
      direction,
      item,
      spacing: spacing2,
      wrap,
      zeroMinWidth,
      breakpoints
    } = ownerState;
    let spacingStyles = [];
    if (container2) {
      spacingStyles = resolveSpacingStyles(spacing2, breakpoints, styles2);
    }
    const breakpointsStyles = [];
    breakpoints.forEach((breakpoint) => {
      const value = ownerState[breakpoint];
      if (value) {
        breakpointsStyles.push(styles2[`grid-${breakpoint}-${String(value)}`]);
      }
    });
    return [styles2.root, container2 && styles2.container, item && styles2.item, zeroMinWidth && styles2.zeroMinWidth, ...spacingStyles, direction !== "row" && styles2[`direction-xs-${String(direction)}`], wrap !== "wrap" && styles2[`wrap-xs-${String(wrap)}`], ...breakpointsStyles];
  }
})(({
  ownerState
}) => _extends$8({
  boxSizing: "border-box"
}, ownerState.container && {
  display: "flex",
  flexWrap: "wrap",
  width: "100%"
}, ownerState.item && {
  margin: 0
  // For instance, it's useful when used with a `figure` element.
}, ownerState.zeroMinWidth && {
  minWidth: 0
}, ownerState.wrap !== "wrap" && {
  flexWrap: ownerState.wrap
}), generateDirection, generateRowGap, generateColumnGap, generateGrid);
function resolveSpacingClasses(spacing2, breakpoints) {
  if (!spacing2 || spacing2 <= 0) {
    return [];
  }
  if (typeof spacing2 === "string" && !Number.isNaN(Number(spacing2)) || typeof spacing2 === "number") {
    return [`spacing-xs-${String(spacing2)}`];
  }
  const classes = [];
  breakpoints.forEach((breakpoint) => {
    const value = spacing2[breakpoint];
    if (Number(value) > 0) {
      const className = `spacing-${breakpoint}-${String(value)}`;
      classes.push(className);
    }
  });
  return classes;
}
const useUtilityClasses$x = (ownerState) => {
  const {
    classes,
    container: container2,
    direction,
    item,
    spacing: spacing2,
    wrap,
    zeroMinWidth,
    breakpoints
  } = ownerState;
  let spacingClasses = [];
  if (container2) {
    spacingClasses = resolveSpacingClasses(spacing2, breakpoints);
  }
  const breakpointsClasses = [];
  breakpoints.forEach((breakpoint) => {
    const value = ownerState[breakpoint];
    if (value) {
      breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
    }
  });
  const slots = {
    root: ["root", container2 && "container", item && "item", zeroMinWidth && "zeroMinWidth", ...spacingClasses, direction !== "row" && `direction-xs-${String(direction)}`, wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...breakpointsClasses]
  };
  return composeClasses(slots, getGridUtilityClass, classes);
};
const Grid = /* @__PURE__ */ reactExports.forwardRef(function Grid2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiGrid"
  });
  const {
    breakpoints
  } = useTheme();
  const props = extendSxProp(themeProps);
  const {
    className,
    columns: columnsProp,
    columnSpacing: columnSpacingProp,
    component = "div",
    container: container2 = false,
    direction = "row",
    item = false,
    rowSpacing: rowSpacingProp,
    spacing: spacing2 = 0,
    wrap = "wrap",
    zeroMinWidth = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$H);
  const rowSpacing = rowSpacingProp || spacing2;
  const columnSpacing = columnSpacingProp || spacing2;
  const columnsContext = reactExports.useContext(GridContext$1);
  const columns = container2 ? columnsProp || 12 : columnsContext;
  const breakpointsValues = {};
  const otherFiltered = _extends$8({}, other);
  breakpoints.keys.forEach((breakpoint) => {
    if (other[breakpoint] != null) {
      breakpointsValues[breakpoint] = other[breakpoint];
      delete otherFiltered[breakpoint];
    }
  });
  const ownerState = _extends$8({}, props, {
    columns,
    container: container2,
    direction,
    item,
    rowSpacing,
    columnSpacing,
    wrap,
    zeroMinWidth,
    spacing: spacing2
  }, breakpointsValues, {
    breakpoints: breakpoints.keys
  });
  const classes = useUtilityClasses$x(ownerState);
  return /* @__PURE__ */ jsx(GridContext$1.Provider, {
    value: columns,
    children: /* @__PURE__ */ jsx(GridRoot, _extends$8({
      ownerState,
      className: clsx(classes.root, className),
      as: component,
      ref
    }, otherFiltered))
  });
});
const Grid$1 = Grid;
const _excluded$G = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$1 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$G);
  const timer = reactExports.useRef();
  const autoTimeout = reactExports.useRef();
  const theme2 = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = (callback2) => (maybeIsAppearing) => {
    if (callback2) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback2(node2);
      } else {
        callback2(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration5;
    if (timeout === "auto") {
      duration5 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration5;
    } else {
      duration5 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration5,
      delay
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration5 : duration5 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration5;
    if (timeout === "auto") {
      duration5 = theme2.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration5;
    } else {
      duration5 = transitionDuration;
    }
    node2.style.transition = [theme2.transitions.create("opacity", {
      duration: duration5,
      delay
    }), theme2.transitions.create("transform", {
      duration: isWebKit154 ? duration5 : duration5 * 0.666,
      delay: isWebKit154 ? delay : delay || duration5 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.current = setTimeout(next2, autoTimeout.current || 0);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(timer.current);
    };
  }, []);
  return /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$8({
        style: _extends$8({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$1[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
Grow.muiSupportAuto = true;
const Grow$1 = Grow;
function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  const [match2, setMatch] = reactExports.useState(() => {
    if (noSsr && supportMatchMedia) {
      return matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  });
  useEnhancedEffect$1(() => {
    let active = true;
    if (!supportMatchMedia) {
      return void 0;
    }
    const queryList = matchMedia(query);
    const updateMatch = () => {
      if (active) {
        setMatch(queryList.matches);
      }
    };
    updateMatch();
    queryList.addListener(updateMatch);
    return () => {
      active = false;
      queryList.removeListener(updateMatch);
    };
  }, [query, matchMedia, supportMatchMedia]);
  return match2;
}
const maybeReactUseSyncExternalStore = React$1["useSyncExternalStore"];
function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia) {
  const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = reactExports.useMemo(() => {
    if (ssrMatchMedia !== null) {
      const {
        matches
      } = ssrMatchMedia(query);
      return () => matches;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia]);
  const [getSnapshot, subscribe] = reactExports.useMemo(() => {
    if (matchMedia === null) {
      return [getDefaultSnapshot, () => () => {
      }];
    }
    const mediaQueryList = matchMedia(query);
    return [() => mediaQueryList.matches, (notify2) => {
      mediaQueryList.addListener(notify2);
      return () => {
        mediaQueryList.removeListener(notify2);
      };
    }];
  }, [getDefaultSnapshot, matchMedia, query]);
  const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  return match2;
}
function useMediaQuery(queryInput, options = {}) {
  const theme2 = useTheme$2();
  const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  const {
    defaultMatches = false,
    matchMedia = supportMatchMedia ? window.matchMedia : null,
    ssrMatchMedia = null,
    noSsr
  } = getThemeProps({
    name: "MuiUseMediaQuery",
    props: options,
    theme: theme2
  });
  let query = typeof queryInput === "function" ? queryInput(theme2) : queryInput;
  query = query.replace(/^@media( ?)/m, "");
  const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
  const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
  return match2;
}
function getImageListUtilityClass(slot) {
  return generateUtilityClass("MuiImageList", slot);
}
generateUtilityClasses("MuiImageList", ["root", "masonry", "quilted", "standard", "woven"]);
const ImageListContext = /* @__PURE__ */ reactExports.createContext({});
const ImageListContext$1 = ImageListContext;
const _excluded$F = ["children", "className", "cols", "component", "rowHeight", "gap", "style", "variant"];
const useUtilityClasses$w = (ownerState) => {
  const {
    classes,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant]
  };
  return composeClasses(slots, getImageListUtilityClass, classes);
};
const ImageListRoot = styled$2("ul", {
  name: "MuiImageList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant]];
  }
})(({
  ownerState
}) => {
  return _extends$8({
    display: "grid",
    overflowY: "auto",
    listStyle: "none",
    padding: 0,
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch"
  }, ownerState.variant === "masonry" && {
    display: "block"
  });
});
const ImageList = /* @__PURE__ */ reactExports.forwardRef(function ImageList2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiImageList"
  });
  const {
    children,
    className,
    cols = 2,
    component = "ul",
    rowHeight = "auto",
    gap: gap2 = 4,
    style: styleProp,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$F);
  const contextValue = reactExports.useMemo(() => ({
    rowHeight,
    gap: gap2,
    variant
  }), [rowHeight, gap2, variant]);
  reactExports.useEffect(() => {
  }, []);
  const style2 = variant === "masonry" ? _extends$8({
    columnCount: cols,
    columnGap: gap2
  }, styleProp) : _extends$8({
    gridTemplateColumns: `repeat(${cols}, 1fr)`,
    gap: gap2
  }, styleProp);
  const ownerState = _extends$8({}, props, {
    component,
    gap: gap2,
    rowHeight,
    variant
  });
  const classes = useUtilityClasses$w(ownerState);
  return /* @__PURE__ */ jsx(ImageListRoot, _extends$8({
    as: component,
    className: clsx(classes.root, classes[variant], className),
    ref,
    style: style2,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsx(ImageListContext$1.Provider, {
      value: contextValue,
      children
    })
  }));
});
const ImageList$1 = ImageList;
const _excluded$E = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$v = (ownerState) => {
  const {
    classes,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes);
  return _extends$8({}, classes, composedClasses);
};
const InputRoot = styled$2(InputBaseRoot, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const light2 = theme2.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme2.vars) {
    bottomLineColor = `rgba(${theme2.vars.palette.common.onBackgroundChannel} / ${theme2.vars.opacity.inputUnderline})`;
  }
  return _extends$8({
    position: "relative"
  }, ownerState.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !ownerState.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(theme2.vars || theme2).palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme2.transitions.create("transform", {
        duration: theme2.transitions.duration.shorter,
        easing: theme2.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${inputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${inputClasses$1.error}:after`]: {
      borderBottomColor: (theme2.vars || theme2).palette.error.main,
      transform: "scaleX(1)"
      // error is always underlined in red
    },
    "&:before": {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme2.transitions.create("border-bottom-color", {
        duration: theme2.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${inputClasses$1.disabled}):before`]: {
      borderBottom: `2px solid ${(theme2.vars || theme2).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        borderBottom: `1px solid ${bottomLineColor}`
      }
    },
    [`&.${inputClasses$1.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
});
const InputInput = styled$2(InputBaseComponent, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiInput"
  });
  const {
    disableUnderline,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type: type2 = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$E);
  const classes = useUtilityClasses$v(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
  return /* @__PURE__ */ jsx(InputBase$1, _extends$8({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type: type2
  }, other, {
    classes
  }));
});
Input.muiName = "Input";
const Input$1 = Input;
function getInputLabelUtilityClasses(slot) {
  return generateUtilityClass("MuiInputLabel", slot);
}
generateUtilityClasses("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
const _excluded$D = ["disableAnimation", "margin", "shrink", "variant", "className"];
const useUtilityClasses$u = (ownerState) => {
  const {
    classes,
    formControl,
    size,
    shrink: shrink3,
    disableAnimation,
    variant,
    required
  } = ownerState;
  const slots = {
    root: ["root", formControl && "formControl", !disableAnimation && "animated", shrink3 && "shrink", size === "small" && "sizeSmall", variant],
    asterisk: [required && "asterisk"]
  };
  const composedClasses = composeClasses(slots, getInputLabelUtilityClasses, classes);
  return _extends$8({}, classes, composedClasses);
};
const InputLabelRoot = styled$2(FormLabel$1, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiInputLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${formLabelClasses$1.asterisk}`]: styles2.asterisk
    }, styles2.root, ownerState.formControl && styles2.formControl, ownerState.size === "small" && styles2.sizeSmall, ownerState.shrink && styles2.shrink, !ownerState.disableAnimation && styles2.animated, styles2[ownerState.variant]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  display: "block",
  transformOrigin: "top left",
  whiteSpace: "nowrap",
  overflow: "hidden",
  textOverflow: "ellipsis",
  maxWidth: "100%"
}, ownerState.formControl && {
  position: "absolute",
  left: 0,
  top: 0,
  // slight alteration to spec spacing to match visual spec result
  transform: "translate(0, 20px) scale(1)"
}, ownerState.size === "small" && {
  // Compensation for the `Input.inputSizeSmall` style.
  transform: "translate(0, 17px) scale(1)"
}, ownerState.shrink && {
  transform: "translate(0, -1.5px) scale(0.75)",
  transformOrigin: "top left",
  maxWidth: "133%"
}, !ownerState.disableAnimation && {
  transition: theme2.transitions.create(["color", "transform", "max-width"], {
    duration: theme2.transitions.duration.shorter,
    easing: theme2.transitions.easing.easeOut
  })
}, ownerState.variant === "filled" && _extends$8({
  // Chrome's autofill feature gives the input field a yellow background.
  // Since the input field is behind the label in the HTML tree,
  // the input field is drawn last and hides the label with an opaque background color.
  // zIndex: 1 will raise the label above opaque background-colors of input.
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(12px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 13px) scale(1)"
}, ownerState.shrink && _extends$8({
  userSelect: "none",
  pointerEvents: "auto",
  transform: "translate(12px, 7px) scale(0.75)",
  maxWidth: "calc(133% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(12px, 4px) scale(0.75)"
})), ownerState.variant === "outlined" && _extends$8({
  // see comment above on filled.zIndex
  zIndex: 1,
  pointerEvents: "none",
  transform: "translate(14px, 16px) scale(1)",
  maxWidth: "calc(100% - 24px)"
}, ownerState.size === "small" && {
  transform: "translate(14px, 9px) scale(1)"
}, ownerState.shrink && {
  userSelect: "none",
  pointerEvents: "auto",
  maxWidth: "calc(133% - 24px)",
  transform: "translate(14px, -9px) scale(0.75)"
})));
const InputLabel = /* @__PURE__ */ reactExports.forwardRef(function InputLabel2(inProps, ref) {
  const props = useThemeProps({
    name: "MuiInputLabel",
    props: inProps
  });
  const {
    disableAnimation = false,
    shrink: shrinkProp,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$D);
  const muiFormControl = useFormControl();
  let shrink3 = shrinkProp;
  if (typeof shrink3 === "undefined" && muiFormControl) {
    shrink3 = muiFormControl.filled || muiFormControl.focused || muiFormControl.adornedStart;
  }
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["size", "variant", "required"]
  });
  const ownerState = _extends$8({}, props, {
    disableAnimation,
    formControl: muiFormControl,
    shrink: shrink3,
    size: fcs.size,
    variant: fcs.variant,
    required: fcs.required
  });
  const classes = useUtilityClasses$u(ownerState);
  return /* @__PURE__ */ jsx(InputLabelRoot, _extends$8({
    "data-shrink": shrink3,
    ownerState,
    ref,
    className: clsx(classes.root, className)
  }, other, {
    classes
  }));
});
const InputLabel$1 = InputLabel;
function getLinearProgressUtilityClass(slot) {
  return generateUtilityClass("MuiLinearProgress", slot);
}
generateUtilityClasses("MuiLinearProgress", ["root", "colorPrimary", "colorSecondary", "determinate", "indeterminate", "buffer", "query", "dashed", "dashedColorPrimary", "dashedColorSecondary", "bar", "barColorPrimary", "barColorSecondary", "bar1Indeterminate", "bar1Determinate", "bar1Buffer", "bar2Indeterminate", "bar2Buffer"]);
const _excluded$C = ["className", "color", "value", "valueBuffer", "variant"];
let _$2 = (t3) => t3, _t$1, _t2$1, _t3$1, _t4$1, _t5, _t6;
const TRANSITION_DURATION = 4;
const indeterminate1Keyframe = keyframes(_t$1 || (_t$1 = _$2`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`));
const indeterminate2Keyframe = keyframes(_t2$1 || (_t2$1 = _$2`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`));
const bufferKeyframe = keyframes(_t3$1 || (_t3$1 = _$2`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`));
const useUtilityClasses$t = (ownerState) => {
  const {
    classes,
    variant,
    color: color2
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, variant],
    dashed: ["dashed", `dashedColor${capitalize(color2)}`],
    bar1: ["bar", `barColor${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar1Indeterminate", variant === "determinate" && "bar1Determinate", variant === "buffer" && "bar1Buffer"],
    bar2: ["bar", variant !== "buffer" && `barColor${capitalize(color2)}`, variant === "buffer" && `color${capitalize(color2)}`, (variant === "indeterminate" || variant === "query") && "bar2Indeterminate", variant === "buffer" && "bar2Buffer"]
  };
  return composeClasses(slots, getLinearProgressUtilityClass, classes);
};
const getColorShade = (theme2, color2) => {
  if (color2 === "inherit") {
    return "currentColor";
  }
  if (theme2.vars) {
    return theme2.vars.palette.LinearProgress[`${color2}Bg`];
  }
  return theme2.palette.mode === "light" ? lighten(theme2.palette[color2].main, 0.62) : darken(theme2.palette[color2].main, 0.5);
};
const LinearProgressRoot = styled$2("span", {
  name: "MuiLinearProgress",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`color${capitalize(ownerState.color)}`], styles2[ownerState.variant]];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$8({
  position: "relative",
  overflow: "hidden",
  display: "block",
  height: 4,
  zIndex: 0,
  // Fix Safari's bug during composition of different paint.
  "@media print": {
    colorAdjust: "exact"
  },
  backgroundColor: getColorShade(theme2, ownerState.color)
}, ownerState.color === "inherit" && ownerState.variant !== "buffer" && {
  backgroundColor: "none",
  "&::before": {
    content: '""',
    position: "absolute",
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    backgroundColor: "currentColor",
    opacity: 0.3
  }
}, ownerState.variant === "buffer" && {
  backgroundColor: "transparent"
}, ownerState.variant === "query" && {
  transform: "rotate(180deg)"
}));
const LinearProgressDashed = styled$2("span", {
  name: "MuiLinearProgress",
  slot: "Dashed",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.dashed, styles2[`dashedColor${capitalize(ownerState.color)}`]];
  }
})(({
  ownerState,
  theme: theme2
}) => {
  const backgroundColor2 = getColorShade(theme2, ownerState.color);
  return _extends$8({
    position: "absolute",
    marginTop: 0,
    height: "100%",
    width: "100%"
  }, ownerState.color === "inherit" && {
    opacity: 0.3
  }, {
    backgroundImage: `radial-gradient(${backgroundColor2} 0%, ${backgroundColor2} 16%, transparent 42%)`,
    backgroundSize: "10px 10px",
    backgroundPosition: "0 -23px"
  });
}, css(_t4$1 || (_t4$1 = _$2`
    animation: ${0} 3s infinite linear;
  `), bufferKeyframe));
const LinearProgressBar1 = styled$2("span", {
  name: "MuiLinearProgress",
  slot: "Bar1",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar1Indeterminate, ownerState.variant === "determinate" && styles2.bar1Determinate, ownerState.variant === "buffer" && styles2.bar1Buffer];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$8({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left",
  backgroundColor: ownerState.color === "inherit" ? "currentColor" : (theme2.vars || theme2).palette[ownerState.color].main
}, ownerState.variant === "determinate" && {
  transition: `transform .${TRANSITION_DURATION}s linear`
}, ownerState.variant === "buffer" && {
  zIndex: 1,
  transition: `transform .${TRANSITION_DURATION}s linear`
}), ({
  ownerState
}) => (ownerState.variant === "indeterminate" || ownerState.variant === "query") && css(_t5 || (_t5 = _$2`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
    `), indeterminate1Keyframe));
const LinearProgressBar2 = styled$2("span", {
  name: "MuiLinearProgress",
  slot: "Bar2",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.bar, styles2[`barColor${capitalize(ownerState.color)}`], (ownerState.variant === "indeterminate" || ownerState.variant === "query") && styles2.bar2Indeterminate, ownerState.variant === "buffer" && styles2.bar2Buffer];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$8({
  width: "100%",
  position: "absolute",
  left: 0,
  bottom: 0,
  top: 0,
  transition: "transform 0.2s linear",
  transformOrigin: "left"
}, ownerState.variant !== "buffer" && {
  backgroundColor: ownerState.color === "inherit" ? "currentColor" : (theme2.vars || theme2).palette[ownerState.color].main
}, ownerState.color === "inherit" && {
  opacity: 0.3
}, ownerState.variant === "buffer" && {
  backgroundColor: getColorShade(theme2, ownerState.color),
  transition: `transform .${TRANSITION_DURATION}s linear`
}), ({
  ownerState
}) => (ownerState.variant === "indeterminate" || ownerState.variant === "query") && css(_t6 || (_t6 = _$2`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
    `), indeterminate2Keyframe));
const LinearProgress = /* @__PURE__ */ reactExports.forwardRef(function LinearProgress2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiLinearProgress"
  });
  const {
    className,
    color: color2 = "primary",
    value,
    valueBuffer,
    variant = "indeterminate"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$C);
  const ownerState = _extends$8({}, props, {
    color: color2,
    variant
  });
  const classes = useUtilityClasses$t(ownerState);
  const theme2 = useTheme();
  const rootProps = {};
  const inlineStyles = {
    bar1: {},
    bar2: {}
  };
  if (variant === "determinate" || variant === "buffer") {
    if (value !== void 0) {
      rootProps["aria-valuenow"] = Math.round(value);
      rootProps["aria-valuemin"] = 0;
      rootProps["aria-valuemax"] = 100;
      let transform3 = value - 100;
      if (theme2.direction === "rtl") {
        transform3 = -transform3;
      }
      inlineStyles.bar1.transform = `translateX(${transform3}%)`;
    }
  }
  if (variant === "buffer") {
    if (valueBuffer !== void 0) {
      let transform3 = (valueBuffer || 0) - 100;
      if (theme2.direction === "rtl") {
        transform3 = -transform3;
      }
      inlineStyles.bar2.transform = `translateX(${transform3}%)`;
    }
  }
  return /* @__PURE__ */ jsxs(LinearProgressRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    role: "progressbar"
  }, rootProps, {
    ref
  }, other, {
    children: [variant === "buffer" ? /* @__PURE__ */ jsx(LinearProgressDashed, {
      className: classes.dashed,
      ownerState
    }) : null, /* @__PURE__ */ jsx(LinearProgressBar1, {
      className: classes.bar1,
      ownerState,
      style: inlineStyles.bar1
    }), variant === "determinate" ? null : /* @__PURE__ */ jsx(LinearProgressBar2, {
      className: classes.bar2,
      ownerState,
      style: inlineStyles.bar2
    })]
  }));
});
const LinearProgress$1 = LinearProgress;
const ListContext = /* @__PURE__ */ reactExports.createContext({});
const ListContext$1 = ListContext;
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$B = ["children", "className", "component", "dense", "disablePadding", "subheader"];
const useUtilityClasses$s = (ownerState) => {
  const {
    classes,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes);
};
const ListRoot = styled$2("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})(({
  ownerState
}) => _extends$8({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !ownerState.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.subheader && {
  paddingTop: 0
}));
const List = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$B);
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = _extends$8({}, props, {
    component,
    dense,
    disablePadding
  });
  const classes = useUtilityClasses$s(ownerState);
  return /* @__PURE__ */ jsx(ListContext$1.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxs(ListRoot, _extends$8({
      as: component,
      className: clsx(classes.root, className),
      ref,
      ownerState
    }, other, {
      children: [subheader, children]
    }))
  });
});
const List$1 = List;
function getListItemUtilityClass(slot) {
  return generateUtilityClass("MuiListItem", slot);
}
const listItemClasses = generateUtilityClasses("MuiListItem", ["root", "container", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "padding", "button", "secondaryAction", "selected"]);
const listItemClasses$1 = listItemClasses;
function getListItemButtonUtilityClass(slot) {
  return generateUtilityClass("MuiListItemButton", slot);
}
const listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
const listItemButtonClasses$1 = listItemButtonClasses;
const _excluded$A = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"];
const overridesResolver$2 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$r = (ownerState) => {
  const {
    alignItems: alignItems2,
    classes,
    dense,
    disabled,
    disableGutters,
    divider,
    selected
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", divider && "divider", disabled && "disabled", alignItems2 === "flex-start" && "alignItemsFlexStart", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getListItemButtonUtilityClass, classes);
  return _extends$8({}, classes, composedClasses);
};
const ListItemButtonRoot = styled$2(ButtonBase$1, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiListItemButton",
  slot: "Root",
  overridesResolver: overridesResolver$2
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  display: "flex",
  flexGrow: 1,
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minWidth: 0,
  boxSizing: "border-box",
  textAlign: "left",
  paddingTop: 8,
  paddingBottom: 8,
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${listItemButtonClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${listItemButtonClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${listItemButtonClasses$1.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  },
  [`&.${listItemButtonClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${listItemButtonClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  }
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, ownerState.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.dense && {
  paddingTop: 4,
  paddingBottom: 4
}));
const ListItemButton = /* @__PURE__ */ reactExports.forwardRef(function ListItemButton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemButton"
  });
  const {
    alignItems: alignItems2 = "center",
    autoFocus = false,
    component = "div",
    children,
    dense = false,
    disableGutters = false,
    divider = false,
    focusVisibleClassName,
    selected = false,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$A);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems: alignItems2,
    disableGutters
  }), [alignItems2, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      if (listItemRef.current) {
        listItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$8({}, props, {
    alignItems: alignItems2,
    dense: childContext.dense,
    disableGutters,
    divider,
    selected
  });
  const classes = useUtilityClasses$r(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  return /* @__PURE__ */ jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsx(ListItemButtonRoot, _extends$8({
      ref: handleRef,
      href: other.href || other.to,
      component: (other.href || other.to) && component === "div" ? "a" : component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      ownerState,
      className: clsx(classes.root, className)
    }, other, {
      classes,
      children
    }))
  });
});
const ListItemButton$1 = ListItemButton;
function getListItemSecondaryActionClassesUtilityClass(slot) {
  return generateUtilityClass("MuiListItemSecondaryAction", slot);
}
generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const _excluded$z = ["className"];
const useUtilityClasses$q = (ownerState) => {
  const {
    disableGutters,
    classes
  } = ownerState;
  const slots = {
    root: ["root", disableGutters && "disableGutters"]
  };
  return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);
};
const ListItemSecondaryActionRoot = styled$2("div", {
  name: "MuiListItemSecondaryAction",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.disableGutters && styles2.disableGutters];
  }
})(({
  ownerState
}) => _extends$8({
  position: "absolute",
  right: 16,
  top: "50%",
  transform: "translateY(-50%)"
}, ownerState.disableGutters && {
  right: 0
}));
const ListItemSecondaryAction = /* @__PURE__ */ reactExports.forwardRef(function ListItemSecondaryAction2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemSecondaryAction"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$z);
  const context = reactExports.useContext(ListContext$1);
  const ownerState = _extends$8({}, props, {
    disableGutters: context.disableGutters
  });
  const classes = useUtilityClasses$q(ownerState);
  return /* @__PURE__ */ jsx(ListItemSecondaryActionRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
const ListItemSecondaryAction$1 = ListItemSecondaryAction;
const _excluded$y = ["className"], _excluded2$4 = ["alignItems", "autoFocus", "button", "children", "className", "component", "components", "componentsProps", "ContainerComponent", "ContainerProps", "dense", "disabled", "disableGutters", "disablePadding", "divider", "focusVisibleClassName", "secondaryAction", "selected", "slotProps", "slots"];
const overridesResolver$1 = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters, !ownerState.disablePadding && styles2.padding, ownerState.button && styles2.button, ownerState.hasSecondaryAction && styles2.secondaryAction];
};
const useUtilityClasses$p = (ownerState) => {
  const {
    alignItems: alignItems2,
    button,
    classes,
    dense,
    disabled,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction,
    selected
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", !disablePadding && "padding", divider && "divider", disabled && "disabled", button && "button", alignItems2 === "flex-start" && "alignItemsFlexStart", hasSecondaryAction && "secondaryAction", selected && "selected"],
    container: ["container"]
  };
  return composeClasses(slots, getListItemUtilityClass, classes);
};
const ListItemRoot = styled$2("div", {
  name: "MuiListItem",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  width: "100%",
  boxSizing: "border-box",
  textAlign: "left"
}, !ownerState.disablePadding && _extends$8({
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.dense && {
  paddingTop: 4,
  paddingBottom: 4
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, !!ownerState.secondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
}), !!ownerState.secondaryAction && {
  [`& > .${listItemButtonClasses$1.root}`]: {
    paddingRight: 48
  }
}, {
  [`&.${listItemClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${listItemClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${listItemClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${listItemClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  }
}, ownerState.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, ownerState.button && {
  transition: theme2.transitions.create("background-color", {
    duration: theme2.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${listItemClasses$1.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  }
}, ownerState.hasSecondaryAction && {
  // Add some space to avoid collision as `ListItemSecondaryAction`
  // is absolutely positioned.
  paddingRight: 48
}));
const ListItemContainer = styled$2("li", {
  name: "MuiListItem",
  slot: "Container",
  overridesResolver: (props, styles2) => styles2.container
})({
  position: "relative"
});
const ListItem$1 = /* @__PURE__ */ reactExports.forwardRef(function ListItem(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItem"
  });
  const {
    alignItems: alignItems2 = "center",
    autoFocus = false,
    button = false,
    children: childrenProp,
    className,
    component: componentProp,
    components = {},
    componentsProps = {},
    ContainerComponent = "li",
    ContainerProps: {
      className: ContainerClassName
    } = {},
    dense = false,
    disabled = false,
    disableGutters = false,
    disablePadding = false,
    divider = false,
    focusVisibleClassName,
    secondaryAction,
    selected = false,
    slotProps = {},
    slots = {}
  } = props, ContainerProps = _objectWithoutPropertiesLoose(props.ContainerProps, _excluded$y), other = _objectWithoutPropertiesLoose(props, _excluded2$4);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems: alignItems2,
    disableGutters
  }), [alignItems2, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      if (listItemRef.current) {
        listItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const children = reactExports.Children.toArray(childrenProp);
  const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ["ListItemSecondaryAction"]);
  const ownerState = _extends$8({}, props, {
    alignItems: alignItems2,
    autoFocus,
    button,
    dense: childContext.dense,
    disabled,
    disableGutters,
    disablePadding,
    divider,
    hasSecondaryAction,
    selected
  });
  const classes = useUtilityClasses$p(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  const Root2 = slots.root || components.Root || ListItemRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const componentProps = _extends$8({
    className: clsx(classes.root, rootProps.className, className),
    disabled
  }, other);
  let Component2 = componentProp || "li";
  if (button) {
    componentProps.component = componentProp || "div";
    componentProps.focusVisibleClassName = clsx(listItemClasses$1.focusVisible, focusVisibleClassName);
    Component2 = ButtonBase$1;
  }
  if (hasSecondaryAction) {
    Component2 = !componentProps.component && !componentProp ? "div" : Component2;
    if (ContainerComponent === "li") {
      if (Component2 === "li") {
        Component2 = "div";
      } else if (componentProps.component === "li") {
        componentProps.component = "div";
      }
    }
    return /* @__PURE__ */ jsx(ListContext$1.Provider, {
      value: childContext,
      children: /* @__PURE__ */ jsxs(ListItemContainer, _extends$8({
        as: ContainerComponent,
        className: clsx(classes.container, ContainerClassName),
        ref: handleRef,
        ownerState
      }, ContainerProps, {
        children: [/* @__PURE__ */ jsx(Root2, _extends$8({}, rootProps, !isHostComponent(Root2) && {
          as: Component2,
          ownerState: _extends$8({}, ownerState, rootProps.ownerState)
        }, componentProps, {
          children
        })), children.pop()]
      }))
    });
  }
  return /* @__PURE__ */ jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxs(Root2, _extends$8({}, rootProps, {
      as: Component2,
      ref: handleRef
    }, !isHostComponent(Root2) && {
      ownerState: _extends$8({}, ownerState, rootProps.ownerState)
    }, componentProps, {
      children: [children, secondaryAction && /* @__PURE__ */ jsx(ListItemSecondaryAction$1, {
        children: secondaryAction
      })]
    }))
  });
});
const ListItem$2 = ListItem$1;
function getListItemIconUtilityClass(slot) {
  return generateUtilityClass("MuiListItemIcon", slot);
}
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const listItemIconClasses$1 = listItemIconClasses;
const _excluded$x = ["className"];
const useUtilityClasses$o = (ownerState) => {
  const {
    alignItems: alignItems2,
    classes
  } = ownerState;
  const slots = {
    root: ["root", alignItems2 === "flex-start" && "alignItemsFlexStart"]
  };
  return composeClasses(slots, getListItemIconUtilityClass, classes);
};
const ListItemIconRoot = styled$2("div", {
  name: "MuiListItemIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.alignItems === "flex-start" && styles2.alignItemsFlexStart];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  minWidth: 56,
  color: (theme2.vars || theme2).palette.action.active,
  flexShrink: 0,
  display: "inline-flex"
}, ownerState.alignItems === "flex-start" && {
  marginTop: 8
}));
const ListItemIcon = /* @__PURE__ */ reactExports.forwardRef(function ListItemIcon2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemIcon"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$x);
  const context = reactExports.useContext(ListContext$1);
  const ownerState = _extends$8({}, props, {
    alignItems: context.alignItems
  });
  const classes = useUtilityClasses$o(ownerState);
  return /* @__PURE__ */ jsx(ListItemIconRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const ListItemIcon$1 = ListItemIcon;
function getListItemTextUtilityClass(slot) {
  return generateUtilityClass("MuiListItemText", slot);
}
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
const listItemTextClasses$1 = listItemTextClasses;
const _excluded$w = ["children", "className", "disableTypography", "inset", "primary", "primaryTypographyProps", "secondary", "secondaryTypographyProps"];
const useUtilityClasses$n = (ownerState) => {
  const {
    classes,
    inset,
    primary,
    secondary,
    dense
  } = ownerState;
  const slots = {
    root: ["root", inset && "inset", dense && "dense", primary && secondary && "multiline"],
    primary: ["primary"],
    secondary: ["secondary"]
  };
  return composeClasses(slots, getListItemTextUtilityClass, classes);
};
const ListItemTextRoot = styled$2("div", {
  name: "MuiListItemText",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${listItemTextClasses$1.primary}`]: styles2.primary
    }, {
      [`& .${listItemTextClasses$1.secondary}`]: styles2.secondary
    }, styles2.root, ownerState.inset && styles2.inset, ownerState.primary && ownerState.secondary && styles2.multiline, ownerState.dense && styles2.dense];
  }
})(({
  ownerState
}) => _extends$8({
  flex: "1 1 auto",
  minWidth: 0,
  marginTop: 4,
  marginBottom: 4
}, ownerState.primary && ownerState.secondary && {
  marginTop: 6,
  marginBottom: 6
}, ownerState.inset && {
  paddingLeft: 56
}));
const ListItemText = /* @__PURE__ */ reactExports.forwardRef(function ListItemText2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiListItemText"
  });
  const {
    children,
    className,
    disableTypography = false,
    inset = false,
    primary: primaryProp,
    primaryTypographyProps,
    secondary: secondaryProp,
    secondaryTypographyProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$w);
  const {
    dense
  } = reactExports.useContext(ListContext$1);
  let primary = primaryProp != null ? primaryProp : children;
  let secondary = secondaryProp;
  const ownerState = _extends$8({}, props, {
    disableTypography,
    inset,
    primary: !!primary,
    secondary: !!secondary,
    dense
  });
  const classes = useUtilityClasses$n(ownerState);
  if (primary != null && primary.type !== Typography$1 && !disableTypography) {
    primary = /* @__PURE__ */ jsx(Typography$1, _extends$8({
      variant: dense ? "body2" : "body1",
      className: classes.primary,
      component: primaryTypographyProps != null && primaryTypographyProps.variant ? void 0 : "span",
      display: "block"
    }, primaryTypographyProps, {
      children: primary
    }));
  }
  if (secondary != null && secondary.type !== Typography$1 && !disableTypography) {
    secondary = /* @__PURE__ */ jsx(Typography$1, _extends$8({
      variant: "body2",
      className: classes.secondary,
      color: "text.secondary",
      display: "block"
    }, secondaryTypographyProps, {
      children: secondary
    }));
  }
  return /* @__PURE__ */ jsxs(ListItemTextRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other, {
    children: [primary, secondary]
  }));
});
const ListItemText$1 = ListItemText;
const _excluded$v = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem$1(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem$1(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: actions2,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$v);
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions2, () => ({
    adjustStyleForScrollbar: (containerElement, theme2) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
        listRef.current.style[theme2.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown2 = (event) => {
    const list = listRef.current;
    const key = event.key;
    const currentFocus = ownerDocument(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus$1(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, nextItem$1);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus$1(list, null, disableListWrap, disabledItemsFocusable, previousItem$1);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus$1(list, currentFocus, false, disabledItemsFocusable, nextItem$1, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef(listRef, ref);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index2) => {
    if (index2 === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsx(List$1, _extends$8({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown2,
    tabIndex: autoFocus ? 0 : -1
  }, other, {
    children: items
  }));
});
const MenuList$1 = MenuList;
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const _excluded$u = ["onEntering"], _excluded2$3 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"];
function getOffsetTop(rect, vertical2) {
  let offset3 = 0;
  if (typeof vertical2 === "number") {
    offset3 = vertical2;
  } else if (vertical2 === "center") {
    offset3 = rect.height / 2;
  } else if (vertical2 === "bottom") {
    offset3 = rect.height;
  }
  return offset3;
}
function getOffsetLeft(rect, horizontal2) {
  let offset3 = 0;
  if (typeof horizontal2 === "number") {
    offset3 = horizontal2;
  } else if (horizontal2 === "center") {
    offset3 = rect.width / 2;
  } else if (horizontal2 === "right") {
    offset3 = rect.width;
  }
  return offset3;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$m = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes);
};
const PopoverRoot = styled$2(Modal$1, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const PopoverPaper = styled$2(Paper$1, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps = {},
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow$1,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering
    } = {}
  } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$u), other = _objectWithoutPropertiesLoose(props, _excluded2$3);
  const paperRef = reactExports.useRef();
  const handlePaperRef = useForkRef(paperRef, PaperProps.ref);
  const ownerState = _extends$8({}, props, {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    PaperProps,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes = useUtilityClasses$m(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top2 = anchorOffset.top - elemTransformOrigin.vertical;
    let left2 = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom2 = top2 + elemRect.height;
    const right2 = left2 + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (top2 < marginThreshold) {
      const diff = top2 - marginThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (bottom2 > heightThreshold) {
      const diff = bottom2 - heightThreshold;
      top2 -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (left2 < marginThreshold) {
      const diff = left2 - marginThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right2 > widthThreshold) {
      const diff = right2 - widthThreshold;
      left2 -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top2)}px`,
      left: `${Math.round(left2)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  const handleEntering = (element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  reactExports.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce$2(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container2 = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  return /* @__PURE__ */ jsx(PopoverRoot, _extends$8({
    BackdropProps: {
      invisible: true
    },
    className: clsx(classes.root, className),
    container: container2,
    open,
    ref,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
      appear: true,
      in: open,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration
    }, TransitionProps, {
      children: /* @__PURE__ */ jsx(PopoverPaper, _extends$8({
        elevation
      }, PaperProps, {
        ref: handlePaperRef,
        className: clsx(classes.paper, PaperProps.className)
      }, isPositioned ? void 0 : {
        style: _extends$8({}, PaperProps.style, {
          opacity: 0
        })
      }, {
        ownerState,
        children
      }))
    }))
  }));
});
const Popover$1 = Popover;
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const _excluded$t = ["onEntering"], _excluded2$2 = ["autoFocus", "children", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"];
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$l = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass, classes);
};
const MenuRoot = styled$2(Popover$1, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const MenuPaper = styled$2(Paper$1, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tapable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled$2(MenuList$1, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu$2 = /* @__PURE__ */ reactExports.forwardRef(function Menu(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering
    } = {},
    variant = "selectedMenu"
  } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$t), other = _objectWithoutPropertiesLoose(props, _excluded2$2);
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const ownerState = _extends$8({}, props, {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes = useUtilityClasses$l(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, theme2);
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index2;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index2;
      }
    }
  });
  return /* @__PURE__ */ jsx(MenuRoot, _extends$8({
    classes: PopoverClasses,
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    PaperProps: _extends$8({
      component: MenuPaper
    }, PaperProps, {
      classes: _extends$8({}, PaperProps.classes, {
        root: classes.paper
      })
    }),
    className: classes.root,
    open,
    ref,
    transitionDuration,
    TransitionProps: _extends$8({
      onEntering: handleEntering
    }, TransitionProps),
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsx(MenuMenuList, _extends$8({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, MenuListProps, {
      className: clsx(classes.list, MenuListProps.className),
      children
    }))
  }));
});
const Menu$3 = Menu$2;
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const menuItemClasses$1 = menuItemClasses;
const _excluded$s = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$k = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
  return _extends$8({}, classes, composedClasses);
};
const MenuItemRoot = styled$2(ButtonBase$1, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$8({}, theme2.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme2.vars || theme2).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme2.vars || theme2).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    [`&.${menuItemClasses$1.focusVisible}`]: {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.focusOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses$1.selected}:hover`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses$1.focusVisible}`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.focus
  },
  [`&.${menuItemClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses$1.root}`]: {
    marginTop: theme2.spacing(1),
    marginBottom: theme2.spacing(1)
  },
  [`& + .${dividerClasses$1.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses$1.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses$1.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses$1.root}`]: {
    minWidth: 36
  }
}, !ownerState.dense && {
  [theme2.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, ownerState.dense && _extends$8({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, theme2.typography.body2, {
  [`& .${listItemIconClasses$1.root} svg`]: {
    fontSize: "1.25rem"
  }
})));
const MenuItem$1 = /* @__PURE__ */ reactExports.forwardRef(function MenuItem(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$s);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$8({}, props, {
    dense: childContext.dense,
    divider,
    disableGutters
  });
  const classes = useUtilityClasses$k(props);
  const handleRef = useForkRef(menuItemRef, ref);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsx(MenuItemRoot, _extends$8({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      className: clsx(classes.root, className)
    }, other, {
      ownerState,
      classes
    }))
  });
});
const MenuItem$2 = MenuItem$1;
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput"]);
const nativeSelectClasses$1 = nativeSelectClasses;
const _excluded$r = ["className", "disabled", "IconComponent", "inputRef", "variant"];
const useUtilityClasses$j = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes);
};
const nativeSelectSelectStyles = ({
  ownerState,
  theme: theme2
}) => _extends$8({
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  borderRadius: 0,
  // Reset
  cursor: "pointer",
  "&:focus": _extends$8({}, theme2.vars ? {
    backgroundColor: `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
  }, {
    borderRadius: 0
    // Reset Chrome style
  }),
  // Remove IE11 arrow
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${nativeSelectClasses$1.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme2.vars || theme2).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  "&&&": {
    paddingRight: 24,
    minWidth: 16
    // So it doesn't collapse.
  }
}, ownerState.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, ownerState.variant === "outlined" && {
  borderRadius: (theme2.vars || theme2).shape.borderRadius,
  "&:focus": {
    borderRadius: (theme2.vars || theme2).shape.borderRadius
    // Reset the reset for Chrome style
  },
  "&&&": {
    paddingRight: 32
  }
});
const NativeSelectSelect = styled$2("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], {
      [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
    }];
  }
})(nativeSelectSelectStyles);
const nativeSelectIconStyles = ({
  ownerState,
  theme: theme2
}) => _extends$8({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  // Center vertically, height is 1em
  pointerEvents: "none",
  // Don't block pointer events on the select under the icon.
  color: (theme2.vars || theme2).palette.action.active,
  [`&.${nativeSelectClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.action.disabled
  }
}, ownerState.open && {
  transform: "rotate(180deg)"
}, ownerState.variant === "filled" && {
  right: 7
}, ownerState.variant === "outlined" && {
  right: 7
});
const NativeSelectIcon = styled$2("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
  const {
    className,
    disabled,
    IconComponent,
    inputRef,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$r);
  const ownerState = _extends$8({}, props, {
    disabled,
    variant
  });
  const classes = useUtilityClasses$j(ownerState);
  return /* @__PURE__ */ jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsx(NativeSelectSelect, _extends$8({
      ownerState,
      className: clsx(classes.select, className),
      disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /* @__PURE__ */ jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes.icon
    })]
  });
});
const NativeSelectInput$1 = NativeSelectInput;
var _span$1;
const _excluded$q = ["children", "classes", "className", "label", "notched"];
const NotchedOutlineRoot$1 = styled$2("fieldset")({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled$2("legend")(({
  ownerState,
  theme: theme2
}) => _extends$8({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden"
}, !ownerState.withLabel && {
  padding: 0,
  lineHeight: "11px",
  // sync with `height` in `legend` styles
  transition: theme2.transitions.create("width", {
    duration: 150,
    easing: theme2.transitions.easing.easeOut
  })
}, ownerState.withLabel && _extends$8({
  display: "block",
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: theme2.transitions.create("max-width", {
    duration: 50,
    easing: theme2.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, ownerState.notched && {
  maxWidth: "100%",
  transition: theme2.transitions.create("max-width", {
    duration: 100,
    easing: theme2.transitions.easing.easeOut,
    delay: 50
  })
})));
function NotchedOutline(props) {
  const {
    className,
    label,
    notched
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$q);
  const withLabel = label != null && label !== "";
  const ownerState = _extends$8({}, props, {
    notched,
    withLabel
  });
  return /* @__PURE__ */ jsx(NotchedOutlineRoot$1, _extends$8({
    "aria-hidden": true,
    className,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$1 || (_span$1 = /* @__PURE__ */ jsx("span", {
          className: "notranslate",
          children: ""
        }))
      )
    })
  }));
}
const _excluded$p = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
const useUtilityClasses$i = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes);
  return _extends$8({}, classes, composedClasses);
};
const OutlinedInputRoot = styled$2(InputBaseRoot, {
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) || prop3 === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return _extends$8({
    position: "relative",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      }
    },
    [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette[ownerState.color].main,
      borderWidth: 2
    },
    [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.error.main
    },
    [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme2.vars || theme2).palette.action.disabled
    }
  }, ownerState.startAdornment && {
    paddingLeft: 14
  }, ownerState.endAdornment && {
    paddingRight: 14
  }, ownerState.multiline && _extends$8({
    padding: "16.5px 14px"
  }, ownerState.size === "small" && {
    padding: "8.5px 14px"
  }));
});
const NotchedOutlineRoot = styled$2(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles2) => styles2.notchedOutline
})(({
  theme: theme2
}) => {
  const borderColor2 = theme2.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme2.vars ? `rgba(${theme2.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
});
const OutlinedInputInput = styled$2(InputBaseComponent, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  padding: "16.5px 14px"
}, !theme2.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme2.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme2.palette.mode === "light" ? null : "#fff",
    caretColor: theme2.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, theme2.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [theme2.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  padding: "8.5px 14px"
}, ownerState.multiline && {
  padding: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}));
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
  const props = useThemeProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    type: type2 = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$p);
  const classes = useUtilityClasses$i(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["required"]
  });
  const ownerState = _extends$8({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type: type2
  });
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
  return /* @__PURE__ */ jsx(InputBase$1, _extends$8({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    renderSuffix: (state) => /* @__PURE__ */ jsx(NotchedOutlineRoot, {
      ownerState,
      className: classes.notchedOutline,
      label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxs(reactExports.Fragment, {
        children: [label, "", "*"]
      })) : label,
      notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type: type2
  }, other, {
    classes: _extends$8({}, classes, {
      notchedOutline: null
    })
  }));
});
OutlinedInput.muiName = "Input";
const OutlinedInput$1 = OutlinedInput;
const FirstPageIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage");
const LastPageIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage");
function getSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses("MuiSelect", ["select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput"]);
const selectClasses$1 = selectClasses;
var _span;
const _excluded$o = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
const SelectSelect = styled$2("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses$1.select}`]: styles2.select
      },
      {
        [`&.${selectClasses$1.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses$1.multiple}`]: styles2.multiple
      }
    ];
  }
})(nativeSelectSelectStyles, {
  // Win specificity over the input base
  [`&.${selectClasses$1.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon = styled$2("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const SelectNativeInput = styled$2("input", {
  shouldForwardProp: (prop3) => slotShouldForwardProp(prop3) && prop3 !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (props, styles2) => styles2.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a2, b2) {
  if (typeof b2 === "object" && b2 !== null) {
    return a2 === b2;
  }
  return String(a2) === String(b2);
}
function isEmpty$2(display2) {
  return display2 == null || typeof display2 === "string" && !display2.trim();
}
const useUtilityClasses$h = (ownerState) => {
  const {
    classes,
    variant,
    disabled,
    multiple,
    open
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes);
};
const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
  const {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name,
    onBlur,
    onChange,
    onClose,
    onFocus,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    value: valueProp,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$o);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = reactExports.useRef(null);
  const displayRef = reactExports.useRef(null);
  const [displayNode, setDisplayNode] = reactExports.useState(null);
  const {
    current: isOpenControlled
  } = reactExports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
  const handleRef = useForkRef(ref, inputRefProp);
  const handleDisplayRef = reactExports.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  reactExports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  reactExports.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  reactExports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update2 = (open2, event) => {
    if (open2) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : displayNode.clientWidth);
      setOpenState(open2);
    }
  };
  const handleMouseDown = (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update2(true, event);
  };
  const handleClose = (event) => {
    update2(false, event);
  };
  const childrenArray = reactExports.Children.toArray(children);
  const handleChange = (event) => {
    const index2 = childrenArray.map((child2) => child2.props.value).indexOf(event.target.value);
    if (index2 === -1) {
      return;
    }
    const child = childrenArray[index2];
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = (child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update2(false, event);
    }
  };
  const handleKeyDown2 = (event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/example-index/combobox/combobox-select-only.html
        "Enter"
      ];
      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update2(true, event);
      }
    }
  };
  const open = displayNode !== null && openState;
  const handleBlur = (event) => {
    if (!open && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name
        }
      });
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  let display2;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display2 = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child, index2, arr) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage(2));
      }
      selected = value.some((v2) => areEqualValues(v2, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    if (child.props.value === void 0) {
      return /* @__PURE__ */ reactExports.cloneElement(child, {
        "aria-readonly": true,
        role: "option"
      });
    }
    const isFirstSelectableElement = () => {
      if (value) {
        return selected;
      }
      const firstSelectableElement = arr.find((item) => item.props.value !== void 0 && item.props.disabled !== true);
      if (child === firstSelectableElement) {
        return true;
      }
      return selected;
    };
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected: arr[0].props.value === void 0 || arr[0].props.disabled === true ? isFirstSelectableElement() : selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display2 = null;
      } else {
        display2 = displayMultiple.reduce((output, child, index2) => {
          output.push(child);
          if (index2 < displayMultiple.length - 1) {
            output.push(", ");
          }
          return output;
        }, []);
      }
    } else {
      display2 = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = displayNode.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
  const ownerState = _extends$8({}, props, {
    variant,
    value,
    open
  });
  const classes = useUtilityClasses$h(ownerState);
  return /* @__PURE__ */ jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsx(SelectSelect, _extends$8({
      ref: handleDisplayRef,
      tabIndex,
      role: "button",
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown2,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus
    }, SelectDisplayProps, {
      ownerState,
      className: clsx(SelectDisplayProps.className, classes.select, className),
      id: buttonId,
      children: isEmpty$2(display2) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span || (_span = /* @__PURE__ */ jsx("span", {
          className: "notranslate",
          children: ""
        }))
      ) : display2
    })), /* @__PURE__ */ jsx(SelectNativeInput, _extends$8({
      value: Array.isArray(value) ? value.join(",") : value,
      name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes.nativeInput,
      autoFocus,
      ownerState
    }, other)), /* @__PURE__ */ jsx(SelectIcon, {
      as: IconComponent,
      className: classes.icon,
      ownerState
    }), /* @__PURE__ */ jsx(Menu$3, _extends$8({
      id: `menu-${name || ""}`,
      anchorEl: displayNode,
      open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, MenuProps, {
      MenuListProps: _extends$8({
        "aria-labelledby": labelId,
        role: "listbox",
        disableListWrap: true
      }, MenuProps.MenuListProps),
      PaperProps: _extends$8({}, MenuProps.PaperProps, {
        style: _extends$8({
          minWidth: menuMinWidth
        }, MenuProps.PaperProps != null ? MenuProps.PaperProps.style : null)
      }),
      children: items
    }))]
  });
});
const SelectInput$1 = SelectInput;
var _StyledInput, _StyledFilledInput;
const _excluded$n = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"];
const useUtilityClasses$g = (ownerState) => {
  const {
    classes
  } = ownerState;
  return classes;
};
const styledRootConfig = {
  name: "MuiSelect",
  overridesResolver: (props, styles2) => styles2.root,
  shouldForwardProp: (prop3) => rootShouldForwardProp(prop3) && prop3 !== "variant",
  slot: "Root"
};
const StyledInput = styled$2(Input$1, styledRootConfig)("");
const StyledOutlinedInput = styled$2(OutlinedInput$1, styledRootConfig)("");
const StyledFilledInput = styled$2(FilledInput$1, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
  const props = useThemeProps({
    name: "MuiSelect",
    props: inProps
  });
  const {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon,
    id: id2,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$n);
  const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant"]
  });
  const variant = fcs.variant || variantProp;
  const InputComponent = input || {
    standard: _StyledInput || (_StyledInput = /* @__PURE__ */ jsx(StyledInput, {})),
    outlined: /* @__PURE__ */ jsx(StyledOutlinedInput, {
      label
    }),
    filled: _StyledFilledInput || (_StyledFilledInput = /* @__PURE__ */ jsx(StyledFilledInput, {}))
  }[variant];
  const ownerState = _extends$8({}, props, {
    variant,
    classes: classesProp
  });
  const classes = useUtilityClasses$g(ownerState);
  const inputComponentRef = useForkRef(ref, InputComponent.ref);
  return /* @__PURE__ */ jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$8({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: _extends$8({
        children,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple
      }, native ? {
        id: id2
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps: _extends$8({
          id: id2
        }, SelectDisplayProps)
      }, inputProps, {
        classes: inputProps ? deepmerge(classes, inputProps.classes) : classes
      }, input ? input.props.inputProps : {})
    }, multiple && native && variant === "outlined" ? {
      notched: true
    } : {}, {
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className)
    }, !input && {
      variant
    }, other))
  });
});
Select.muiName = "Select";
const Select$1 = Select;
function getSkeletonUtilityClass(slot) {
  return generateUtilityClass("MuiSkeleton", slot);
}
generateUtilityClasses("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
const _excluded$m = ["animation", "className", "component", "height", "style", "variant", "width"];
let _$1 = (t3) => t3, _t, _t2, _t3, _t4;
const useUtilityClasses$f = (ownerState) => {
  const {
    classes,
    variant,
    animation,
    hasChildren,
    width: width3,
    height: height3
  } = ownerState;
  const slots = {
    root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width3 && "fitContent", hasChildren && !height3 && "heightAuto"]
  };
  return composeClasses(slots, getSkeletonUtilityClass, classes);
};
const pulseKeyframe = keyframes(_t || (_t = _$1`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`));
const waveKeyframe = keyframes(_t2 || (_t2 = _$1`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`));
const SkeletonRoot = styled$2("span", {
  name: "MuiSkeleton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const radiusUnit = getUnit(theme2.shape.borderRadius) || "px";
  const radiusValue = toUnitless(theme2.shape.borderRadius);
  return _extends$8({
    display: "block",
    // Create a "on paper" color with sufficient contrast retaining the color
    backgroundColor: theme2.vars ? theme2.vars.palette.Skeleton.bg : alpha(theme2.palette.text.primary, theme2.palette.mode === "light" ? 0.11 : 0.13),
    height: "1.2em"
  }, ownerState.variant === "text" && {
    marginTop: 0,
    marginBottom: 0,
    height: "auto",
    transformOrigin: "0 55%",
    transform: "scale(1, 0.60)",
    borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
    "&:empty:before": {
      content: '"\\00a0"'
    }
  }, ownerState.variant === "circular" && {
    borderRadius: "50%"
  }, ownerState.variant === "rounded" && {
    borderRadius: (theme2.vars || theme2).shape.borderRadius
  }, ownerState.hasChildren && {
    "& > *": {
      visibility: "hidden"
    }
  }, ownerState.hasChildren && !ownerState.width && {
    maxWidth: "fit-content"
  }, ownerState.hasChildren && !ownerState.height && {
    height: "auto"
  });
}, ({
  ownerState
}) => ownerState.animation === "pulse" && css(_t3 || (_t3 = _$1`
      animation: ${0} 1.5s ease-in-out 0.5s infinite;
    `), pulseKeyframe), ({
  ownerState,
  theme: theme2
}) => ownerState.animation === "wave" && css(_t4 || (_t4 = _$1`
      position: relative;
      overflow: hidden;

      /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
      -webkit-mask-image: -webkit-radial-gradient(white, black);

      &::after {
        animation: ${0} 1.6s linear 0.5s infinite;
        background: linear-gradient(
          90deg,
          transparent,
          ${0},
          transparent
        );
        content: '';
        position: absolute;
        transform: translateX(-100%); /* Avoid flash during server-side hydration */
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
      }
    `), waveKeyframe, (theme2.vars || theme2).palette.action.hover));
const Skeleton = /* @__PURE__ */ reactExports.forwardRef(function Skeleton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSkeleton"
  });
  const {
    animation = "pulse",
    className,
    component = "span",
    height: height3,
    style: style2,
    variant = "text",
    width: width3
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$m);
  const ownerState = _extends$8({}, props, {
    animation,
    component,
    variant,
    hasChildren: Boolean(other.children)
  });
  const classes = useUtilityClasses$f(ownerState);
  return /* @__PURE__ */ jsx(SkeletonRoot, _extends$8({
    as: component,
    ref,
    className: clsx(classes.root, className),
    ownerState
  }, other, {
    style: _extends$8({
      width: width3,
      height: height3
    }, style2)
  }));
});
const Skeleton$1 = Skeleton;
function getSnackbarContentUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbarContent", slot);
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const _excluded$l = ["action", "className", "message", "role"];
const useUtilityClasses$e = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    action: ["action"],
    message: ["message"]
  };
  return composeClasses(slots, getSnackbarContentUtilityClass, classes);
};
const SnackbarContentRoot = styled$2(Paper$1, {
  name: "MuiSnackbarContent",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => {
  const emphasis = theme2.palette.mode === "light" ? 0.8 : 0.98;
  const backgroundColor2 = emphasize(theme2.palette.background.default, emphasis);
  return _extends$8({}, theme2.typography.body2, {
    color: theme2.vars ? theme2.vars.palette.SnackbarContent.color : theme2.palette.getContrastText(backgroundColor2),
    backgroundColor: theme2.vars ? theme2.vars.palette.SnackbarContent.bg : backgroundColor2,
    display: "flex",
    alignItems: "center",
    flexWrap: "wrap",
    padding: "6px 16px",
    borderRadius: (theme2.vars || theme2).shape.borderRadius,
    flexGrow: 1,
    [theme2.breakpoints.up("sm")]: {
      flexGrow: "initial",
      minWidth: 288
    }
  });
});
const SnackbarContentMessage = styled$2("div", {
  name: "MuiSnackbarContent",
  slot: "Message",
  overridesResolver: (props, styles2) => styles2.message
})({
  padding: "8px 0"
});
const SnackbarContentAction = styled$2("div", {
  name: "MuiSnackbarContent",
  slot: "Action",
  overridesResolver: (props, styles2) => styles2.action
})({
  display: "flex",
  alignItems: "center",
  marginLeft: "auto",
  paddingLeft: 16,
  marginRight: -8
});
const SnackbarContent = /* @__PURE__ */ reactExports.forwardRef(function SnackbarContent2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSnackbarContent"
  });
  const {
    action,
    className,
    message,
    role = "alert"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$l);
  const ownerState = props;
  const classes = useUtilityClasses$e(ownerState);
  return /* @__PURE__ */ jsxs(SnackbarContentRoot, _extends$8({
    role,
    square: true,
    elevation: 6,
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other, {
    children: [/* @__PURE__ */ jsx(SnackbarContentMessage, {
      className: classes.message,
      ownerState,
      children: message
    }), action ? /* @__PURE__ */ jsx(SnackbarContentAction, {
      className: classes.action,
      ownerState,
      children: action
    }) : null]
  }));
});
const SnackbarContent$1 = SnackbarContent;
function getSnackbarUtilityClass(slot) {
  return generateUtilityClass("MuiSnackbar", slot);
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const _excluded$k = ["onEnter", "onExited"], _excluded2$1 = ["action", "anchorOrigin", "autoHideDuration", "children", "className", "ClickAwayListenerProps", "ContentProps", "disableWindowBlurListener", "message", "onBlur", "onClose", "onFocus", "onMouseEnter", "onMouseLeave", "open", "resumeHideDuration", "TransitionComponent", "transitionDuration", "TransitionProps"];
const useUtilityClasses$d = (ownerState) => {
  const {
    classes,
    anchorOrigin
  } = ownerState;
  const slots = {
    root: ["root", `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`]
  };
  return composeClasses(slots, getSnackbarUtilityClass, classes);
};
const SnackbarRoot = styled$2("div", {
  name: "MuiSnackbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[`anchorOrigin${capitalize(ownerState.anchorOrigin.vertical)}${capitalize(ownerState.anchorOrigin.horizontal)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => {
  const center = {
    left: "50%",
    right: "auto",
    transform: "translateX(-50%)"
  };
  return _extends$8({
    zIndex: (theme2.vars || theme2).zIndex.snackbar,
    position: "fixed",
    display: "flex",
    left: 8,
    right: 8,
    justifyContent: "center",
    alignItems: "center"
  }, ownerState.anchorOrigin.vertical === "top" ? {
    top: 8
  } : {
    bottom: 8
  }, ownerState.anchorOrigin.horizontal === "left" && {
    justifyContent: "flex-start"
  }, ownerState.anchorOrigin.horizontal === "right" && {
    justifyContent: "flex-end"
  }, {
    [theme2.breakpoints.up("sm")]: _extends$8({}, ownerState.anchorOrigin.vertical === "top" ? {
      top: 24
    } : {
      bottom: 24
    }, ownerState.anchorOrigin.horizontal === "center" && center, ownerState.anchorOrigin.horizontal === "left" && {
      left: 24,
      right: "auto"
    }, ownerState.anchorOrigin.horizontal === "right" && {
      right: 24,
      left: "auto"
    })
  });
});
const Snackbar = /* @__PURE__ */ reactExports.forwardRef(function Snackbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSnackbar"
  });
  const theme2 = useTheme();
  const defaultTransitionDuration = {
    enter: theme2.transitions.duration.enteringScreen,
    exit: theme2.transitions.duration.leavingScreen
  };
  const {
    action,
    anchorOrigin: {
      vertical: vertical2,
      horizontal: horizontal2
    } = {
      vertical: "bottom",
      horizontal: "left"
    },
    autoHideDuration = null,
    children,
    className,
    ClickAwayListenerProps,
    ContentProps,
    disableWindowBlurListener = false,
    message,
    onBlur,
    onClose,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    open,
    resumeHideDuration,
    TransitionComponent = Grow$1,
    transitionDuration = defaultTransitionDuration,
    TransitionProps: {
      onEnter,
      onExited
    } = {}
  } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$k), other = _objectWithoutPropertiesLoose(props, _excluded2$1);
  const ownerState = _extends$8({}, props, {
    anchorOrigin: {
      vertical: vertical2,
      horizontal: horizontal2
    }
  });
  const classes = useUtilityClasses$d(ownerState);
  const timerAutoHide = reactExports.useRef();
  const [exited, setExited] = reactExports.useState(true);
  const handleClose = useEventCallback((...args) => {
    if (onClose) {
      onClose(...args);
    }
  });
  const setAutoHideTimer = useEventCallback((autoHideDurationParam) => {
    if (!onClose || autoHideDurationParam == null) {
      return;
    }
    clearTimeout(timerAutoHide.current);
    timerAutoHide.current = setTimeout(() => {
      handleClose(null, "timeout");
    }, autoHideDurationParam);
  });
  reactExports.useEffect(() => {
    if (open) {
      setAutoHideTimer(autoHideDuration);
    }
    return () => {
      clearTimeout(timerAutoHide.current);
    };
  }, [open, autoHideDuration, setAutoHideTimer]);
  const handlePause = () => {
    clearTimeout(timerAutoHide.current);
  };
  const handleResume = reactExports.useCallback(() => {
    if (autoHideDuration != null) {
      setAutoHideTimer(resumeHideDuration != null ? resumeHideDuration : autoHideDuration * 0.5);
    }
  }, [autoHideDuration, resumeHideDuration, setAutoHideTimer]);
  const handleFocus = (event) => {
    if (onFocus) {
      onFocus(event);
    }
    handlePause();
  };
  const handleMouseEnter = (event) => {
    if (onMouseEnter) {
      onMouseEnter(event);
    }
    handlePause();
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    handleResume();
  };
  const handleMouseLeave = (event) => {
    if (onMouseLeave) {
      onMouseLeave(event);
    }
    handleResume();
  };
  const handleClickAway = (event) => {
    if (onClose) {
      onClose(event, "clickaway");
    }
  };
  const handleExited = (node2) => {
    setExited(true);
    if (onExited) {
      onExited(node2);
    }
  };
  const handleEnter = (node2, isAppearing) => {
    setExited(false);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  };
  reactExports.useEffect(() => {
    if (!disableWindowBlurListener && open) {
      window.addEventListener("focus", handleResume);
      window.addEventListener("blur", handlePause);
      return () => {
        window.removeEventListener("focus", handleResume);
        window.removeEventListener("blur", handlePause);
      };
    }
    return void 0;
  }, [disableWindowBlurListener, handleResume, open]);
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    function handleKeyDown2(nativeEvent) {
      if (!nativeEvent.defaultPrevented) {
        if (nativeEvent.key === "Escape" || nativeEvent.key === "Esc") {
          if (onClose) {
            onClose(nativeEvent, "escapeKeyDown");
          }
        }
      }
    }
    document.addEventListener("keydown", handleKeyDown2);
    return () => {
      document.removeEventListener("keydown", handleKeyDown2);
    };
  }, [exited, open, onClose]);
  if (!open && exited) {
    return null;
  }
  return /* @__PURE__ */ jsx(ClickAwayListener, _extends$8({
    onClickAway: handleClickAway
  }, ClickAwayListenerProps, {
    children: /* @__PURE__ */ jsx(SnackbarRoot, _extends$8({
      className: clsx(classes.root, className),
      onBlur: handleBlur,
      onFocus: handleFocus,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      ownerState,
      ref,
      role: "presentation"
    }, other, {
      children: /* @__PURE__ */ jsx(TransitionComponent, _extends$8({
        appear: true,
        in: open,
        timeout: transitionDuration,
        direction: vertical2 === "top" ? "down" : "up",
        onEnter: handleEnter,
        onExited: handleExited
      }, TransitionProps, {
        children: children || /* @__PURE__ */ jsx(SnackbarContent$1, _extends$8({
          message,
          action
        }, ContentProps))
      }))
    }))
  }));
});
const Snackbar$1 = Snackbar;
const _excluded$j = ["component", "direction", "spacing", "divider", "children"];
function joinChildren(children, separator) {
  const childrenArray = reactExports.Children.toArray(children).filter(Boolean);
  return childrenArray.reduce((output, child, index2) => {
    output.push(child);
    if (index2 < childrenArray.length - 1) {
      output.push(/* @__PURE__ */ reactExports.cloneElement(separator, {
        key: `separator-${index2}`
      }));
    }
    return output;
  }, []);
}
const getSideFromDirection = (direction) => {
  return {
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
  }[direction];
};
const style$3 = ({
  ownerState,
  theme: theme2
}) => {
  let styles2 = _extends$8({
    display: "flex",
    flexDirection: "column"
  }, handleBreakpoints({
    theme: theme2
  }, resolveBreakpointValues({
    values: ownerState.direction,
    breakpoints: theme2.breakpoints.values
  }), (propValue) => ({
    flexDirection: propValue
  })));
  if (ownerState.spacing) {
    const transformer = createUnarySpacing(theme2);
    const base = Object.keys(theme2.breakpoints.values).reduce((acc, breakpoint) => {
      if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
        acc[breakpoint] = true;
      }
      return acc;
    }, {});
    const directionValues = resolveBreakpointValues({
      values: ownerState.direction,
      base
    });
    const spacingValues = resolveBreakpointValues({
      values: ownerState.spacing,
      base
    });
    if (typeof directionValues === "object") {
      Object.keys(directionValues).forEach((breakpoint, index2, breakpoints) => {
        const directionValue = directionValues[breakpoint];
        if (!directionValue) {
          const previousDirectionValue = index2 > 0 ? directionValues[breakpoints[index2 - 1]] : "column";
          directionValues[breakpoint] = previousDirectionValue;
        }
      });
    }
    const styleFromPropValue = (propValue, breakpoint) => {
      return {
        "& > :not(style) + :not(style)": {
          margin: 0,
          [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue$1(transformer, propValue)
        }
      };
    };
    styles2 = deepmerge(styles2, handleBreakpoints({
      theme: theme2
    }, spacingValues, styleFromPropValue));
  }
  styles2 = mergeBreakpointsInOrder(theme2.breakpoints, styles2);
  return styles2;
};
const StackRoot = styled$2("div", {
  name: "MuiStack",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    return [styles2.root];
  }
})(style$3);
const Stack = /* @__PURE__ */ reactExports.forwardRef(function Stack2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiStack"
  });
  const props = extendSxProp(themeProps);
  const {
    component = "div",
    direction = "column",
    spacing: spacing2 = 0,
    divider,
    children
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$j);
  const ownerState = {
    direction,
    spacing: spacing2
  };
  return /* @__PURE__ */ jsx(StackRoot, _extends$8({
    as: component,
    ownerState,
    ref
  }, other, {
    children: divider ? joinChildren(children, divider) : children
  }));
});
const Stack$1 = Stack;
function getTabUtilityClass(slot) {
  return generateUtilityClass("MuiTab", slot);
}
const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper"]);
const tabClasses$1 = tabClasses;
const _excluded$i = ["className", "disabled", "disableFocusRipple", "fullWidth", "icon", "iconPosition", "indicator", "label", "onChange", "onClick", "onFocus", "selected", "selectionFollowsFocus", "textColor", "value", "wrapped"];
const useUtilityClasses$c = (ownerState) => {
  const {
    classes,
    textColor,
    fullWidth,
    wrapped,
    icon,
    label,
    selected,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", icon && label && "labelIcon", `textColor${capitalize(textColor)}`, fullWidth && "fullWidth", wrapped && "wrapped", selected && "selected", disabled && "disabled"],
    iconWrapper: ["iconWrapper"]
  };
  return composeClasses(slots, getTabUtilityClass, classes);
};
const TabRoot = styled$2(ButtonBase$1, {
  name: "MuiTab",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.label && ownerState.icon && styles2.labelIcon, styles2[`textColor${capitalize(ownerState.textColor)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.wrapped && styles2.wrapped];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({}, theme2.typography.button, {
  maxWidth: 360,
  minWidth: 90,
  position: "relative",
  minHeight: 48,
  flexShrink: 0,
  padding: "12px 16px",
  overflow: "hidden",
  whiteSpace: "normal",
  textAlign: "center"
}, ownerState.label && {
  flexDirection: ownerState.iconPosition === "top" || ownerState.iconPosition === "bottom" ? "column" : "row"
}, {
  lineHeight: 1.25
}, ownerState.icon && ownerState.label && {
  minHeight: 72,
  paddingTop: 9,
  paddingBottom: 9,
  [`& > .${tabClasses$1.iconWrapper}`]: _extends$8({}, ownerState.iconPosition === "top" && {
    marginBottom: 6
  }, ownerState.iconPosition === "bottom" && {
    marginTop: 6
  }, ownerState.iconPosition === "start" && {
    marginRight: theme2.spacing(1)
  }, ownerState.iconPosition === "end" && {
    marginLeft: theme2.spacing(1)
  })
}, ownerState.textColor === "inherit" && {
  color: "inherit",
  opacity: 0.6,
  // same opacity as theme.palette.text.secondary
  [`&.${tabClasses$1.selected}`]: {
    opacity: 1
  },
  [`&.${tabClasses$1.disabled}`]: {
    opacity: (theme2.vars || theme2).palette.action.disabledOpacity
  }
}, ownerState.textColor === "primary" && {
  color: (theme2.vars || theme2).palette.text.secondary,
  [`&.${tabClasses$1.selected}`]: {
    color: (theme2.vars || theme2).palette.primary.main
  },
  [`&.${tabClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  }
}, ownerState.textColor === "secondary" && {
  color: (theme2.vars || theme2).palette.text.secondary,
  [`&.${tabClasses$1.selected}`]: {
    color: (theme2.vars || theme2).palette.secondary.main
  },
  [`&.${tabClasses$1.disabled}`]: {
    color: (theme2.vars || theme2).palette.text.disabled
  }
}, ownerState.fullWidth && {
  flexShrink: 1,
  flexGrow: 1,
  flexBasis: 0,
  maxWidth: "none"
}, ownerState.wrapped && {
  fontSize: theme2.typography.pxToRem(12)
}));
const Tab = /* @__PURE__ */ reactExports.forwardRef(function Tab2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTab"
  });
  const {
    className,
    disabled = false,
    disableFocusRipple = false,
    // eslint-disable-next-line react/prop-types
    fullWidth,
    icon: iconProp,
    iconPosition = "top",
    // eslint-disable-next-line react/prop-types
    indicator,
    label,
    onChange,
    onClick,
    onFocus,
    // eslint-disable-next-line react/prop-types
    selected,
    // eslint-disable-next-line react/prop-types
    selectionFollowsFocus,
    // eslint-disable-next-line react/prop-types
    textColor = "inherit",
    value,
    wrapped = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$i);
  const ownerState = _extends$8({}, props, {
    disabled,
    disableFocusRipple,
    selected,
    icon: !!iconProp,
    iconPosition,
    label: !!label,
    fullWidth,
    textColor,
    wrapped
  });
  const classes = useUtilityClasses$c(ownerState);
  const icon = iconProp && label && /* @__PURE__ */ reactExports.isValidElement(iconProp) ? /* @__PURE__ */ reactExports.cloneElement(iconProp, {
    className: clsx(classes.iconWrapper, iconProp.props.className)
  }) : iconProp;
  const handleClick = (event) => {
    if (!selected && onChange) {
      onChange(event, value);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleFocus = (event) => {
    if (selectionFollowsFocus && !selected && onChange) {
      onChange(event, value);
    }
    if (onFocus) {
      onFocus(event);
    }
  };
  return /* @__PURE__ */ jsxs(TabRoot, _extends$8({
    focusRipple: !disableFocusRipple,
    className: clsx(classes.root, className),
    ref,
    role: "tab",
    "aria-selected": selected,
    disabled,
    onClick: handleClick,
    onFocus: handleFocus,
    ownerState,
    tabIndex: selected ? 0 : -1
  }, other, {
    children: [iconPosition === "top" || iconPosition === "start" ? /* @__PURE__ */ jsxs(reactExports.Fragment, {
      children: [icon, label]
    }) : /* @__PURE__ */ jsxs(reactExports.Fragment, {
      children: [label, icon]
    }), indicator]
  }));
});
const Tab$1 = Tab;
const TableContext = /* @__PURE__ */ reactExports.createContext();
const TableContext$1 = TableContext;
function getTableUtilityClass(slot) {
  return generateUtilityClass("MuiTable", slot);
}
generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);
const _excluded$h = ["className", "component", "padding", "size", "stickyHeader"];
const useUtilityClasses$b = (ownerState) => {
  const {
    classes,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", stickyHeader && "stickyHeader"]
  };
  return composeClasses(slots, getTableUtilityClass, classes);
};
const TableRoot = styled$2("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": _extends$8({}, theme2.typography.body2, {
    padding: theme2.spacing(2),
    color: (theme2.vars || theme2).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  })
}, ownerState.stickyHeader && {
  borderCollapse: "separate"
}));
const defaultComponent$3 = "table";
const Table = /* @__PURE__ */ reactExports.forwardRef(function Table2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTable"
  });
  const {
    className,
    component = defaultComponent$3,
    padding = "normal",
    size = "medium",
    stickyHeader = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$h);
  const ownerState = _extends$8({}, props, {
    component,
    padding,
    size,
    stickyHeader
  });
  const classes = useUtilityClasses$b(ownerState);
  const table = reactExports.useMemo(() => ({
    padding,
    size,
    stickyHeader
  }), [padding, size, stickyHeader]);
  return /* @__PURE__ */ jsx(TableContext$1.Provider, {
    value: table,
    children: /* @__PURE__ */ jsx(TableRoot, _extends$8({
      as: component,
      role: component === defaultComponent$3 ? null : "table",
      ref,
      className: clsx(classes.root, className),
      ownerState
    }, other))
  });
});
const Table$1 = Table;
const Tablelvl2Context = /* @__PURE__ */ reactExports.createContext();
const Tablelvl2Context$1 = Tablelvl2Context;
function getTableBodyUtilityClass(slot) {
  return generateUtilityClass("MuiTableBody", slot);
}
generateUtilityClasses("MuiTableBody", ["root"]);
const _excluded$g = ["className", "component"];
const useUtilityClasses$a = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableBodyUtilityClass, classes);
};
const TableBodyRoot = styled$2("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-row-group"
});
const tablelvl2$1 = {
  variant: "body"
};
const defaultComponent$2 = "tbody";
const TableBody = /* @__PURE__ */ reactExports.forwardRef(function TableBody2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableBody"
  });
  const {
    className,
    component = defaultComponent$2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const ownerState = _extends$8({}, props, {
    component
  });
  const classes = useUtilityClasses$a(ownerState);
  return /* @__PURE__ */ jsx(Tablelvl2Context$1.Provider, {
    value: tablelvl2$1,
    children: /* @__PURE__ */ jsx(TableBodyRoot, _extends$8({
      className: clsx(classes.root, className),
      as: component,
      ref,
      role: component === defaultComponent$2 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
const TableBody$1 = TableBody;
function getTableCellUtilityClass(slot) {
  return generateUtilityClass("MuiTableCell", slot);
}
const tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
const tableCellClasses$1 = tableCellClasses;
const _excluded$f = ["align", "className", "component", "padding", "scope", "size", "sortDirection", "variant"];
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes,
    variant,
    align,
    padding,
    size,
    stickyHeader
  } = ownerState;
  const slots = {
    root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize(align)}`, padding !== "normal" && `padding${capitalize(padding)}`, `size${capitalize(size)}`]
  };
  return composeClasses(slots, getTableCellUtilityClass, classes);
};
const TableCellRoot = styled$2("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({}, theme2.typography.body2, {
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: theme2.vars ? `1px solid ${theme2.vars.palette.TableCell.border}` : `1px solid
    ${theme2.palette.mode === "light" ? lighten(alpha(theme2.palette.divider, 1), 0.88) : darken(alpha(theme2.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16
}, ownerState.variant === "head" && {
  color: (theme2.vars || theme2).palette.text.primary,
  lineHeight: theme2.typography.pxToRem(24),
  fontWeight: theme2.typography.fontWeightMedium
}, ownerState.variant === "body" && {
  color: (theme2.vars || theme2).palette.text.primary
}, ownerState.variant === "footer" && {
  color: (theme2.vars || theme2).palette.text.secondary,
  lineHeight: theme2.typography.pxToRem(21),
  fontSize: theme2.typography.pxToRem(12)
}, ownerState.size === "small" && {
  padding: "6px 16px",
  [`&.${tableCellClasses$1.paddingCheckbox}`]: {
    width: 24,
    // prevent the checkbox column from growing
    padding: "0 12px 0 16px",
    "& > *": {
      padding: 0
    }
  }
}, ownerState.padding === "checkbox" && {
  width: 48,
  // prevent the checkbox column from growing
  padding: "0 0 0 4px"
}, ownerState.padding === "none" && {
  padding: 0
}, ownerState.align === "left" && {
  textAlign: "left"
}, ownerState.align === "center" && {
  textAlign: "center"
}, ownerState.align === "right" && {
  textAlign: "right",
  flexDirection: "row-reverse"
}, ownerState.align === "justify" && {
  textAlign: "justify"
}, ownerState.stickyHeader && {
  position: "sticky",
  top: 0,
  zIndex: 2,
  backgroundColor: (theme2.vars || theme2).palette.background.default
}));
const TableCell = /* @__PURE__ */ reactExports.forwardRef(function TableCell2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableCell"
  });
  const {
    align = "inherit",
    className,
    component: componentProp,
    padding: paddingProp,
    scope: scopeProp,
    size: sizeProp,
    sortDirection,
    variant: variantProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$f);
  const table = reactExports.useContext(TableContext$1);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context$1);
  const isHeadCell = tablelvl22 && tablelvl22.variant === "head";
  let component;
  if (componentProp) {
    component = componentProp;
  } else {
    component = isHeadCell ? "th" : "td";
  }
  let scope = scopeProp;
  if (!scope && isHeadCell) {
    scope = "col";
  }
  const variant = variantProp || tablelvl22 && tablelvl22.variant;
  const ownerState = _extends$8({}, props, {
    align,
    component,
    padding: paddingProp || (table && table.padding ? table.padding : "normal"),
    size: sizeProp || (table && table.size ? table.size : "medium"),
    sortDirection,
    stickyHeader: variant === "head" && table && table.stickyHeader,
    variant
  });
  const classes = useUtilityClasses$9(ownerState);
  let ariaSort = null;
  if (sortDirection) {
    ariaSort = sortDirection === "asc" ? "ascending" : "descending";
  }
  return /* @__PURE__ */ jsx(TableCellRoot, _extends$8({
    as: component,
    ref,
    className: clsx(classes.root, className),
    "aria-sort": ariaSort,
    scope,
    ownerState
  }, other));
});
const TableCell$1 = TableCell;
function getTableContainerUtilityClass(slot) {
  return generateUtilityClass("MuiTableContainer", slot);
}
generateUtilityClasses("MuiTableContainer", ["root"]);
const _excluded$e = ["className", "component"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableContainerUtilityClass, classes);
};
const TableContainerRoot = styled$2("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  width: "100%",
  overflowX: "auto"
});
const TableContainer = /* @__PURE__ */ reactExports.forwardRef(function TableContainer2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableContainer"
  });
  const {
    className,
    component = "div"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
  const ownerState = _extends$8({}, props, {
    component
  });
  const classes = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsx(TableContainerRoot, _extends$8({
    ref,
    as: component,
    className: clsx(classes.root, className),
    ownerState
  }, other));
});
const TableContainer$1 = TableContainer;
function getTableHeadUtilityClass(slot) {
  return generateUtilityClass("MuiTableHead", slot);
}
generateUtilityClasses("MuiTableHead", ["root"]);
const _excluded$d = ["className", "component"];
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTableHeadUtilityClass, classes);
};
const TableHeadRoot = styled$2("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "table-header-group"
});
const tablelvl2 = {
  variant: "head"
};
const defaultComponent$1 = "thead";
const TableHead = /* @__PURE__ */ reactExports.forwardRef(function TableHead2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableHead"
  });
  const {
    className,
    component = defaultComponent$1
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const ownerState = _extends$8({}, props, {
    component
  });
  const classes = useUtilityClasses$7(ownerState);
  return /* @__PURE__ */ jsx(Tablelvl2Context$1.Provider, {
    value: tablelvl2,
    children: /* @__PURE__ */ jsx(TableHeadRoot, _extends$8({
      as: component,
      className: clsx(classes.root, className),
      ref,
      role: component === defaultComponent$1 ? null : "rowgroup",
      ownerState
    }, other))
  });
});
const TableHead$1 = TableHead;
function getToolbarUtilityClass(slot) {
  return generateUtilityClass("MuiToolbar", slot);
}
generateUtilityClasses("MuiToolbar", ["root", "gutters", "regular", "dense"]);
const _excluded$c = ["className", "component", "disableGutters", "variant"];
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes,
    disableGutters,
    variant
  } = ownerState;
  const slots = {
    root: ["root", !disableGutters && "gutters", variant]
  };
  return composeClasses(slots, getToolbarUtilityClass, classes);
};
const ToolbarRoot = styled$2("div", {
  name: "MuiToolbar",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disableGutters && styles2.gutters, styles2[ownerState.variant]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  position: "relative",
  display: "flex",
  alignItems: "center"
}, !ownerState.disableGutters && {
  paddingLeft: theme2.spacing(2),
  paddingRight: theme2.spacing(2),
  [theme2.breakpoints.up("sm")]: {
    paddingLeft: theme2.spacing(3),
    paddingRight: theme2.spacing(3)
  }
}, ownerState.variant === "dense" && {
  minHeight: 48
}), ({
  theme: theme2,
  ownerState
}) => ownerState.variant === "regular" && theme2.mixins.toolbar);
const Toolbar = /* @__PURE__ */ reactExports.forwardRef(function Toolbar2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiToolbar"
  });
  const {
    className,
    component = "div",
    disableGutters = false,
    variant = "regular"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
  const ownerState = _extends$8({}, props, {
    component,
    disableGutters,
    variant
  });
  const classes = useUtilityClasses$6(ownerState);
  return /* @__PURE__ */ jsx(ToolbarRoot, _extends$8({
    as: component,
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other));
});
const Toolbar$1 = Toolbar;
const KeyboardArrowLeft = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft");
const KeyboardArrowRight = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
var _LastPageIcon, _FirstPageIcon, _KeyboardArrowRight$1, _KeyboardArrowLeft$1, _KeyboardArrowLeft2, _KeyboardArrowRight2, _FirstPageIcon2, _LastPageIcon2;
const _excluded$b = ["backIconButtonProps", "count", "getItemAriaLabel", "nextIconButtonProps", "onPageChange", "page", "rowsPerPage", "showFirstButton", "showLastButton"];
const TablePaginationActions = /* @__PURE__ */ reactExports.forwardRef(function TablePaginationActions2(props, ref) {
  const {
    backIconButtonProps,
    count: count2,
    getItemAriaLabel,
    nextIconButtonProps,
    onPageChange,
    page,
    rowsPerPage,
    showFirstButton,
    showLastButton
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
  const theme2 = useTheme();
  const handleFirstPageButtonClick = (event) => {
    onPageChange(event, 0);
  };
  const handleBackButtonClick = (event) => {
    onPageChange(event, page - 1);
  };
  const handleNextButtonClick = (event) => {
    onPageChange(event, page + 1);
  };
  const handleLastPageButtonClick = (event) => {
    onPageChange(event, Math.max(0, Math.ceil(count2 / rowsPerPage) - 1));
  };
  return /* @__PURE__ */ jsxs("div", _extends$8({
    ref
  }, other, {
    children: [showFirstButton && /* @__PURE__ */ jsx(IconButton$1, {
      onClick: handleFirstPageButtonClick,
      disabled: page === 0,
      "aria-label": getItemAriaLabel("first", page),
      title: getItemAriaLabel("first", page),
      children: theme2.direction === "rtl" ? _LastPageIcon || (_LastPageIcon = /* @__PURE__ */ jsx(LastPageIcon, {})) : _FirstPageIcon || (_FirstPageIcon = /* @__PURE__ */ jsx(FirstPageIcon, {}))
    }), /* @__PURE__ */ jsx(IconButton$1, _extends$8({
      onClick: handleBackButtonClick,
      disabled: page === 0,
      color: "inherit",
      "aria-label": getItemAriaLabel("previous", page),
      title: getItemAriaLabel("previous", page)
    }, backIconButtonProps, {
      children: theme2.direction === "rtl" ? _KeyboardArrowRight$1 || (_KeyboardArrowRight$1 = /* @__PURE__ */ jsx(KeyboardArrowRight, {})) : _KeyboardArrowLeft$1 || (_KeyboardArrowLeft$1 = /* @__PURE__ */ jsx(KeyboardArrowLeft, {}))
    })), /* @__PURE__ */ jsx(IconButton$1, _extends$8({
      onClick: handleNextButtonClick,
      disabled: count2 !== -1 ? page >= Math.ceil(count2 / rowsPerPage) - 1 : false,
      color: "inherit",
      "aria-label": getItemAriaLabel("next", page),
      title: getItemAriaLabel("next", page)
    }, nextIconButtonProps, {
      children: theme2.direction === "rtl" ? _KeyboardArrowLeft2 || (_KeyboardArrowLeft2 = /* @__PURE__ */ jsx(KeyboardArrowLeft, {})) : _KeyboardArrowRight2 || (_KeyboardArrowRight2 = /* @__PURE__ */ jsx(KeyboardArrowRight, {}))
    })), showLastButton && /* @__PURE__ */ jsx(IconButton$1, {
      onClick: handleLastPageButtonClick,
      disabled: page >= Math.ceil(count2 / rowsPerPage) - 1,
      "aria-label": getItemAriaLabel("last", page),
      title: getItemAriaLabel("last", page),
      children: theme2.direction === "rtl" ? _FirstPageIcon2 || (_FirstPageIcon2 = /* @__PURE__ */ jsx(FirstPageIcon, {})) : _LastPageIcon2 || (_LastPageIcon2 = /* @__PURE__ */ jsx(LastPageIcon, {}))
    })]
  }));
});
const TablePaginationActions$1 = TablePaginationActions;
function getTablePaginationUtilityClass(slot) {
  return generateUtilityClass("MuiTablePagination", slot);
}
const tablePaginationClasses = generateUtilityClasses("MuiTablePagination", ["root", "toolbar", "spacer", "selectLabel", "selectRoot", "select", "selectIcon", "input", "menuItem", "displayedRows", "actions"]);
const tablePaginationClasses$1 = tablePaginationClasses;
var _InputBase;
const _excluded$a = ["ActionsComponent", "backIconButtonProps", "className", "colSpan", "component", "count", "getItemAriaLabel", "labelDisplayedRows", "labelRowsPerPage", "nextIconButtonProps", "onPageChange", "onRowsPerPageChange", "page", "rowsPerPage", "rowsPerPageOptions", "SelectProps", "showFirstButton", "showLastButton"];
const TablePaginationRoot = styled$2(TableCell$1, {
  name: "MuiTablePagination",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme: theme2
}) => ({
  overflow: "auto",
  color: (theme2.vars || theme2).palette.text.primary,
  fontSize: theme2.typography.pxToRem(14),
  // Increase the specificity to override TableCell.
  "&:last-child": {
    padding: 0
  }
}));
const TablePaginationToolbar = styled$2(Toolbar$1, {
  name: "MuiTablePagination",
  slot: "Toolbar",
  overridesResolver: (props, styles2) => _extends$8({
    [`& .${tablePaginationClasses$1.actions}`]: styles2.actions
  }, styles2.toolbar)
})(({
  theme: theme2
}) => ({
  minHeight: 52,
  paddingRight: 2,
  [`${theme2.breakpoints.up("xs")} and (orientation: landscape)`]: {
    minHeight: 52
  },
  [theme2.breakpoints.up("sm")]: {
    minHeight: 52,
    paddingRight: 2
  },
  [`& .${tablePaginationClasses$1.actions}`]: {
    flexShrink: 0,
    marginLeft: 20
  }
}));
const TablePaginationSpacer = styled$2("div", {
  name: "MuiTablePagination",
  slot: "Spacer",
  overridesResolver: (props, styles2) => styles2.spacer
})({
  flex: "1 1 100%"
});
const TablePaginationSelectLabel = styled$2("p", {
  name: "MuiTablePagination",
  slot: "SelectLabel",
  overridesResolver: (props, styles2) => styles2.selectLabel
})(({
  theme: theme2
}) => _extends$8({}, theme2.typography.body2, {
  flexShrink: 0
}));
const TablePaginationSelect = styled$2(Select$1, {
  name: "MuiTablePagination",
  slot: "Select",
  overridesResolver: (props, styles2) => _extends$8({
    [`& .${tablePaginationClasses$1.selectIcon}`]: styles2.selectIcon,
    [`& .${tablePaginationClasses$1.select}`]: styles2.select
  }, styles2.input, styles2.selectRoot)
})({
  color: "inherit",
  fontSize: "inherit",
  flexShrink: 0,
  marginRight: 32,
  marginLeft: 8,
  [`& .${tablePaginationClasses$1.select}`]: {
    paddingLeft: 8,
    paddingRight: 24,
    textAlign: "right",
    textAlignLast: "right"
    // Align <select> on Chrome.
  }
});
const TablePaginationMenuItem = styled$2(MenuItem$2, {
  name: "MuiTablePagination",
  slot: "MenuItem",
  overridesResolver: (props, styles2) => styles2.menuItem
})({});
const TablePaginationDisplayedRows = styled$2("p", {
  name: "MuiTablePagination",
  slot: "DisplayedRows",
  overridesResolver: (props, styles2) => styles2.displayedRows
})(({
  theme: theme2
}) => _extends$8({}, theme2.typography.body2, {
  flexShrink: 0
}));
function defaultLabelDisplayedRows({
  from: from3,
  to,
  count: count2
}) {
  return `${from3}${to} of ${count2 !== -1 ? count2 : `more than ${to}`}`;
}
function defaultGetAriaLabel(type2) {
  return `Go to ${type2} page`;
}
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    toolbar: ["toolbar"],
    spacer: ["spacer"],
    selectLabel: ["selectLabel"],
    select: ["select"],
    input: ["input"],
    selectIcon: ["selectIcon"],
    menuItem: ["menuItem"],
    displayedRows: ["displayedRows"],
    actions: ["actions"]
  };
  return composeClasses(slots, getTablePaginationUtilityClass, classes);
};
const TablePagination = /* @__PURE__ */ reactExports.forwardRef(function TablePagination2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTablePagination"
  });
  const {
    ActionsComponent = TablePaginationActions$1,
    backIconButtonProps,
    className,
    colSpan: colSpanProp,
    component = TableCell$1,
    count: count2,
    getItemAriaLabel = defaultGetAriaLabel,
    labelDisplayedRows = defaultLabelDisplayedRows,
    labelRowsPerPage = "Rows per page:",
    nextIconButtonProps,
    onPageChange,
    onRowsPerPageChange,
    page,
    rowsPerPage,
    rowsPerPageOptions = [10, 25, 50, 100],
    SelectProps = {},
    showFirstButton = false,
    showLastButton = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
  const ownerState = props;
  const classes = useUtilityClasses$5(ownerState);
  const MenuItemComponent = SelectProps.native ? "option" : TablePaginationMenuItem;
  let colSpan;
  if (component === TableCell$1 || component === "td") {
    colSpan = colSpanProp || 1e3;
  }
  const selectId = useId(SelectProps.id);
  const labelId = useId(SelectProps.labelId);
  const getLabelDisplayedRowsTo = () => {
    if (count2 === -1) {
      return (page + 1) * rowsPerPage;
    }
    return rowsPerPage === -1 ? count2 : Math.min(count2, (page + 1) * rowsPerPage);
  };
  return /* @__PURE__ */ jsx(TablePaginationRoot, _extends$8({
    colSpan,
    ref,
    as: component,
    ownerState,
    className: clsx(classes.root, className)
  }, other, {
    children: /* @__PURE__ */ jsxs(TablePaginationToolbar, {
      className: classes.toolbar,
      children: [/* @__PURE__ */ jsx(TablePaginationSpacer, {
        className: classes.spacer
      }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ jsx(TablePaginationSelectLabel, {
        className: classes.selectLabel,
        id: labelId,
        children: labelRowsPerPage
      }), rowsPerPageOptions.length > 1 && /* @__PURE__ */ jsx(TablePaginationSelect, _extends$8({
        variant: "standard"
      }, !SelectProps.variant && {
        input: _InputBase || (_InputBase = /* @__PURE__ */ jsx(InputBase$1, {}))
      }, {
        value: rowsPerPage,
        onChange: onRowsPerPageChange,
        id: selectId,
        labelId
      }, SelectProps, {
        classes: _extends$8({}, SelectProps.classes, {
          // TODO v5 remove `classes.input`
          root: clsx(classes.input, classes.selectRoot, (SelectProps.classes || {}).root),
          select: clsx(classes.select, (SelectProps.classes || {}).select),
          // TODO v5 remove `selectIcon`
          icon: clsx(classes.selectIcon, (SelectProps.classes || {}).icon)
        }),
        children: rowsPerPageOptions.map((rowsPerPageOption) => /* @__PURE__ */ reactExports.createElement(MenuItemComponent, _extends$8({}, !isHostComponent(MenuItemComponent) && {
          ownerState
        }, {
          className: classes.menuItem,
          key: rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption,
          value: rowsPerPageOption.value ? rowsPerPageOption.value : rowsPerPageOption
        }), rowsPerPageOption.label ? rowsPerPageOption.label : rowsPerPageOption))
      })), /* @__PURE__ */ jsx(TablePaginationDisplayedRows, {
        className: classes.displayedRows,
        children: labelDisplayedRows({
          from: count2 === 0 ? 0 : page * rowsPerPage + 1,
          to: getLabelDisplayedRowsTo(),
          count: count2 === -1 ? -1 : count2,
          page
        })
      }), /* @__PURE__ */ jsx(ActionsComponent, {
        className: classes.actions,
        backIconButtonProps,
        count: count2,
        nextIconButtonProps,
        onPageChange,
        page,
        rowsPerPage,
        showFirstButton,
        showLastButton,
        getItemAriaLabel
      })]
    })
  }));
});
const TablePagination$1 = TablePagination;
function getTableRowUtilityClass(slot) {
  return generateUtilityClass("MuiTableRow", slot);
}
const tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
const tableRowClasses$1 = tableRowClasses;
const _excluded$9 = ["className", "component", "hover", "selected"];
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes,
    selected,
    hover,
    head,
    footer
  } = ownerState;
  const slots = {
    root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
  };
  return composeClasses(slots, getTableRowUtilityClass, classes);
};
const TableRowRoot = styled$2("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
  }
})(({
  theme: theme2
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${tableRowClasses$1.hover}:hover`]: {
    backgroundColor: (theme2.vars || theme2).palette.action.hover
  },
  [`&.${tableRowClasses$1.selected}`]: {
    backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / ${theme2.vars.palette.action.selectedOpacity})` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme2.vars ? `rgba(${theme2.vars.palette.primary.mainChannel} / calc(${theme2.vars.palette.action.selectedOpacity} + ${theme2.vars.palette.action.hoverOpacity}))` : alpha(theme2.palette.primary.main, theme2.palette.action.selectedOpacity + theme2.palette.action.hoverOpacity)
    }
  }
}));
const defaultComponent = "tr";
const TableRow = /* @__PURE__ */ reactExports.forwardRef(function TableRow2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableRow"
  });
  const {
    className,
    component = defaultComponent,
    hover = false,
    selected = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$9);
  const tablelvl22 = reactExports.useContext(Tablelvl2Context$1);
  const ownerState = _extends$8({}, props, {
    component,
    hover,
    selected,
    head: tablelvl22 && tablelvl22.variant === "head",
    footer: tablelvl22 && tablelvl22.variant === "footer"
  });
  const classes = useUtilityClasses$4(ownerState);
  return /* @__PURE__ */ jsx(TableRowRoot, _extends$8({
    as: component,
    ref,
    className: clsx(classes.root, className),
    role: component === defaultComponent ? null : "row",
    ownerState
  }, other));
});
const TableRow$1 = TableRow;
const ArrowDownwardIcon = createSvgIcon$1(/* @__PURE__ */ jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}), "ArrowDownward");
function getTableSortLabelUtilityClass(slot) {
  return generateUtilityClass("MuiTableSortLabel", slot);
}
const tableSortLabelClasses = generateUtilityClasses("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc"]);
const tableSortLabelClasses$1 = tableSortLabelClasses;
const _excluded$8 = ["active", "children", "className", "direction", "hideSortIcon", "IconComponent"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes,
    direction,
    active
  } = ownerState;
  const slots = {
    root: ["root", active && "active"],
    icon: ["icon", `iconDirection${capitalize(direction)}`]
  };
  return composeClasses(slots, getTableSortLabelUtilityClass, classes);
};
const TableSortLabelRoot = styled$2(ButtonBase$1, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.active && styles2.active];
  }
})(({
  theme: theme2
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (theme2.vars || theme2).palette.text.secondary
  },
  "&:hover": {
    color: (theme2.vars || theme2).palette.text.secondary,
    [`& .${tableSortLabelClasses$1.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${tableSortLabelClasses$1.active}`]: {
    color: (theme2.vars || theme2).palette.text.primary,
    [`& .${tableSortLabelClasses$1.icon}`]: {
      opacity: 1,
      color: (theme2.vars || theme2).palette.text.secondary
    }
  }
}));
const TableSortLabelIcon = styled$2("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, styles2[`iconDirection${capitalize(ownerState.direction)}`]];
  }
})(({
  theme: theme2,
  ownerState
}) => _extends$8({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: theme2.transitions.create(["opacity", "transform"], {
    duration: theme2.transitions.duration.shorter
  }),
  userSelect: "none"
}, ownerState.direction === "desc" && {
  transform: "rotate(0deg)"
}, ownerState.direction === "asc" && {
  transform: "rotate(180deg)"
}));
const TableSortLabel = /* @__PURE__ */ reactExports.forwardRef(function TableSortLabel2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTableSortLabel"
  });
  const {
    active = false,
    children,
    className,
    direction = "asc",
    hideSortIcon = false,
    IconComponent = ArrowDownwardIcon
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
  const ownerState = _extends$8({}, props, {
    active,
    direction,
    hideSortIcon,
    IconComponent
  });
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxs(TableSortLabelRoot, _extends$8({
    className: clsx(classes.root, className),
    component: "span",
    disableRipple: true,
    ownerState,
    ref
  }, other, {
    children: [children, hideSortIcon && !active ? null : /* @__PURE__ */ jsx(TableSortLabelIcon, {
      as: IconComponent,
      className: clsx(classes.icon),
      ownerState
    })]
  }));
});
const TableSortLabel$1 = TableSortLabel;
function easeInOutSin(time2) {
  return (1 + Math.sin(Math.PI * time2 - Math.PI / 2)) / 2;
}
function animate(property, element, to, options = {}, cb2 = () => {
}) {
  const {
    ease: ease2 = easeInOutSin,
    duration: duration5 = 300
    // standard
  } = options;
  let start3 = null;
  const from3 = element[property];
  let cancelled = false;
  const cancel = () => {
    cancelled = true;
  };
  const step = (timestamp) => {
    if (cancelled) {
      cb2(new Error("Animation cancelled"));
      return;
    }
    if (start3 === null) {
      start3 = timestamp;
    }
    const time2 = Math.min(1, (timestamp - start3) / duration5);
    element[property] = ease2(time2) * (to - from3) + from3;
    if (time2 >= 1) {
      requestAnimationFrame(() => {
        cb2(null);
      });
      return;
    }
    requestAnimationFrame(step);
  };
  if (from3 === to) {
    cb2(new Error("Element already at target position"));
    return cancel;
  }
  requestAnimationFrame(step);
  return cancel;
}
const _excluded$7 = ["onChange"];
const styles = {
  width: 99,
  height: 99,
  position: "absolute",
  top: -9999,
  overflow: "scroll"
};
function ScrollbarSize(props) {
  const {
    onChange
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$7);
  const scrollbarHeight = reactExports.useRef();
  const nodeRef = reactExports.useRef(null);
  const setMeasurements = () => {
    scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
  };
  reactExports.useEffect(() => {
    const handleResize = debounce$2(() => {
      const prevHeight = scrollbarHeight.current;
      setMeasurements();
      if (prevHeight !== scrollbarHeight.current) {
        onChange(scrollbarHeight.current);
      }
    });
    const containerWindow = ownerWindow(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [onChange]);
  reactExports.useEffect(() => {
    setMeasurements();
    onChange(scrollbarHeight.current);
  }, [onChange]);
  return /* @__PURE__ */ jsx("div", _extends$8({
    style: styles,
    ref: nodeRef
  }, other));
}
function getTabScrollButtonUtilityClass(slot) {
  return generateUtilityClass("MuiTabScrollButton", slot);
}
const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
const tabScrollButtonClasses$1 = tabScrollButtonClasses;
var _KeyboardArrowLeft, _KeyboardArrowRight;
const _excluded$6 = ["className", "direction", "orientation", "disabled"];
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes,
    orientation,
    disabled
  } = ownerState;
  const slots = {
    root: ["root", orientation, disabled && "disabled"]
  };
  return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
};
const TabScrollButtonRoot = styled$2(ButtonBase$1, {
  name: "MuiTabScrollButton",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
  }
})(({
  ownerState
}) => _extends$8({
  width: 40,
  flexShrink: 0,
  opacity: 0.8,
  [`&.${tabScrollButtonClasses$1.disabled}`]: {
    opacity: 0
  }
}, ownerState.orientation === "vertical" && {
  width: "100%",
  height: 40,
  "& svg": {
    transform: `rotate(${ownerState.isRtl ? -90 : 90}deg)`
  }
}));
const TabScrollButton = /* @__PURE__ */ reactExports.forwardRef(function TabScrollButton2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTabScrollButton"
  });
  const {
    className,
    direction
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$6);
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const ownerState = _extends$8({
    isRtl
  }, props);
  const classes = useUtilityClasses$2(ownerState);
  return /* @__PURE__ */ jsx(TabScrollButtonRoot, _extends$8({
    component: "div",
    className: clsx(classes.root, className),
    ref,
    role: null,
    ownerState,
    tabIndex: null
  }, other, {
    children: direction === "left" ? _KeyboardArrowLeft || (_KeyboardArrowLeft = /* @__PURE__ */ jsx(KeyboardArrowLeft, {
      fontSize: "small"
    })) : _KeyboardArrowRight || (_KeyboardArrowRight = /* @__PURE__ */ jsx(KeyboardArrowRight, {
      fontSize: "small"
    }))
  }));
});
const TabScrollButton$1 = TabScrollButton;
function getTabsUtilityClass(slot) {
  return generateUtilityClass("MuiTabs", slot);
}
const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
const tabsClasses$1 = tabsClasses;
const _excluded$5 = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"];
const nextItem = (list, item) => {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list.firstChild;
};
const previousItem = (list, item) => {
  if (list === item) {
    return list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list.lastChild;
};
const moveFocus = (list, currentFocus, traversalFunction) => {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};
const useUtilityClasses$1 = (ownerState) => {
  const {
    vertical: vertical2,
    fixed,
    hideScrollbar,
    scrollableX,
    scrollableY,
    centered,
    scrollButtonsHideMobile,
    classes
  } = ownerState;
  const slots = {
    root: ["root", vertical2 && "vertical"],
    scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
    flexContainer: ["flexContainer", vertical2 && "flexContainerVertical", centered && "centered"],
    indicator: ["indicator"],
    scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
    scrollableX: [scrollableX && "scrollableX"],
    hideScrollbar: [hideScrollbar && "hideScrollbar"]
  };
  return composeClasses(slots, getTabsUtilityClass, classes);
};
const TabsRoot = styled$2("div", {
  name: "MuiTabs",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${tabsClasses$1.scrollButtons}`]: styles2.scrollButtons
    }, {
      [`& .${tabsClasses$1.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
    }, styles2.root, ownerState.vertical && styles2.vertical];
  }
})(({
  ownerState,
  theme: theme2
}) => _extends$8({
  overflow: "hidden",
  minHeight: 48,
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  display: "flex"
}, ownerState.vertical && {
  flexDirection: "column"
}, ownerState.scrollButtonsHideMobile && {
  [`& .${tabsClasses$1.scrollButtons}`]: {
    [theme2.breakpoints.down("sm")]: {
      display: "none"
    }
  }
}));
const TabsScroller = styled$2("div", {
  name: "MuiTabs",
  slot: "Scroller",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
  }
})(({
  ownerState
}) => _extends$8({
  position: "relative",
  display: "inline-block",
  flex: "1 1 auto",
  whiteSpace: "nowrap"
}, ownerState.fixed && {
  overflowX: "hidden",
  width: "100%"
}, ownerState.hideScrollbar && {
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
}, ownerState.scrollableX && {
  overflowX: "auto",
  overflowY: "hidden"
}, ownerState.scrollableY && {
  overflowY: "auto",
  overflowX: "hidden"
}));
const FlexContainer = styled$2("div", {
  name: "MuiTabs",
  slot: "FlexContainer",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
  }
})(({
  ownerState
}) => _extends$8({
  display: "flex"
}, ownerState.vertical && {
  flexDirection: "column"
}, ownerState.centered && {
  justifyContent: "center"
}));
const TabsIndicator = styled$2("span", {
  name: "MuiTabs",
  slot: "Indicator",
  overridesResolver: (props, styles2) => styles2.indicator
})(({
  ownerState,
  theme: theme2
}) => _extends$8({
  position: "absolute",
  height: 2,
  bottom: 0,
  width: "100%",
  transition: theme2.transitions.create()
}, ownerState.indicatorColor === "primary" && {
  backgroundColor: (theme2.vars || theme2).palette.primary.main
}, ownerState.indicatorColor === "secondary" && {
  backgroundColor: (theme2.vars || theme2).palette.secondary.main
}, ownerState.vertical && {
  height: "100%",
  width: 2,
  right: 0
}));
const TabsScrollbarSize = styled$2(ScrollbarSize, {
  name: "MuiTabs",
  slot: "ScrollbarSize"
})({
  overflowX: "auto",
  overflowY: "hidden",
  // Hide dimensionless scrollbar on macOS
  scrollbarWidth: "none",
  // Firefox
  "&::-webkit-scrollbar": {
    display: "none"
    // Safari + Chrome
  }
});
const defaultIndicatorStyle = {};
const Tabs = /* @__PURE__ */ reactExports.forwardRef(function Tabs2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTabs"
  });
  const theme2 = useTheme();
  const isRtl = theme2.direction === "rtl";
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    action,
    centered = false,
    children: childrenProp,
    className,
    component = "div",
    allowScrollButtonsMobile = false,
    indicatorColor = "primary",
    onChange,
    orientation = "horizontal",
    ScrollButtonComponent = TabScrollButton$1,
    scrollButtons = "auto",
    selectionFollowsFocus,
    TabIndicatorProps = {},
    TabScrollButtonProps = {},
    textColor = "primary",
    value,
    variant = "standard",
    visibleScrollbar = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$5);
  const scrollable = variant === "scrollable";
  const vertical2 = orientation === "vertical";
  const scrollStart = vertical2 ? "scrollTop" : "scrollLeft";
  const start3 = vertical2 ? "top" : "left";
  const end2 = vertical2 ? "bottom" : "right";
  const clientSize = vertical2 ? "clientHeight" : "clientWidth";
  const size = vertical2 ? "height" : "width";
  const ownerState = _extends$8({}, props, {
    component,
    allowScrollButtonsMobile,
    indicatorColor,
    orientation,
    vertical: vertical2,
    scrollButtons,
    textColor,
    variant,
    visibleScrollbar,
    fixed: !scrollable,
    hideScrollbar: scrollable && !visibleScrollbar,
    scrollableX: scrollable && !vertical2,
    scrollableY: scrollable && vertical2,
    centered: centered && !scrollable,
    scrollButtonsHideMobile: !allowScrollButtonsMobile
  });
  const classes = useUtilityClasses$1(ownerState);
  const [mounted, setMounted] = reactExports.useState(false);
  const [indicatorStyle, setIndicatorStyle] = reactExports.useState(defaultIndicatorStyle);
  const [displayScroll, setDisplayScroll] = reactExports.useState({
    start: false,
    end: false
  });
  const [scrollerStyle, setScrollerStyle] = reactExports.useState({
    overflow: "hidden",
    scrollbarWidth: 0
  });
  const valueToIndex = /* @__PURE__ */ new Map();
  const tabsRef = reactExports.useRef(null);
  const tabListRef = reactExports.useRef(null);
  const getTabsMeta = () => {
    const tabsNode = tabsRef.current;
    let tabsMeta;
    if (tabsNode) {
      const rect = tabsNode.getBoundingClientRect();
      tabsMeta = {
        clientWidth: tabsNode.clientWidth,
        scrollLeft: tabsNode.scrollLeft,
        scrollTop: tabsNode.scrollTop,
        scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, theme2.direction),
        scrollWidth: tabsNode.scrollWidth,
        top: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        right: rect.right
      };
    }
    let tabMeta;
    if (tabsNode && value !== false) {
      const children2 = tabListRef.current.children;
      if (children2.length > 0) {
        const tab2 = children2[valueToIndex.get(value)];
        tabMeta = tab2 ? tab2.getBoundingClientRect() : null;
      }
    }
    return {
      tabsMeta,
      tabMeta
    };
  };
  const updateIndicatorState = useEventCallback(() => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    let startValue = 0;
    let startIndicator;
    if (vertical2) {
      startIndicator = "top";
      if (tabMeta && tabsMeta) {
        startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
      }
    } else {
      startIndicator = isRtl ? "right" : "left";
      if (tabMeta && tabsMeta) {
        const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;
        startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + correction);
      }
    }
    const newIndicatorStyle = {
      [startIndicator]: startValue,
      // May be wrong until the font is loaded.
      [size]: tabMeta ? tabMeta[size] : 0
    };
    if (isNaN(indicatorStyle[startIndicator]) || isNaN(indicatorStyle[size])) {
      setIndicatorStyle(newIndicatorStyle);
    } else {
      const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
      const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
      if (dStart >= 1 || dSize >= 1) {
        setIndicatorStyle(newIndicatorStyle);
      }
    }
  });
  const scroll3 = (scrollValue, {
    animation = true
  } = {}) => {
    if (animation) {
      animate(scrollStart, tabsRef.current, scrollValue, {
        duration: theme2.transitions.duration.standard
      });
    } else {
      tabsRef.current[scrollStart] = scrollValue;
    }
  };
  const moveTabsScroll = (delta) => {
    let scrollValue = tabsRef.current[scrollStart];
    if (vertical2) {
      scrollValue += delta;
    } else {
      scrollValue += delta * (isRtl ? -1 : 1);
      scrollValue *= isRtl && detectScrollType() === "reverse" ? -1 : 1;
    }
    scroll3(scrollValue);
  };
  const getScrollSize = () => {
    const containerSize = tabsRef.current[clientSize];
    let totalSize = 0;
    const children2 = Array.from(tabListRef.current.children);
    for (let i = 0; i < children2.length; i += 1) {
      const tab2 = children2[i];
      if (totalSize + tab2[clientSize] > containerSize) {
        if (i === 0) {
          totalSize = containerSize;
        }
        break;
      }
      totalSize += tab2[clientSize];
    }
    return totalSize;
  };
  const handleStartScrollClick = () => {
    moveTabsScroll(-1 * getScrollSize());
  };
  const handleEndScrollClick = () => {
    moveTabsScroll(getScrollSize());
  };
  const handleScrollbarSizeChange = reactExports.useCallback((scrollbarWidth) => {
    setScrollerStyle({
      overflow: null,
      scrollbarWidth
    });
  }, []);
  const getConditionalElements = () => {
    const conditionalElements2 = {};
    conditionalElements2.scrollbarSizeListener = scrollable ? /* @__PURE__ */ jsx(TabsScrollbarSize, {
      onChange: handleScrollbarSizeChange,
      className: clsx(classes.scrollableX, classes.hideScrollbar)
    }) : null;
    const scrollButtonsActive = displayScroll.start || displayScroll.end;
    const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
    conditionalElements2.scrollButtonStart = showScrollButtons ? /* @__PURE__ */ jsx(ScrollButtonComponent, _extends$8({
      orientation,
      direction: isRtl ? "right" : "left",
      onClick: handleStartScrollClick,
      disabled: !displayScroll.start
    }, TabScrollButtonProps, {
      className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
    })) : null;
    conditionalElements2.scrollButtonEnd = showScrollButtons ? /* @__PURE__ */ jsx(ScrollButtonComponent, _extends$8({
      orientation,
      direction: isRtl ? "left" : "right",
      onClick: handleEndScrollClick,
      disabled: !displayScroll.end
    }, TabScrollButtonProps, {
      className: clsx(classes.scrollButtons, TabScrollButtonProps.className)
    })) : null;
    return conditionalElements2;
  };
  const scrollSelectedIntoView = useEventCallback((animation) => {
    const {
      tabsMeta,
      tabMeta
    } = getTabsMeta();
    if (!tabMeta || !tabsMeta) {
      return;
    }
    if (tabMeta[start3] < tabsMeta[start3]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start3] - tabsMeta[start3]);
      scroll3(nextScrollStart, {
        animation
      });
    } else if (tabMeta[end2] > tabsMeta[end2]) {
      const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end2] - tabsMeta[end2]);
      scroll3(nextScrollStart, {
        animation
      });
    }
  });
  const updateScrollButtonState = useEventCallback(() => {
    if (scrollable && scrollButtons !== false) {
      const {
        scrollTop,
        scrollHeight,
        clientHeight,
        scrollWidth,
        clientWidth
      } = tabsRef.current;
      let showStartScroll;
      let showEndScroll;
      if (vertical2) {
        showStartScroll = scrollTop > 1;
        showEndScroll = scrollTop < scrollHeight - clientHeight - 1;
      } else {
        const scrollLeft = getNormalizedScrollLeft(tabsRef.current, theme2.direction);
        showStartScroll = isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
        showEndScroll = !isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
      }
      if (showStartScroll !== displayScroll.start || showEndScroll !== displayScroll.end) {
        setDisplayScroll({
          start: showStartScroll,
          end: showEndScroll
        });
      }
    }
  });
  reactExports.useEffect(() => {
    const handleResize = debounce$2(() => {
      if (tabsRef.current) {
        updateIndicatorState();
        updateScrollButtonState();
      }
    });
    const win2 = ownerWindow(tabsRef.current);
    win2.addEventListener("resize", handleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      Array.from(tabListRef.current.children).forEach((child) => {
        resizeObserver.observe(child);
      });
    }
    return () => {
      handleResize.clear();
      win2.removeEventListener("resize", handleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [updateIndicatorState, updateScrollButtonState]);
  const handleTabsScroll = reactExports.useMemo(() => debounce$2(() => {
    updateScrollButtonState();
  }), [updateScrollButtonState]);
  reactExports.useEffect(() => {
    return () => {
      handleTabsScroll.clear();
    };
  }, [handleTabsScroll]);
  reactExports.useEffect(() => {
    setMounted(true);
  }, []);
  reactExports.useEffect(() => {
    updateIndicatorState();
    updateScrollButtonState();
  });
  reactExports.useEffect(() => {
    scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
  }, [scrollSelectedIntoView, indicatorStyle]);
  reactExports.useImperativeHandle(action, () => ({
    updateIndicator: updateIndicatorState,
    updateScrollButtons: updateScrollButtonState
  }), [updateIndicatorState, updateScrollButtonState]);
  const indicator = /* @__PURE__ */ jsx(TabsIndicator, _extends$8({}, TabIndicatorProps, {
    className: clsx(classes.indicator, TabIndicatorProps.className),
    ownerState,
    style: _extends$8({}, indicatorStyle, TabIndicatorProps.style)
  }));
  let childIndex = 0;
  const children = reactExports.Children.map(childrenProp, (child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    const childValue = child.props.value === void 0 ? childIndex : child.props.value;
    valueToIndex.set(childValue, childIndex);
    const selected = childValue === value;
    childIndex += 1;
    return /* @__PURE__ */ reactExports.cloneElement(child, _extends$8({
      fullWidth: variant === "fullWidth",
      indicator: selected && !mounted && indicator,
      selected,
      selectionFollowsFocus,
      onChange,
      textColor,
      value: childValue
    }, childIndex === 1 && value === false && !child.props.tabIndex ? {
      tabIndex: 0
    } : {}));
  });
  const handleKeyDown2 = (event) => {
    const list = tabListRef.current;
    const currentFocus = ownerDocument(list).activeElement;
    const role = currentFocus.getAttribute("role");
    if (role !== "tab") {
      return;
    }
    let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
    let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
    if (orientation === "horizontal" && isRtl) {
      previousItemKey = "ArrowRight";
      nextItemKey = "ArrowLeft";
    }
    switch (event.key) {
      case previousItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, previousItem);
        break;
      case nextItemKey:
        event.preventDefault();
        moveFocus(list, currentFocus, nextItem);
        break;
      case "Home":
        event.preventDefault();
        moveFocus(list, null, nextItem);
        break;
      case "End":
        event.preventDefault();
        moveFocus(list, null, previousItem);
        break;
    }
  };
  const conditionalElements = getConditionalElements();
  return /* @__PURE__ */ jsxs(TabsRoot, _extends$8({
    className: clsx(classes.root, className),
    ownerState,
    ref,
    as: component
  }, other, {
    children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, /* @__PURE__ */ jsxs(TabsScroller, {
      className: classes.scroller,
      ownerState,
      style: {
        overflow: scrollerStyle.overflow,
        [vertical2 ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
      },
      ref: tabsRef,
      onScroll: handleTabsScroll,
      children: [/* @__PURE__ */ jsx(FlexContainer, {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-orientation": orientation === "vertical" ? "vertical" : null,
        className: classes.flexContainer,
        ownerState,
        onKeyDown: handleKeyDown2,
        ref: tabListRef,
        role: "tablist",
        children
      }), mounted && indicator]
    }), conditionalElements.scrollButtonEnd]
  }));
});
const Tabs$1 = Tabs;
function getTextFieldUtilityClass(slot) {
  return generateUtilityClass("MuiTextField", slot);
}
generateUtilityClasses("MuiTextField", ["root"]);
const _excluded$4 = ["autoComplete", "autoFocus", "children", "className", "color", "defaultValue", "disabled", "error", "FormHelperTextProps", "fullWidth", "helperText", "id", "InputLabelProps", "inputProps", "InputProps", "inputRef", "label", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onFocus", "placeholder", "required", "rows", "select", "SelectProps", "type", "value", "variant"];
const variantComponent = {
  standard: Input$1,
  filled: FilledInput$1,
  outlined: OutlinedInput$1
};
const useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTextFieldUtilityClass, classes);
};
const TextFieldRoot = styled$2(FormControl$1, {
  name: "MuiTextField",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const TextField = /* @__PURE__ */ reactExports.forwardRef(function TextField2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTextField"
  });
  const {
    autoComplete,
    autoFocus = false,
    children,
    className,
    color: color2 = "primary",
    defaultValue,
    disabled = false,
    error = false,
    FormHelperTextProps,
    fullWidth = false,
    helperText,
    id: idOverride,
    InputLabelProps,
    inputProps,
    InputProps,
    inputRef,
    label,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    required = false,
    rows,
    select = false,
    SelectProps,
    type: type2,
    value,
    variant = "outlined"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$4);
  const ownerState = _extends$8({}, props, {
    autoFocus,
    color: color2,
    disabled,
    error,
    fullWidth,
    multiline,
    required,
    select,
    variant
  });
  const classes = useUtilityClasses(ownerState);
  const InputMore = {};
  if (variant === "outlined") {
    if (InputLabelProps && typeof InputLabelProps.shrink !== "undefined") {
      InputMore.notched = InputLabelProps.shrink;
    }
    InputMore.label = label;
  }
  if (select) {
    if (!SelectProps || !SelectProps.native) {
      InputMore.id = void 0;
    }
    InputMore["aria-describedby"] = void 0;
  }
  const id2 = useId(idOverride);
  const helperTextId = helperText && id2 ? `${id2}-helper-text` : void 0;
  const inputLabelId = label && id2 ? `${id2}-label` : void 0;
  const InputComponent = variantComponent[variant];
  const InputElement = /* @__PURE__ */ jsx(InputComponent, _extends$8({
    "aria-describedby": helperTextId,
    autoComplete,
    autoFocus,
    defaultValue,
    fullWidth,
    multiline,
    name,
    rows,
    maxRows,
    minRows,
    type: type2,
    value,
    id: id2,
    inputRef,
    onBlur,
    onChange,
    onFocus,
    placeholder,
    inputProps
  }, InputMore, InputProps));
  return /* @__PURE__ */ jsxs(TextFieldRoot, _extends$8({
    className: clsx(classes.root, className),
    disabled,
    error,
    fullWidth,
    ref,
    required,
    color: color2,
    variant,
    ownerState
  }, other, {
    children: [label != null && label !== "" && /* @__PURE__ */ jsx(InputLabel$1, _extends$8({
      htmlFor: id2,
      id: inputLabelId
    }, InputLabelProps, {
      children: label
    })), select ? /* @__PURE__ */ jsx(Select$1, _extends$8({
      "aria-describedby": helperTextId,
      id: id2,
      labelId: inputLabelId,
      value,
      input: InputElement
    }, SelectProps, {
      children
    })) : InputElement, helperText && /* @__PURE__ */ jsx(FormHelperText$1, _extends$8({
      id: helperTextId
    }, FormHelperTextProps, {
      children: helperText
    }))]
  }));
});
const TextField$1 = TextField;
const _excluded$3 = ["getTrigger", "target"];
function defaultTrigger(store, options) {
  const {
    disableHysteresis = false,
    threshold = 100,
    target
  } = options;
  const previous = store.current;
  if (target) {
    store.current = target.pageYOffset !== void 0 ? target.pageYOffset : target.scrollTop;
  }
  if (!disableHysteresis && previous !== void 0) {
    if (store.current < previous) {
      return false;
    }
  }
  return store.current > threshold;
}
const defaultTarget = typeof window !== "undefined" ? window : null;
function useScrollTrigger(options = {}) {
  const {
    getTrigger = defaultTrigger,
    target = defaultTarget
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$3);
  const store = reactExports.useRef();
  const [trigger2, setTrigger] = reactExports.useState(() => getTrigger(store, other));
  reactExports.useEffect(() => {
    const handleScroll = () => {
      setTrigger(getTrigger(store, _extends$8({
        target
      }, other)));
    };
    handleScroll();
    target.addEventListener("scroll", handleScroll, {
      passive: true
    });
    return () => {
      target.removeEventListener("scroll", handleScroll, {
        passive: true
      });
    };
  }, [target, getTrigger, JSON.stringify(other)]);
  return trigger2;
}
var PlayCircle = {};
var interopRequireDefaultExports = {};
var interopRequireDefault = {
  get exports() {
    return interopRequireDefaultExports;
  },
  set exports(v2) {
    interopRequireDefaultExports = v2;
  }
};
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var createSvgIcon = {};
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(utils$2);
var hasRequiredCreateSvgIcon;
function requireCreateSvgIcon() {
  if (hasRequiredCreateSvgIcon)
    return createSvgIcon;
  hasRequiredCreateSvgIcon = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _utils2.createSvgIcon;
      }
    });
    var _utils2 = require$$0$2;
  })(createSvgIcon);
  return createSvgIcon;
}
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(jsxRuntime);
var _interopRequireDefault$B = interopRequireDefaultExports;
Object.defineProperty(PlayCircle, "__esModule", {
  value: true
});
var default_1$z = PlayCircle.default = void 0;
var _createSvgIcon$z = _interopRequireDefault$B(requireCreateSvgIcon());
var _jsxRuntime$z = require$$2;
var _default$z = (0, _createSvgIcon$z.default)(/* @__PURE__ */ (0, _jsxRuntime$z.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM9.5 16.5v-9l7 4.5-7 4.5z"
}), "PlayCircle");
default_1$z = PlayCircle.default = _default$z;
function Logo() {
  const context = reactExports.useContext(NavigationContext);
  const handleClick = () => {
    context == null ? void 0 : context.setOpen(true);
  };
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      component: Link,
      to: "/",
      sx: {
        display: "flex",
        alignItems: "center",
        color: "#fff",
        height: "48px",
        width: "80px",
        pl: 1,
        cursor: "pointer"
      },
      onClick: () => handleClick(),
      children: [
        /* @__PURE__ */ jsx(
          Typography$1,
          {
            variant: "h4",
            sx: {
              fontWeight: 900
            },
            children: "VP"
          }
        ),
        /* @__PURE__ */ jsx(default_1$z, { fontSize: "large" })
      ]
    }
  );
}
var Search$1 = {};
var _interopRequireDefault$A = interopRequireDefaultExports;
Object.defineProperty(Search$1, "__esModule", {
  value: true
});
var default_1$y = Search$1.default = void 0;
var _createSvgIcon$y = _interopRequireDefault$A(requireCreateSvgIcon());
var _jsxRuntime$y = require$$2;
var _default$y = (0, _createSvgIcon$y.default)(/* @__PURE__ */ (0, _jsxRuntime$y.jsx)("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"
}), "Search");
default_1$y = Search$1.default = _default$y;
var Route = /* @__PURE__ */ ((Route2) => {
  Route2["channel"] = "channel";
  Route2["myChannels"] = "my-channels";
  Route2["myPlaylists"] = "my-playlists";
  Route2["myVideos"] = "my-videos";
  Route2["playlist"] = "playlist";
  Route2["search"] = "search";
  Route2["tagEdit"] = "tag-edit";
  Route2["upload"] = "upload";
  Route2["userEdit"] = "user-edit";
  Route2["users"] = "users";
  Route2["video"] = "video";
  Route2["videoEdit"] = "video-edit";
  return Route2;
})(Route || {});
async function loader$a({ request: request2 }) {
  const url = new URL(request2.url);
  const searchTerm = url.searchParams.get("q");
  if (searchTerm) {
    return { searchTerm };
  }
  const tags2 = url.searchParams.get("tags");
  if (tags2) {
    return { tags: tags2 };
  }
  return Promise.reject();
}
const searchTagsUrl = (searchedTags) => {
  return `/${Route.search}?q=tags:${searchedTags.toString()}`;
};
function Search() {
  const [value, setValue] = React.useState("");
  const [inputValue, setInputValue] = React.useState("");
  const predmety = ["ISVZ", "PDF", "KKS", "LOL"];
  const navigate = useNavigate();
  const searchButtonClickHandle = (e2) => {
    e2.preventDefault();
    const params = { q: inputValue };
    if ((inputValue == null ? void 0 : inputValue.length) === 0) {
      return;
    }
    navigate({
      pathname: `/${Route.search}`,
      search: `?${createSearchParams(params)}`
    });
  };
  const selectedOption = (option) => {
    console.log(`/api/search?q=${option}`);
  };
  return /* @__PURE__ */ jsx(
    Box$1,
    {
      sx: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: ["100%", "50%"]
      },
      children: /* @__PURE__ */ jsxs(
        Box$1,
        {
          sx: {
            position: "relative",
            borderRadius: 1,
            backgroundColor: alpha("#fff", 0.15),
            "&:hover": {
              backgroundColor: alpha("#fff", 0.25)
            },
            width: "100%"
          },
          children: [
            /* @__PURE__ */ jsx(
              IconButton$1,
              {
                sx: {
                  color: "#FFF",
                  padding: "0,5",
                  height: "100%",
                  position: "absolute",
                  pointerEvents: "none",
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  "&:hover": {
                    backgroundColor: "#40CCFD"
                  }
                },
                onClick: searchButtonClickHandle,
                children: /* @__PURE__ */ jsx(default_1$y, {})
              }
            ),
            /* @__PURE__ */ jsx("form", { id: "search-form", role: "search", children: /* @__PURE__ */ jsx(
              Autocomplete$1,
              {
                id: "free-solo-demo",
                freeSolo: true,
                value,
                onChange: (event, newValue) => {
                  setValue(newValue);
                  selectedOption(newValue);
                },
                inputValue,
                onInputChange: (event, newInputValue) => {
                  setInputValue(newInputValue);
                },
                options: predmety,
                sx: {
                  "& .MuiAutocomplete-endAdornment > button": {
                    color: "white"
                  }
                },
                renderInput: (params) => {
                  const { InputLabelProps, InputProps, ...rest } = params;
                  return /* @__PURE__ */ jsx(
                    InputBase$1,
                    {
                      ...params.InputProps,
                      ...rest,
                      name: "q",
                      type: "search",
                      sx: {
                        color: "white",
                        "& .MuiInputBase-input": {
                          width: "100%",
                          paddingLeft: 4
                        }
                      },
                      endAdornment: void 0,
                      placeholder: "Vyhledvn",
                      onKeyPress: (event) => {
                        if (event.key === "Enter")
                          searchButtonClickHandle(event);
                      }
                    }
                  );
                }
              }
            ) })
          ]
        }
      )
    }
  );
}
var Close = {};
var _interopRequireDefault$z = interopRequireDefaultExports;
Object.defineProperty(Close, "__esModule", {
  value: true
});
var default_1$x = Close.default = void 0;
var _createSvgIcon$x = _interopRequireDefault$z(requireCreateSvgIcon());
var _jsxRuntime$x = require$$2;
var _default$x = (0, _createSvgIcon$x.default)(/* @__PURE__ */ (0, _jsxRuntime$x.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
default_1$x = Close.default = _default$x;
var Logout = {};
var _interopRequireDefault$y = interopRequireDefaultExports;
Object.defineProperty(Logout, "__esModule", {
  value: true
});
var default_1$w = Logout.default = void 0;
var _createSvgIcon$w = _interopRequireDefault$y(requireCreateSvgIcon());
var _jsxRuntime$w = require$$2;
var _default$w = (0, _createSvgIcon$w.default)(/* @__PURE__ */ (0, _jsxRuntime$w.jsx)("path", {
  d: "m17 7-1.41 1.41L18.17 11H8v2h10.17l-2.58 2.58L17 17l5-5zM4 5h8V3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h8v-2H4V5z"
}), "Logout");
default_1$w = Logout.default = _default$w;
var Settings$1 = {};
var _interopRequireDefault$x = interopRequireDefaultExports;
Object.defineProperty(Settings$1, "__esModule", {
  value: true
});
var default_1$v = Settings$1.default = void 0;
var _createSvgIcon$v = _interopRequireDefault$x(requireCreateSvgIcon());
var _jsxRuntime$v = require$$2;
var _default$v = (0, _createSvgIcon$v.default)(/* @__PURE__ */ (0, _jsxRuntime$v.jsx)("path", {
  d: "M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"
}), "Settings");
default_1$v = Settings$1.default = _default$v;
function SimpleListItem({ text, icon, onClick }) {
  return /* @__PURE__ */ jsx(ListItem$2, { disablePadding: true, children: /* @__PURE__ */ jsxs(ListItemButton$1, { onClick, children: [
    /* @__PURE__ */ jsx(ListItemIcon$1, { children: icon }),
    /* @__PURE__ */ jsx(ListItemText$1, { primary: text })
  ] }) });
}
var getDefaultStyle = function(visible) {
  return {
    display: visible ? "flex" : "none"
  };
};
var DEFAULT_COLOR = "#4fa94d";
var DEFAULT_WAI_ARIA_ATTRIBUTE = {
  "aria-busy": true,
  role: "status"
};
var __assign$v = globalThis && globalThis.__assign || function() {
  __assign$v = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$v.apply(this, arguments);
};
var __assign$u = globalThis && globalThis.__assign || function() {
  __assign$u = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$u.apply(this, arguments);
};
var __assign$t = globalThis && globalThis.__assign || function() {
  __assign$t = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$t.apply(this, arguments);
};
var __assign$s = globalThis && globalThis.__assign || function() {
  __assign$s = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$s.apply(this, arguments);
};
var __assign$r = globalThis && globalThis.__assign || function() {
  __assign$r = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$r.apply(this, arguments);
};
var __assign$q = globalThis && globalThis.__assign || function() {
  __assign$q = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$q.apply(this, arguments);
};
var __assign$p = globalThis && globalThis.__assign || function() {
  __assign$p = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$p.apply(this, arguments);
};
function stylis_min(W2) {
  function M2(d3, c2, e2, h2, a2) {
    for (var m2 = 0, b2 = 0, v2 = 0, n2 = 0, q2, g2, x = 0, K2 = 0, k2, u2 = k2 = q2 = 0, l2 = 0, r3 = 0, I2 = 0, t3 = 0, B3 = e2.length, J2 = B3 - 1, y2, f2 = "", p2 = "", F3 = "", G3 = "", C2; l2 < B3; ) {
      g2 = e2.charCodeAt(l2);
      l2 === J2 && 0 !== b2 + n2 + v2 + m2 && (0 !== b2 && (g2 = 47 === b2 ? 10 : 47), n2 = v2 = m2 = 0, B3++, J2++);
      if (0 === b2 + n2 + v2 + m2) {
        if (l2 === J2 && (0 < r3 && (f2 = f2.replace(N2, "")), 0 < f2.trim().length)) {
          switch (g2) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f2 += e2.charAt(l2);
          }
          g2 = 59;
        }
        switch (g2) {
          case 123:
            f2 = f2.trim();
            q2 = f2.charCodeAt(0);
            k2 = 1;
            for (t3 = ++l2; l2 < B3; ) {
              switch (g2 = e2.charCodeAt(l2)) {
                case 123:
                  k2++;
                  break;
                case 125:
                  k2--;
                  break;
                case 47:
                  switch (g2 = e2.charCodeAt(l2 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u2 = l2 + 1; u2 < J2; ++u2) {
                          switch (e2.charCodeAt(u2)) {
                            case 47:
                              if (42 === g2 && 42 === e2.charCodeAt(u2 - 1) && l2 + 2 !== u2) {
                                l2 = u2 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (47 === g2) {
                                l2 = u2 + 1;
                                break a;
                              }
                          }
                        }
                        l2 = u2;
                      }
                  }
                  break;
                case 91:
                  g2++;
                case 40:
                  g2++;
                case 34:
                case 39:
                  for (; l2++ < J2 && e2.charCodeAt(l2) !== g2; ) {
                  }
              }
              if (0 === k2)
                break;
              l2++;
            }
            k2 = e2.substring(t3, l2);
            0 === q2 && (q2 = (f2 = f2.replace(ca2, "").trim()).charCodeAt(0));
            switch (q2) {
              case 64:
                0 < r3 && (f2 = f2.replace(N2, ""));
                g2 = f2.charCodeAt(1);
                switch (g2) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r3 = c2;
                    break;
                  default:
                    r3 = O2;
                }
                k2 = M2(c2, r3, k2, g2, a2 + 1);
                t3 = k2.length;
                0 < A2 && (r3 = X2(O2, f2, I2), C2 = H2(3, k2, r3, c2, D2, z2, t3, g2, a2, h2), f2 = r3.join(""), void 0 !== C2 && 0 === (t3 = (k2 = C2.trim()).length) && (g2 = 0, k2 = ""));
                if (0 < t3)
                  switch (g2) {
                    case 115:
                      f2 = f2.replace(da2, ea2);
                    case 100:
                    case 109:
                    case 45:
                      k2 = f2 + "{" + k2 + "}";
                      break;
                    case 107:
                      f2 = f2.replace(fa2, "$1 $2");
                      k2 = f2 + "{" + k2 + "}";
                      k2 = 1 === w2 || 2 === w2 && L2("@" + k2, 3) ? "@-webkit-" + k2 + "@" + k2 : "@" + k2;
                      break;
                    default:
                      k2 = f2 + k2, 112 === h2 && (k2 = (p2 += k2, ""));
                  }
                else
                  k2 = "";
                break;
              default:
                k2 = M2(c2, X2(c2, f2, I2), k2, h2, a2 + 1);
            }
            F3 += k2;
            k2 = I2 = r3 = u2 = q2 = 0;
            f2 = "";
            g2 = e2.charCodeAt(++l2);
            break;
          case 125:
          case 59:
            f2 = (0 < r3 ? f2.replace(N2, "") : f2).trim();
            if (1 < (t3 = f2.length))
              switch (0 === u2 && (q2 = f2.charCodeAt(0), 45 === q2 || 96 < q2 && 123 > q2) && (t3 = (f2 = f2.replace(" ", ":")).length), 0 < A2 && void 0 !== (C2 = H2(1, f2, c2, d3, D2, z2, p2.length, h2, a2, h2)) && 0 === (t3 = (f2 = C2.trim()).length) && (f2 = "\0\0"), q2 = f2.charCodeAt(0), g2 = f2.charCodeAt(1), q2) {
                case 0:
                  break;
                case 64:
                  if (105 === g2 || 99 === g2) {
                    G3 += f2 + e2.charAt(l2);
                    break;
                  }
                default:
                  58 !== f2.charCodeAt(t3 - 1) && (p2 += P2(f2, q2, g2, f2.charCodeAt(2)));
              }
            I2 = r3 = u2 = q2 = 0;
            f2 = "";
            g2 = e2.charCodeAt(++l2);
        }
      }
      switch (g2) {
        case 13:
        case 10:
          47 === b2 ? b2 = 0 : 0 === 1 + q2 && 107 !== h2 && 0 < f2.length && (r3 = 1, f2 += "\0");
          0 < A2 * Y2 && H2(0, f2, c2, d3, D2, z2, p2.length, h2, a2, h2);
          z2 = 1;
          D2++;
          break;
        case 59:
        case 125:
          if (0 === b2 + n2 + v2 + m2) {
            z2++;
            break;
          }
        default:
          z2++;
          y2 = e2.charAt(l2);
          switch (g2) {
            case 9:
            case 32:
              if (0 === n2 + m2 + b2)
                switch (x) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    y2 = "";
                    break;
                  default:
                    32 !== g2 && (y2 = " ");
                }
              break;
            case 0:
              y2 = "\\0";
              break;
            case 12:
              y2 = "\\f";
              break;
            case 11:
              y2 = "\\v";
              break;
            case 38:
              0 === n2 + b2 + m2 && (r3 = I2 = 1, y2 = "\f" + y2);
              break;
            case 108:
              if (0 === n2 + b2 + m2 + E2 && 0 < u2)
                switch (l2 - u2) {
                  case 2:
                    112 === x && 58 === e2.charCodeAt(l2 - 3) && (E2 = x);
                  case 8:
                    111 === K2 && (E2 = K2);
                }
              break;
            case 58:
              0 === n2 + b2 + m2 && (u2 = l2);
              break;
            case 44:
              0 === b2 + v2 + n2 + m2 && (r3 = 1, y2 += "\r");
              break;
            case 34:
            case 39:
              0 === b2 && (n2 = n2 === g2 ? 0 : 0 === n2 ? g2 : n2);
              break;
            case 91:
              0 === n2 + b2 + v2 && m2++;
              break;
            case 93:
              0 === n2 + b2 + v2 && m2--;
              break;
            case 41:
              0 === n2 + b2 + m2 && v2--;
              break;
            case 40:
              if (0 === n2 + b2 + m2) {
                if (0 === q2)
                  switch (2 * x + 3 * K2) {
                    case 533:
                      break;
                    default:
                      q2 = 1;
                  }
                v2++;
              }
              break;
            case 64:
              0 === b2 + v2 + n2 + m2 + u2 + k2 && (k2 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n2 + m2 + v2))
                switch (b2) {
                  case 0:
                    switch (2 * g2 + 3 * e2.charCodeAt(l2 + 1)) {
                      case 235:
                        b2 = 47;
                        break;
                      case 220:
                        t3 = l2, b2 = 42;
                    }
                    break;
                  case 42:
                    47 === g2 && 42 === x && t3 + 2 !== l2 && (33 === e2.charCodeAt(t3 + 2) && (p2 += e2.substring(t3, l2 + 1)), y2 = "", b2 = 0);
                }
          }
          0 === b2 && (f2 += y2);
      }
      K2 = x;
      x = g2;
      l2++;
    }
    t3 = p2.length;
    if (0 < t3) {
      r3 = c2;
      if (0 < A2 && (C2 = H2(2, p2, r3, d3, D2, z2, t3, h2, a2, h2), void 0 !== C2 && 0 === (p2 = C2).length))
        return G3 + p2 + F3;
      p2 = r3.join(",") + "{" + p2 + "}";
      if (0 !== w2 * E2) {
        2 !== w2 || L2(p2, 2) || (E2 = 0);
        switch (E2) {
          case 111:
            p2 = p2.replace(ha2, ":-moz-$1") + p2;
            break;
          case 112:
            p2 = p2.replace(Q2, "::-webkit-input-$1") + p2.replace(Q2, "::-moz-$1") + p2.replace(Q2, ":-ms-input-$1") + p2;
        }
        E2 = 0;
      }
    }
    return G3 + p2 + F3;
  }
  function X2(d3, c2, e2) {
    var h2 = c2.trim().split(ia2);
    c2 = h2;
    var a2 = h2.length, m2 = d3.length;
    switch (m2) {
      case 0:
      case 1:
        var b2 = 0;
        for (d3 = 0 === m2 ? "" : d3[0] + " "; b2 < a2; ++b2) {
          c2[b2] = Z2(d3, c2[b2], e2).trim();
        }
        break;
      default:
        var v2 = b2 = 0;
        for (c2 = []; b2 < a2; ++b2) {
          for (var n2 = 0; n2 < m2; ++n2) {
            c2[v2++] = Z2(d3[n2] + " ", h2[b2], e2).trim();
          }
        }
    }
    return c2;
  }
  function Z2(d3, c2, e2) {
    var h2 = c2.charCodeAt(0);
    33 > h2 && (h2 = (c2 = c2.trim()).charCodeAt(0));
    switch (h2) {
      case 38:
        return c2.replace(F2, "$1" + d3.trim());
      case 58:
        return d3.trim() + c2.replace(F2, "$1" + d3.trim());
      default:
        if (0 < 1 * e2 && 0 < c2.indexOf("\f"))
          return c2.replace(F2, (58 === d3.charCodeAt(0) ? "" : "$1") + d3.trim());
    }
    return d3 + c2;
  }
  function P2(d3, c2, e2, h2) {
    var a2 = d3 + ";", m2 = 2 * c2 + 3 * e2 + 4 * h2;
    if (944 === m2) {
      d3 = a2.indexOf(":", 9) + 1;
      var b2 = a2.substring(d3, a2.length - 1).trim();
      b2 = a2.substring(0, d3).trim() + b2 + ";";
      return 1 === w2 || 2 === w2 && L2(b2, 1) ? "-webkit-" + b2 + b2 : b2;
    }
    if (0 === w2 || 2 === w2 && !L2(a2, 1))
      return a2;
    switch (m2) {
      case 1015:
        return 97 === a2.charCodeAt(10) ? "-webkit-" + a2 + a2 : a2;
      case 951:
        return 116 === a2.charCodeAt(3) ? "-webkit-" + a2 + a2 : a2;
      case 963:
        return 110 === a2.charCodeAt(5) ? "-webkit-" + a2 + a2 : a2;
      case 1009:
        if (100 !== a2.charCodeAt(4))
          break;
      case 969:
      case 942:
        return "-webkit-" + a2 + a2;
      case 978:
        return "-webkit-" + a2 + "-moz-" + a2 + a2;
      case 1019:
      case 983:
        return "-webkit-" + a2 + "-moz-" + a2 + "-ms-" + a2 + a2;
      case 883:
        if (45 === a2.charCodeAt(8))
          return "-webkit-" + a2 + a2;
        if (0 < a2.indexOf("image-set(", 11))
          return a2.replace(ja2, "$1-webkit-$2") + a2;
        break;
      case 932:
        if (45 === a2.charCodeAt(4))
          switch (a2.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + a2.replace("-grow", "") + "-webkit-" + a2 + "-ms-" + a2.replace("grow", "positive") + a2;
            case 115:
              return "-webkit-" + a2 + "-ms-" + a2.replace("shrink", "negative") + a2;
            case 98:
              return "-webkit-" + a2 + "-ms-" + a2.replace("basis", "preferred-size") + a2;
          }
        return "-webkit-" + a2 + "-ms-" + a2 + a2;
      case 964:
        return "-webkit-" + a2 + "-ms-flex-" + a2 + a2;
      case 1023:
        if (99 !== a2.charCodeAt(8))
          break;
        b2 = a2.substring(a2.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
        return "-webkit-box-pack" + b2 + "-webkit-" + a2 + "-ms-flex-pack" + b2 + a2;
      case 1005:
        return ka2.test(a2) ? a2.replace(aa2, ":-webkit-") + a2.replace(aa2, ":-moz-") + a2 : a2;
      case 1e3:
        b2 = a2.substring(13).trim();
        c2 = b2.indexOf("-") + 1;
        switch (b2.charCodeAt(0) + b2.charCodeAt(c2)) {
          case 226:
            b2 = a2.replace(G2, "tb");
            break;
          case 232:
            b2 = a2.replace(G2, "tb-rl");
            break;
          case 220:
            b2 = a2.replace(G2, "lr");
            break;
          default:
            return a2;
        }
        return "-webkit-" + a2 + "-ms-" + b2 + a2;
      case 1017:
        if (-1 === a2.indexOf("sticky", 9))
          break;
      case 975:
        c2 = (a2 = d3).length - 10;
        b2 = (33 === a2.charCodeAt(c2) ? a2.substring(0, c2) : a2).substring(d3.indexOf(":", 7) + 1).trim();
        switch (m2 = b2.charCodeAt(0) + (b2.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b2.charCodeAt(8))
              break;
          case 115:
            a2 = a2.replace(b2, "-webkit-" + b2) + ";" + a2;
            break;
          case 207:
          case 102:
            a2 = a2.replace(b2, "-webkit-" + (102 < m2 ? "inline-" : "") + "box") + ";" + a2.replace(b2, "-webkit-" + b2) + ";" + a2.replace(b2, "-ms-" + b2 + "box") + ";" + a2;
        }
        return a2 + ";";
      case 938:
        if (45 === a2.charCodeAt(5))
          switch (a2.charCodeAt(6)) {
            case 105:
              return b2 = a2.replace("-items", ""), "-webkit-" + a2 + "-webkit-box-" + b2 + "-ms-flex-" + b2 + a2;
            case 115:
              return "-webkit-" + a2 + "-ms-flex-item-" + a2.replace(ba, "") + a2;
            default:
              return "-webkit-" + a2 + "-ms-flex-line-pack" + a2.replace("align-content", "").replace(ba, "") + a2;
          }
        break;
      case 973:
      case 989:
        if (45 !== a2.charCodeAt(3) || 122 === a2.charCodeAt(4))
          break;
      case 931:
      case 953:
        if (true === la2.test(d3))
          return 115 === (b2 = d3.substring(d3.indexOf(":") + 1)).charCodeAt(0) ? P2(d3.replace("stretch", "fill-available"), c2, e2, h2).replace(":fill-available", ":stretch") : a2.replace(b2, "-webkit-" + b2) + a2.replace(b2, "-moz-" + b2.replace("fill-", "")) + a2;
        break;
      case 962:
        if (a2 = "-webkit-" + a2 + (102 === a2.charCodeAt(5) ? "-ms-" + a2 : "") + a2, 211 === e2 + h2 && 105 === a2.charCodeAt(13) && 0 < a2.indexOf("transform", 10))
          return a2.substring(0, a2.indexOf(";", 27) + 1).replace(ma2, "$1-webkit-$2") + a2;
    }
    return a2;
  }
  function L2(d3, c2) {
    var e2 = d3.indexOf(1 === c2 ? ":" : "{"), h2 = d3.substring(0, 3 !== c2 ? e2 : 10);
    e2 = d3.substring(e2 + 1, d3.length - 1);
    return R2(2 !== c2 ? h2 : h2.replace(na, "$1"), e2, c2);
  }
  function ea2(d3, c2) {
    var e2 = P2(c2, c2.charCodeAt(0), c2.charCodeAt(1), c2.charCodeAt(2));
    return e2 !== c2 + ";" ? e2.replace(oa2, " or ($1)").substring(4) : "(" + c2 + ")";
  }
  function H2(d3, c2, e2, h2, a2, m2, b2, v2, n2, q2) {
    for (var g2 = 0, x = c2, w3; g2 < A2; ++g2) {
      switch (w3 = S2[g2].call(B2, d3, x, e2, h2, a2, m2, b2, v2, n2, q2)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          x = w3;
      }
    }
    if (x !== c2)
      return x;
  }
  function T2(d3) {
    switch (d3) {
      case void 0:
      case null:
        A2 = S2.length = 0;
        break;
      default:
        if ("function" === typeof d3)
          S2[A2++] = d3;
        else if ("object" === typeof d3)
          for (var c2 = 0, e2 = d3.length; c2 < e2; ++c2) {
            T2(d3[c2]);
          }
        else
          Y2 = !!d3 | 0;
    }
    return T2;
  }
  function U2(d3) {
    d3 = d3.prefix;
    void 0 !== d3 && (R2 = null, d3 ? "function" !== typeof d3 ? w2 = 1 : (w2 = 2, R2 = d3) : w2 = 0);
    return U2;
  }
  function B2(d3, c2) {
    var e2 = d3;
    33 > e2.charCodeAt(0) && (e2 = e2.trim());
    V2 = e2;
    e2 = [V2];
    if (0 < A2) {
      var h2 = H2(-1, c2, e2, e2, D2, z2, 0, 0, 0, 0);
      void 0 !== h2 && "string" === typeof h2 && (c2 = h2);
    }
    var a2 = M2(O2, e2, c2, 0, 0);
    0 < A2 && (h2 = H2(-2, a2, e2, e2, D2, z2, a2.length, 0, 0, 0), void 0 !== h2 && (a2 = h2));
    V2 = "";
    E2 = 0;
    z2 = D2 = 1;
    return a2;
  }
  var ca2 = /^\0+/g, N2 = /[\0\r\f]/g, aa2 = /: */g, ka2 = /zoo|gra/, ma2 = /([,: ])(transform)/g, ia2 = /,\r+?/g, F2 = /([\t\r\n ])*\f?&/g, fa2 = /@(k\w+)\s*(\S*)\s*/, Q2 = /::(place)/g, ha2 = /:(read-only)/g, G2 = /[svh]\w+-[tblr]{2}/, da2 = /\(\s*(.*)\s*\)/g, oa2 = /([\s\S]*?);/g, ba = /-self|flex-/g, na = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la2 = /stretch|:\s*\w+\-(?:conte|avail)/, ja2 = /([^-])(image-set\()/, z2 = 1, D2 = 1, E2 = 0, w2 = 1, O2 = [], S2 = [], A2 = 0, R2 = null, Y2 = 0, V2 = "";
  B2.use = T2;
  B2.set = U2;
  void 0 !== W2 && U2(W2);
  return B2;
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function v$1() {
  return (v$1 = Object.assign || function(e2) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var n2 = arguments[t3];
      for (var r3 in n2)
        Object.prototype.hasOwnProperty.call(n2, r3) && (e2[r3] = n2[r3]);
    }
    return e2;
  }).apply(this, arguments);
}
var g$1 = function(e2, t3) {
  for (var n2 = [e2[0]], r3 = 0, o = t3.length; r3 < o; r3 += 1)
    n2.push(t3[r3], e2[r3 + 1]);
  return n2;
}, S = function(t3) {
  return null !== t3 && "object" == typeof t3 && "[object Object]" === (t3.toString ? t3.toString() : Object.prototype.toString.call(t3)) && !reactIsExports$1.typeOf(t3);
}, w$1 = Object.freeze([]), E$1 = Object.freeze({});
function b$1(e2) {
  return "function" == typeof e2;
}
function _(e2) {
  return e2.displayName || e2.name || "Component";
}
function N(e2) {
  return e2 && "string" == typeof e2.styledComponentId;
}
var A$1 = "undefined" != typeof process && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", I$1 = "undefined" != typeof window && "HTMLElement" in window, P = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== {}.REACT_APP_SC_DISABLE_SPEEDY && "" !== {}.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== {}.REACT_APP_SC_DISABLE_SPEEDY && {}.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== {}.SC_DISABLE_SPEEDY && "" !== {}.SC_DISABLE_SPEEDY ? "false" !== {}.SC_DISABLE_SPEEDY && {}.SC_DISABLE_SPEEDY : false);
function j(e2) {
  for (var t3 = arguments.length, n2 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n2[r3 - 1] = arguments[r3];
  throw new Error("An error occurred. See https://git.io/JUIaE#" + e2 + " for more information." + (n2.length > 0 ? " Args: " + n2.join(", ") : ""));
}
var T = function() {
  function e2(e3) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
  }
  var t3 = e2.prototype;
  return t3.indexOfGroup = function(e3) {
    for (var t4 = 0, n2 = 0; n2 < e3; n2++)
      t4 += this.groupSizes[n2];
    return t4;
  }, t3.insertRules = function(e3, t4) {
    if (e3 >= this.groupSizes.length) {
      for (var n2 = this.groupSizes, r3 = n2.length, o = r3; e3 >= o; )
        (o <<= 1) < 0 && j(16, "" + e3);
      this.groupSizes = new Uint32Array(o), this.groupSizes.set(n2), this.length = o;
      for (var s = r3; s < o; s++)
        this.groupSizes[s] = 0;
    }
    for (var i = this.indexOfGroup(e3 + 1), a2 = 0, c2 = t4.length; a2 < c2; a2++)
      this.tag.insertRule(i, t4[a2]) && (this.groupSizes[e3]++, i++);
  }, t3.clearGroup = function(e3) {
    if (e3 < this.length) {
      var t4 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), r3 = n2 + t4;
      this.groupSizes[e3] = 0;
      for (var o = n2; o < r3; o++)
        this.tag.deleteRule(n2);
    }
  }, t3.getGroup = function(e3) {
    var t4 = "";
    if (e3 >= this.length || 0 === this.groupSizes[e3])
      return t4;
    for (var n2 = this.groupSizes[e3], r3 = this.indexOfGroup(e3), o = r3 + n2, s = r3; s < o; s++)
      t4 += this.tag.getRule(s) + "/*!sc*/\n";
    return t4;
  }, e2;
}(), x$1 = /* @__PURE__ */ new Map(), k$1 = /* @__PURE__ */ new Map(), V = 1, B$1 = function(e2) {
  if (x$1.has(e2))
    return x$1.get(e2);
  for (; k$1.has(V); )
    V++;
  var t3 = V++;
  return x$1.set(e2, t3), k$1.set(t3, e2), t3;
}, z$1 = function(e2) {
  return k$1.get(e2);
}, M = function(e2, t3) {
  t3 >= V && (V = t3 + 1), x$1.set(e2, t3), k$1.set(t3, e2);
}, G$1 = "style[" + A$1 + '][data-styled-version="5.3.6"]', L = new RegExp("^" + A$1 + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), F$1 = function(e2, t3, n2) {
  for (var r3, o = n2.split(","), s = 0, i = o.length; s < i; s++)
    (r3 = o[s]) && e2.registerName(t3, r3);
}, Y = function(e2, t3) {
  for (var n2 = (t3.textContent || "").split("/*!sc*/\n"), r3 = [], o = 0, s = n2.length; o < s; o++) {
    var i = n2[o].trim();
    if (i) {
      var a2 = i.match(L);
      if (a2) {
        var c2 = 0 | parseInt(a2[1], 10), u2 = a2[2];
        0 !== c2 && (M(u2, c2), F$1(e2, u2, a2[3]), e2.getTag().insertRules(c2, r3)), r3.length = 0;
      } else
        r3.push(i);
    }
  }
}, q$1 = function() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}, H$1 = function(e2) {
  var t3 = document.head, n2 = e2 || t3, r3 = document.createElement("style"), o = function(e3) {
    for (var t4 = e3.childNodes, n3 = t4.length; n3 >= 0; n3--) {
      var r4 = t4[n3];
      if (r4 && 1 === r4.nodeType && r4.hasAttribute(A$1))
        return r4;
    }
  }(n2), s = void 0 !== o ? o.nextSibling : null;
  r3.setAttribute(A$1, "active"), r3.setAttribute("data-styled-version", "5.3.6");
  var i = q$1();
  return i && r3.setAttribute("nonce", i), n2.insertBefore(r3, s), r3;
}, $$1 = function() {
  function e2(e3) {
    var t4 = this.element = H$1(e3);
    t4.appendChild(document.createTextNode("")), this.sheet = function(e4) {
      if (e4.sheet)
        return e4.sheet;
      for (var t5 = document.styleSheets, n2 = 0, r3 = t5.length; n2 < r3; n2++) {
        var o = t5[n2];
        if (o.ownerNode === e4)
          return o;
      }
      j(17);
    }(t4), this.length = 0;
  }
  var t3 = e2.prototype;
  return t3.insertRule = function(e3, t4) {
    try {
      return this.sheet.insertRule(t4, e3), this.length++, true;
    } catch (e4) {
      return false;
    }
  }, t3.deleteRule = function(e3) {
    this.sheet.deleteRule(e3), this.length--;
  }, t3.getRule = function(e3) {
    var t4 = this.sheet.cssRules[e3];
    return void 0 !== t4 && "string" == typeof t4.cssText ? t4.cssText : "";
  }, e2;
}(), W = function() {
  function e2(e3) {
    var t4 = this.element = H$1(e3);
    this.nodes = t4.childNodes, this.length = 0;
  }
  var t3 = e2.prototype;
  return t3.insertRule = function(e3, t4) {
    if (e3 <= this.length && e3 >= 0) {
      var n2 = document.createTextNode(t4), r3 = this.nodes[e3];
      return this.element.insertBefore(n2, r3 || null), this.length++, true;
    }
    return false;
  }, t3.deleteRule = function(e3) {
    this.element.removeChild(this.nodes[e3]), this.length--;
  }, t3.getRule = function(e3) {
    return e3 < this.length ? this.nodes[e3].textContent : "";
  }, e2;
}(), U = function() {
  function e2(e3) {
    this.rules = [], this.length = 0;
  }
  var t3 = e2.prototype;
  return t3.insertRule = function(e3, t4) {
    return e3 <= this.length && (this.rules.splice(e3, 0, t4), this.length++, true);
  }, t3.deleteRule = function(e3) {
    this.rules.splice(e3, 1), this.length--;
  }, t3.getRule = function(e3) {
    return e3 < this.length ? this.rules[e3] : "";
  }, e2;
}(), J = I$1, X = { isServer: !I$1, useCSSOMInjection: !P }, Z = function() {
  function e2(e3, t4, n2) {
    void 0 === e3 && (e3 = E$1), void 0 === t4 && (t4 = {}), this.options = v$1({}, X, {}, e3), this.gs = t4, this.names = new Map(n2), this.server = !!e3.isServer, !this.server && I$1 && J && (J = false, function(e4) {
      for (var t5 = document.querySelectorAll(G$1), n3 = 0, r3 = t5.length; n3 < r3; n3++) {
        var o = t5[n3];
        o && "active" !== o.getAttribute(A$1) && (Y(e4, o), o.parentNode && o.parentNode.removeChild(o));
      }
    }(this));
  }
  e2.registerId = function(e3) {
    return B$1(e3);
  };
  var t3 = e2.prototype;
  return t3.reconstructWithOptions = function(t4, n2) {
    return void 0 === n2 && (n2 = true), new e2(v$1({}, this.options, {}, t4), this.gs, n2 && this.names || void 0);
  }, t3.allocateGSInstance = function(e3) {
    return this.gs[e3] = (this.gs[e3] || 0) + 1;
  }, t3.getTag = function() {
    return this.tag || (this.tag = (n2 = (t4 = this.options).isServer, r3 = t4.useCSSOMInjection, o = t4.target, e3 = n2 ? new U(o) : r3 ? new $$1(o) : new W(o), new T(e3)));
    var e3, t4, n2, r3, o;
  }, t3.hasNameForId = function(e3, t4) {
    return this.names.has(e3) && this.names.get(e3).has(t4);
  }, t3.registerName = function(e3, t4) {
    if (B$1(e3), this.names.has(e3))
      this.names.get(e3).add(t4);
    else {
      var n2 = /* @__PURE__ */ new Set();
      n2.add(t4), this.names.set(e3, n2);
    }
  }, t3.insertRules = function(e3, t4, n2) {
    this.registerName(e3, t4), this.getTag().insertRules(B$1(e3), n2);
  }, t3.clearNames = function(e3) {
    this.names.has(e3) && this.names.get(e3).clear();
  }, t3.clearRules = function(e3) {
    this.getTag().clearGroup(B$1(e3)), this.clearNames(e3);
  }, t3.clearTag = function() {
    this.tag = void 0;
  }, t3.toString = function() {
    return function(e3) {
      for (var t4 = e3.getTag(), n2 = t4.length, r3 = "", o = 0; o < n2; o++) {
        var s = z$1(o);
        if (void 0 !== s) {
          var i = e3.names.get(s), a2 = t4.getGroup(o);
          if (i && a2 && i.size) {
            var c2 = A$1 + ".g" + o + '[id="' + s + '"]', u2 = "";
            void 0 !== i && i.forEach(function(e4) {
              e4.length > 0 && (u2 += e4 + ",");
            }), r3 += "" + a2 + c2 + '{content:"' + u2 + '"}/*!sc*/\n';
          }
        }
      }
      return r3;
    }(this);
  }, e2;
}(), K = /(a)(d)/gi, Q = function(e2) {
  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
};
function ee(e2) {
  var t3, n2 = "";
  for (t3 = Math.abs(e2); t3 > 52; t3 = t3 / 52 | 0)
    n2 = Q(t3 % 52) + n2;
  return (Q(t3 % 52) + n2).replace(K, "$1-$2");
}
var te = function(e2, t3) {
  for (var n2 = t3.length; n2; )
    e2 = 33 * e2 ^ t3.charCodeAt(--n2);
  return e2;
}, ne = function(e2) {
  return te(5381, e2);
};
function re(e2) {
  for (var t3 = 0; t3 < e2.length; t3 += 1) {
    var n2 = e2[t3];
    if (b$1(n2) && !N(n2))
      return false;
  }
  return true;
}
var oe = ne("5.3.6"), se = function() {
  function e2(e3, t3, n2) {
    this.rules = e3, this.staticRulesId = "", this.isStatic = (void 0 === n2 || n2.isStatic) && re(e3), this.componentId = t3, this.baseHash = te(oe, t3), this.baseStyle = n2, Z.registerId(t3);
  }
  return e2.prototype.generateAndInjectStyles = function(e3, t3, n2) {
    var r3 = this.componentId, o = [];
    if (this.baseStyle && o.push(this.baseStyle.generateAndInjectStyles(e3, t3, n2)), this.isStatic && !n2.hash)
      if (this.staticRulesId && t3.hasNameForId(r3, this.staticRulesId))
        o.push(this.staticRulesId);
      else {
        var s = Ne(this.rules, e3, t3, n2).join(""), i = ee(te(this.baseHash, s) >>> 0);
        if (!t3.hasNameForId(r3, i)) {
          var a2 = n2(s, "." + i, void 0, r3);
          t3.insertRules(r3, i, a2);
        }
        o.push(i), this.staticRulesId = i;
      }
    else {
      for (var c2 = this.rules.length, u2 = te(this.baseHash, n2.hash), l2 = "", d3 = 0; d3 < c2; d3++) {
        var h2 = this.rules[d3];
        if ("string" == typeof h2)
          l2 += h2;
        else if (h2) {
          var p2 = Ne(h2, e3, t3, n2), f2 = Array.isArray(p2) ? p2.join("") : p2;
          u2 = te(u2, f2 + d3), l2 += f2;
        }
      }
      if (l2) {
        var m2 = ee(u2 >>> 0);
        if (!t3.hasNameForId(r3, m2)) {
          var y2 = n2(l2, "." + m2, void 0, r3);
          t3.insertRules(r3, m2, y2);
        }
        o.push(m2);
      }
    }
    return o.join(" ");
  }, e2;
}(), ie = /^\s*\/\/.*$/gm, ae = [":", "[", ".", "#"];
function ce(e2) {
  var t3, n2, r3, o, s = void 0 === e2 ? E$1 : e2, i = s.options, a2 = void 0 === i ? E$1 : i, c2 = s.plugins, u2 = void 0 === c2 ? w$1 : c2, l2 = new stylis_min(a2), d3 = [], h2 = function(e3) {
    function t4(t5) {
      if (t5)
        try {
          e3(t5 + "}");
        } catch (e4) {
        }
    }
    return function(n3, r4, o2, s2, i2, a3, c3, u3, l3, d4) {
      switch (n3) {
        case 1:
          if (0 === l3 && 64 === r4.charCodeAt(0))
            return e3(r4 + ";"), "";
          break;
        case 2:
          if (0 === u3)
            return r4 + "/*|*/";
          break;
        case 3:
          switch (u3) {
            case 102:
            case 112:
              return e3(o2[0] + r4), "";
            default:
              return r4 + (0 === d4 ? "/*|*/" : "");
          }
        case -2:
          r4.split("/*|*/}").forEach(t4);
      }
    };
  }(function(e3) {
    d3.push(e3);
  }), f2 = function(e3, r4, s2) {
    return 0 === r4 && -1 !== ae.indexOf(s2[n2.length]) || s2.match(o) ? e3 : "." + t3;
  };
  function m2(e3, s2, i2, a3) {
    void 0 === a3 && (a3 = "&");
    var c3 = e3.replace(ie, ""), u3 = s2 && i2 ? i2 + " " + s2 + " { " + c3 + " }" : c3;
    return t3 = a3, n2 = s2, r3 = new RegExp("\\" + n2 + "\\b", "g"), o = new RegExp("(\\" + n2 + "\\b){2,}"), l2(i2 || !s2 ? "" : s2, u3);
  }
  return l2.use([].concat(u2, [function(e3, t4, o2) {
    2 === e3 && o2.length && o2[0].lastIndexOf(n2) > 0 && (o2[0] = o2[0].replace(r3, f2));
  }, h2, function(e3) {
    if (-2 === e3) {
      var t4 = d3;
      return d3 = [], t4;
    }
  }])), m2.hash = u2.length ? u2.reduce(function(e3, t4) {
    return t4.name || j(15), te(e3, t4.name);
  }, 5381).toString() : "", m2;
}
var ue = React.createContext();
ue.Consumer;
var de = React.createContext(), he = (de.Consumer, new Z()), pe = ce();
function fe() {
  return reactExports.useContext(ue) || he;
}
function me() {
  return reactExports.useContext(de) || pe;
}
var ve = function() {
  function e2(e3, t3) {
    var n2 = this;
    this.inject = function(e4, t4) {
      void 0 === t4 && (t4 = pe);
      var r3 = n2.name + t4.hash;
      e4.hasNameForId(n2.id, r3) || e4.insertRules(n2.id, r3, t4(n2.rules, r3, "@keyframes"));
    }, this.toString = function() {
      return j(12, String(n2.name));
    }, this.name = e3, this.id = "sc-keyframes-" + e3, this.rules = t3;
  }
  return e2.prototype.getName = function(e3) {
    return void 0 === e3 && (e3 = pe), this.name + e3.hash;
  }, e2;
}(), ge = /([A-Z])/, Se = /([A-Z])/g, we = /^ms-/, Ee = function(e2) {
  return "-" + e2.toLowerCase();
};
function be(e2) {
  return ge.test(e2) ? e2.replace(Se, Ee).replace(we, "-ms-") : e2;
}
var _e = function(e2) {
  return null == e2 || false === e2 || "" === e2;
};
function Ne(e2, n2, r3, o) {
  if (Array.isArray(e2)) {
    for (var s, i = [], a2 = 0, c2 = e2.length; a2 < c2; a2 += 1)
      "" !== (s = Ne(e2[a2], n2, r3, o)) && (Array.isArray(s) ? i.push.apply(i, s) : i.push(s));
    return i;
  }
  if (_e(e2))
    return "";
  if (N(e2))
    return "." + e2.styledComponentId;
  if (b$1(e2)) {
    if ("function" != typeof (l2 = e2) || l2.prototype && l2.prototype.isReactComponent || !n2)
      return e2;
    var u2 = e2(n2);
    return Ne(u2, n2, r3, o);
  }
  var l2;
  return e2 instanceof ve ? r3 ? (e2.inject(r3, o), e2.getName(o)) : e2 : S(e2) ? function e3(t3, n3) {
    var r4, o2, s2 = [];
    for (var i2 in t3)
      t3.hasOwnProperty(i2) && !_e(t3[i2]) && (Array.isArray(t3[i2]) && t3[i2].isCss || b$1(t3[i2]) ? s2.push(be(i2) + ":", t3[i2], ";") : S(t3[i2]) ? s2.push.apply(s2, e3(t3[i2], i2)) : s2.push(be(i2) + ": " + (r4 = i2, null == (o2 = t3[i2]) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || r4 in unitlessKeys ? String(o2).trim() : o2 + "px") + ";"));
    return n3 ? [n3 + " {"].concat(s2, ["}"]) : s2;
  }(e2) : e2.toString();
}
var Ae = function(e2) {
  return Array.isArray(e2) && (e2.isCss = true), e2;
};
function Ce(e2) {
  for (var t3 = arguments.length, n2 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n2[r3 - 1] = arguments[r3];
  return b$1(e2) || S(e2) ? Ae(Ne(g$1(w$1, [e2].concat(n2)))) : 0 === n2.length && 1 === e2.length && "string" == typeof e2[0] ? e2 : Ae(Ne(g$1(e2, n2)));
}
var Re = function(e2, t3, n2) {
  return void 0 === n2 && (n2 = E$1), e2.theme !== n2.theme && e2.theme || t3 || n2.theme;
}, De = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, je = /(^-|-$)/g;
function Te(e2) {
  return e2.replace(De, "-").replace(je, "");
}
var xe = function(e2) {
  return ee(ne(e2) >>> 0);
};
function ke(e2) {
  return "string" == typeof e2 && true;
}
var Ve = function(e2) {
  return "function" == typeof e2 || "object" == typeof e2 && null !== e2 && !Array.isArray(e2);
}, Be = function(e2) {
  return "__proto__" !== e2 && "constructor" !== e2 && "prototype" !== e2;
};
function ze(e2, t3, n2) {
  var r3 = e2[n2];
  Ve(t3) && Ve(r3) ? Me(r3, t3) : e2[n2] = t3;
}
function Me(e2) {
  for (var t3 = arguments.length, n2 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n2[r3 - 1] = arguments[r3];
  for (var o = 0, s = n2; o < s.length; o++) {
    var i = s[o];
    if (Ve(i))
      for (var a2 in i)
        Be(a2) && ze(e2, i[a2], a2);
  }
  return e2;
}
var Ge = React.createContext();
Ge.Consumer;
var Ye = {};
function qe(e2, t3, n2) {
  var o = N(e2), i = !ke(e2), a2 = t3.attrs, c2 = void 0 === a2 ? w$1 : a2, d3 = t3.componentId, h2 = void 0 === d3 ? function(e3, t4) {
    var n3 = "string" != typeof e3 ? "sc" : Te(e3);
    Ye[n3] = (Ye[n3] || 0) + 1;
    var r3 = n3 + "-" + xe("5.3.6" + n3 + Ye[n3]);
    return t4 ? t4 + "-" + r3 : r3;
  }(t3.displayName, t3.parentComponentId) : d3, p2 = t3.displayName, f2 = void 0 === p2 ? function(e3) {
    return ke(e3) ? "styled." + e3 : "Styled(" + _(e3) + ")";
  }(e2) : p2, g2 = t3.displayName && t3.componentId ? Te(t3.displayName) + "-" + t3.componentId : t3.componentId || h2, S2 = o && e2.attrs ? Array.prototype.concat(e2.attrs, c2).filter(Boolean) : c2, A2 = t3.shouldForwardProp;
  o && e2.shouldForwardProp && (A2 = t3.shouldForwardProp ? function(n3, r3, o2) {
    return e2.shouldForwardProp(n3, r3, o2) && t3.shouldForwardProp(n3, r3, o2);
  } : e2.shouldForwardProp);
  var C2, I2 = new se(n2, g2, o ? e2.componentStyle : void 0), P2 = I2.isStatic && 0 === c2.length, O2 = function(e3, t4) {
    return function(e4, t5, n3, r3) {
      var o2 = e4.attrs, i2 = e4.componentStyle, a3 = e4.defaultProps, c3 = e4.foldedComponentIds, d4 = e4.shouldForwardProp, h3 = e4.styledComponentId, p3 = e4.target;
      var f3 = function(e5, t6, n4) {
        void 0 === e5 && (e5 = E$1);
        var r4 = v$1({}, t6, { theme: e5 }), o3 = {};
        return n4.forEach(function(e6) {
          var t7, n5, s, i3 = e6;
          for (t7 in b$1(i3) && (i3 = i3(r4)), i3)
            r4[t7] = o3[t7] = "className" === t7 ? (n5 = o3[t7], s = i3[t7], n5 && s ? n5 + " " + s : n5 || s) : i3[t7];
        }), [r4, o3];
      }(Re(t5, reactExports.useContext(Ge), a3) || E$1, t5, o2), y2 = f3[0], g3 = f3[1], S3 = function(e5, t6, n4, r4) {
        var o3 = fe(), s = me(), i3 = t6 ? e5.generateAndInjectStyles(E$1, o3, s) : e5.generateAndInjectStyles(n4, o3, s);
        return i3;
      }(i2, r3, y2), w2 = n3, _2 = g3.$as || t5.$as || g3.as || t5.as || p3, N2 = ke(_2), A3 = g3 !== t5 ? v$1({}, t5, {}, g3) : t5, C3 = {};
      for (var I3 in A3)
        "$" !== I3[0] && "as" !== I3 && ("forwardedAs" === I3 ? C3.as = A3[I3] : (d4 ? d4(I3, isPropValid, _2) : !N2 || isPropValid(I3)) && (C3[I3] = A3[I3]));
      return t5.style && g3.style !== t5.style && (C3.style = v$1({}, t5.style, {}, g3.style)), C3.className = Array.prototype.concat(c3, h3, S3 !== h3 ? S3 : null, t5.className, g3.className).filter(Boolean).join(" "), C3.ref = w2, reactExports.createElement(_2, C3);
    }(C2, e3, t4, P2);
  };
  return O2.displayName = f2, (C2 = React.forwardRef(O2)).attrs = S2, C2.componentStyle = I2, C2.displayName = f2, C2.shouldForwardProp = A2, C2.foldedComponentIds = o ? Array.prototype.concat(e2.foldedComponentIds, e2.styledComponentId) : w$1, C2.styledComponentId = g2, C2.target = o ? e2.target : e2, C2.withComponent = function(e3) {
    var r3 = t3.componentId, o2 = function(e4, t4) {
      if (null == e4)
        return {};
      var n3, r4, o3 = {}, s2 = Object.keys(e4);
      for (r4 = 0; r4 < s2.length; r4++)
        n3 = s2[r4], t4.indexOf(n3) >= 0 || (o3[n3] = e4[n3]);
      return o3;
    }(t3, ["componentId"]), s = r3 && r3 + "-" + (ke(e3) ? e3 : Te(_(e3)));
    return qe(e3, v$1({}, o2, { attrs: S2, componentId: s }), n2);
  }, Object.defineProperty(C2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t4) {
    this._foldedDefaultProps = o ? Me({}, e2.defaultProps, t4) : t4;
  } }), C2.toString = function() {
    return "." + C2.styledComponentId;
  }, i && hoistNonReactStatics_cjs(C2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), C2;
}
var He = function(e2) {
  return function e3(t3, r3, o) {
    if (void 0 === o && (o = E$1), !reactIsExports$1.isValidElementType(r3))
      return j(1, String(r3));
    var s = function() {
      return t3(r3, o, Ce.apply(void 0, arguments));
    };
    return s.withConfig = function(n2) {
      return e3(t3, r3, v$1({}, o, {}, n2));
    }, s.attrs = function(n2) {
      return e3(t3, r3, v$1({}, o, { attrs: Array.prototype.concat(o.attrs, n2).filter(Boolean) }));
    }, s;
  }(qe, e2);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e2) {
  He[e2] = He(e2);
});
function Ue(e2) {
  for (var t3 = arguments.length, n2 = new Array(t3 > 1 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
    n2[r3 - 1] = arguments[r3];
  var o = Ce.apply(void 0, [e2].concat(n2)).join(""), s = xe(o);
  return new ve(s, o);
}
const styled = He;
var __makeTemplateObject$2 = globalThis && globalThis.__makeTemplateObject || function(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
};
var len = 242.776657104492;
var time = 1.6;
var anim = Ue(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject$2(["\n  12.5% {\n    stroke-dasharray: ", "px, ", "px;\n    stroke-dashoffset: -", "px;\n  }\n  43.75% {\n    stroke-dasharray: ", "px, ", "px;\n    stroke-dashoffset: -", "px;\n  }\n  100% {\n    stroke-dasharray: ", "px, ", "px;\n    stroke-dashoffset: -", "px;\n  }\n"], ["\n  12.5% {\n    stroke-dasharray: ", "px, ", "px;\n    stroke-dashoffset: -", "px;\n  }\n  43.75% {\n    stroke-dasharray: ", "px, ", "px;\n    stroke-dashoffset: -", "px;\n  }\n  100% {\n    stroke-dasharray: ", "px, ", "px;\n    stroke-dashoffset: -", "px;\n  }\n"])), len * 0.14, len, len * 0.11, len * 0.35, len, len * 0.35, len * 0.01, len, len * 0.99);
styled.path(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject$2(["\n  stroke-dasharray: ", "px, ", ";\n  stroke-dashoffset: 0;\n  animation: ", " ", "s linear infinite;\n"], ["\n  stroke-dasharray: ", "px, ", ";\n  stroke-dashoffset: 0;\n  animation: ", " ", "s linear infinite;\n"])), len * 0.01, len, anim, time);
var templateObject_1$2, templateObject_2$2;
var __assign$o = globalThis && globalThis.__assign || function() {
  __assign$o = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$o.apply(this, arguments);
};
var __assign$n = globalThis && globalThis.__assign || function() {
  __assign$n = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$n.apply(this, arguments);
};
var __assign$m = globalThis && globalThis.__assign || function() {
  __assign$m = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$m.apply(this, arguments);
};
var __assign$l = globalThis && globalThis.__assign || function() {
  __assign$l = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$l.apply(this, arguments);
};
var __assign$k = globalThis && globalThis.__assign || function() {
  __assign$k = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$k.apply(this, arguments);
};
var __assign$j = globalThis && globalThis.__assign || function() {
  __assign$j = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$j.apply(this, arguments);
};
var __assign$i = globalThis && globalThis.__assign || function() {
  __assign$i = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$i.apply(this, arguments);
};
var prop = function prop2(path, defaultValue) {
  return function() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (typeof props[path] !== "undefined") {
      return props[path];
    }
    if (path && path.indexOf(".") > 0) {
      var paths = path.split(".");
      var length2 = paths.length;
      var object = props[paths[0]];
      var index2 = 1;
      while (object != null && index2 < length2) {
        object = object[paths[index2]];
        index2 += 1;
      }
      if (typeof object !== "undefined") {
        return object;
      }
    }
    return defaultValue;
  };
};
var __makeTemplateObject$1 = globalThis && globalThis.__makeTemplateObject || function(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
};
var __assign$h = globalThis && globalThis.__assign || function() {
  __assign$h = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$h.apply(this, arguments);
};
var spin = Ue(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject$1(["\n to {\n    transform: rotate(360deg);\n  }\n"], ["\n to {\n    transform: rotate(360deg);\n  }\n"])));
styled.svg(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject$1(["\n  animation: ", " 0.75s steps(12, end) infinite;\n  animation-duration: ", "s;\n"], ["\n  animation: ", " 0.75s steps(12, end) infinite;\n  animation-duration: ", "s;\n"])), spin, prop("speed", "0.75"));
styled.polyline(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject$1(["\n  stroke-width: ", "px;\n  stroke-linecap: round;\n\n  &:nth-child(12n + 0) {\n    stroke-opacity: 0.08;\n  }\n\n  &:nth-child(12n + 1) {\n    stroke-opacity: 0.17;\n  }\n\n  &:nth-child(12n + 2) {\n    stroke-opacity: 0.25;\n  }\n\n  &:nth-child(12n + 3) {\n    stroke-opacity: 0.33;\n  }\n\n  &:nth-child(12n + 4) {\n    stroke-opacity: 0.42;\n  }\n\n  &:nth-child(12n + 5) {\n    stroke-opacity: 0.5;\n  }\n\n  &:nth-child(12n + 6) {\n    stroke-opacity: 0.58;\n  }\n\n  &:nth-child(12n + 7) {\n    stroke-opacity: 0.66;\n  }\n\n  &:nth-child(12n + 8) {\n    stroke-opacity: 0.75;\n  }\n\n  &:nth-child(12n + 9) {\n    stroke-opacity: 0.83;\n  }\n\n  &:nth-child(12n + 11) {\n    stroke-opacity: 0.92;\n  }\n"], ["\n  stroke-width: ", "px;\n  stroke-linecap: round;\n\n  &:nth-child(12n + 0) {\n    stroke-opacity: 0.08;\n  }\n\n  &:nth-child(12n + 1) {\n    stroke-opacity: 0.17;\n  }\n\n  &:nth-child(12n + 2) {\n    stroke-opacity: 0.25;\n  }\n\n  &:nth-child(12n + 3) {\n    stroke-opacity: 0.33;\n  }\n\n  &:nth-child(12n + 4) {\n    stroke-opacity: 0.42;\n  }\n\n  &:nth-child(12n + 5) {\n    stroke-opacity: 0.5;\n  }\n\n  &:nth-child(12n + 6) {\n    stroke-opacity: 0.58;\n  }\n\n  &:nth-child(12n + 7) {\n    stroke-opacity: 0.66;\n  }\n\n  &:nth-child(12n + 8) {\n    stroke-opacity: 0.75;\n  }\n\n  &:nth-child(12n + 9) {\n    stroke-opacity: 0.83;\n  }\n\n  &:nth-child(12n + 11) {\n    stroke-opacity: 0.92;\n  }\n"])), function(props) {
  return props.width;
});
var templateObject_1$1, templateObject_2$1, templateObject_3$1;
var __assign$g = globalThis && globalThis.__assign || function() {
  __assign$g = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$g.apply(this, arguments);
};
var TailSpin = function(_a) {
  var _b = _a.height, height3 = _b === void 0 ? 80 : _b, _c = _a.width, width3 = _c === void 0 ? 80 : _c, _d = _a.radius, radius = _d === void 0 ? 1 : _d, _e2 = _a.color, color2 = _e2 === void 0 ? DEFAULT_COLOR : _e2, _f = _a.ariaLabel, ariaLabel = _f === void 0 ? "tail-spin-loading" : _f, wrapperStyle = _a.wrapperStyle, wrapperClass = _a.wrapperClass, _g = _a.visible, visible = _g === void 0 ? true : _g;
  return React.createElement(
    "div",
    __assign$g({ style: __assign$g(__assign$g({}, getDefaultStyle(visible)), wrapperStyle), className: wrapperClass, "data-testid": "tail-spin-loading", "aria-label": ariaLabel }, DEFAULT_WAI_ARIA_ATTRIBUTE),
    React.createElement(
      "svg",
      { width: width3, height: height3, viewBox: "0 0 38 38", xmlns: "http://www.w3.org/2000/svg", "data-testid": "tail-spin-svg" },
      React.createElement(
        "defs",
        null,
        React.createElement(
          "linearGradient",
          { x1: "8.042%", y1: "0%", x2: "65.682%", y2: "23.865%", id: "a" },
          React.createElement("stop", { stopColor: color2, stopOpacity: "0", offset: "0%" }),
          React.createElement("stop", { stopColor: color2, stopOpacity: ".631", offset: "63.146%" }),
          React.createElement("stop", { stopColor: color2, offset: "100%" })
        )
      ),
      React.createElement(
        "g",
        { fill: "none", fillRule: "evenodd" },
        React.createElement(
          "g",
          { transform: "translate(1 1)" },
          React.createElement(
            "path",
            { d: "M36 18c0-9.94-8.06-18-18-18", id: "Oval-2", stroke: color2, strokeWidth: "2" },
            React.createElement("animateTransform", { attributeName: "transform", type: "rotate", from: "0 18 18", to: "360 18 18", dur: "0.9s", repeatCount: "indefinite" })
          ),
          React.createElement(
            "circle",
            { fill: "#fff", cx: "36", cy: "18", r: radius },
            React.createElement("animateTransform", { attributeName: "transform", type: "rotate", from: "0 18 18", to: "360 18 18", dur: "0.9s", repeatCount: "indefinite" })
          )
        )
      )
    )
  );
};
var __assign$f = globalThis && globalThis.__assign || function() {
  __assign$f = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$f.apply(this, arguments);
};
var __assign$e = globalThis && globalThis.__assign || function() {
  __assign$e = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$e.apply(this, arguments);
};
var __makeTemplateObject = globalThis && globalThis.__makeTemplateObject || function(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
};
var __assign$d = globalThis && globalThis.__assign || function() {
  __assign$d = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$d.apply(this, arguments);
};
var dash = Ue(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n to {\n    stroke-dashoffset: 136;\n  }\n"], ["\n to {\n    stroke-dashoffset: 136;\n  }\n"])));
styled.polygon(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n  stroke-dasharray: 17;\n  animation: ", " 2.5s cubic-bezier(0.35, 0.04, 0.63, 0.95) infinite;\n"], ["\n  stroke-dasharray: 17;\n  animation: ", " 2.5s cubic-bezier(0.35, 0.04, 0.63, 0.95) infinite;\n"])), dash);
styled.svg(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n  transform-origin: 50% 65%;\n"], ["\n  transform-origin: 50% 65%;\n"])));
var templateObject_1, templateObject_2, templateObject_3;
var __assign$c = globalThis && globalThis.__assign || function() {
  __assign$c = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$c.apply(this, arguments);
};
var __assign$b = globalThis && globalThis.__assign || function() {
  __assign$b = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$b.apply(this, arguments);
};
var __assign$a = globalThis && globalThis.__assign || function() {
  __assign$a = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$a.apply(this, arguments);
};
var __assign$9 = globalThis && globalThis.__assign || function() {
  __assign$9 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$9.apply(this, arguments);
};
var __assign$8 = globalThis && globalThis.__assign || function() {
  __assign$8 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$8.apply(this, arguments);
};
var __assign$7 = globalThis && globalThis.__assign || function() {
  __assign$7 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$7.apply(this, arguments);
};
var __assign$6 = globalThis && globalThis.__assign || function() {
  __assign$6 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$6.apply(this, arguments);
};
var __assign$5 = globalThis && globalThis.__assign || function() {
  __assign$5 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$5.apply(this, arguments);
};
var __assign$4 = globalThis && globalThis.__assign || function() {
  __assign$4 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$4.apply(this, arguments);
};
var __assign$3 = globalThis && globalThis.__assign || function() {
  __assign$3 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$3.apply(this, arguments);
};
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$2.apply(this, arguments);
};
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign$1.apply(this, arguments);
};
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t3[p2] = s[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function LoginForm({ handleRegisterClick }) {
  const [statusText, setStatusText] = reactExports.useState(void 0);
  const [sucessfullLogin, setSucessfullLogin] = reactExports.useState(false);
  const userContext = reactExports.useContext(UserContext);
  const loginMutation = useLoginMutation();
  const getCurrentUser = useMeQuery({
    enabled: false,
    onSuccess: (result) => {
      const user = result;
      setTimeout(() => {
        userContext == null ? void 0 : userContext.setUser(
          new UserDTO({
            email: user.email,
            id: user.id,
            initials: user.initials,
            name: user.name,
            roles: user.roles
          })
        );
      }, 500);
    },
    onError: (error) => {
      console.log(error);
    }
  });
  const handleSubmit = (event) => {
    event.preventDefault();
    setStatusText(void 0);
    const data = new FormData(event.currentTarget);
    const password = data.get("password").toString();
    const email = data.get("email").toString();
    loginMutation.mutateAsync(new LoginDTO({ email, password }), {
      onSuccess: async (result) => {
        localStorage.setItem("token", result);
        setStatusText("Pihlen probhlo spn ");
        setSucessfullLogin(true);
        getCurrentUser.refetch();
      },
      onError: () => {
        setStatusText("Email nebo heslo nemme bohuel v databzi ");
        setSucessfullLogin(false);
      }
    });
  };
  return /* @__PURE__ */ jsx(Container$1, { component: "main", maxWidth: "xs", children: /* @__PURE__ */ jsxs(
    Box$1,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      },
      pb: 2,
      children: [
        /* @__PURE__ */ jsx(Typography$1, { variant: "subtitle1", color: sucessfullLogin ? "primary" : "error", children: statusText }),
        /* @__PURE__ */ jsxs(Box$1, { component: "form", onSubmit: handleSubmit, noValidate: true, sx: { mt: 1 }, children: [
          /* @__PURE__ */ jsx(
            TextField$1,
            {
              margin: "normal",
              required: true,
              fullWidth: true,
              id: "email",
              label: "Email",
              name: "email",
              type: "email",
              autoComplete: "email",
              autoFocus: true
            }
          ),
          /* @__PURE__ */ jsx(
            TextField$1,
            {
              margin: "normal",
              required: true,
              fullWidth: true,
              name: "password",
              label: "Heslo",
              type: "password",
              id: "password",
              autoComplete: "current-password"
            }
          ),
          /* @__PURE__ */ jsxs(Button$2, { type: "submit", fullWidth: true, variant: "contained", sx: { mt: 3, mb: 2 }, children: [
            "Pihlsit",
            loginMutation.isLoading && /* @__PURE__ */ jsx(
              TailSpin,
              {
                height: "25",
                width: "25",
                color: "white",
                ariaLabel: "tail-spin-loading",
                radius: "2",
                wrapperStyle: {},
                wrapperClass: ""
              }
            )
          ] }),
          /* @__PURE__ */ jsx(Grid$1, { container: true, justifyContent: "end", children: /* @__PURE__ */ jsx(Grid$1, { item: true, children: /* @__PURE__ */ jsx(Button$2, { onClick: handleRegisterClick, children: /* @__PURE__ */ jsx(Typography$1, { variant: "body2", children: "Registrovat se" }) }) }) })
        ] })
      ]
    }
  ) });
}
function RegistrationForm({ handleLoginClick }) {
  const [statusText, setStatusText] = reactExports.useState(void 0);
  const [sucessfullRegistration, setSuccessfullRegistration] = reactExports.useState(false);
  const userContext = reactExports.useContext(UserContext);
  const registrationMutation = useRegisterMutation();
  const getCurrentUser = useMeQuery({
    enabled: false,
    onSuccess: (result) => {
      const user = result;
      setTimeout(() => {
        userContext == null ? void 0 : userContext.setUser({
          email: user.email,
          id: user.id,
          initials: user.initials,
          name: user.name,
          rights: user.rights
        });
      }, 500);
    },
    onError: (error) => {
      console.log(error);
    }
  });
  const handleSubmit = (event) => {
    event.preventDefault();
    setStatusText(void 0);
    const data = new FormData(event.currentTarget);
    const password = data.get("password").toString();
    const email = data.get("email").toString();
    const name = data.get("name").toString();
    registrationMutation.mutateAsync(new RegisterDTO({ email, name, password }), {
      onSuccess: (result) => {
        localStorage.setItem("token", result);
        setStatusText("Registrace probhla spn ");
        setSuccessfullRegistration(true);
        getCurrentUser.refetch();
      },
      onError: (error) => {
        setStatusText((error == null ? void 0 : error.response) ?? error);
        setSuccessfullRegistration(false);
      }
    });
  };
  return /* @__PURE__ */ jsx(Container$1, { component: "main", maxWidth: "xs", children: /* @__PURE__ */ jsxs(
    Box$1,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center"
      },
      pb: 2,
      children: [
        /* @__PURE__ */ jsx(Typography$1, { variant: "subtitle1", color: sucessfullRegistration ? "primary" : "error", children: statusText }),
        /* @__PURE__ */ jsxs(Box$1, { component: "form", onSubmit: handleSubmit, noValidate: true, sx: { mt: 1 }, children: [
          /* @__PURE__ */ jsx(
            TextField$1,
            {
              margin: "normal",
              required: true,
              fullWidth: true,
              id: "email",
              label: "Email",
              name: "email",
              type: "email",
              autoComplete: "email",
              autoFocus: true
            }
          ),
          /* @__PURE__ */ jsx(
            TextField$1,
            {
              margin: "normal",
              required: true,
              fullWidth: true,
              id: "name",
              label: "Jmno",
              name: "name",
              type: "text",
              autoComplete: "name"
            }
          ),
          /* @__PURE__ */ jsx(
            TextField$1,
            {
              margin: "normal",
              required: true,
              fullWidth: true,
              name: "password",
              label: "Heslo",
              type: "password",
              id: "password",
              autoComplete: "current-password"
            }
          ),
          /* @__PURE__ */ jsxs(Button$2, { type: "submit", fullWidth: true, variant: "contained", sx: { mt: 3, mb: 2 }, children: [
            "Registrovat",
            registrationMutation.isLoading && /* @__PURE__ */ jsx(
              TailSpin,
              {
                height: "25",
                width: "25",
                color: "white",
                ariaLabel: "tail-spin-loading",
                radius: "2",
                wrapperStyle: {},
                wrapperClass: ""
              }
            )
          ] }),
          /* @__PURE__ */ jsx(Grid$1, { container: true, justifyContent: "end", children: /* @__PURE__ */ jsx(Grid$1, { item: true, children: /* @__PURE__ */ jsx(Button$2, { onClick: handleLoginClick, children: /* @__PURE__ */ jsx(Typography$1, { variant: "body2", children: "Pihlsit se" }) }) }) })
        ] })
      ]
    }
  ) });
}
const Transition = React.forwardRef(
  (props, ref) => {
    return /* @__PURE__ */ jsx(Slide$1, { direction: "down", ref, ...props });
  }
);
function Avatar2() {
  var _a, _b, _c;
  const [open, setOpen] = React.useState(false);
  const isDesktop = useMediaQuery(theme.breakpoints.up("md"));
  const userContext = reactExports.useContext(UserContext);
  const [openRegistration, setOpenRegistration] = React.useState(false);
  const handleClickOpen = () => {
    setOpen(true);
  };
  const handleClose = () => {
    setOpen(false);
  };
  const handleLogout = () => {
    userContext == null ? void 0 : userContext.setUser(void 0);
    localStorage.removeItem("token");
  };
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      sx: {
        width: "48px",
        height: "48px",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        paddingRight: 1
      },
      children: [
        /* @__PURE__ */ jsx(Avatar$2, { sx: { height: "32px", width: "32px" }, onClick: handleClickOpen, children: (_a = userContext == null ? void 0 : userContext.user) == null ? void 0 : _a.initials }),
        /* @__PURE__ */ jsxs(
          Dialog$1,
          {
            fullScreen: !isDesktop,
            fullWidth: isDesktop,
            maxWidth: isDesktop ? "xs" : false,
            open,
            onClose: handleClose,
            TransitionComponent: Transition,
            children: [
              /* @__PURE__ */ jsx(AppBar$1, { sx: { position: "relative" }, children: /* @__PURE__ */ jsxs(Toolbar$1, { variant: "dense", children: [
                /* @__PURE__ */ jsx(IconButton$1, { edge: "start", color: "inherit", onClick: handleClose, "aria-label": "close", children: /* @__PURE__ */ jsx(default_1$x, {}) }),
                /* @__PURE__ */ jsx(Typography$1, { sx: { ml: 2, flex: 1 }, variant: "h6", component: "div", children: "et" })
              ] }) }),
              /* @__PURE__ */ jsxs(Box$1, { sx: { display: "flex", justifyContent: "flex-start" }, children: [
                /* @__PURE__ */ jsx(Avatar$2, { sx: { height: "64px", width: "64px", m: 2 }, children: (_b = userContext == null ? void 0 : userContext.user) == null ? void 0 : _b.initials }),
                /* @__PURE__ */ jsxs(Box$1, { sx: { display: "flex", flexDirection: "column", justifyContent: "center" }, children: [
                  /* @__PURE__ */ jsx(Typography$1, { variant: "h6", component: "div", children: ((_c = userContext == null ? void 0 : userContext.user) == null ? void 0 : _c.name) ?? "Nepihlen uivatel" }),
                  (userContext == null ? void 0 : userContext.user) && /* @__PURE__ */ jsx(Typography$1, { variant: "body1", component: "div", children: "Spravovat et" })
                ] })
              ] }),
              /* @__PURE__ */ jsx(Divider$1, { variant: "middle" }),
              /* @__PURE__ */ jsx(List$1, {
                // eslint-disable-next-line no-nested-ternary
                children: (userContext == null ? void 0 : userContext.user) ? /* @__PURE__ */ jsxs(Fragment, { children: [
                  /* @__PURE__ */ jsx(SimpleListItem, { text: "Nastaven", icon: /* @__PURE__ */ jsx(default_1$v, {}) }),
                  /* @__PURE__ */ jsx(SimpleListItem, { text: "Odhlsit se", icon: /* @__PURE__ */ jsx(default_1$w, {}), onClick: handleLogout })
                ] }) : openRegistration ? /* @__PURE__ */ jsx(RegistrationForm, { handleLoginClick: () => setOpenRegistration(false) }) : /* @__PURE__ */ jsx(LoginForm, { handleRegisterClick: () => setOpenRegistration(true) })
              })
            ]
          }
        )
      ]
    }
  );
}
function HideOnScroll(props) {
  const { children } = props;
  const isDesktop = useMediaQuery(theme.breakpoints.up("md"));
  const trigger2 = useScrollTrigger();
  if (isDesktop)
    return children;
  return /* @__PURE__ */ jsx(Slide$1, { appear: false, direction: "down", in: !isDesktop && !trigger2, children });
}
function AppBarModified() {
  return /* @__PURE__ */ jsx(HideOnScroll, { children: /* @__PURE__ */ jsx(
    AppBar$1,
    {
      sx: {
        backgroundColor: "primary.main",
        zIndex: 1201
      },
      children: /* @__PURE__ */ jsxs(
        Toolbar$1,
        {
          sx: {
            display: "flex",
            justifyContent: "space-between",
            gap: [1, 0]
          },
          children: [
            /* @__PURE__ */ jsx(Logo, {}),
            /* @__PURE__ */ jsx(Search, {}),
            /* @__PURE__ */ jsx(Avatar2, {})
          ]
        }
      )
    }
  ) });
}
var AccountBox = {};
var _interopRequireDefault$w = interopRequireDefaultExports;
Object.defineProperty(AccountBox, "__esModule", {
  value: true
});
var default_1$u = AccountBox.default = void 0;
var _createSvgIcon$u = _interopRequireDefault$w(requireCreateSvgIcon());
var _jsxRuntime$u = require$$2;
var _default$u = (0, _createSvgIcon$u.default)(/* @__PURE__ */ (0, _jsxRuntime$u.jsx)("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm7 13H5v-.23c0-.62.28-1.2.76-1.58C7.47 15.82 9.64 15 12 15s4.53.82 6.24 2.19c.48.38.76.97.76 1.58V19z"
}), "AccountBox");
default_1$u = AccountBox.default = _default$u;
var Home = {};
var _interopRequireDefault$v = interopRequireDefaultExports;
Object.defineProperty(Home, "__esModule", {
  value: true
});
var default_1$t = Home.default = void 0;
var _createSvgIcon$t = _interopRequireDefault$v(requireCreateSvgIcon());
var _jsxRuntime$t = require$$2;
var _default$t = (0, _createSvgIcon$t.default)(/* @__PURE__ */ (0, _jsxRuntime$t.jsx)("path", {
  d: "M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"
}), "Home");
default_1$t = Home.default = _default$t;
var CloudUpload = {};
var _interopRequireDefault$u = interopRequireDefaultExports;
Object.defineProperty(CloudUpload, "__esModule", {
  value: true
});
var default_1$s = CloudUpload.default = void 0;
var _createSvgIcon$s = _interopRequireDefault$u(requireCreateSvgIcon());
var _jsxRuntime$s = require$$2;
var _default$s = (0, _createSvgIcon$s.default)(/* @__PURE__ */ (0, _jsxRuntime$s.jsx)("path", {
  d: "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"
}), "CloudUpload");
default_1$s = CloudUpload.default = _default$s;
var Dataset = {};
var _interopRequireDefault$t = interopRequireDefaultExports;
Object.defineProperty(Dataset, "__esModule", {
  value: true
});
var default_1$r = Dataset.default = void 0;
var _createSvgIcon$r = _interopRequireDefault$t(requireCreateSvgIcon());
var _jsxRuntime$r = require$$2;
var _default$r = (0, _createSvgIcon$r.default)(/* @__PURE__ */ (0, _jsxRuntime$r.jsx)("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 14H7v-4h4v4zm0-6H7V7h4v4zm6 6h-4v-4h4v4zm0-6h-4V7h4v4z"
}), "Dataset");
default_1$r = Dataset.default = _default$r;
var ManageAccounts = {};
var _interopRequireDefault$s = interopRequireDefaultExports;
Object.defineProperty(ManageAccounts, "__esModule", {
  value: true
});
var default_1$q = ManageAccounts.default = void 0;
var _createSvgIcon$q = _interopRequireDefault$s(requireCreateSvgIcon());
var _jsxRuntime$q = require$$2;
var _default$q = (0, _createSvgIcon$q.default)([/* @__PURE__ */ (0, _jsxRuntime$q.jsx)("circle", {
  cx: "10",
  cy: "8",
  r: "4"
}, "0"), /* @__PURE__ */ (0, _jsxRuntime$q.jsx)("path", {
  d: "M10.67 13.02c-.22-.01-.44-.02-.67-.02-2.42 0-4.68.67-6.61 1.82-.88.52-1.39 1.5-1.39 2.53V20h9.26c-.79-1.13-1.26-2.51-1.26-4 0-1.07.25-2.07.67-2.98zM20.75 16c0-.22-.03-.42-.06-.63l1.14-1.01-1-1.73-1.45.49c-.32-.27-.68-.48-1.08-.63L18 11h-2l-.3 1.49c-.4.15-.76.36-1.08.63l-1.45-.49-1 1.73 1.14 1.01c-.03.21-.06.41-.06.63s.03.42.06.63l-1.14 1.01 1 1.73 1.45-.49c.32.27.68.48 1.08.63L16 21h2l.3-1.49c.4-.15.76-.36 1.08-.63l1.45.49 1-1.73-1.14-1.01c.03-.21.06-.41.06-.63zM17 18c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"
}, "1")], "ManageAccounts");
default_1$q = ManageAccounts.default = _default$q;
var LocalOffer = {};
var _interopRequireDefault$r = interopRequireDefaultExports;
Object.defineProperty(LocalOffer, "__esModule", {
  value: true
});
var default_1$p = LocalOffer.default = void 0;
var _createSvgIcon$p = _interopRequireDefault$r(requireCreateSvgIcon());
var _jsxRuntime$p = require$$2;
var _default$p = (0, _createSvgIcon$p.default)(/* @__PURE__ */ (0, _jsxRuntime$p.jsx)("path", {
  d: "m21.41 11.58-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7z"
}), "LocalOffer");
default_1$p = LocalOffer.default = _default$p;
var PlaylistPlay = {};
var _interopRequireDefault$q = interopRequireDefaultExports;
Object.defineProperty(PlaylistPlay, "__esModule", {
  value: true
});
var default_1$o = PlaylistPlay.default = void 0;
var _createSvgIcon$o = _interopRequireDefault$q(requireCreateSvgIcon());
var _jsxRuntime$o = require$$2;
var _default$o = (0, _createSvgIcon$o.default)(/* @__PURE__ */ (0, _jsxRuntime$o.jsx)("path", {
  d: "M3 10h11v2H3zm0-4h11v2H3zm0 8h7v2H3zm13-1v8l6-4z"
}), "PlaylistPlay");
default_1$o = PlaylistPlay.default = _default$o;
const CustomNavLink = reactExports.forwardRef((props, ref) => {
  const context = reactExports.useContext(NavigationContext);
  const handleClick = () => {
    context == null ? void 0 : context.setOpen(true);
  };
  return /* @__PURE__ */ jsx(
    NavLink,
    {
      ref,
      ...props,
      onClick: handleClick,
      className: ({ isActive }) => isActive ? `${props.className} Mui-selected` : props.className,
      end: true
    }
  );
});
function AndroidNavigation({ items }) {
  return /* @__PURE__ */ jsx(Paper$1, { sx: { position: "fixed", bottom: 0, left: 0, right: 0, zIndex: 1 }, elevation: 3, children: /* @__PURE__ */ jsx(BottomNavigation$1, { sx: { position: "fixed", bottom: 0, left: 0, right: 0 }, showLabels: true, children: items.map((item) => {
    return /* @__PURE__ */ jsx(
      BottomNavigationAction$1,
      {
        component: CustomNavLink,
        to: item.route,
        label: item.title,
        icon: item.icon
      },
      item.route
    );
  }) }) });
}
var Menu$1 = {};
var _interopRequireDefault$p = interopRequireDefaultExports;
Object.defineProperty(Menu$1, "__esModule", {
  value: true
});
var default_1$n = Menu$1.default = void 0;
var _createSvgIcon$n = _interopRequireDefault$p(requireCreateSvgIcon());
var _jsxRuntime$n = require$$2;
var _default$n = (0, _createSvgIcon$n.default)(/* @__PURE__ */ (0, _jsxRuntime$n.jsx)("path", {
  d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
}), "Menu");
default_1$n = Menu$1.default = _default$n;
function DesktopNavigation({ items }) {
  const context = reactExports.useContext(NavigationContext);
  const handleOpenClose = () => {
    context == null ? void 0 : context.setOpen(!(context == null ? void 0 : context.open));
  };
  const drawerWidth = 256;
  return /* @__PURE__ */ jsxs(
    Drawer$1,
    {
      variant: "permanent",
      open: context == null ? void 0 : context.open,
      anchor: "left",
      sx: {
        flexShrink: 0,
        width: drawerWidth,
        [`& .MuiDrawer-paper`]: { width: drawerWidth, boxSizing: "border-box" },
        transition: theme.transitions.create("width", {
          easing: theme.transitions.easing.sharp,
          duration: theme.transitions.duration.enteringScreen
        }),
        overflowX: "hidden",
        whiteSpace: "nowrap",
        boxSizing: "border-box",
        ...!(context == null ? void 0 : context.open) && {
          "& .MuiDrawer-paper": {
            transition: theme.transitions.create("width", {
              easing: theme.transitions.easing.sharp,
              duration: theme.transitions.duration.leavingScreen
            }),
            overflowX: "hidden",
            width: `calc(${theme.spacing(7)} + 1px)`
          },
          transition: theme.transitions.create("width", {
            easing: theme.transitions.easing.sharp,
            duration: theme.transitions.duration.leavingScreen
          }),
          overflowX: "hidden",
          width: `calc(${theme.spacing(7)} + 1px)`
        }
      },
      children: [
        /* @__PURE__ */ jsx(Toolbar$1, {}),
        /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(IconButton$1, { onClick: handleOpenClose, sx: { p: 2 }, children: /* @__PURE__ */ jsx(default_1$n, {}) }) }),
        /* @__PURE__ */ jsx(Divider$1, {}),
        /* @__PURE__ */ jsx(List$1, { children: items.map((item) => /* @__PURE__ */ jsx(ListItem$2, { disablePadding: true, sx: { display: "block" }, children: /* @__PURE__ */ jsxs(ListItemButton$1, { component: CustomNavLink, to: item.route, children: [
          /* @__PURE__ */ jsx(ListItemIcon$1, { children: item.icon }),
          /* @__PURE__ */ jsx(ListItemText$1, { primary: item.title })
        ] }, item.route) }, item.route)) })
      ]
    }
  );
}
const NavigationItems = [
  { route: "/", title: "Dom", icon: /* @__PURE__ */ jsx(default_1$t, {}) },
  {
    route: `/${Route.myVideos}`,
    title: "Moje videa",
    icon: /* @__PURE__ */ jsx(default_1$u, {}),
    // todo gearbox
    signed: true,
    userRole: ["videoEditor"]
  },
  {
    route: `/${Route.upload}`,
    title: "Nahrt video",
    icon: /* @__PURE__ */ jsx(default_1$s, {}),
    signed: true,
    userRole: ["videoEditor"]
  },
  {
    route: `/${Route.myChannels}`,
    title: "Moje kanly",
    icon: /* @__PURE__ */ jsx(default_1$r, {}),
    signed: true,
    userRole: ["videoEditor"]
  },
  {
    route: `/${Route.users}`,
    title: "Sprva uivatel",
    icon: /* @__PURE__ */ jsx(default_1$q, {}),
    signed: true,
    userRole: ["administrator"]
  },
  {
    route: `/${Route.tagEdit}`,
    title: "Sprva tag",
    icon: /* @__PURE__ */ jsx(default_1$p, {}),
    signed: true,
    userRole: ["administrator"]
  },
  {
    route: `/${Route.myPlaylists}`,
    title: "Sprva playlist",
    icon: /* @__PURE__ */ jsx(default_1$o, {}),
    signed: true,
    userRole: ["user", "administrator"]
  }
];
function Navigation() {
  const isDesktop = useMediaQuery(theme.breakpoints.up("md"));
  const userContext = reactExports.useContext(UserContext);
  const itemsWithRights = NavigationItems.filter(
    (x) => {
      var _a;
      return !x.signed || x.signed && (userContext == null ? void 0 : userContext.user) && (x.userRole === void 0 || ((_a = userContext == null ? void 0 : userContext.user) == null ? void 0 : _a.roles) && x.userRole.some((role) => {
        var _a2;
        return ((_a2 = userContext == null ? void 0 : userContext.user) == null ? void 0 : _a2.roles[role]) === true;
      }));
    }
  );
  return isDesktop ? /* @__PURE__ */ jsx(DesktopNavigation, { items: itemsWithRights }) : /* @__PURE__ */ jsx(AndroidNavigation, { items: itemsWithRights });
}
const NavigationContext = React.createContext(null);
const UserContext = React.createContext(null);
function Root() {
  const navigation = useNavigation();
  const [navigationOpen, setNavigationOpen] = reactExports.useState(true);
  const [user, setUser] = reactExports.useState();
  const [isLoading, setIsLoading] = reactExports.useState(true);
  const getCurrentUser = useMeQuery({
    enabled: false,
    onSuccess: (result) => {
      setUser(
        new UserDTO({
          email: result.email,
          id: result.id,
          initials: result.initials,
          name: result.name,
          roles: result.roles
        })
      );
      setIsLoading(false);
    },
    onError: () => {
      setUser(void 0);
      localStorage.removeItem("token");
      setIsLoading(false);
    }
  });
  const userContextMemo = reactExports.useMemo(
    () => ({
      isLoading,
      user,
      setUser
    }),
    [user, setUser]
  );
  const navigationContextMemo = reactExports.useMemo(
    () => ({
      open: navigationOpen,
      setOpen: setNavigationOpen
    }),
    [navigationOpen, setNavigationOpen]
  );
  reactExports.useEffect(() => {
    if (!user && localStorage.getItem("token")) {
      setIsLoading(true);
      getCurrentUser.refetch();
    }
  }, [user]);
  return /* @__PURE__ */ jsx(NavigationContext.Provider, { value: navigationContextMemo, children: /* @__PURE__ */ jsxs(UserContext.Provider, { value: userContextMemo, children: [
    /* @__PURE__ */ jsx(AppBarModified, {}),
    /* @__PURE__ */ jsxs(Box$3, { padding: { xs: 0, md: 0 }, width: "100%", children: [
      /* @__PURE__ */ jsx(Toolbar$1, {}),
      /* @__PURE__ */ jsx(Navigation, {}),
      /* @__PURE__ */ jsx(Box$3, { component: "main", sx: { flexGrow: 1, overflow: "auto" }, children: /* @__PURE__ */ jsx(
        Box$3,
        {
          id: "detail",
          className: navigation.state === "loading" ? "loading" : "",
          sx: {
            p: { xs: 0, md: "0 0 0 256px" },
            ...!navigationOpen && {
              p: { xs: 0, md: `0 0 0 calc(${theme.spacing(7)} - 1px)` },
              width: `calc(100% - ${theme.spacing(7)} + 1px)`,
              transition: theme.transitions.create(["width", "margin"], {
                easing: theme.transitions.easing.sharp,
                duration: theme.transitions.duration.enteringScreen
              })
            }
          },
          children: /* @__PURE__ */ jsx(Outlet, {})
        }
      ) })
    ] })
  ] }) });
}
function ErrorPage() {
  const error = useRouteError();
  return /* @__PURE__ */ jsx(Container$1, { maxWidth: "md", children: /* @__PURE__ */ jsxs(
    Box$1,
    {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      mt: 10,
      mb: 10,
      p: 4,
      bgcolor: "#f8f8f8",
      borderRadius: 10,
      boxShadow: 3,
      children: [
        /* @__PURE__ */ jsx(
          "img",
          {
            src: "https://robohash.org/error%20page",
            alt: "Funny Error Illustration",
            style: { width: "200px" }
          }
        ),
        /* @__PURE__ */ jsx(Typography$1, { variant: "h2", component: "h1", align: "center", gutterBottom: true, children: "Ups!" }),
        /* @__PURE__ */ jsx(Typography$1, { variant: "h6", component: "h2", align: "center", gutterBottom: true, children: error.message })
      ]
    }
  ) });
}
function GetInitials(input) {
  if (!input) {
    return void 0;
  }
  return input.indexOf(" ") > 0 ? `${input[0]}${input[input.indexOf(" ") + 1]}` : input[0];
}
function ChannelAvatar({ imageSrc, avatarInitials, large = false }) {
  return /* @__PURE__ */ jsx(
    Avatar$2,
    {
      sx: {
        width: large ? 48 : 24,
        height: large ? 48 : 24,
        border: "0.1px solid lightgray",
        padding: "4px",
        img: { objectFit: "fill", borderRadius: "50%" }
      },
      src: imageSrc,
      children: !imageSrc ? GetInitials(avatarInitials) : ""
    }
  );
}
function AvatarButton({ key, url, image, text, customAvatarText }) {
  return /* @__PURE__ */ jsxs(
    Box$3,
    {
      display: "flex",
      alignItems: "center",
      component: url ? Link : Box$3,
      to: url ?? void 0,
      padding: "4px !important",
      sx: {
        textDecoration: "none",
        color: "unset",
        ...url && {
          "&:hover": {
            backgroundColor: "rgba(0, 0, 0, 0.04)"
          }
        },
        borderRadius: "15px"
      },
      children: [
        /* @__PURE__ */ jsx(ChannelAvatar, { imageSrc: image, avatarInitials: customAvatarText ?? text, large: true }),
        /* @__PURE__ */ jsx(Typography$1, { paddingLeft: 1, children: text })
      ]
    },
    key
  );
}
const colors = [
  "#aa1945",
  "#3c3cad",
  "#140de5",
  "#ba1c14",
  "#8f15c4",
  "#1d1682",
  "#d6177d",
  "#c44274",
  "#5e16b7",
  "#c61baa",
  "#122182",
  "#18598e",
  "#c6235a",
  "#9144b5",
  "#35137c",
  "#09128c",
  "#aa2940",
  "#8e180e",
  "#8964c4",
  "#791df9",
  "#7048ba",
  "#2870c1",
  "#8239ef",
  "#037739",
  "#65128c",
  "#963410",
  "#12015b",
  "#350ccc",
  "#20930e",
  "#7446c9",
  "#5957ba",
  "#154a99",
  "#1c3bed",
  "#5139db",
  "#8f59d6",
  "#1a9e53",
  "#5f37d6",
  "#194c7f"
];
function GetRandomColor() {
  return colors[Math.floor(Math.random() * colors.length)];
}
function CustomChip({
  text,
  icon,
  onClick,
  onDelete,
  color: color2,
  bgColor,
  linkTo,
  link = true,
  active = false
}) {
  bgColor = bgColor ?? GetRandomColor();
  color2 = color2 ?? bgColor;
  const ConditionalLink = link ? Link : Box$1;
  return /* @__PURE__ */ jsx(ConditionalLink, { to: link ? linkTo ?? (text && searchTagsUrl([text])) ?? "" : "", children: /* @__PURE__ */ jsx(
    Chip$1,
    {
      label: text,
      icon,
      variant: "outlined",
      onClick,
      onDelete,
      clickable: true,
      sx: {
        color: color2,
        borderColor: bgColor,
        "&:hover": {
          backgroundColor: `${bgColor}55`
        },
        ...active && {
          color: "#FFF",
          backgroundColor: bgColor,
          "&:hover": {
            color: bgColor,
            "& .MuiChip-deleteIcon": {
              color: "#00000042"
            }
          },
          "& .MuiChip-deleteIcon": {
            color: "white"
          }
        }
      }
    },
    text
  ) });
}
const ApiUrl = `${"https://fs.panda7789.fun"}`;
const ApiPath = (input) => input ? `${ApiUrl}/${input}` : void 0;
async function getVideoById(id2) {
  return videosGET(id2);
}
function videoUrl(video2) {
  return `/${Route.video}/${video2.id}`;
}
function playlistParams(playlist, index2) {
  return `?playlist=${playlist.id}&index=${index2}`;
}
function IsDropDownMenuCustomAction(action) {
  return action.elementFactory !== void 0;
}
function DropDownMenu({ actions: actions2, sx, icon, text, enabled = true }) {
  const [open, setOpen] = React.useState(false);
  const anchorRef = React.useRef(null);
  const [listenClickAway, setListenClickAway] = React.useState(true);
  const handleToggle = (event) => {
    event.stopPropagation();
    event.preventDefault();
    setOpen((prevOpen2) => !prevOpen2);
  };
  const handleClose = (event) => {
    event.stopPropagation();
    event.preventDefault();
    if (anchorRef.current && anchorRef.current.contains(event.target)) {
      return;
    }
    setOpen(false);
  };
  const prevOpen = React.useRef(open);
  React.useEffect(() => {
    if (prevOpen.current === true && open === false) {
      anchorRef.current.focus();
    }
    prevOpen.current = open;
  }, [open]);
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      setOpen(false);
    } else if (event.key === "Escape") {
      setOpen(false);
    }
  };
  return /* @__PURE__ */ jsxs(Box$1, { sx, children: [
    /* @__PURE__ */ jsx(
      IconButton$1,
      {
        "aria-label": "more",
        id: "long-button",
        "aria-controls": "long-menu",
        "aria-haspopup": "true",
        onClick: handleToggle,
        ref: anchorRef,
        disabled: !enabled,
        children: icon
      }
    ),
    text && /* @__PURE__ */ jsx(Typography$1, { children: text }),
    /* @__PURE__ */ jsx(
      Popper$1,
      {
        open,
        anchorEl: anchorRef.current,
        role: void 0,
        placement: "bottom-start",
        transition: true,
        children: ({ TransitionProps, placement }) => /* @__PURE__ */ jsx(
          Grow$1,
          {
            ...TransitionProps,
            style: {
              transformOrigin: placement === "bottom-start" ? "left bottom" : "left bottom"
            },
            children: /* @__PURE__ */ jsx(Paper$1, { children: /* @__PURE__ */ jsx(ClickAwayListener, { onClickAway: listenClickAway ? handleClose : () => {
            }, children: /* @__PURE__ */ jsx(
              MenuList$1,
              {
                autoFocusItem: open,
                id: "composition-menu",
                "aria-labelledby": "composition-button",
                onKeyDown: handleListKeyDown,
                children: actions2.map((action) => {
                  if (IsDropDownMenuCustomAction(action)) {
                    return action.elementFactory({
                      onClose: (e2) => {
                        if (e2) {
                          e2.preventDefault();
                        }
                        setOpen(false);
                        setListenClickAway(true);
                      },
                      onClick: (e2) => {
                        e2.preventDefault();
                        e2.stopPropagation();
                        setListenClickAway(false);
                      }
                    });
                  }
                  const normalAction = action;
                  return /* @__PURE__ */ jsxs(
                    MenuItem$2,
                    {
                      onClick: (event) => {
                        handleClose(event);
                        normalAction.onClick();
                      },
                      children: [
                        normalAction.icon && /* @__PURE__ */ jsx(ListItemIcon$1, { children: normalAction.icon }),
                        /* @__PURE__ */ jsx(ListItemText$1, { children: normalAction.name })
                      ]
                    },
                    normalAction.name
                  );
                })
              }
            ) }) })
          }
        )
      }
    )
  ] });
}
function AspectRatio({ children, ratio, sx }) {
  return /* @__PURE__ */ jsx(
    Box$3,
    {
      sx: {
        ...sx,
        position: "relative",
        width: "100%",
        height: 0,
        paddingBottom: `calc((1 / ${ratio}) * 100%)`
      },
      children: /* @__PURE__ */ jsx(Box$3, { sx: { position: "absolute", top: 0, left: 0, width: "100%", height: "100%" }, children })
    }
  );
}
var win;
if (typeof window !== "undefined") {
  win = window;
} else if (typeof commonjsGlobal !== "undefined") {
  win = commonjsGlobal;
} else if (typeof self !== "undefined") {
  win = self;
} else {
  win = {};
}
var window_1 = win;
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var topLevel = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : {};
var minDoc = require$$0$1;
var doccy;
if (typeof document !== "undefined") {
  doccy = document;
} else {
  doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
  if (!doccy) {
    doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
  }
}
var document_1 = doccy;
var keycodeExports = {};
var keycode$1 = {
  get exports() {
    return keycodeExports;
  },
  set exports(v2) {
    keycodeExports = v2;
  }
};
(function(module, exports) {
  function keyCode(searchInput) {
    if (searchInput && "object" === typeof searchInput) {
      var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
      if (hasKeyCode)
        searchInput = hasKeyCode;
    }
    if ("number" === typeof searchInput)
      return names2[searchInput];
    var search2 = String(searchInput);
    var foundNamedKey = codes[search2.toLowerCase()];
    if (foundNamedKey)
      return foundNamedKey;
    var foundNamedKey = aliases2[search2.toLowerCase()];
    if (foundNamedKey)
      return foundNamedKey;
    if (search2.length === 1)
      return search2.charCodeAt(0);
    return void 0;
  }
  keyCode.isEventKey = function isEventKey(event, nameOrCode) {
    if (event && "object" === typeof event) {
      var keyCode2 = event.which || event.keyCode || event.charCode;
      if (keyCode2 === null || keyCode2 === void 0) {
        return false;
      }
      if (typeof nameOrCode === "string") {
        var foundNamedKey = codes[nameOrCode.toLowerCase()];
        if (foundNamedKey) {
          return foundNamedKey === keyCode2;
        }
        var foundNamedKey = aliases2[nameOrCode.toLowerCase()];
        if (foundNamedKey) {
          return foundNamedKey === keyCode2;
        }
      } else if (typeof nameOrCode === "number") {
        return nameOrCode === keyCode2;
      }
      return false;
    }
  };
  exports = module.exports = keyCode;
  var codes = exports.code = exports.codes = {
    "backspace": 8,
    "tab": 9,
    "enter": 13,
    "shift": 16,
    "ctrl": 17,
    "alt": 18,
    "pause/break": 19,
    "caps lock": 20,
    "esc": 27,
    "space": 32,
    "page up": 33,
    "page down": 34,
    "end": 35,
    "home": 36,
    "left": 37,
    "up": 38,
    "right": 39,
    "down": 40,
    "insert": 45,
    "delete": 46,
    "command": 91,
    "left command": 91,
    "right command": 93,
    "numpad *": 106,
    "numpad +": 107,
    "numpad -": 109,
    "numpad .": 110,
    "numpad /": 111,
    "num lock": 144,
    "scroll lock": 145,
    "my computer": 182,
    "my calculator": 183,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  var aliases2 = exports.aliases = {
    "windows": 91,
    "": 16,
    "": 18,
    "": 17,
    "": 91,
    "ctl": 17,
    "control": 17,
    "option": 18,
    "pause": 19,
    "break": 19,
    "caps": 20,
    "return": 13,
    "escape": 27,
    "spc": 32,
    "spacebar": 32,
    "pgup": 33,
    "pgdn": 34,
    "ins": 45,
    "del": 46,
    "cmd": 91
  };
  /*!
   * Programatically add the following
   */
  for (i = 97; i < 123; i++)
    codes[String.fromCharCode(i)] = i - 32;
  for (var i = 48; i < 58; i++)
    codes[i - 48] = i;
  for (i = 1; i < 13; i++)
    codes["f" + i] = i + 111;
  for (i = 0; i < 10; i++)
    codes["numpad " + i] = i + 96;
  var names2 = exports.names = exports.title = {};
  for (i in codes)
    names2[codes[i]] = i;
  for (var alias in aliases2) {
    codes[alias] = aliases2[alias];
  }
})(keycode$1, keycodeExports);
const keycode = keycodeExports;
var tuple = SafeParseTuple;
function SafeParseTuple(obj, reviver) {
  var json;
  var error = null;
  try {
    json = JSON.parse(obj, reviver);
  } catch (err) {
    error = err;
  }
  return [error, json];
}
var libExports = {};
var lib$2 = {
  get exports() {
    return libExports;
  },
  set exports(v2) {
    libExports = v2;
  }
};
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(_extends$9);
var isFunction_1$1 = isFunction$3;
var toString$1 = Object.prototype.toString;
function isFunction$3(fn2) {
  if (!fn2) {
    return false;
  }
  var string = toString$1.call(fn2);
  return string === "[object Function]" || typeof fn2 === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && // IE8 and below
  (fn2 === window.setTimeout || fn2 === window.alert || fn2 === window.confirm || fn2 === window.prompt);
}
var window$3 = window_1;
var httpResponseHandler = function httpResponseHandler2(callback2, decodeResponseBody) {
  if (decodeResponseBody === void 0) {
    decodeResponseBody = false;
  }
  return function(err, response, responseBody) {
    if (err) {
      callback2(err);
      return;
    }
    if (response.statusCode >= 400 && response.statusCode <= 599) {
      var cause = responseBody;
      if (decodeResponseBody) {
        if (window$3.TextDecoder) {
          var charset = getCharset(response.headers && response.headers["content-type"]);
          try {
            cause = new TextDecoder(charset).decode(responseBody);
          } catch (e2) {
          }
        } else {
          cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
        }
      }
      callback2({
        cause
      });
      return;
    }
    callback2(null, responseBody);
  };
};
function getCharset(contentTypeHeader) {
  if (contentTypeHeader === void 0) {
    contentTypeHeader = "";
  }
  return contentTypeHeader.toLowerCase().split(";").reduce(function(charset, contentType) {
    var _contentType$split = contentType.split("="), type2 = _contentType$split[0], value = _contentType$split[1];
    if (type2.trim() === "charset") {
      return value.trim();
    }
    return charset;
  }, "utf-8");
}
var httpHandler = httpResponseHandler;
var window$2 = window_1;
var _extends$7 = require$$1;
var isFunction$2 = isFunction_1$1;
createXHR.httpHandler = httpHandler;
/**
 * @license
 * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
 * Copyright (c) 2014 David Bjrklund
 * Available under the MIT license
 * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
 */
var parseHeaders = function parseHeaders2(headers) {
  var result = {};
  if (!headers) {
    return result;
  }
  headers.trim().split("\n").forEach(function(row) {
    var index2 = row.indexOf(":");
    var key = row.slice(0, index2).trim().toLowerCase();
    var value = row.slice(index2 + 1).trim();
    if (typeof result[key] === "undefined") {
      result[key] = value;
    } else if (Array.isArray(result[key])) {
      result[key].push(value);
    } else {
      result[key] = [result[key], value];
    }
  });
  return result;
};
lib$2.exports = createXHR;
libExports.default = createXHR;
createXHR.XMLHttpRequest = window$2.XMLHttpRequest || noop$4;
createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window$2.XDomainRequest;
forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
  createXHR[method === "delete" ? "del" : method] = function(uri, options, callback2) {
    options = initParams(uri, options, callback2);
    options.method = method.toUpperCase();
    return _createXHR(options);
  };
});
function forEachArray(array, iterator) {
  for (var i = 0; i < array.length; i++) {
    iterator(array[i]);
  }
}
function isEmpty$1(obj) {
  for (var i in obj) {
    if (obj.hasOwnProperty(i))
      return false;
  }
  return true;
}
function initParams(uri, options, callback2) {
  var params = uri;
  if (isFunction$2(options)) {
    callback2 = options;
    if (typeof uri === "string") {
      params = {
        uri
      };
    }
  } else {
    params = _extends$7({}, options, {
      uri
    });
  }
  params.callback = callback2;
  return params;
}
function createXHR(uri, options, callback2) {
  options = initParams(uri, options, callback2);
  return _createXHR(options);
}
function _createXHR(options) {
  if (typeof options.callback === "undefined") {
    throw new Error("callback argument missing");
  }
  var called = false;
  var callback2 = function cbOnce(err, response, body2) {
    if (!called) {
      called = true;
      options.callback(err, response, body2);
    }
  };
  function readystatechange() {
    if (xhr.readyState === 4) {
      setTimeout(loadFunc, 0);
    }
  }
  function getBody2() {
    var body2 = void 0;
    if (xhr.response) {
      body2 = xhr.response;
    } else {
      body2 = xhr.responseText || getXml(xhr);
    }
    if (isJson) {
      try {
        body2 = JSON.parse(body2);
      } catch (e2) {
      }
    }
    return body2;
  }
  function errorFunc(evt) {
    clearTimeout(timeoutTimer);
    if (!(evt instanceof Error)) {
      evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
    }
    evt.statusCode = 0;
    return callback2(evt, failureResponse);
  }
  function loadFunc() {
    if (aborted)
      return;
    var status;
    clearTimeout(timeoutTimer);
    if (options.useXDR && xhr.status === void 0) {
      status = 200;
    } else {
      status = xhr.status === 1223 ? 204 : xhr.status;
    }
    var response = failureResponse;
    var err = null;
    if (status !== 0) {
      response = {
        body: getBody2(),
        statusCode: status,
        method,
        headers: {},
        url: uri,
        rawRequest: xhr
      };
      if (xhr.getAllResponseHeaders) {
        response.headers = parseHeaders(xhr.getAllResponseHeaders());
      }
    } else {
      err = new Error("Internal XMLHttpRequest Error");
    }
    return callback2(err, response, response.body);
  }
  var xhr = options.xhr || null;
  if (!xhr) {
    if (options.cors || options.useXDR) {
      xhr = new createXHR.XDomainRequest();
    } else {
      xhr = new createXHR.XMLHttpRequest();
    }
  }
  var key;
  var aborted;
  var uri = xhr.url = options.uri || options.url;
  var method = xhr.method = options.method || "GET";
  var body = options.body || options.data;
  var headers = xhr.headers = options.headers || {};
  var sync = !!options.sync;
  var isJson = false;
  var timeoutTimer;
  var failureResponse = {
    body: void 0,
    headers: {},
    statusCode: 0,
    method,
    url: uri,
    rawRequest: xhr
  };
  if ("json" in options && options.json !== false) {
    isJson = true;
    headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
    if (method !== "GET" && method !== "HEAD") {
      headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
      body = JSON.stringify(options.json === true ? body : options.json);
    }
  }
  xhr.onreadystatechange = readystatechange;
  xhr.onload = loadFunc;
  xhr.onerror = errorFunc;
  xhr.onprogress = function() {
  };
  xhr.onabort = function() {
    aborted = true;
  };
  xhr.ontimeout = errorFunc;
  xhr.open(method, uri, !sync, options.username, options.password);
  if (!sync) {
    xhr.withCredentials = !!options.withCredentials;
  }
  if (!sync && options.timeout > 0) {
    timeoutTimer = setTimeout(function() {
      if (aborted)
        return;
      aborted = true;
      xhr.abort("timeout");
      var e2 = new Error("XMLHttpRequest timeout");
      e2.code = "ETIMEDOUT";
      errorFunc(e2);
    }, options.timeout);
  }
  if (xhr.setRequestHeader) {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        xhr.setRequestHeader(key, headers[key]);
      }
    }
  } else if (options.headers && !isEmpty$1(options.headers)) {
    throw new Error("Headers cannot be set on an XDomainRequest object");
  }
  if ("responseType" in options) {
    xhr.responseType = options.responseType;
  }
  if ("beforeSend" in options && typeof options.beforeSend === "function") {
    options.beforeSend(xhr);
  }
  xhr.send(body || null);
  return xhr;
}
function getXml(xhr) {
  try {
    if (xhr.responseType === "document") {
      return xhr.responseXML;
    }
    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
    if (xhr.responseType === "" && !firefoxBugTakenEffect) {
      return xhr.responseXML;
    }
  } catch (e2) {
  }
  return null;
}
function noop$4() {
}
var browserIndexExports = {};
var browserIndex = {
  get exports() {
    return browserIndexExports;
  },
  set exports(v2) {
    browserIndexExports = v2;
  }
};
var document$1 = document_1;
var _objCreate = Object.create || function() {
  function F2() {
  }
  return function(o) {
    if (arguments.length !== 1) {
      throw new Error("Object.create shim only accepts one parameter.");
    }
    F2.prototype = o;
    return new F2();
  };
}();
function ParsingError(errorData, message) {
  this.name = "ParsingError";
  this.code = errorData.code;
  this.message = message || errorData.message;
}
ParsingError.prototype = _objCreate(Error.prototype);
ParsingError.prototype.constructor = ParsingError;
ParsingError.Errors = {
  BadSignature: {
    code: 0,
    message: "Malformed WebVTT signature."
  },
  BadTimeStamp: {
    code: 1,
    message: "Malformed time stamp."
  }
};
function parseTimeStamp(input) {
  function computeSeconds(h2, m3, s, f2) {
    return (h2 | 0) * 3600 + (m3 | 0) * 60 + (s | 0) + (f2 | 0) / 1e3;
  }
  var m2 = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
  if (!m2) {
    return null;
  }
  if (m2[3]) {
    return computeSeconds(m2[1], m2[2], m2[3].replace(":", ""), m2[4]);
  } else if (m2[1] > 59) {
    return computeSeconds(m2[1], m2[2], 0, m2[4]);
  } else {
    return computeSeconds(0, m2[1], m2[2], m2[4]);
  }
}
function Settings() {
  this.values = _objCreate(null);
}
Settings.prototype = {
  // Only accept the first assignment to any key.
  set: function(k2, v2) {
    if (!this.get(k2) && v2 !== "") {
      this.values[k2] = v2;
    }
  },
  // Return the value for a key, or a default value.
  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with
  // a number of possible default values as properties where 'defaultKey' is
  // the key of the property that will be chosen; otherwise it's assumed to be
  // a single value.
  get: function(k2, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k2) ? this.values[k2] : dflt[defaultKey];
    }
    return this.has(k2) ? this.values[k2] : dflt;
  },
  // Check whether we have a value for a key.
  has: function(k2) {
    return k2 in this.values;
  },
  // Accept a setting if its one of the given alternatives.
  alt: function(k2, v2, a2) {
    for (var n2 = 0; n2 < a2.length; ++n2) {
      if (v2 === a2[n2]) {
        this.set(k2, v2);
        break;
      }
    }
  },
  // Accept a setting if its a valid (signed) integer.
  integer: function(k2, v2) {
    if (/^-?\d+$/.test(v2)) {
      this.set(k2, parseInt(v2, 10));
    }
  },
  // Accept a setting if its a valid percentage.
  percent: function(k2, v2) {
    if (v2.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
      v2 = parseFloat(v2);
      if (v2 >= 0 && v2 <= 100) {
        this.set(k2, v2);
        return true;
      }
    }
    return false;
  }
};
function parseOptions(input, callback2, keyValueDelim, groupDelim) {
  var groups = groupDelim ? input.split(groupDelim) : [input];
  for (var i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    var kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    var k2 = kv[0].trim();
    var v2 = kv[1].trim();
    callback2(k2, v2);
  }
}
function parseCue(input, cue, regionList) {
  var oInput = input;
  function consumeTimeStamp() {
    var ts2 = parseTimeStamp(input);
    if (ts2 === null) {
      throw new ParsingError(
        ParsingError.Errors.BadTimeStamp,
        "Malformed timestamp: " + oInput
      );
    }
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts2;
  }
  function consumeCueSettings(input2, cue2) {
    var settings = new Settings();
    parseOptions(input2, function(k2, v2) {
      switch (k2) {
        case "region":
          for (var i = regionList.length - 1; i >= 0; i--) {
            if (regionList[i].id === v2) {
              settings.set(k2, regionList[i].region);
              break;
            }
          }
          break;
        case "vertical":
          settings.alt(k2, v2, ["rl", "lr"]);
          break;
        case "line":
          var vals = v2.split(","), vals0 = vals[0];
          settings.integer(k2, vals0);
          settings.percent(k2, vals0) ? settings.set("snapToLines", false) : null;
          settings.alt(k2, vals0, ["auto"]);
          if (vals.length === 2) {
            settings.alt("lineAlign", vals[1], ["start", "center", "end"]);
          }
          break;
        case "position":
          vals = v2.split(",");
          settings.percent(k2, vals[0]);
          if (vals.length === 2) {
            settings.alt("positionAlign", vals[1], ["start", "center", "end"]);
          }
          break;
        case "size":
          settings.percent(k2, v2);
          break;
        case "align":
          settings.alt(k2, v2, ["start", "center", "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/);
    cue2.region = settings.get("region", null);
    cue2.vertical = settings.get("vertical", "");
    try {
      cue2.line = settings.get("line", "auto");
    } catch (e2) {
    }
    cue2.lineAlign = settings.get("lineAlign", "start");
    cue2.snapToLines = settings.get("snapToLines", true);
    cue2.size = settings.get("size", 100);
    try {
      cue2.align = settings.get("align", "center");
    } catch (e2) {
      cue2.align = settings.get("align", "middle");
    }
    try {
      cue2.position = settings.get("position", "auto");
    } catch (e2) {
      cue2.position = settings.get("position", {
        start: 0,
        left: 0,
        center: 50,
        middle: 50,
        end: 100,
        right: 100
      }, cue2.align);
    }
    cue2.positionAlign = settings.get("positionAlign", {
      start: "start",
      left: "start",
      center: "center",
      middle: "center",
      end: "end",
      right: "end"
    }, cue2.align);
  }
  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }
  skipWhitespace();
  cue.startTime = consumeTimeStamp();
  skipWhitespace();
  if (input.substr(0, 3) !== "-->") {
    throw new ParsingError(
      ParsingError.Errors.BadTimeStamp,
      "Malformed time stamp (time stamps must be separated by '-->'): " + oInput
    );
  }
  input = input.substr(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();
  skipWhitespace();
  consumeCueSettings(input, cue);
}
var TEXTAREA_ELEMENT = document$1.createElement && document$1.createElement("textarea");
var TAG_NAME = {
  c: "span",
  i: "i",
  b: "b",
  u: "u",
  ruby: "ruby",
  rt: "rt",
  v: "span",
  lang: "span"
};
var DEFAULT_COLOR_CLASS = {
  white: "rgba(255,255,255,1)",
  lime: "rgba(0,255,0,1)",
  cyan: "rgba(0,255,255,1)",
  red: "rgba(255,0,0,1)",
  yellow: "rgba(255,255,0,1)",
  magenta: "rgba(255,0,255,1)",
  blue: "rgba(0,0,255,1)",
  black: "rgba(0,0,0,1)"
};
var TAG_ANNOTATION = {
  v: "title",
  lang: "lang"
};
var NEEDS_PARENT = {
  rt: "ruby"
};
function parseContent(window2, input) {
  function nextToken() {
    if (!input) {
      return null;
    }
    function consume(result) {
      input = input.substr(result.length);
      return result;
    }
    var m3 = input.match(/^([^<]*)(<[^>]*>?)?/);
    return consume(m3[1] ? m3[1] : m3[2]);
  }
  function unescape2(s) {
    TEXTAREA_ELEMENT.innerHTML = s;
    s = TEXTAREA_ELEMENT.textContent;
    TEXTAREA_ELEMENT.textContent = "";
    return s;
  }
  function shouldAdd(current2, element) {
    return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current2.localName;
  }
  function createElement(type2, annotation) {
    var tagName = TAG_NAME[type2];
    if (!tagName) {
      return null;
    }
    var element = window2.document.createElement(tagName);
    var name = TAG_ANNOTATION[type2];
    if (name && annotation) {
      element[name] = annotation.trim();
    }
    return element;
  }
  var rootDiv = window2.document.createElement("div"), current = rootDiv, t3, tagStack = [];
  while ((t3 = nextToken()) !== null) {
    if (t3[0] === "<") {
      if (t3[1] === "/") {
        if (tagStack.length && tagStack[tagStack.length - 1] === t3.substr(2).replace(">", "")) {
          tagStack.pop();
          current = current.parentNode;
        }
        continue;
      }
      var ts2 = parseTimeStamp(t3.substr(1, t3.length - 2));
      var node2;
      if (ts2) {
        node2 = window2.document.createProcessingInstruction("timestamp", ts2);
        current.appendChild(node2);
        continue;
      }
      var m2 = t3.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
      if (!m2) {
        continue;
      }
      node2 = createElement(m2[1], m2[3]);
      if (!node2) {
        continue;
      }
      if (!shouldAdd(current, node2)) {
        continue;
      }
      if (m2[2]) {
        var classes = m2[2].split(".");
        classes.forEach(function(cl2) {
          var bgColor = /^bg_/.test(cl2);
          var colorName = bgColor ? cl2.slice(3) : cl2;
          if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
            var propName = bgColor ? "background-color" : "color";
            var propValue = DEFAULT_COLOR_CLASS[colorName];
            node2.style[propName] = propValue;
          }
        });
        node2.className = classes.join(" ");
      }
      tagStack.push(m2[1]);
      current.appendChild(node2);
      current = node2;
      continue;
    }
    current.appendChild(window2.document.createTextNode(unescape2(t3)));
  }
  return rootDiv;
}
var strongRTLRanges = [
  [1470, 1470],
  [1472, 1472],
  [1475, 1475],
  [1478, 1478],
  [1488, 1514],
  [1520, 1524],
  [1544, 1544],
  [1547, 1547],
  [1549, 1549],
  [1563, 1563],
  [1566, 1610],
  [1645, 1647],
  [1649, 1749],
  [1765, 1766],
  [1774, 1775],
  [1786, 1805],
  [1807, 1808],
  [1810, 1839],
  [1869, 1957],
  [1969, 1969],
  [1984, 2026],
  [2036, 2037],
  [2042, 2042],
  [2048, 2069],
  [2074, 2074],
  [2084, 2084],
  [2088, 2088],
  [2096, 2110],
  [2112, 2136],
  [2142, 2142],
  [2208, 2208],
  [2210, 2220],
  [8207, 8207],
  [64285, 64285],
  [64287, 64296],
  [64298, 64310],
  [64312, 64316],
  [64318, 64318],
  [64320, 64321],
  [64323, 64324],
  [64326, 64449],
  [64467, 64829],
  [64848, 64911],
  [64914, 64967],
  [65008, 65020],
  [65136, 65140],
  [65142, 65276],
  [67584, 67589],
  [67592, 67592],
  [67594, 67637],
  [67639, 67640],
  [67644, 67644],
  [67647, 67669],
  [67671, 67679],
  [67840, 67867],
  [67872, 67897],
  [67903, 67903],
  [67968, 68023],
  [68030, 68031],
  [68096, 68096],
  [68112, 68115],
  [68117, 68119],
  [68121, 68147],
  [68160, 68167],
  [68176, 68184],
  [68192, 68223],
  [68352, 68405],
  [68416, 68437],
  [68440, 68466],
  [68472, 68479],
  [68608, 68680],
  [126464, 126467],
  [126469, 126495],
  [126497, 126498],
  [126500, 126500],
  [126503, 126503],
  [126505, 126514],
  [126516, 126519],
  [126521, 126521],
  [126523, 126523],
  [126530, 126530],
  [126535, 126535],
  [126537, 126537],
  [126539, 126539],
  [126541, 126543],
  [126545, 126546],
  [126548, 126548],
  [126551, 126551],
  [126553, 126553],
  [126555, 126555],
  [126557, 126557],
  [126559, 126559],
  [126561, 126562],
  [126564, 126564],
  [126567, 126570],
  [126572, 126578],
  [126580, 126583],
  [126585, 126588],
  [126590, 126590],
  [126592, 126601],
  [126603, 126619],
  [126625, 126627],
  [126629, 126633],
  [126635, 126651],
  [1114109, 1114109]
];
function isStrongRTLChar(charCode) {
  for (var i = 0; i < strongRTLRanges.length; i++) {
    var currentRange = strongRTLRanges[i];
    if (charCode >= currentRange[0] && charCode <= currentRange[1]) {
      return true;
    }
  }
  return false;
}
function determineBidi(cueDiv) {
  var nodeStack = [], text = "", charCode;
  if (!cueDiv || !cueDiv.childNodes) {
    return "ltr";
  }
  function pushNodes(nodeStack2, node2) {
    for (var i2 = node2.childNodes.length - 1; i2 >= 0; i2--) {
      nodeStack2.push(node2.childNodes[i2]);
    }
  }
  function nextTextNode(nodeStack2) {
    if (!nodeStack2 || !nodeStack2.length) {
      return null;
    }
    var node2 = nodeStack2.pop(), text2 = node2.textContent || node2.innerText;
    if (text2) {
      var m2 = text2.match(/^.*(\n|\r)/);
      if (m2) {
        nodeStack2.length = 0;
        return m2[0];
      }
      return text2;
    }
    if (node2.tagName === "ruby") {
      return nextTextNode(nodeStack2);
    }
    if (node2.childNodes) {
      pushNodes(nodeStack2, node2);
      return nextTextNode(nodeStack2);
    }
  }
  pushNodes(nodeStack, cueDiv);
  while (text = nextTextNode(nodeStack)) {
    for (var i = 0; i < text.length; i++) {
      charCode = text.charCodeAt(i);
      if (isStrongRTLChar(charCode)) {
        return "rtl";
      }
    }
  }
  return "ltr";
}
function computeLinePos(cue) {
  if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) {
    return cue.line;
  }
  if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) {
    return -1;
  }
  var track = cue.track, trackList = track.textTrackList, count2 = 0;
  for (var i = 0; i < trackList.length && trackList[i] !== track; i++) {
    if (trackList[i].mode === "showing") {
      count2++;
    }
  }
  return ++count2 * -1;
}
function StyleBox() {
}
StyleBox.prototype.applyStyles = function(styles2, div) {
  div = div || this.div;
  for (var prop3 in styles2) {
    if (styles2.hasOwnProperty(prop3)) {
      div.style[prop3] = styles2[prop3];
    }
  }
};
StyleBox.prototype.formatStyle = function(val, unit) {
  return val === 0 ? 0 : val + unit;
};
function CueStyleBox(window2, cue, styleOptions) {
  StyleBox.call(this);
  this.cue = cue;
  this.cueDiv = parseContent(window2, cue.text);
  var styles2 = {
    color: "rgba(255, 255, 255, 1)",
    backgroundColor: "rgba(0, 0, 0, 0.8)",
    position: "relative",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    display: "inline",
    writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
    unicodeBidi: "plaintext"
  };
  this.applyStyles(styles2, this.cueDiv);
  this.div = window2.document.createElement("div");
  styles2 = {
    direction: determineBidi(this.cueDiv),
    writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
    unicodeBidi: "plaintext",
    textAlign: cue.align === "middle" ? "center" : cue.align,
    font: styleOptions.font,
    whiteSpace: "pre-line",
    position: "absolute"
  };
  this.applyStyles(styles2);
  this.div.appendChild(this.cueDiv);
  var textPos = 0;
  switch (cue.positionAlign) {
    case "start":
      textPos = cue.position;
      break;
    case "center":
      textPos = cue.position - cue.size / 2;
      break;
    case "end":
      textPos = cue.position - cue.size;
      break;
  }
  if (cue.vertical === "") {
    this.applyStyles({
      left: this.formatStyle(textPos, "%"),
      width: this.formatStyle(cue.size, "%")
    });
  } else {
    this.applyStyles({
      top: this.formatStyle(textPos, "%"),
      height: this.formatStyle(cue.size, "%")
    });
  }
  this.move = function(box) {
    this.applyStyles({
      top: this.formatStyle(box.top, "px"),
      bottom: this.formatStyle(box.bottom, "px"),
      left: this.formatStyle(box.left, "px"),
      right: this.formatStyle(box.right, "px"),
      height: this.formatStyle(box.height, "px"),
      width: this.formatStyle(box.width, "px")
    });
  };
}
CueStyleBox.prototype = _objCreate(StyleBox.prototype);
CueStyleBox.prototype.constructor = CueStyleBox;
function BoxPosition(obj) {
  var lh2, height3, width3, top2;
  if (obj.div) {
    height3 = obj.div.offsetHeight;
    width3 = obj.div.offsetWidth;
    top2 = obj.div.offsetTop;
    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
    obj = obj.div.getBoundingClientRect();
    lh2 = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
  }
  this.left = obj.left;
  this.right = obj.right;
  this.top = obj.top || top2;
  this.height = obj.height || height3;
  this.bottom = obj.bottom || top2 + (obj.height || height3);
  this.width = obj.width || width3;
  this.lineHeight = lh2 !== void 0 ? lh2 : obj.lineHeight;
}
BoxPosition.prototype.move = function(axis, toMove) {
  toMove = toMove !== void 0 ? toMove : this.lineHeight;
  switch (axis) {
    case "+x":
      this.left += toMove;
      this.right += toMove;
      break;
    case "-x":
      this.left -= toMove;
      this.right -= toMove;
      break;
    case "+y":
      this.top += toMove;
      this.bottom += toMove;
      break;
    case "-y":
      this.top -= toMove;
      this.bottom -= toMove;
      break;
  }
};
BoxPosition.prototype.overlaps = function(b2) {
  return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
};
BoxPosition.prototype.overlapsAny = function(boxes) {
  for (var i = 0; i < boxes.length; i++) {
    if (this.overlaps(boxes[i])) {
      return true;
    }
  }
  return false;
};
BoxPosition.prototype.within = function(container2) {
  return this.top >= container2.top && this.bottom <= container2.bottom && this.left >= container2.left && this.right <= container2.right;
};
BoxPosition.prototype.overlapsOppositeAxis = function(container2, axis) {
  switch (axis) {
    case "+x":
      return this.left < container2.left;
    case "-x":
      return this.right > container2.right;
    case "+y":
      return this.top < container2.top;
    case "-y":
      return this.bottom > container2.bottom;
  }
};
BoxPosition.prototype.intersectPercentage = function(b2) {
  var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y2 = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y2;
  return intersectArea / (this.height * this.width);
};
BoxPosition.prototype.toCSSCompatValues = function(reference2) {
  return {
    top: this.top - reference2.top,
    bottom: reference2.bottom - this.bottom,
    left: this.left - reference2.left,
    right: reference2.right - this.right,
    height: this.height,
    width: this.width
  };
};
BoxPosition.getSimpleBoxPosition = function(obj) {
  var height3 = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
  var width3 = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
  var top2 = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
  obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
  var ret = {
    left: obj.left,
    right: obj.right,
    top: obj.top || top2,
    height: obj.height || height3,
    bottom: obj.bottom || top2 + (obj.height || height3),
    width: obj.width || width3
  };
  return ret;
};
function moveBoxToLinePosition(window2, styleBox, containerBox, boxPositions) {
  function findBestPosition(b2, axis2) {
    var bestPosition2, specifiedPosition = new BoxPosition(b2), percentage = 1;
    for (var i = 0; i < axis2.length; i++) {
      while (b2.overlapsOppositeAxis(containerBox, axis2[i]) || b2.within(containerBox) && b2.overlapsAny(boxPositions)) {
        b2.move(axis2[i]);
      }
      if (b2.within(containerBox)) {
        return b2;
      }
      var p2 = b2.intersectPercentage(containerBox);
      if (percentage > p2) {
        bestPosition2 = new BoxPosition(b2);
        percentage = p2;
      }
      b2 = new BoxPosition(specifiedPosition);
    }
    return bestPosition2 || specifiedPosition;
  }
  var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
  if (cue.snapToLines) {
    var size;
    switch (cue.vertical) {
      case "":
        axis = ["+y", "-y"];
        size = "height";
        break;
      case "rl":
        axis = ["+x", "-x"];
        size = "width";
        break;
      case "lr":
        axis = ["-x", "+x"];
        size = "width";
        break;
    }
    var step = boxPosition.lineHeight, position3 = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
    if (Math.abs(position3) > maxPosition) {
      position3 = position3 < 0 ? -1 : 1;
      position3 *= Math.ceil(maxPosition / step) * step;
    }
    if (linePos < 0) {
      position3 += cue.vertical === "" ? containerBox.height : containerBox.width;
      axis = axis.reverse();
    }
    boxPosition.move(initialAxis, position3);
  } else {
    var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
    switch (cue.lineAlign) {
      case "center":
        linePos -= calculatedPercentage / 2;
        break;
      case "end":
        linePos -= calculatedPercentage;
        break;
    }
    switch (cue.vertical) {
      case "":
        styleBox.applyStyles({
          top: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "rl":
        styleBox.applyStyles({
          left: styleBox.formatStyle(linePos, "%")
        });
        break;
      case "lr":
        styleBox.applyStyles({
          right: styleBox.formatStyle(linePos, "%")
        });
        break;
    }
    axis = ["+y", "-x", "+x", "-y"];
    boxPosition = new BoxPosition(styleBox);
  }
  var bestPosition = findBestPosition(boxPosition, axis);
  styleBox.move(bestPosition.toCSSCompatValues(containerBox));
}
function WebVTT$1() {
}
WebVTT$1.StringDecoder = function() {
  return {
    decode: function(data) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
};
WebVTT$1.convertCueToDOMTree = function(window2, cuetext) {
  if (!window2 || !cuetext) {
    return null;
  }
  return parseContent(window2, cuetext);
};
var FONT_SIZE_PERCENT = 0.05;
var FONT_STYLE = "sans-serif";
var CUE_BACKGROUND_PADDING = "1.5%";
WebVTT$1.processCues = function(window2, cues, overlay) {
  if (!window2 || !cues || !overlay) {
    return null;
  }
  while (overlay.firstChild) {
    overlay.removeChild(overlay.firstChild);
  }
  var paddedOverlay = window2.document.createElement("div");
  paddedOverlay.style.position = "absolute";
  paddedOverlay.style.left = "0";
  paddedOverlay.style.right = "0";
  paddedOverlay.style.top = "0";
  paddedOverlay.style.bottom = "0";
  paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
  overlay.appendChild(paddedOverlay);
  function shouldCompute(cues2) {
    for (var i2 = 0; i2 < cues2.length; i2++) {
      if (cues2[i2].hasBeenReset || !cues2[i2].displayState) {
        return true;
      }
    }
    return false;
  }
  if (!shouldCompute(cues)) {
    for (var i = 0; i < cues.length; i++) {
      paddedOverlay.appendChild(cues[i].displayState);
    }
    return;
  }
  var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize2 = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
  var styleOptions = {
    font: fontSize2 + "px " + FONT_STYLE
  };
  (function() {
    var styleBox, cue;
    for (var i2 = 0; i2 < cues.length; i2++) {
      cue = cues[i2];
      styleBox = new CueStyleBox(window2, cue, styleOptions);
      paddedOverlay.appendChild(styleBox.div);
      moveBoxToLinePosition(window2, styleBox, containerBox, boxPositions);
      cue.displayState = styleBox.div;
      boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
    }
  })();
};
WebVTT$1.Parser = function(window2, vttjs2, decoder) {
  if (!decoder) {
    decoder = vttjs2;
    vttjs2 = {};
  }
  if (!vttjs2) {
    vttjs2 = {};
  }
  this.window = window2;
  this.vttjs = vttjs2;
  this.state = "INITIAL";
  this.buffer = "";
  this.decoder = decoder || new TextDecoder("utf8");
  this.regionList = [];
};
WebVTT$1.Parser.prototype = {
  // If the error is a ParsingError then report it to the consumer if
  // possible. If it's not a ParsingError then throw it like normal.
  reportOrThrowError: function(e2) {
    if (e2 instanceof ParsingError) {
      this.onparsingerror && this.onparsingerror(e2);
    } else {
      throw e2;
    }
  },
  parse: function(data) {
    var self2 = this;
    if (data) {
      self2.buffer += self2.decoder.decode(data, { stream: true });
    }
    function collectNextLine() {
      var buffer = self2.buffer;
      var pos = 0;
      while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
        ++pos;
      }
      var line3 = buffer.substr(0, pos);
      if (buffer[pos] === "\r") {
        ++pos;
      }
      if (buffer[pos] === "\n") {
        ++pos;
      }
      self2.buffer = buffer.substr(pos);
      return line3;
    }
    function parseRegion(input) {
      var settings = new Settings();
      parseOptions(input, function(k2, v2) {
        switch (k2) {
          case "id":
            settings.set(k2, v2);
            break;
          case "width":
            settings.percent(k2, v2);
            break;
          case "lines":
            settings.integer(k2, v2);
            break;
          case "regionanchor":
          case "viewportanchor":
            var xy = v2.split(",");
            if (xy.length !== 2) {
              break;
            }
            var anchor = new Settings();
            anchor.percent("x", xy[0]);
            anchor.percent("y", xy[1]);
            if (!anchor.has("x") || !anchor.has("y")) {
              break;
            }
            settings.set(k2 + "X", anchor.get("x"));
            settings.set(k2 + "Y", anchor.get("y"));
            break;
          case "scroll":
            settings.alt(k2, v2, ["up"]);
            break;
        }
      }, /=/, /\s/);
      if (settings.has("id")) {
        var region = new (self2.vttjs.VTTRegion || self2.window.VTTRegion)();
        region.width = settings.get("width", 100);
        region.lines = settings.get("lines", 3);
        region.regionAnchorX = settings.get("regionanchorX", 0);
        region.regionAnchorY = settings.get("regionanchorY", 100);
        region.viewportAnchorX = settings.get("viewportanchorX", 0);
        region.viewportAnchorY = settings.get("viewportanchorY", 100);
        region.scroll = settings.get("scroll", "");
        self2.onregion && self2.onregion(region);
        self2.regionList.push({
          id: settings.get("id"),
          region
        });
      }
    }
    function parseTimestampMap(input) {
      var settings = new Settings();
      parseOptions(input, function(k2, v2) {
        switch (k2) {
          case "MPEGT":
            settings.integer(k2 + "S", v2);
            break;
          case "LOCA":
            settings.set(k2 + "L", parseTimeStamp(v2));
            break;
        }
      }, /[^\d]:/, /,/);
      self2.ontimestampmap && self2.ontimestampmap({
        "MPEGTS": settings.get("MPEGTS"),
        "LOCAL": settings.get("LOCAL")
      });
    }
    function parseHeader(input) {
      if (input.match(/X-TIMESTAMP-MAP/)) {
        parseOptions(input, function(k2, v2) {
          switch (k2) {
            case "X-TIMESTAMP-MAP":
              parseTimestampMap(v2);
              break;
          }
        }, /=/);
      } else {
        parseOptions(input, function(k2, v2) {
          switch (k2) {
            case "Region":
              parseRegion(v2);
              break;
          }
        }, /:/);
      }
    }
    try {
      var line2;
      if (self2.state === "INITIAL") {
        if (!/\r\n|\n/.test(self2.buffer)) {
          return this;
        }
        line2 = collectNextLine();
        var m2 = line2.match(/^WEBVTT([ \t].*)?$/);
        if (!m2 || !m2[0]) {
          throw new ParsingError(ParsingError.Errors.BadSignature);
        }
        self2.state = "HEADER";
      }
      var alreadyCollectedLine = false;
      while (self2.buffer) {
        if (!/\r\n|\n/.test(self2.buffer)) {
          return this;
        }
        if (!alreadyCollectedLine) {
          line2 = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }
        switch (self2.state) {
          case "HEADER":
            if (/:/.test(line2)) {
              parseHeader(line2);
            } else if (!line2) {
              self2.state = "ID";
            }
            continue;
          case "NOTE":
            if (!line2) {
              self2.state = "ID";
            }
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(line2)) {
              self2.state = "NOTE";
              break;
            }
            if (!line2) {
              continue;
            }
            self2.cue = new (self2.vttjs.VTTCue || self2.window.VTTCue)(0, 0, "");
            try {
              self2.cue.align = "center";
            } catch (e2) {
              self2.cue.align = "middle";
            }
            self2.state = "CUE";
            if (line2.indexOf("-->") === -1) {
              self2.cue.id = line2;
              continue;
            }
          case "CUE":
            try {
              parseCue(line2, self2.cue, self2.regionList);
            } catch (e2) {
              self2.reportOrThrowError(e2);
              self2.cue = null;
              self2.state = "BADCUE";
              continue;
            }
            self2.state = "CUETEXT";
            continue;
          case "CUETEXT":
            var hasSubstring = line2.indexOf("-->") !== -1;
            if (!line2 || hasSubstring && (alreadyCollectedLine = true)) {
              self2.oncue && self2.oncue(self2.cue);
              self2.cue = null;
              self2.state = "ID";
              continue;
            }
            if (self2.cue.text) {
              self2.cue.text += "\n";
            }
            self2.cue.text += line2.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
            continue;
          case "BADCUE":
            if (!line2) {
              self2.state = "ID";
            }
            continue;
        }
      }
    } catch (e2) {
      self2.reportOrThrowError(e2);
      if (self2.state === "CUETEXT" && self2.cue && self2.oncue) {
        self2.oncue(self2.cue);
      }
      self2.cue = null;
      self2.state = self2.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  },
  flush: function() {
    var self2 = this;
    try {
      self2.buffer += self2.decoder.decode();
      if (self2.cue || self2.state === "HEADER") {
        self2.buffer += "\n\n";
        self2.parse();
      }
      if (self2.state === "INITIAL") {
        throw new ParsingError(ParsingError.Errors.BadSignature);
      }
    } catch (e2) {
      self2.reportOrThrowError(e2);
    }
    self2.onflush && self2.onflush();
    return this;
  }
};
var vtt = WebVTT$1;
var autoKeyword = "auto";
var directionSetting = {
  "": 1,
  "lr": 1,
  "rl": 1
};
var alignSetting = {
  "start": 1,
  "center": 1,
  "end": 1,
  "left": 1,
  "right": 1,
  "auto": 1,
  "line-left": 1,
  "line-right": 1
};
function findDirectionSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var dir = directionSetting[value.toLowerCase()];
  return dir ? value.toLowerCase() : false;
}
function findAlignSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var align = alignSetting[value.toLowerCase()];
  return align ? value.toLowerCase() : false;
}
function VTTCue(startTime, endTime, text) {
  this.hasBeenReset = false;
  var _id = "";
  var _pauseOnExit = false;
  var _startTime = startTime;
  var _endTime = endTime;
  var _text = text;
  var _region = null;
  var _vertical = "";
  var _snapToLines = true;
  var _line = "auto";
  var _lineAlign = "start";
  var _position = "auto";
  var _positionAlign = "auto";
  var _size = 100;
  var _align = "center";
  Object.defineProperties(this, {
    "id": {
      enumerable: true,
      get: function() {
        return _id;
      },
      set: function(value) {
        _id = "" + value;
      }
    },
    "pauseOnExit": {
      enumerable: true,
      get: function() {
        return _pauseOnExit;
      },
      set: function(value) {
        _pauseOnExit = !!value;
      }
    },
    "startTime": {
      enumerable: true,
      get: function() {
        return _startTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    },
    "endTime": {
      enumerable: true,
      get: function() {
        return _endTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    },
    "text": {
      enumerable: true,
      get: function() {
        return _text;
      },
      set: function(value) {
        _text = "" + value;
        this.hasBeenReset = true;
      }
    },
    "region": {
      enumerable: true,
      get: function() {
        return _region;
      },
      set: function(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    },
    "vertical": {
      enumerable: true,
      get: function() {
        return _vertical;
      },
      set: function(value) {
        var setting = findDirectionSetting(value);
        if (setting === false) {
          throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    },
    "snapToLines": {
      enumerable: true,
      get: function() {
        return _snapToLines;
      },
      set: function(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    },
    "line": {
      enumerable: true,
      get: function() {
        return _line;
      },
      set: function(value) {
        if (typeof value !== "number" && value !== autoKeyword) {
          throw new SyntaxError("Line: an invalid number or illegal string was specified.");
        }
        _line = value;
        this.hasBeenReset = true;
      }
    },
    "lineAlign": {
      enumerable: true,
      get: function() {
        return _lineAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          console.warn("lineAlign: an invalid or illegal string was specified.");
        } else {
          _lineAlign = setting;
          this.hasBeenReset = true;
        }
      }
    },
    "position": {
      enumerable: true,
      get: function() {
        return _position;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value;
        this.hasBeenReset = true;
      }
    },
    "positionAlign": {
      enumerable: true,
      get: function() {
        return _positionAlign;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          console.warn("positionAlign: an invalid or illegal string was specified.");
        } else {
          _positionAlign = setting;
          this.hasBeenReset = true;
        }
      }
    },
    "size": {
      enumerable: true,
      get: function() {
        return _size;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value;
        this.hasBeenReset = true;
      }
    },
    "align": {
      enumerable: true,
      get: function() {
        return _align;
      },
      set: function(value) {
        var setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }
  });
  this.displayState = void 0;
}
VTTCue.prototype.getCueAsHTML = function() {
  return WebVTT.convertCueToDOMTree(window, this.text);
};
var vttcue = VTTCue;
var scrollSetting = {
  "": true,
  "up": true
};
function findScrollSetting(value) {
  if (typeof value !== "string") {
    return false;
  }
  var scroll3 = scrollSetting[value.toLowerCase()];
  return scroll3 ? value.toLowerCase() : false;
}
function isValidPercentValue(value) {
  return typeof value === "number" && (value >= 0 && value <= 100);
}
function VTTRegion() {
  var _width = 100;
  var _lines = 3;
  var _regionAnchorX = 0;
  var _regionAnchorY = 100;
  var _viewportAnchorX = 0;
  var _viewportAnchorY = 100;
  var _scroll = "";
  Object.defineProperties(this, {
    "width": {
      enumerable: true,
      get: function() {
        return _width;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("Width must be between 0 and 100.");
        }
        _width = value;
      }
    },
    "lines": {
      enumerable: true,
      get: function() {
        return _lines;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Lines must be set to a number.");
        }
        _lines = value;
      }
    },
    "regionAnchorY": {
      enumerable: true,
      get: function() {
        return _regionAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("RegionAnchorX must be between 0 and 100.");
        }
        _regionAnchorY = value;
      }
    },
    "regionAnchorX": {
      enumerable: true,
      get: function() {
        return _regionAnchorX;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("RegionAnchorY must be between 0 and 100.");
        }
        _regionAnchorX = value;
      }
    },
    "viewportAnchorY": {
      enumerable: true,
      get: function() {
        return _viewportAnchorY;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorY must be between 0 and 100.");
        }
        _viewportAnchorY = value;
      }
    },
    "viewportAnchorX": {
      enumerable: true,
      get: function() {
        return _viewportAnchorX;
      },
      set: function(value) {
        if (!isValidPercentValue(value)) {
          throw new Error("ViewportAnchorX must be between 0 and 100.");
        }
        _viewportAnchorX = value;
      }
    },
    "scroll": {
      enumerable: true,
      get: function() {
        return _scroll;
      },
      set: function(value) {
        var setting = findScrollSetting(value);
        if (setting === false) {
          console.warn("Scroll: an invalid or illegal string was specified.");
        } else {
          _scroll = setting;
        }
      }
    }
  });
}
var vttregion = VTTRegion;
var window$1 = window_1;
var vttjs = browserIndex.exports = {
  WebVTT: vtt,
  VTTCue: vttcue,
  VTTRegion: vttregion
};
window$1.vttjs = vttjs;
window$1.WebVTT = vttjs.WebVTT;
var cueShim = vttjs.VTTCue;
var regionShim = vttjs.VTTRegion;
var nativeVTTCue = window$1.VTTCue;
var nativeVTTRegion = window$1.VTTRegion;
vttjs.shim = function() {
  window$1.VTTCue = cueShim;
  window$1.VTTRegion = regionShim;
};
vttjs.restore = function() {
  window$1.VTTCue = nativeVTTCue;
  window$1.VTTRegion = nativeVTTRegion;
};
if (!window$1.VTTCue) {
  vttjs.shim();
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var urlToolkitExports = {};
var urlToolkit = {
  get exports() {
    return urlToolkitExports;
  },
  set exports(v2) {
    urlToolkitExports = v2;
  }
};
(function(module, exports) {
  (function(root2) {
    var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
    var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
    var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
    var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
    var URLToolkit2 = {
      // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //
      // E.g
      // With opts.alwaysNormalize = false (default, spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g
      // With opts.alwaysNormalize = true (not spec compliant)
      // http://a.com/b/cd + /e/f/../g => http://a.com/e/g
      buildAbsoluteURL: function(baseURL, relativeURL, opts) {
        opts = opts || {};
        baseURL = baseURL.trim();
        relativeURL = relativeURL.trim();
        if (!relativeURL) {
          if (!opts.alwaysNormalize) {
            return baseURL;
          }
          var basePartsForNormalise = URLToolkit2.parseURL(baseURL);
          if (!basePartsForNormalise) {
            throw new Error("Error trying to parse base URL.");
          }
          basePartsForNormalise.path = URLToolkit2.normalizePath(
            basePartsForNormalise.path
          );
          return URLToolkit2.buildURLFromParts(basePartsForNormalise);
        }
        var relativeParts = URLToolkit2.parseURL(relativeURL);
        if (!relativeParts) {
          throw new Error("Error trying to parse relative URL.");
        }
        if (relativeParts.scheme) {
          if (!opts.alwaysNormalize) {
            return relativeURL;
          }
          relativeParts.path = URLToolkit2.normalizePath(relativeParts.path);
          return URLToolkit2.buildURLFromParts(relativeParts);
        }
        var baseParts = URLToolkit2.parseURL(baseURL);
        if (!baseParts) {
          throw new Error("Error trying to parse base URL.");
        }
        if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
          var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
          baseParts.netLoc = pathParts[1];
          baseParts.path = pathParts[2];
        }
        if (baseParts.netLoc && !baseParts.path) {
          baseParts.path = "/";
        }
        var builtParts = {
          // 2c) Otherwise, the embedded URL inherits the scheme of
          // the base URL.
          scheme: baseParts.scheme,
          netLoc: relativeParts.netLoc,
          path: null,
          params: relativeParts.params,
          query: relativeParts.query,
          fragment: relativeParts.fragment
        };
        if (!relativeParts.netLoc) {
          builtParts.netLoc = baseParts.netLoc;
          if (relativeParts.path[0] !== "/") {
            if (!relativeParts.path) {
              builtParts.path = baseParts.path;
              if (!relativeParts.params) {
                builtParts.params = baseParts.params;
                if (!relativeParts.query) {
                  builtParts.query = baseParts.query;
                }
              }
            } else {
              var baseURLPath = baseParts.path;
              var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
              builtParts.path = URLToolkit2.normalizePath(newPath);
            }
          }
        }
        if (builtParts.path === null) {
          builtParts.path = opts.alwaysNormalize ? URLToolkit2.normalizePath(relativeParts.path) : relativeParts.path;
        }
        return URLToolkit2.buildURLFromParts(builtParts);
      },
      parseURL: function(url) {
        var parts = URL_REGEX.exec(url);
        if (!parts) {
          return null;
        }
        return {
          scheme: parts[1] || "",
          netLoc: parts[2] || "",
          path: parts[3] || "",
          params: parts[4] || "",
          query: parts[5] || "",
          fragment: parts[6] || ""
        };
      },
      normalizePath: function(path) {
        path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
        while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
        }
        return path.split("").reverse().join("");
      },
      buildURLFromParts: function(parts) {
        return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
      }
    };
    module.exports = URLToolkit2;
  })();
})(urlToolkit);
const URLToolkit = urlToolkitExports;
var DEFAULT_LOCATION = "http://example.com";
var resolveUrl$1 = function resolveUrl(baseUrl, relativeUrl) {
  if (/^[a-z]+:/i.test(relativeUrl)) {
    return relativeUrl;
  }
  if (/^data:/.test(baseUrl)) {
    baseUrl = window_1.location && window_1.location.href || "";
  }
  var nativeURL = typeof window_1.URL === "function";
  var protocolLess = /^\/\//.test(baseUrl);
  var removeLocation = !window_1.location && !/\/\//i.test(baseUrl);
  if (nativeURL) {
    baseUrl = new window_1.URL(baseUrl, window_1.location || DEFAULT_LOCATION);
  } else if (!/\/\//i.test(baseUrl)) {
    baseUrl = URLToolkit.buildAbsoluteURL(window_1.location && window_1.location.href || "", baseUrl);
  }
  if (nativeURL) {
    var newUrl = new URL(relativeUrl, baseUrl);
    if (removeLocation) {
      return newUrl.href.slice(DEFAULT_LOCATION.length);
    } else if (protocolLess) {
      return newUrl.href.slice(newUrl.protocol.length);
    }
    return newUrl.href;
  }
  return URLToolkit.buildAbsoluteURL(baseUrl, relativeUrl);
};
var Stream = /* @__PURE__ */ function() {
  function Stream2() {
    this.listeners = {};
  }
  var _proto = Stream2.prototype;
  _proto.on = function on3(type2, listener) {
    if (!this.listeners[type2]) {
      this.listeners[type2] = [];
    }
    this.listeners[type2].push(listener);
  };
  _proto.off = function off2(type2, listener) {
    if (!this.listeners[type2]) {
      return false;
    }
    var index2 = this.listeners[type2].indexOf(listener);
    this.listeners[type2] = this.listeners[type2].slice(0);
    this.listeners[type2].splice(index2, 1);
    return index2 > -1;
  };
  _proto.trigger = function trigger2(type2) {
    var callbacks = this.listeners[type2];
    if (!callbacks) {
      return;
    }
    if (arguments.length === 2) {
      var length2 = callbacks.length;
      for (var i = 0; i < length2; ++i) {
        callbacks[i].call(this, arguments[1]);
      }
    } else {
      var args = Array.prototype.slice.call(arguments, 1);
      var _length = callbacks.length;
      for (var _i = 0; _i < _length; ++_i) {
        callbacks[_i].apply(this, args);
      }
    }
  };
  _proto.dispose = function dispose() {
    this.listeners = {};
  };
  _proto.pipe = function pipe(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
  };
  return Stream2;
}();
var atob$1 = function atob2(s) {
  return window_1.atob ? window_1.atob(s) : Buffer.from(s, "base64").toString("binary");
};
function decodeB64ToUint8Array(b64Text) {
  var decodedString = atob$1(b64Text);
  var array = new Uint8Array(decodedString.length);
  for (var i = 0; i < decodedString.length; i++) {
    array[i] = decodedString.charCodeAt(i);
  }
  return array;
}
/*! @name m3u8-parser @version 4.7.1 @license Apache-2.0 */
var LineStream = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(LineStream2, _Stream);
  function LineStream2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.buffer = "";
    return _this;
  }
  var _proto = LineStream2.prototype;
  _proto.push = function push(data) {
    var nextNewline;
    this.buffer += data;
    nextNewline = this.buffer.indexOf("\n");
    for (; nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
      this.trigger("data", this.buffer.substring(0, nextNewline));
      this.buffer = this.buffer.substring(nextNewline + 1);
    }
  };
  return LineStream2;
}(Stream);
var TAB = String.fromCharCode(9);
var parseByterange = function parseByterange2(byterangeString) {
  var match2 = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
  var result = {};
  if (match2[1]) {
    result.length = parseInt(match2[1], 10);
  }
  if (match2[2]) {
    result.offset = parseInt(match2[2], 10);
  }
  return result;
};
var attributeSeparator = function attributeSeparator2() {
  var key = "[^=]*";
  var value = '"[^"]*"|[^,]*';
  var keyvalue = "(?:" + key + ")=(?:" + value + ")";
  return new RegExp("(?:^|,)(" + keyvalue + ")");
};
var parseAttributes$1 = function parseAttributes(attributes) {
  var attrs = attributes.split(attributeSeparator());
  var result = {};
  var i = attrs.length;
  var attr;
  while (i--) {
    if (attrs[i] === "") {
      continue;
    }
    attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
    attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
    attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
    result[attr[0]] = attr[1];
  }
  return result;
};
var ParseStream = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(ParseStream2, _Stream);
  function ParseStream2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.customParsers = [];
    _this.tagMappers = [];
    return _this;
  }
  var _proto = ParseStream2.prototype;
  _proto.push = function push(line2) {
    var _this2 = this;
    var match2;
    var event;
    line2 = line2.trim();
    if (line2.length === 0) {
      return;
    }
    if (line2[0] !== "#") {
      this.trigger("data", {
        type: "uri",
        uri: line2
      });
      return;
    }
    var newLines = this.tagMappers.reduce(function(acc, mapper) {
      var mappedLine = mapper(line2);
      if (mappedLine === line2) {
        return acc;
      }
      return acc.concat([mappedLine]);
    }, [line2]);
    newLines.forEach(function(newLine) {
      for (var i = 0; i < _this2.customParsers.length; i++) {
        if (_this2.customParsers[i].call(_this2, newLine)) {
          return;
        }
      }
      if (newLine.indexOf("#EXT") !== 0) {
        _this2.trigger("data", {
          type: "comment",
          text: newLine.slice(1)
        });
        return;
      }
      newLine = newLine.replace("\r", "");
      match2 = /^#EXTM3U/.exec(newLine);
      if (match2) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "m3u"
        });
        return;
      }
      match2 = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "inf"
        };
        if (match2[1]) {
          event.duration = parseFloat(match2[1]);
        }
        if (match2[2]) {
          event.title = match2[2];
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "targetduration"
        };
        if (match2[1]) {
          event.duration = parseInt(match2[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "version"
        };
        if (match2[1]) {
          event.version = parseInt(match2[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "media-sequence"
        };
        if (match2[1]) {
          event.number = parseInt(match2[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "discontinuity-sequence"
        };
        if (match2[1]) {
          event.number = parseInt(match2[1], 10);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "playlist-type"
        };
        if (match2[1]) {
          event.playlistType = match2[1];
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-BYTERANGE:?(.*)?$/.exec(newLine);
      if (match2) {
        event = _extends$8(parseByterange(match2[1]), {
          type: "tag",
          tagType: "byterange"
        });
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "allow-cache"
        };
        if (match2[1]) {
          event.allowed = !/NO/.test(match2[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-MAP:?(.*)$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "map"
        };
        if (match2[1]) {
          var attributes = parseAttributes$1(match2[1]);
          if (attributes.URI) {
            event.uri = attributes.URI;
          }
          if (attributes.BYTERANGE) {
            event.byterange = parseByterange(attributes.BYTERANGE);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-STREAM-INF:?(.*)$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "stream-inf"
        };
        if (match2[1]) {
          event.attributes = parseAttributes$1(match2[1]);
          if (event.attributes.RESOLUTION) {
            var split2 = event.attributes.RESOLUTION.split("x");
            var resolution = {};
            if (split2[0]) {
              resolution.width = parseInt(split2[0], 10);
            }
            if (split2[1]) {
              resolution.height = parseInt(split2[1], 10);
            }
            event.attributes.RESOLUTION = resolution;
          }
          if (event.attributes.BANDWIDTH) {
            event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
          }
          if (event.attributes["PROGRAM-ID"]) {
            event.attributes["PROGRAM-ID"] = parseInt(event.attributes["PROGRAM-ID"], 10);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-MEDIA:?(.*)$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "media"
        };
        if (match2[1]) {
          event.attributes = parseAttributes$1(match2[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-ENDLIST/.exec(newLine);
      if (match2) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "endlist"
        });
        return;
      }
      match2 = /^#EXT-X-DISCONTINUITY/.exec(newLine);
      if (match2) {
        _this2.trigger("data", {
          type: "tag",
          tagType: "discontinuity"
        });
        return;
      }
      match2 = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "program-date-time"
        };
        if (match2[1]) {
          event.dateTimeString = match2[1];
          event.dateTimeObject = new Date(match2[1]);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-KEY:?(.*)$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "key"
        };
        if (match2[1]) {
          event.attributes = parseAttributes$1(match2[1]);
          if (event.attributes.IV) {
            if (event.attributes.IV.substring(0, 2).toLowerCase() === "0x") {
              event.attributes.IV = event.attributes.IV.substring(2);
            }
            event.attributes.IV = event.attributes.IV.match(/.{8}/g);
            event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
            event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
            event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
            event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
            event.attributes.IV = new Uint32Array(event.attributes.IV);
          }
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-START:?(.*)$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "start"
        };
        if (match2[1]) {
          event.attributes = parseAttributes$1(match2[1]);
          event.attributes["TIME-OFFSET"] = parseFloat(event.attributes["TIME-OFFSET"]);
          event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "cue-out-cont"
        };
        if (match2[1]) {
          event.data = match2[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "cue-out"
        };
        if (match2[1]) {
          event.data = match2[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-CUE-IN:?(.*)?$/.exec(newLine);
      if (match2) {
        event = {
          type: "tag",
          tagType: "cue-in"
        };
        if (match2[1]) {
          event.data = match2[1];
        } else {
          event.data = "";
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
      if (match2 && match2[1]) {
        event = {
          type: "tag",
          tagType: "skip"
        };
        event.attributes = parseAttributes$1(match2[1]);
        if (event.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) {
          event.attributes["SKIPPED-SEGMENTS"] = parseInt(event.attributes["SKIPPED-SEGMENTS"], 10);
        }
        if (event.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) {
          event.attributes["RECENTLY-REMOVED-DATERANGES"] = event.attributes["RECENTLY-REMOVED-DATERANGES"].split(TAB);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-PART:(.*)$/.exec(newLine);
      if (match2 && match2[1]) {
        event = {
          type: "tag",
          tagType: "part"
        };
        event.attributes = parseAttributes$1(match2[1]);
        ["DURATION"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ["INDEPENDENT", "GAP"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });
        if (event.attributes.hasOwnProperty("BYTERANGE")) {
          event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
        }
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
      if (match2 && match2[1]) {
        event = {
          type: "tag",
          tagType: "server-control"
        };
        event.attributes = parseAttributes$1(match2[1]);
        ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = /YES/.test(event.attributes[key]);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
      if (match2 && match2[1]) {
        event = {
          type: "tag",
          tagType: "part-inf"
        };
        event.attributes = parseAttributes$1(match2[1]);
        ["PART-TARGET"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseFloat(event.attributes[key]);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
      if (match2 && match2[1]) {
        event = {
          type: "tag",
          tagType: "preload-hint"
        };
        event.attributes = parseAttributes$1(match2[1]);
        ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
            var subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
            event.attributes.byterange = event.attributes.byterange || {};
            event.attributes.byterange[subkey] = event.attributes[key];
            delete event.attributes[key];
          }
        });
        _this2.trigger("data", event);
        return;
      }
      match2 = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
      if (match2 && match2[1]) {
        event = {
          type: "tag",
          tagType: "rendition-report"
        };
        event.attributes = parseAttributes$1(match2[1]);
        ["LAST-MSN", "LAST-PART"].forEach(function(key) {
          if (event.attributes.hasOwnProperty(key)) {
            event.attributes[key] = parseInt(event.attributes[key], 10);
          }
        });
        _this2.trigger("data", event);
        return;
      }
      _this2.trigger("data", {
        type: "tag",
        data: newLine.slice(4)
      });
    });
  };
  _proto.addParser = function addParser(_ref) {
    var _this3 = this;
    var expression = _ref.expression, customType = _ref.customType, dataParser = _ref.dataParser, segment = _ref.segment;
    if (typeof dataParser !== "function") {
      dataParser = function dataParser2(line2) {
        return line2;
      };
    }
    this.customParsers.push(function(line2) {
      var match2 = expression.exec(line2);
      if (match2) {
        _this3.trigger("data", {
          type: "custom",
          data: dataParser(line2),
          customType,
          segment
        });
        return true;
      }
    });
  };
  _proto.addTagMapper = function addTagMapper(_ref2) {
    var expression = _ref2.expression, map = _ref2.map;
    var mapFn = function mapFn2(line2) {
      if (expression.test(line2)) {
        return map(line2);
      }
      return line2;
    };
    this.tagMappers.push(mapFn);
  };
  return ParseStream2;
}(Stream);
var camelCase = function camelCase2(str) {
  return str.toLowerCase().replace(/-(\w)/g, function(a2) {
    return a2[1].toUpperCase();
  });
};
var camelCaseKeys = function camelCaseKeys2(attributes) {
  var result = {};
  Object.keys(attributes).forEach(function(key) {
    result[camelCase(key)] = attributes[key];
  });
  return result;
};
var setHoldBack = function setHoldBack2(manifest) {
  var serverControl = manifest.serverControl, targetDuration = manifest.targetDuration, partTargetDuration = manifest.partTargetDuration;
  if (!serverControl) {
    return;
  }
  var tag = "#EXT-X-SERVER-CONTROL";
  var hb2 = "holdBack";
  var phb = "partHoldBack";
  var minTargetDuration = targetDuration && targetDuration * 3;
  var minPartDuration = partTargetDuration && partTargetDuration * 2;
  if (targetDuration && !serverControl.hasOwnProperty(hb2)) {
    serverControl[hb2] = minTargetDuration;
    this.trigger("info", {
      message: tag + " defaulting HOLD-BACK to targetDuration * 3 (" + minTargetDuration + ")."
    });
  }
  if (minTargetDuration && serverControl[hb2] < minTargetDuration) {
    this.trigger("warn", {
      message: tag + " clamping HOLD-BACK (" + serverControl[hb2] + ") to targetDuration * 3 (" + minTargetDuration + ")"
    });
    serverControl[hb2] = minTargetDuration;
  }
  if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
    serverControl[phb] = partTargetDuration * 3;
    this.trigger("info", {
      message: tag + " defaulting PART-HOLD-BACK to partTargetDuration * 3 (" + serverControl[phb] + ")."
    });
  }
  if (partTargetDuration && serverControl[phb] < minPartDuration) {
    this.trigger("warn", {
      message: tag + " clamping PART-HOLD-BACK (" + serverControl[phb] + ") to partTargetDuration * 2 (" + minPartDuration + ")."
    });
    serverControl[phb] = minPartDuration;
  }
};
var Parser = /* @__PURE__ */ function(_Stream) {
  _inheritsLoose(Parser2, _Stream);
  function Parser2() {
    var _this;
    _this = _Stream.call(this) || this;
    _this.lineStream = new LineStream();
    _this.parseStream = new ParseStream();
    _this.lineStream.pipe(_this.parseStream);
    var self2 = _assertThisInitialized(_this);
    var uris = [];
    var currentUri = {};
    var currentMap;
    var _key;
    var hasParts = false;
    var noop2 = function noop3() {
    };
    var defaultMediaGroups = {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    };
    var widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
    var currentTimeline = 0;
    _this.manifest = {
      allowCache: true,
      discontinuityStarts: [],
      segments: []
    };
    var lastByterangeEnd = 0;
    var lastPartByterangeEnd = 0;
    _this.on("end", function() {
      if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) {
        return;
      }
      if (!currentUri.map && currentMap) {
        currentUri.map = currentMap;
      }
      if (!currentUri.key && _key) {
        currentUri.key = _key;
      }
      if (!currentUri.timeline && typeof currentTimeline === "number") {
        currentUri.timeline = currentTimeline;
      }
      _this.manifest.preloadSegment = currentUri;
    });
    _this.parseStream.on("data", function(entry) {
      var mediaGroup;
      var rendition;
      ({
        tag: function tag() {
          ({
            version: function version2() {
              if (entry.version) {
                this.manifest.version = entry.version;
              }
            },
            "allow-cache": function allowCache() {
              this.manifest.allowCache = entry.allowed;
              if (!("allowed" in entry)) {
                this.trigger("info", {
                  message: "defaulting allowCache to YES"
                });
                this.manifest.allowCache = true;
              }
            },
            byterange: function byterange() {
              var byterange2 = {};
              if ("length" in entry) {
                currentUri.byterange = byterange2;
                byterange2.length = entry.length;
                if (!("offset" in entry)) {
                  entry.offset = lastByterangeEnd;
                }
              }
              if ("offset" in entry) {
                currentUri.byterange = byterange2;
                byterange2.offset = entry.offset;
              }
              lastByterangeEnd = byterange2.offset + byterange2.length;
            },
            endlist: function endlist() {
              this.manifest.endList = true;
            },
            inf: function inf() {
              if (!("mediaSequence" in this.manifest)) {
                this.manifest.mediaSequence = 0;
                this.trigger("info", {
                  message: "defaulting media sequence to zero"
                });
              }
              if (!("discontinuitySequence" in this.manifest)) {
                this.manifest.discontinuitySequence = 0;
                this.trigger("info", {
                  message: "defaulting discontinuity sequence to zero"
                });
              }
              if (entry.duration > 0) {
                currentUri.duration = entry.duration;
              }
              if (entry.duration === 0) {
                currentUri.duration = 0.01;
                this.trigger("info", {
                  message: "updating zero segment duration to a small value"
                });
              }
              this.manifest.segments = uris;
            },
            key: function key() {
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring key declaration without attribute list"
                });
                return;
              }
              if (entry.attributes.METHOD === "NONE") {
                _key = null;
                return;
              }
              if (!entry.attributes.URI) {
                this.trigger("warn", {
                  message: "ignoring key declaration without URI"
                });
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.apple.fps.1_0"] = {
                  attributes: entry.attributes
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.microsoft.playready"] = {
                  uri: entry.attributes.URI
                };
                return;
              }
              if (entry.attributes.KEYFORMAT === widevineUuid) {
                var VALID_METHODS = ["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"];
                if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                  this.trigger("warn", {
                    message: "invalid key method provided for Widevine"
                  });
                  return;
                }
                if (entry.attributes.METHOD === "SAMPLE-AES-CENC") {
                  this.trigger("warn", {
                    message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                  });
                }
                if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                  this.trigger("warn", {
                    message: "invalid key URI provided for Widevine"
                  });
                  return;
                }
                if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                  this.trigger("warn", {
                    message: "invalid key ID provided for Widevine"
                  });
                  return;
                }
                this.manifest.contentProtection = this.manifest.contentProtection || {};
                this.manifest.contentProtection["com.widevine.alpha"] = {
                  attributes: {
                    schemeIdUri: entry.attributes.KEYFORMAT,
                    // remove '0x' from the key id string
                    keyId: entry.attributes.KEYID.substring(2)
                  },
                  // decode the base64-encoded PSSH box
                  pssh: decodeB64ToUint8Array(entry.attributes.URI.split(",")[1])
                };
                return;
              }
              if (!entry.attributes.METHOD) {
                this.trigger("warn", {
                  message: "defaulting key method to AES-128"
                });
              }
              _key = {
                method: entry.attributes.METHOD || "AES-128",
                uri: entry.attributes.URI
              };
              if (typeof entry.attributes.IV !== "undefined") {
                _key.iv = entry.attributes.IV;
              }
            },
            "media-sequence": function mediaSequence() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid media sequence: " + entry.number
                });
                return;
              }
              this.manifest.mediaSequence = entry.number;
            },
            "discontinuity-sequence": function discontinuitySequence() {
              if (!isFinite(entry.number)) {
                this.trigger("warn", {
                  message: "ignoring invalid discontinuity sequence: " + entry.number
                });
                return;
              }
              this.manifest.discontinuitySequence = entry.number;
              currentTimeline = entry.number;
            },
            "playlist-type": function playlistType() {
              if (!/VOD|EVENT/.test(entry.playlistType)) {
                this.trigger("warn", {
                  message: "ignoring unknown playlist type: " + entry.playlist
                });
                return;
              }
              this.manifest.playlistType = entry.playlistType;
            },
            map: function map() {
              currentMap = {};
              if (entry.uri) {
                currentMap.uri = entry.uri;
              }
              if (entry.byterange) {
                currentMap.byterange = entry.byterange;
              }
              if (_key) {
                currentMap.key = _key;
              }
            },
            "stream-inf": function streamInf() {
              this.manifest.playlists = uris;
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!entry.attributes) {
                this.trigger("warn", {
                  message: "ignoring empty stream-inf attributes"
                });
                return;
              }
              if (!currentUri.attributes) {
                currentUri.attributes = {};
              }
              _extends$8(currentUri.attributes, entry.attributes);
            },
            media: function media() {
              this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
              if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                this.trigger("warn", {
                  message: "ignoring incomplete or missing media group"
                });
                return;
              }
              var mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
              mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
              mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
              rendition = {
                default: /yes/i.test(entry.attributes.DEFAULT)
              };
              if (rendition.default) {
                rendition.autoselect = true;
              } else {
                rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
              }
              if (entry.attributes.LANGUAGE) {
                rendition.language = entry.attributes.LANGUAGE;
              }
              if (entry.attributes.URI) {
                rendition.uri = entry.attributes.URI;
              }
              if (entry.attributes["INSTREAM-ID"]) {
                rendition.instreamId = entry.attributes["INSTREAM-ID"];
              }
              if (entry.attributes.CHARACTERISTICS) {
                rendition.characteristics = entry.attributes.CHARACTERISTICS;
              }
              if (entry.attributes.FORCED) {
                rendition.forced = /yes/i.test(entry.attributes.FORCED);
              }
              mediaGroup[entry.attributes.NAME] = rendition;
            },
            discontinuity: function discontinuity() {
              currentTimeline += 1;
              currentUri.discontinuity = true;
              this.manifest.discontinuityStarts.push(uris.length);
            },
            "program-date-time": function programDateTime() {
              if (typeof this.manifest.dateTimeString === "undefined") {
                this.manifest.dateTimeString = entry.dateTimeString;
                this.manifest.dateTimeObject = entry.dateTimeObject;
              }
              currentUri.dateTimeString = entry.dateTimeString;
              currentUri.dateTimeObject = entry.dateTimeObject;
            },
            targetduration: function targetduration() {
              if (!isFinite(entry.duration) || entry.duration < 0) {
                this.trigger("warn", {
                  message: "ignoring invalid target duration: " + entry.duration
                });
                return;
              }
              this.manifest.targetDuration = entry.duration;
              setHoldBack.call(this, this.manifest);
            },
            start: function start3() {
              if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                this.trigger("warn", {
                  message: "ignoring start declaration without appropriate attribute list"
                });
                return;
              }
              this.manifest.start = {
                timeOffset: entry.attributes["TIME-OFFSET"],
                precise: entry.attributes.PRECISE
              };
            },
            "cue-out": function cueOut() {
              currentUri.cueOut = entry.data;
            },
            "cue-out-cont": function cueOutCont() {
              currentUri.cueOutCont = entry.data;
            },
            "cue-in": function cueIn() {
              currentUri.cueIn = entry.data;
            },
            "skip": function skip() {
              this.manifest.skip = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, ["SKIPPED-SEGMENTS"]);
            },
            "part": function part() {
              var _this2 = this;
              hasParts = true;
              var segmentIndex = this.manifest.segments.length;
              var part2 = camelCaseKeys(entry.attributes);
              currentUri.parts = currentUri.parts || [];
              currentUri.parts.push(part2);
              if (part2.byterange) {
                if (!part2.byterange.hasOwnProperty("offset")) {
                  part2.byterange.offset = lastPartByterangeEnd;
                }
                lastPartByterangeEnd = part2.byterange.offset + part2.byterange.length;
              }
              var partIndex = currentUri.parts.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PART #" + partIndex + " for segment #" + segmentIndex, entry.attributes, ["URI", "DURATION"]);
              if (this.manifest.renditionReports) {
                this.manifest.renditionReports.forEach(function(r3, i) {
                  if (!r3.hasOwnProperty("lastPart")) {
                    _this2.trigger("warn", {
                      message: "#EXT-X-RENDITION-REPORT #" + i + " lacks required attribute(s): LAST-PART"
                    });
                  }
                });
              }
            },
            "server-control": function serverControl() {
              var attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
              if (!attrs.hasOwnProperty("canBlockReload")) {
                attrs.canBlockReload = false;
                this.trigger("info", {
                  message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                });
              }
              setHoldBack.call(this, this.manifest);
              if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) {
                this.trigger("warn", {
                  message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                });
              }
            },
            "preload-hint": function preloadHint() {
              var segmentIndex = this.manifest.segments.length;
              var hint = camelCaseKeys(entry.attributes);
              var isPart = hint.type && hint.type === "PART";
              currentUri.preloadHints = currentUri.preloadHints || [];
              currentUri.preloadHints.push(hint);
              if (hint.byterange) {
                if (!hint.byterange.hasOwnProperty("offset")) {
                  hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                  if (isPart) {
                    lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                  }
                }
              }
              var index2 = currentUri.preloadHints.length - 1;
              this.warnOnMissingAttributes_("#EXT-X-PRELOAD-HINT #" + index2 + " for segment #" + segmentIndex, entry.attributes, ["TYPE", "URI"]);
              if (!hint.type) {
                return;
              }
              for (var i = 0; i < currentUri.preloadHints.length - 1; i++) {
                var otherHint = currentUri.preloadHints[i];
                if (!otherHint.type) {
                  continue;
                }
                if (otherHint.type === hint.type) {
                  this.trigger("warn", {
                    message: "#EXT-X-PRELOAD-HINT #" + index2 + " for segment #" + segmentIndex + " has the same TYPE " + hint.type + " as preload hint #" + i
                  });
                }
              }
            },
            "rendition-report": function renditionReport() {
              var report = camelCaseKeys(entry.attributes);
              this.manifest.renditionReports = this.manifest.renditionReports || [];
              this.manifest.renditionReports.push(report);
              var index2 = this.manifest.renditionReports.length - 1;
              var required = ["LAST-MSN", "URI"];
              if (hasParts) {
                required.push("LAST-PART");
              }
              this.warnOnMissingAttributes_("#EXT-X-RENDITION-REPORT #" + index2, entry.attributes, required);
            },
            "part-inf": function partInf() {
              this.manifest.partInf = camelCaseKeys(entry.attributes);
              this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, ["PART-TARGET"]);
              if (this.manifest.partInf.partTarget) {
                this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
              }
              setHoldBack.call(this, this.manifest);
            }
          }[entry.tagType] || noop2).call(self2);
        },
        uri: function uri() {
          currentUri.uri = entry.uri;
          uris.push(currentUri);
          if (this.manifest.targetDuration && !("duration" in currentUri)) {
            this.trigger("warn", {
              message: "defaulting segment duration to the target duration"
            });
            currentUri.duration = this.manifest.targetDuration;
          }
          if (_key) {
            currentUri.key = _key;
          }
          currentUri.timeline = currentTimeline;
          if (currentMap) {
            currentUri.map = currentMap;
          }
          lastPartByterangeEnd = 0;
          currentUri = {};
        },
        comment: function comment2() {
        },
        custom: function custom() {
          if (entry.segment) {
            currentUri.custom = currentUri.custom || {};
            currentUri.custom[entry.customType] = entry.data;
          } else {
            this.manifest.custom = this.manifest.custom || {};
            this.manifest.custom[entry.customType] = entry.data;
          }
        }
      })[entry.type].call(self2);
    });
    return _this;
  }
  var _proto = Parser2.prototype;
  _proto.warnOnMissingAttributes_ = function warnOnMissingAttributes_(identifier2, attributes, required) {
    var missing = [];
    required.forEach(function(key) {
      if (!attributes.hasOwnProperty(key)) {
        missing.push(key);
      }
    });
    if (missing.length) {
      this.trigger("warn", {
        message: identifier2 + " lacks required attribute(s): " + missing.join(", ")
      });
    }
  };
  _proto.push = function push(chunk) {
    this.lineStream.push(chunk);
  };
  _proto.end = function end2() {
    this.lineStream.push("\n");
    this.trigger("end");
  };
  _proto.addParser = function addParser(options) {
    this.parseStream.addParser(options);
  };
  _proto.addTagMapper = function addTagMapper(options) {
    this.parseStream.addTagMapper(options);
  };
  return Parser2;
}(Stream);
var regexs = {
  // to determine mime types
  mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
  webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
  ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
  // to determine if a codec is audio or video
  video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
  audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
  text: /^(stpp.ttml.im1t)/,
  // mux.js support regex
  muxerVideo: /^(avc0?1)/,
  muxerAudio: /^(mp4a)/,
  // match nothing as muxer does not support text right now.
  // there cannot never be a character before the start of a string
  // so this matches nothing.
  muxerText: /a^/
};
var mediaTypes = ["video", "audio", "text"];
var upperMediaTypes = ["Video", "Audio", "Text"];
var translateLegacyCodec = function translateLegacyCodec2(codec) {
  if (!codec) {
    return codec;
  }
  return codec.replace(/avc1\.(\d+)\.(\d+)/i, function(orig, profile, avcLevel) {
    var profileHex = ("00" + Number(profile).toString(16)).slice(-2);
    var avcLevelHex = ("00" + Number(avcLevel).toString(16)).slice(-2);
    return "avc1." + profileHex + "00" + avcLevelHex;
  });
};
var parseCodecs = function parseCodecs2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  var codecs = codecString.split(",");
  var result = [];
  codecs.forEach(function(codec) {
    codec = codec.trim();
    var codecType;
    mediaTypes.forEach(function(name) {
      var match2 = regexs[name].exec(codec.toLowerCase());
      if (!match2 || match2.length <= 1) {
        return;
      }
      codecType = name;
      var type2 = codec.substring(0, match2[1].length);
      var details = codec.replace(type2, "");
      result.push({
        type: type2,
        details,
        mediaType: name
      });
    });
    if (!codecType) {
      result.push({
        type: codec,
        details: "",
        mediaType: "unknown"
      });
    }
  });
  return result;
};
var codecsFromDefault = function codecsFromDefault2(master, audioGroupId) {
  if (!master.mediaGroups.AUDIO || !audioGroupId) {
    return null;
  }
  var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
  if (!audioGroup) {
    return null;
  }
  for (var name in audioGroup) {
    var audioType = audioGroup[name];
    if (audioType.default && audioType.playlists) {
      return parseCodecs(audioType.playlists[0].attributes.CODECS);
    }
  }
  return null;
};
var isAudioCodec = function isAudioCodec2(codec) {
  if (codec === void 0) {
    codec = "";
  }
  return regexs.audio.test(codec.trim().toLowerCase());
};
var isTextCodec = function isTextCodec2(codec) {
  if (codec === void 0) {
    codec = "";
  }
  return regexs.text.test(codec.trim().toLowerCase());
};
var getMimeForCodec = function getMimeForCodec2(codecString) {
  if (!codecString || typeof codecString !== "string") {
    return;
  }
  var codecs = codecString.toLowerCase().split(",").map(function(c2) {
    return translateLegacyCodec(c2.trim());
  });
  var type2 = "video";
  if (codecs.length === 1 && isAudioCodec(codecs[0])) {
    type2 = "audio";
  } else if (codecs.length === 1 && isTextCodec(codecs[0])) {
    type2 = "application";
  }
  var container2 = "mp4";
  if (codecs.every(function(c2) {
    return regexs.mp4.test(c2);
  })) {
    container2 = "mp4";
  } else if (codecs.every(function(c2) {
    return regexs.webm.test(c2);
  })) {
    container2 = "webm";
  } else if (codecs.every(function(c2) {
    return regexs.ogg.test(c2);
  })) {
    container2 = "ogg";
  }
  return type2 + "/" + container2 + ';codecs="' + codecString + '"';
};
var browserSupportsCodec = function browserSupportsCodec2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  return window_1.MediaSource && window_1.MediaSource.isTypeSupported && window_1.MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;
};
var muxerSupportsCodec = function muxerSupportsCodec2(codecString) {
  if (codecString === void 0) {
    codecString = "";
  }
  return codecString.toLowerCase().split(",").every(function(codec) {
    codec = codec.trim();
    for (var i = 0; i < upperMediaTypes.length; i++) {
      var type2 = upperMediaTypes[i];
      if (regexs["muxer" + type2].test(codec)) {
        return true;
      }
    }
    return false;
  });
};
var DEFAULT_AUDIO_CODEC = "mp4a.40.2";
var DEFAULT_VIDEO_CODEC = "avc1.4d400d";
var MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
var DASH_REGEX = /^application\/dash\+xml/i;
var simpleTypeFromSourceType = function simpleTypeFromSourceType2(type2) {
  if (MPEGURL_REGEX.test(type2)) {
    return "hls";
  }
  if (DASH_REGEX.test(type2)) {
    return "dash";
  }
  if (type2 === "application/vnd.videojs.vhs+json") {
    return "vhs-json";
  }
  return null;
};
var countBits = function countBits2(x) {
  return x.toString(2).length;
};
var countBytes = function countBytes2(x) {
  return Math.ceil(countBits(x) / 8);
};
var isArrayBufferView = function isArrayBufferView2(obj) {
  if (ArrayBuffer.isView === "function") {
    return ArrayBuffer.isView(obj);
  }
  return obj && obj.buffer instanceof ArrayBuffer;
};
var isTypedArray = function isTypedArray2(obj) {
  return isArrayBufferView(obj);
};
var toUint8 = function toUint82(bytes) {
  if (bytes instanceof Uint8Array) {
    return bytes;
  }
  if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) {
    if (typeof bytes !== "number" || typeof bytes === "number" && bytes !== bytes) {
      bytes = 0;
    } else {
      bytes = [bytes];
    }
  }
  return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
};
var BigInt = window_1.BigInt || Number;
var BYTE_TABLE = [BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000")];
(function() {
  var a2 = new Uint16Array([65484]);
  var b2 = new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength);
  if (b2[0] === 255) {
    return "big";
  }
  if (b2[0] === 204) {
    return "little";
  }
  return "unknown";
})();
var bytesToNumber = function bytesToNumber2(bytes, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$signed = _ref.signed, signed = _ref$signed === void 0 ? false : _ref$signed, _ref$le = _ref.le, le2 = _ref$le === void 0 ? false : _ref$le;
  bytes = toUint8(bytes);
  var fn2 = le2 ? "reduce" : "reduceRight";
  var obj = bytes[fn2] ? bytes[fn2] : Array.prototype[fn2];
  var number = obj.call(bytes, function(total, byte, i) {
    var exponent = le2 ? i : Math.abs(i + 1 - bytes.length);
    return total + BigInt(byte) * BYTE_TABLE[exponent];
  }, BigInt(0));
  if (signed) {
    var max2 = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);
    number = BigInt(number);
    if (number > max2) {
      number -= max2;
      number -= max2;
      number -= BigInt(2);
    }
  }
  return Number(number);
};
var numberToBytes = function numberToBytes2(number, _temp2) {
  var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$le = _ref2.le, le2 = _ref2$le === void 0 ? false : _ref2$le;
  if (typeof number !== "bigint" && typeof number !== "number" || typeof number === "number" && number !== number) {
    number = 0;
  }
  number = BigInt(number);
  var byteCount = countBytes(number);
  var bytes = new Uint8Array(new ArrayBuffer(byteCount));
  for (var i = 0; i < byteCount; i++) {
    var byteIndex = le2 ? i : Math.abs(i + 1 - bytes.length);
    bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(255));
    if (number < 0) {
      bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
      bytes[byteIndex] -= i === 0 ? 1 : 2;
    }
  }
  return bytes;
};
var stringToBytes = function stringToBytes2(string, stringIsBytes) {
  if (typeof string !== "string" && string && typeof string.toString === "function") {
    string = string.toString();
  }
  if (typeof string !== "string") {
    return new Uint8Array();
  }
  if (!stringIsBytes) {
    string = unescape(encodeURIComponent(string));
  }
  var view = new Uint8Array(string.length);
  for (var i = 0; i < string.length; i++) {
    view[i] = string.charCodeAt(i);
  }
  return view;
};
var concatTypedArrays = function concatTypedArrays2() {
  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
    buffers[_key] = arguments[_key];
  }
  buffers = buffers.filter(function(b2) {
    return b2 && (b2.byteLength || b2.length) && typeof b2 !== "string";
  });
  if (buffers.length <= 1) {
    return toUint8(buffers[0]);
  }
  var totalLen = buffers.reduce(function(total, buf, i) {
    return total + (buf.byteLength || buf.length);
  }, 0);
  var tempBuffer = new Uint8Array(totalLen);
  var offset3 = 0;
  buffers.forEach(function(buf) {
    buf = toUint8(buf);
    tempBuffer.set(buf, offset3);
    offset3 += buf.byteLength;
  });
  return tempBuffer;
};
var bytesMatch = function bytesMatch2(a2, b2, _temp3) {
  var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$offset = _ref3.offset, offset3 = _ref3$offset === void 0 ? 0 : _ref3$offset, _ref3$mask = _ref3.mask, mask = _ref3$mask === void 0 ? [] : _ref3$mask;
  a2 = toUint8(a2);
  b2 = toUint8(b2);
  var fn2 = b2.every ? b2.every : Array.prototype.every;
  return b2.length && a2.length - offset3 >= b2.length && // ie 11 doesn't support every on uin8
  fn2.call(b2, function(bByte, i) {
    var aByte = mask[i] ? mask[i] & a2[offset3 + i] : a2[offset3 + i];
    return bByte === aByte;
  });
};
var forEachMediaGroup$1 = function forEachMediaGroup(master, groups, callback2) {
  groups.forEach(function(mediaType) {
    for (var groupKey in master.mediaGroups[mediaType]) {
      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
        callback2(mediaProperties, mediaType, groupKey, labelKey);
      }
    }
  });
};
var dom$1 = {};
var conventions$2 = {};
function find$2(list, predicate, ac2) {
  if (ac2 === void 0) {
    ac2 = Array.prototype;
  }
  if (list && typeof ac2.find === "function") {
    return ac2.find.call(list, predicate);
  }
  for (var i = 0; i < list.length; i++) {
    if (Object.prototype.hasOwnProperty.call(list, i)) {
      var item = list[i];
      if (predicate.call(void 0, item, i, list)) {
        return item;
      }
    }
  }
}
function freeze(object, oc2) {
  if (oc2 === void 0) {
    oc2 = Object;
  }
  return oc2 && typeof oc2.freeze === "function" ? oc2.freeze(object) : object;
}
var MIME_TYPE = freeze({
  /**
   * `text/html`, the only mime type that triggers treating an XML document as HTML.
   *
   * @see DOMParser.SupportedType.isHTML
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
   */
  HTML: "text/html",
  /**
   * Helper method to check a mime type if it indicates an HTML document
   *
   * @param {string} [value]
   * @returns {boolean}
   *
   * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/HTML Wikipedia
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
   * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  isHTML: function(value) {
    return value === MIME_TYPE.HTML;
  },
  /**
   * `application/xml`, the standard mime type for XML documents.
   *
   * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
   * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_APPLICATION: "application/xml",
  /**
   * `text/html`, an alias for `application/xml`.
   *
   * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
   * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
   * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
   */
  XML_TEXT: "text/xml",
  /**
   * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
   * but is parsed as an XML document.
   *
   * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
   * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
   */
  XML_XHTML_APPLICATION: "application/xhtml+xml",
  /**
   * `image/svg+xml`,
   *
   * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
   * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
   * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
   */
  XML_SVG_IMAGE: "image/svg+xml"
});
var NAMESPACE$3 = freeze({
  /**
   * The XHTML namespace.
   *
   * @see http://www.w3.org/1999/xhtml
   */
  HTML: "http://www.w3.org/1999/xhtml",
  /**
   * Checks if `uri` equals `NAMESPACE.HTML`.
   *
   * @param {string} [uri]
   *
   * @see NAMESPACE.HTML
   */
  isHTML: function(uri) {
    return uri === NAMESPACE$3.HTML;
  },
  /**
   * The SVG namespace.
   *
   * @see http://www.w3.org/2000/svg
   */
  SVG: "http://www.w3.org/2000/svg",
  /**
   * The `xml:` namespace.
   *
   * @see http://www.w3.org/XML/1998/namespace
   */
  XML: "http://www.w3.org/XML/1998/namespace",
  /**
   * The `xmlns:` namespace
   *
   * @see https://www.w3.org/2000/xmlns/
   */
  XMLNS: "http://www.w3.org/2000/xmlns/"
});
conventions$2.find = find$2;
conventions$2.freeze = freeze;
conventions$2.MIME_TYPE = MIME_TYPE;
conventions$2.NAMESPACE = NAMESPACE$3;
var conventions$1 = conventions$2;
var find$1 = conventions$1.find;
var NAMESPACE$2 = conventions$1.NAMESPACE;
function notEmptyString(input) {
  return input !== "";
}
function splitOnASCIIWhitespace(input) {
  return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
}
function orderedSetReducer(current, element) {
  if (!current.hasOwnProperty(element)) {
    current[element] = true;
  }
  return current;
}
function toOrderedSet(input) {
  if (!input)
    return [];
  var list = splitOnASCIIWhitespace(input);
  return Object.keys(list.reduce(orderedSetReducer, {}));
}
function arrayIncludes(list) {
  return function(element) {
    return list && list.indexOf(element) !== -1;
  };
}
function copy(src, dest) {
  for (var p2 in src) {
    if (Object.prototype.hasOwnProperty.call(src, p2)) {
      dest[p2] = src[p2];
    }
  }
}
function _extends$6(Class, Super) {
  var pt = Class.prototype;
  if (!(pt instanceof Super)) {
    let t4 = function() {
    };
    var t3 = t4;
    t4.prototype = Super.prototype;
    t4 = new t4();
    copy(pt, t4);
    Class.prototype = pt = t4;
  }
  if (pt.constructor != Class) {
    if (typeof Class != "function") {
      console.error("unknown Class:" + Class);
    }
    pt.constructor = Class;
  }
}
var NodeType = {};
var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
var TEXT_NODE = NodeType.TEXT_NODE = 3;
var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
var ExceptionCode = {};
var ExceptionMessage = {};
ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
function DOMException(code, message) {
  if (message instanceof Error) {
    var error = message;
  } else {
    error = this;
    Error.call(this, ExceptionMessage[code]);
    this.message = ExceptionMessage[code];
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, DOMException);
  }
  error.code = code;
  if (message)
    this.message = this.message + ": " + message;
  return error;
}
DOMException.prototype = Error.prototype;
copy(ExceptionCode, DOMException);
function NodeList() {
}
NodeList.prototype = {
  /**
   * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
   * @standard level1
   */
  length: 0,
  /**
   * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
   * @standard level1
   * @param index  unsigned long
   *   Index into the collection.
   * @return Node
   * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
   */
  item: function(index2) {
    return this[index2] || null;
  },
  toString: function(isHTML, nodeFilter) {
    for (var buf = [], i = 0; i < this.length; i++) {
      serializeToString(this[i], buf, isHTML, nodeFilter);
    }
    return buf.join("");
  },
  /**
   * @private
   * @param {function (Node):boolean} predicate
   * @returns {Node[]}
   */
  filter: function(predicate) {
    return Array.prototype.filter.call(this, predicate);
  },
  /**
   * @private
   * @param {Node} item
   * @returns {number}
   */
  indexOf: function(item) {
    return Array.prototype.indexOf.call(this, item);
  }
};
function LiveNodeList(node2, refresh) {
  this._node = node2;
  this._refresh = refresh;
  _updateLiveList(this);
}
function _updateLiveList(list) {
  var inc = list._node._inc || list._node.ownerDocument._inc;
  if (list._inc != inc) {
    var ls = list._refresh(list._node);
    __set__(list, "length", ls.length);
    copy(ls, list);
    list._inc = inc;
  }
}
LiveNodeList.prototype.item = function(i) {
  _updateLiveList(this);
  return this[i];
};
_extends$6(LiveNodeList, NodeList);
function NamedNodeMap() {
}
function _findNodeIndex(list, node2) {
  var i = list.length;
  while (i--) {
    if (list[i] === node2) {
      return i;
    }
  }
}
function _addNamedNode(el2, list, newAttr, oldAttr) {
  if (oldAttr) {
    list[_findNodeIndex(list, oldAttr)] = newAttr;
  } else {
    list[list.length++] = newAttr;
  }
  if (el2) {
    newAttr.ownerElement = el2;
    var doc = el2.ownerDocument;
    if (doc) {
      oldAttr && _onRemoveAttribute(doc, el2, oldAttr);
      _onAddAttribute(doc, el2, newAttr);
    }
  }
}
function _removeNamedNode(el2, list, attr) {
  var i = _findNodeIndex(list, attr);
  if (i >= 0) {
    var lastIndex = list.length - 1;
    while (i < lastIndex) {
      list[i] = list[++i];
    }
    list.length = lastIndex;
    if (el2) {
      var doc = el2.ownerDocument;
      if (doc) {
        _onRemoveAttribute(doc, el2, attr);
        attr.ownerElement = null;
      }
    }
  } else {
    throw new DOMException(NOT_FOUND_ERR, new Error(el2.tagName + "@" + attr));
  }
}
NamedNodeMap.prototype = {
  length: 0,
  item: NodeList.prototype.item,
  getNamedItem: function(key) {
    var i = this.length;
    while (i--) {
      var attr = this[i];
      if (attr.nodeName == key) {
        return attr;
      }
    }
  },
  setNamedItem: function(attr) {
    var el2 = attr.ownerElement;
    if (el2 && el2 != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    var oldAttr = this.getNamedItem(attr.nodeName);
    _addNamedNode(this._ownerElement, this, attr, oldAttr);
    return oldAttr;
  },
  /* returns Node */
  setNamedItemNS: function(attr) {
    var el2 = attr.ownerElement, oldAttr;
    if (el2 && el2 != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
    _addNamedNode(this._ownerElement, this, attr, oldAttr);
    return oldAttr;
  },
  /* returns Node */
  removeNamedItem: function(key) {
    var attr = this.getNamedItem(key);
    _removeNamedNode(this._ownerElement, this, attr);
    return attr;
  },
  // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
  //for level2
  removeNamedItemNS: function(namespaceURI, localName) {
    var attr = this.getNamedItemNS(namespaceURI, localName);
    _removeNamedNode(this._ownerElement, this, attr);
    return attr;
  },
  getNamedItemNS: function(namespaceURI, localName) {
    var i = this.length;
    while (i--) {
      var node2 = this[i];
      if (node2.localName == localName && node2.namespaceURI == namespaceURI) {
        return node2;
      }
    }
    return null;
  }
};
function DOMImplementation$1() {
}
DOMImplementation$1.prototype = {
  /**
   * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
   * The different implementations fairly diverged in what kind of features were reported.
   * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
   *
   * @deprecated It is deprecated and modern browsers return true in all cases.
   *
   * @param {string} feature
   * @param {string} [version]
   * @returns {boolean} always true
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
   * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
   */
  hasFeature: function(feature, version2) {
    return true;
  },
  /**
   * Creates an XML Document object of the specified type with its document element.
   *
   * __It behaves slightly different from the description in the living standard__:
   * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
   * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string|null} namespaceURI
   * @param {string} qualifiedName
   * @param {DocumentType=null} doctype
   * @returns {Document}
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocument: function(namespaceURI, qualifiedName, doctype) {
    var doc = new Document();
    doc.implementation = this;
    doc.childNodes = new NodeList();
    doc.doctype = doctype || null;
    if (doctype) {
      doc.appendChild(doctype);
    }
    if (qualifiedName) {
      var root2 = doc.createElementNS(namespaceURI, qualifiedName);
      doc.appendChild(root2);
    }
    return doc;
  },
  /**
   * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
   *
   * __This behavior is slightly different from the in the specs__:
   * - this implementation is not validating names or qualified names
   *   (when parsing XML strings, the SAX parser takes care of that)
   *
   * @param {string} qualifiedName
   * @param {string} [publicId]
   * @param {string} [systemId]
   * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
   * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
   * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
   * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
   *
   * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
   * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
   * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
   */
  createDocumentType: function(qualifiedName, publicId, systemId) {
    var node2 = new DocumentType();
    node2.name = qualifiedName;
    node2.nodeName = qualifiedName;
    node2.publicId = publicId || "";
    node2.systemId = systemId || "";
    return node2;
  }
};
function Node() {
}
Node.prototype = {
  firstChild: null,
  lastChild: null,
  previousSibling: null,
  nextSibling: null,
  attributes: null,
  parentNode: null,
  childNodes: null,
  ownerDocument: null,
  nodeValue: null,
  namespaceURI: null,
  prefix: null,
  localName: null,
  // Modified in DOM Level 2:
  insertBefore: function(newChild, refChild) {
    return _insertBefore(this, newChild, refChild);
  },
  replaceChild: function(newChild, oldChild) {
    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
    if (oldChild) {
      this.removeChild(oldChild);
    }
  },
  removeChild: function(oldChild) {
    return _removeChild(this, oldChild);
  },
  appendChild: function(newChild) {
    return this.insertBefore(newChild, null);
  },
  hasChildNodes: function() {
    return this.firstChild != null;
  },
  cloneNode: function(deep) {
    return cloneNode(this.ownerDocument || this, this, deep);
  },
  // Modified in DOM Level 2:
  normalize: function() {
    var child = this.firstChild;
    while (child) {
      var next2 = child.nextSibling;
      if (next2 && next2.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
        this.removeChild(next2);
        child.appendData(next2.data);
      } else {
        child.normalize();
        child = next2;
      }
    }
  },
  // Introduced in DOM Level 2:
  isSupported: function(feature, version2) {
    return this.ownerDocument.implementation.hasFeature(feature, version2);
  },
  // Introduced in DOM Level 2:
  hasAttributes: function() {
    return this.attributes.length > 0;
  },
  /**
   * Look up the prefix associated to the given namespace URI, starting from this node.
   * **The default namespace declarations are ignored by this method.**
   * See Namespace Prefix Lookup for details on the algorithm used by this method.
   *
   * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
   *
   * @param {string | null} namespaceURI
   * @returns {string | null}
   * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
   * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
   * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
   * @see https://github.com/xmldom/xmldom/issues/322
   */
  lookupPrefix: function(namespaceURI) {
    var el2 = this;
    while (el2) {
      var map = el2._nsMap;
      if (map) {
        for (var n2 in map) {
          if (Object.prototype.hasOwnProperty.call(map, n2) && map[n2] === namespaceURI) {
            return n2;
          }
        }
      }
      el2 = el2.nodeType == ATTRIBUTE_NODE ? el2.ownerDocument : el2.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  lookupNamespaceURI: function(prefix2) {
    var el2 = this;
    while (el2) {
      var map = el2._nsMap;
      if (map) {
        if (prefix2 in map) {
          if (Object.prototype.hasOwnProperty.call(map, prefix2)) {
            return map[prefix2];
          }
        }
      }
      el2 = el2.nodeType == ATTRIBUTE_NODE ? el2.ownerDocument : el2.parentNode;
    }
    return null;
  },
  // Introduced in DOM Level 3:
  isDefaultNamespace: function(namespaceURI) {
    var prefix2 = this.lookupPrefix(namespaceURI);
    return prefix2 == null;
  }
};
function _xmlEncoder(c2) {
  return c2 == "<" && "&lt;" || c2 == ">" && "&gt;" || c2 == "&" && "&amp;" || c2 == '"' && "&quot;" || "&#" + c2.charCodeAt() + ";";
}
copy(NodeType, Node);
copy(NodeType, Node.prototype);
function _visitNode(node2, callback2) {
  if (callback2(node2)) {
    return true;
  }
  if (node2 = node2.firstChild) {
    do {
      if (_visitNode(node2, callback2)) {
        return true;
      }
    } while (node2 = node2.nextSibling);
  }
}
function Document() {
  this.ownerDocument = this;
}
function _onAddAttribute(doc, el2, newAttr) {
  doc && doc._inc++;
  var ns = newAttr.namespaceURI;
  if (ns === NAMESPACE$2.XMLNS) {
    el2._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
  }
}
function _onRemoveAttribute(doc, el2, newAttr, remove2) {
  doc && doc._inc++;
  var ns = newAttr.namespaceURI;
  if (ns === NAMESPACE$2.XMLNS) {
    delete el2._nsMap[newAttr.prefix ? newAttr.localName : ""];
  }
}
function _onUpdateChild(doc, el2, newChild) {
  if (doc && doc._inc) {
    doc._inc++;
    var cs = el2.childNodes;
    if (newChild) {
      cs[cs.length++] = newChild;
    } else {
      var child = el2.firstChild;
      var i = 0;
      while (child) {
        cs[i++] = child;
        child = child.nextSibling;
      }
      cs.length = i;
      delete cs[cs.length];
    }
  }
}
function _removeChild(parentNode, child) {
  var previous = child.previousSibling;
  var next2 = child.nextSibling;
  if (previous) {
    previous.nextSibling = next2;
  } else {
    parentNode.firstChild = next2;
  }
  if (next2) {
    next2.previousSibling = previous;
  } else {
    parentNode.lastChild = previous;
  }
  child.parentNode = null;
  child.previousSibling = null;
  child.nextSibling = null;
  _onUpdateChild(parentNode.ownerDocument, parentNode);
  return child;
}
function hasValidParentNodeType(node2) {
  return node2 && (node2.nodeType === Node.DOCUMENT_NODE || node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node2.nodeType === Node.ELEMENT_NODE);
}
function hasInsertableNodeType(node2) {
  return node2 && (isElementNode(node2) || isTextNode$1(node2) || isDocTypeNode(node2) || node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node2.nodeType === Node.COMMENT_NODE || node2.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
}
function isDocTypeNode(node2) {
  return node2 && node2.nodeType === Node.DOCUMENT_TYPE_NODE;
}
function isElementNode(node2) {
  return node2 && node2.nodeType === Node.ELEMENT_NODE;
}
function isTextNode$1(node2) {
  return node2 && node2.nodeType === Node.TEXT_NODE;
}
function isElementInsertionPossible(doc, child) {
  var parentChildNodes = doc.childNodes || [];
  if (find$1(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
    return false;
  }
  var docTypeNode = find$1(parentChildNodes, isDocTypeNode);
  return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}
function isElementReplacementPossible(doc, child) {
  var parentChildNodes = doc.childNodes || [];
  function hasElementChildThatIsNotChild(node2) {
    return isElementNode(node2) && node2 !== child;
  }
  if (find$1(parentChildNodes, hasElementChildThatIsNotChild)) {
    return false;
  }
  var docTypeNode = find$1(parentChildNodes, isDocTypeNode);
  return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
}
function assertPreInsertionValidity1to5(parent, node2, child) {
  if (!hasValidParentNodeType(parent)) {
    throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
  }
  if (child && child.parentNode !== parent) {
    throw new DOMException(NOT_FOUND_ERR, "child not in parent");
  }
  if (
    // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
    !hasInsertableNodeType(node2) || // 5. If either `node` is a Text node and `parent` is a document,
    // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
    // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
    // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
    isDocTypeNode(node2) && parent.nodeType !== Node.DOCUMENT_NODE
  ) {
    throw new DOMException(
      HIERARCHY_REQUEST_ERR,
      "Unexpected node type " + node2.nodeType + " for parent node type " + parent.nodeType
    );
  }
}
function assertPreInsertionValidityInDocument(parent, node2, child) {
  var parentChildNodes = parent.childNodes || [];
  var nodeChildNodes = node2.childNodes || [];
  if (node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    var nodeChildElements = nodeChildNodes.filter(isElementNode);
    if (nodeChildElements.length > 1 || find$1(nodeChildNodes, isTextNode$1)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
    }
    if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
  }
  if (isElementNode(node2)) {
    if (!isElementInsertionPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    }
  }
  if (isDocTypeNode(node2)) {
    if (find$1(parentChildNodes, isDocTypeNode)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
    }
    var parentElementChild = find$1(parentChildNodes, isElementNode);
    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
    }
    if (!child && parentElementChild) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
    }
  }
}
function assertPreReplacementValidityInDocument(parent, node2, child) {
  var parentChildNodes = parent.childNodes || [];
  var nodeChildNodes = node2.childNodes || [];
  if (node2.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    var nodeChildElements = nodeChildNodes.filter(isElementNode);
    if (nodeChildElements.length > 1 || find$1(nodeChildNodes, isTextNode$1)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
    }
    if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
    }
  }
  if (isElementNode(node2)) {
    if (!isElementReplacementPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    }
  }
  if (isDocTypeNode(node2)) {
    let hasDoctypeChildThatIsNotChild2 = function(node3) {
      return isDocTypeNode(node3) && node3 !== child;
    };
    var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
    if (find$1(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
    }
    var parentElementChild = find$1(parentChildNodes, isElementNode);
    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
    }
  }
}
function _insertBefore(parent, node2, child, _inDocumentAssertion) {
  assertPreInsertionValidity1to5(parent, node2, child);
  if (parent.nodeType === Node.DOCUMENT_NODE) {
    (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node2, child);
  }
  var cp = node2.parentNode;
  if (cp) {
    cp.removeChild(node2);
  }
  if (node2.nodeType === DOCUMENT_FRAGMENT_NODE) {
    var newFirst = node2.firstChild;
    if (newFirst == null) {
      return node2;
    }
    var newLast = node2.lastChild;
  } else {
    newFirst = newLast = node2;
  }
  var pre = child ? child.previousSibling : parent.lastChild;
  newFirst.previousSibling = pre;
  newLast.nextSibling = child;
  if (pre) {
    pre.nextSibling = newFirst;
  } else {
    parent.firstChild = newFirst;
  }
  if (child == null) {
    parent.lastChild = newLast;
  } else {
    child.previousSibling = newLast;
  }
  do {
    newFirst.parentNode = parent;
  } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
  _onUpdateChild(parent.ownerDocument || parent, parent);
  if (node2.nodeType == DOCUMENT_FRAGMENT_NODE) {
    node2.firstChild = node2.lastChild = null;
  }
  return node2;
}
function _appendSingleChild(parentNode, newChild) {
  if (newChild.parentNode) {
    newChild.parentNode.removeChild(newChild);
  }
  newChild.parentNode = parentNode;
  newChild.previousSibling = parentNode.lastChild;
  newChild.nextSibling = null;
  if (newChild.previousSibling) {
    newChild.previousSibling.nextSibling = newChild;
  } else {
    parentNode.firstChild = newChild;
  }
  parentNode.lastChild = newChild;
  _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
  return newChild;
}
Document.prototype = {
  //implementation : null,
  nodeName: "#document",
  nodeType: DOCUMENT_NODE,
  /**
   * The DocumentType node of the document.
   *
   * @readonly
   * @type DocumentType
   */
  doctype: null,
  documentElement: null,
  _inc: 1,
  insertBefore: function(newChild, refChild) {
    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
      var child = newChild.firstChild;
      while (child) {
        var next2 = child.nextSibling;
        this.insertBefore(child, refChild);
        child = next2;
      }
      return newChild;
    }
    _insertBefore(this, newChild, refChild);
    newChild.ownerDocument = this;
    if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
      this.documentElement = newChild;
    }
    return newChild;
  },
  removeChild: function(oldChild) {
    if (this.documentElement == oldChild) {
      this.documentElement = null;
    }
    return _removeChild(this, oldChild);
  },
  replaceChild: function(newChild, oldChild) {
    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
    newChild.ownerDocument = this;
    if (oldChild) {
      this.removeChild(oldChild);
    }
    if (isElementNode(newChild)) {
      this.documentElement = newChild;
    }
  },
  // Introduced in DOM Level 2:
  importNode: function(importedNode, deep) {
    return importNode(this, importedNode, deep);
  },
  // Introduced in DOM Level 2:
  getElementById: function(id2) {
    var rtv = null;
    _visitNode(this.documentElement, function(node2) {
      if (node2.nodeType == ELEMENT_NODE) {
        if (node2.getAttribute("id") == id2) {
          rtv = node2;
          return true;
        }
      }
    });
    return rtv;
  },
  /**
   * The `getElementsByClassName` method of `Document` interface returns an array-like object
   * of all child elements which have **all** of the given class name(s).
   *
   * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
   *
   *
   * Warning: This is a live LiveNodeList.
   * Changes in the DOM will reflect in the array as the changes occur.
   * If an element selected by this array no longer qualifies for the selector,
   * it will automatically be removed. Be aware of this for iteration purposes.
   *
   * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
   * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
   */
  getElementsByClassName: function(classNames) {
    var classNamesSet = toOrderedSet(classNames);
    return new LiveNodeList(this, function(base) {
      var ls = [];
      if (classNamesSet.length > 0) {
        _visitNode(base.documentElement, function(node2) {
          if (node2 !== base && node2.nodeType === ELEMENT_NODE) {
            var nodeClassNames = node2.getAttribute("class");
            if (nodeClassNames) {
              var matches = classNames === nodeClassNames;
              if (!matches) {
                var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
              }
              if (matches) {
                ls.push(node2);
              }
            }
          }
        });
      }
      return ls;
    });
  },
  //document factory method:
  createElement: function(tagName) {
    var node2 = new Element$1();
    node2.ownerDocument = this;
    node2.nodeName = tagName;
    node2.tagName = tagName;
    node2.localName = tagName;
    node2.childNodes = new NodeList();
    var attrs = node2.attributes = new NamedNodeMap();
    attrs._ownerElement = node2;
    return node2;
  },
  createDocumentFragment: function() {
    var node2 = new DocumentFragment$1();
    node2.ownerDocument = this;
    node2.childNodes = new NodeList();
    return node2;
  },
  createTextNode: function(data) {
    var node2 = new Text();
    node2.ownerDocument = this;
    node2.appendData(data);
    return node2;
  },
  createComment: function(data) {
    var node2 = new Comment$1();
    node2.ownerDocument = this;
    node2.appendData(data);
    return node2;
  },
  createCDATASection: function(data) {
    var node2 = new CDATASection();
    node2.ownerDocument = this;
    node2.appendData(data);
    return node2;
  },
  createProcessingInstruction: function(target, data) {
    var node2 = new ProcessingInstruction();
    node2.ownerDocument = this;
    node2.tagName = node2.target = target;
    node2.nodeValue = node2.data = data;
    return node2;
  },
  createAttribute: function(name) {
    var node2 = new Attr();
    node2.ownerDocument = this;
    node2.name = name;
    node2.nodeName = name;
    node2.localName = name;
    node2.specified = true;
    return node2;
  },
  createEntityReference: function(name) {
    var node2 = new EntityReference();
    node2.ownerDocument = this;
    node2.nodeName = name;
    return node2;
  },
  // Introduced in DOM Level 2:
  createElementNS: function(namespaceURI, qualifiedName) {
    var node2 = new Element$1();
    var pl2 = qualifiedName.split(":");
    var attrs = node2.attributes = new NamedNodeMap();
    node2.childNodes = new NodeList();
    node2.ownerDocument = this;
    node2.nodeName = qualifiedName;
    node2.tagName = qualifiedName;
    node2.namespaceURI = namespaceURI;
    if (pl2.length == 2) {
      node2.prefix = pl2[0];
      node2.localName = pl2[1];
    } else {
      node2.localName = qualifiedName;
    }
    attrs._ownerElement = node2;
    return node2;
  },
  // Introduced in DOM Level 2:
  createAttributeNS: function(namespaceURI, qualifiedName) {
    var node2 = new Attr();
    var pl2 = qualifiedName.split(":");
    node2.ownerDocument = this;
    node2.nodeName = qualifiedName;
    node2.name = qualifiedName;
    node2.namespaceURI = namespaceURI;
    node2.specified = true;
    if (pl2.length == 2) {
      node2.prefix = pl2[0];
      node2.localName = pl2[1];
    } else {
      node2.localName = qualifiedName;
    }
    return node2;
  }
};
_extends$6(Document, Node);
function Element$1() {
  this._nsMap = {};
}
Element$1.prototype = {
  nodeType: ELEMENT_NODE,
  hasAttribute: function(name) {
    return this.getAttributeNode(name) != null;
  },
  getAttribute: function(name) {
    var attr = this.getAttributeNode(name);
    return attr && attr.value || "";
  },
  getAttributeNode: function(name) {
    return this.attributes.getNamedItem(name);
  },
  setAttribute: function(name, value) {
    var attr = this.ownerDocument.createAttribute(name);
    attr.value = attr.nodeValue = "" + value;
    this.setAttributeNode(attr);
  },
  removeAttribute: function(name) {
    var attr = this.getAttributeNode(name);
    attr && this.removeAttributeNode(attr);
  },
  //four real opeartion method
  appendChild: function(newChild) {
    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return this.insertBefore(newChild, null);
    } else {
      return _appendSingleChild(this, newChild);
    }
  },
  setAttributeNode: function(newAttr) {
    return this.attributes.setNamedItem(newAttr);
  },
  setAttributeNodeNS: function(newAttr) {
    return this.attributes.setNamedItemNS(newAttr);
  },
  removeAttributeNode: function(oldAttr) {
    return this.attributes.removeNamedItem(oldAttr.nodeName);
  },
  //get real attribute name,and remove it by removeAttributeNode
  removeAttributeNS: function(namespaceURI, localName) {
    var old = this.getAttributeNodeNS(namespaceURI, localName);
    old && this.removeAttributeNode(old);
  },
  hasAttributeNS: function(namespaceURI, localName) {
    return this.getAttributeNodeNS(namespaceURI, localName) != null;
  },
  getAttributeNS: function(namespaceURI, localName) {
    var attr = this.getAttributeNodeNS(namespaceURI, localName);
    return attr && attr.value || "";
  },
  setAttributeNS: function(namespaceURI, qualifiedName, value) {
    var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
    attr.value = attr.nodeValue = "" + value;
    this.setAttributeNode(attr);
  },
  getAttributeNodeNS: function(namespaceURI, localName) {
    return this.attributes.getNamedItemNS(namespaceURI, localName);
  },
  getElementsByTagName: function(tagName) {
    return new LiveNodeList(this, function(base) {
      var ls = [];
      _visitNode(base, function(node2) {
        if (node2 !== base && node2.nodeType == ELEMENT_NODE && (tagName === "*" || node2.tagName == tagName)) {
          ls.push(node2);
        }
      });
      return ls;
    });
  },
  getElementsByTagNameNS: function(namespaceURI, localName) {
    return new LiveNodeList(this, function(base) {
      var ls = [];
      _visitNode(base, function(node2) {
        if (node2 !== base && node2.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node2.namespaceURI === namespaceURI) && (localName === "*" || node2.localName == localName)) {
          ls.push(node2);
        }
      });
      return ls;
    });
  }
};
Document.prototype.getElementsByTagName = Element$1.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element$1.prototype.getElementsByTagNameNS;
_extends$6(Element$1, Node);
function Attr() {
}
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends$6(Attr, Node);
function CharacterData() {
}
CharacterData.prototype = {
  data: "",
  substringData: function(offset3, count2) {
    return this.data.substring(offset3, offset3 + count2);
  },
  appendData: function(text) {
    text = this.data + text;
    this.nodeValue = this.data = text;
    this.length = text.length;
  },
  insertData: function(offset3, text) {
    this.replaceData(offset3, 0, text);
  },
  appendChild: function(newChild) {
    throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
  },
  deleteData: function(offset3, count2) {
    this.replaceData(offset3, count2, "");
  },
  replaceData: function(offset3, count2, text) {
    var start3 = this.data.substring(0, offset3);
    var end2 = this.data.substring(offset3 + count2);
    text = start3 + text + end2;
    this.nodeValue = this.data = text;
    this.length = text.length;
  }
};
_extends$6(CharacterData, Node);
function Text() {
}
Text.prototype = {
  nodeName: "#text",
  nodeType: TEXT_NODE,
  splitText: function(offset3) {
    var text = this.data;
    var newText = text.substring(offset3);
    text = text.substring(0, offset3);
    this.data = this.nodeValue = text;
    this.length = text.length;
    var newNode = this.ownerDocument.createTextNode(newText);
    if (this.parentNode) {
      this.parentNode.insertBefore(newNode, this.nextSibling);
    }
    return newNode;
  }
};
_extends$6(Text, CharacterData);
function Comment$1() {
}
Comment$1.prototype = {
  nodeName: "#comment",
  nodeType: COMMENT_NODE
};
_extends$6(Comment$1, CharacterData);
function CDATASection() {
}
CDATASection.prototype = {
  nodeName: "#cdata-section",
  nodeType: CDATA_SECTION_NODE
};
_extends$6(CDATASection, CharacterData);
function DocumentType() {
}
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends$6(DocumentType, Node);
function Notation() {
}
Notation.prototype.nodeType = NOTATION_NODE;
_extends$6(Notation, Node);
function Entity() {
}
Entity.prototype.nodeType = ENTITY_NODE;
_extends$6(Entity, Node);
function EntityReference() {
}
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends$6(EntityReference, Node);
function DocumentFragment$1() {
}
DocumentFragment$1.prototype.nodeName = "#document-fragment";
DocumentFragment$1.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
_extends$6(DocumentFragment$1, Node);
function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends$6(ProcessingInstruction, Node);
function XMLSerializer() {
}
XMLSerializer.prototype.serializeToString = function(node2, isHtml, nodeFilter) {
  return nodeSerializeToString.call(node2, isHtml, nodeFilter);
};
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml, nodeFilter) {
  var buf = [];
  var refNode = this.nodeType == 9 && this.documentElement || this;
  var prefix2 = refNode.prefix;
  var uri = refNode.namespaceURI;
  if (uri && prefix2 == null) {
    var prefix2 = refNode.lookupPrefix(uri);
    if (prefix2 == null) {
      var visibleNamespaces = [
        { namespace: uri, prefix: null }
        //{namespace:uri,prefix:''}
      ];
    }
  }
  serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
  return buf.join("");
}
function needNamespaceDefine(node2, isHTML, visibleNamespaces) {
  var prefix2 = node2.prefix || "";
  var uri = node2.namespaceURI;
  if (!uri) {
    return false;
  }
  if (prefix2 === "xml" && uri === NAMESPACE$2.XML || uri === NAMESPACE$2.XMLNS) {
    return false;
  }
  var i = visibleNamespaces.length;
  while (i--) {
    var ns = visibleNamespaces[i];
    if (ns.prefix === prefix2) {
      return ns.namespace !== uri;
    }
  }
  return true;
}
function addSerializedAttribute(buf, qualifiedName, value) {
  buf.push(" ", qualifiedName, '="', value.replace(/[<&"]/g, _xmlEncoder), '"');
}
function serializeToString(node2, buf, isHTML, nodeFilter, visibleNamespaces) {
  if (!visibleNamespaces) {
    visibleNamespaces = [];
  }
  if (nodeFilter) {
    node2 = nodeFilter(node2);
    if (node2) {
      if (typeof node2 == "string") {
        buf.push(node2);
        return;
      }
    } else {
      return;
    }
  }
  switch (node2.nodeType) {
    case ELEMENT_NODE:
      var attrs = node2.attributes;
      var len2 = attrs.length;
      var child = node2.firstChild;
      var nodeName = node2.tagName;
      isHTML = NAMESPACE$2.isHTML(node2.namespaceURI) || isHTML;
      var prefixedNodeName = nodeName;
      if (!isHTML && !node2.prefix && node2.namespaceURI) {
        var defaultNS;
        for (var ai2 = 0; ai2 < attrs.length; ai2++) {
          if (attrs.item(ai2).name === "xmlns") {
            defaultNS = attrs.item(ai2).value;
            break;
          }
        }
        if (!defaultNS) {
          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
            var namespace = visibleNamespaces[nsi];
            if (namespace.prefix === "" && namespace.namespace === node2.namespaceURI) {
              defaultNS = namespace.namespace;
              break;
            }
          }
        }
        if (defaultNS !== node2.namespaceURI) {
          for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
            var namespace = visibleNamespaces[nsi];
            if (namespace.namespace === node2.namespaceURI) {
              if (namespace.prefix) {
                prefixedNodeName = namespace.prefix + ":" + nodeName;
              }
              break;
            }
          }
        }
      }
      buf.push("<", prefixedNodeName);
      for (var i = 0; i < len2; i++) {
        var attr = attrs.item(i);
        if (attr.prefix == "xmlns") {
          visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
        } else if (attr.nodeName == "xmlns") {
          visibleNamespaces.push({ prefix: "", namespace: attr.value });
        }
      }
      for (var i = 0; i < len2; i++) {
        var attr = attrs.item(i);
        if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
          var prefix2 = attr.prefix || "";
          var uri = attr.namespaceURI;
          addSerializedAttribute(buf, prefix2 ? "xmlns:" + prefix2 : "xmlns", uri);
          visibleNamespaces.push({ prefix: prefix2, namespace: uri });
        }
        serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
      }
      if (nodeName === prefixedNodeName && needNamespaceDefine(node2, isHTML, visibleNamespaces)) {
        var prefix2 = node2.prefix || "";
        var uri = node2.namespaceURI;
        addSerializedAttribute(buf, prefix2 ? "xmlns:" + prefix2 : "xmlns", uri);
        visibleNamespaces.push({ prefix: prefix2, namespace: uri });
      }
      if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
        buf.push(">");
        if (isHTML && /^script$/i.test(nodeName)) {
          while (child) {
            if (child.data) {
              buf.push(child.data);
            } else {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            }
            child = child.nextSibling;
          }
        } else {
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
        }
        buf.push("</", prefixedNodeName, ">");
      } else {
        buf.push("/>");
      }
      return;
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      var child = node2.firstChild;
      while (child) {
        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
        child = child.nextSibling;
      }
      return;
    case ATTRIBUTE_NODE:
      return addSerializedAttribute(buf, node2.name, node2.value);
    case TEXT_NODE:
      return buf.push(
        node2.data.replace(/[<&]/g, _xmlEncoder).replace(/]]>/g, "]]&gt;")
      );
    case CDATA_SECTION_NODE:
      return buf.push("<![CDATA[", node2.data, "]]>");
    case COMMENT_NODE:
      return buf.push("<!--", node2.data, "-->");
    case DOCUMENT_TYPE_NODE:
      var pubid = node2.publicId;
      var sysid = node2.systemId;
      buf.push("<!DOCTYPE ", node2.name);
      if (pubid) {
        buf.push(" PUBLIC ", pubid);
        if (sysid && sysid != ".") {
          buf.push(" ", sysid);
        }
        buf.push(">");
      } else if (sysid && sysid != ".") {
        buf.push(" SYSTEM ", sysid, ">");
      } else {
        var sub = node2.internalSubset;
        if (sub) {
          buf.push(" [", sub, "]");
        }
        buf.push(">");
      }
      return;
    case PROCESSING_INSTRUCTION_NODE:
      return buf.push("<?", node2.target, " ", node2.data, "?>");
    case ENTITY_REFERENCE_NODE:
      return buf.push("&", node2.nodeName, ";");
    default:
      buf.push("??", node2.nodeName);
  }
}
function importNode(doc, node2, deep) {
  var node22;
  switch (node2.nodeType) {
    case ELEMENT_NODE:
      node22 = node2.cloneNode(false);
      node22.ownerDocument = doc;
    case DOCUMENT_FRAGMENT_NODE:
      break;
    case ATTRIBUTE_NODE:
      deep = true;
      break;
  }
  if (!node22) {
    node22 = node2.cloneNode(false);
  }
  node22.ownerDocument = doc;
  node22.parentNode = null;
  if (deep) {
    var child = node2.firstChild;
    while (child) {
      node22.appendChild(importNode(doc, child, deep));
      child = child.nextSibling;
    }
  }
  return node22;
}
function cloneNode(doc, node2, deep) {
  var node22 = new node2.constructor();
  for (var n2 in node2) {
    if (Object.prototype.hasOwnProperty.call(node2, n2)) {
      var v2 = node2[n2];
      if (typeof v2 != "object") {
        if (v2 != node22[n2]) {
          node22[n2] = v2;
        }
      }
    }
  }
  if (node2.childNodes) {
    node22.childNodes = new NodeList();
  }
  node22.ownerDocument = doc;
  switch (node22.nodeType) {
    case ELEMENT_NODE:
      var attrs = node2.attributes;
      var attrs2 = node22.attributes = new NamedNodeMap();
      var len2 = attrs.length;
      attrs2._ownerElement = node22;
      for (var i = 0; i < len2; i++) {
        node22.setAttributeNode(cloneNode(doc, attrs.item(i), true));
      }
      break;
    case ATTRIBUTE_NODE:
      deep = true;
  }
  if (deep) {
    var child = node2.firstChild;
    while (child) {
      node22.appendChild(cloneNode(doc, child, deep));
      child = child.nextSibling;
    }
  }
  return node22;
}
function __set__(object, key, value) {
  object[key] = value;
}
try {
  if (Object.defineProperty) {
    let getTextContent = function(node2) {
      switch (node2.nodeType) {
        case ELEMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var buf = [];
          node2 = node2.firstChild;
          while (node2) {
            if (node2.nodeType !== 7 && node2.nodeType !== 8) {
              buf.push(getTextContent(node2));
            }
            node2 = node2.nextSibling;
          }
          return buf.join("");
        default:
          return node2.nodeValue;
      }
    };
    var getTextContent2 = getTextContent;
    Object.defineProperty(LiveNodeList.prototype, "length", {
      get: function() {
        _updateLiveList(this);
        return this.$$length;
      }
    });
    Object.defineProperty(Node.prototype, "textContent", {
      get: function() {
        return getTextContent(this);
      },
      set: function(data) {
        switch (this.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            while (this.firstChild) {
              this.removeChild(this.firstChild);
            }
            if (data || String(data)) {
              this.appendChild(this.ownerDocument.createTextNode(data));
            }
            break;
          default:
            this.data = data;
            this.value = data;
            this.nodeValue = data;
        }
      }
    });
    __set__ = function(object, key, value) {
      object["$$" + key] = value;
    };
  }
} catch (e2) {
}
dom$1.DocumentType = DocumentType;
dom$1.DOMException = DOMException;
dom$1.DOMImplementation = DOMImplementation$1;
dom$1.Element = Element$1;
dom$1.Node = Node;
dom$1.NodeList = NodeList;
dom$1.XMLSerializer = XMLSerializer;
var domParser = {};
var entities$1 = {};
(function(exports) {
  var freeze2 = conventions$2.freeze;
  exports.XML_ENTITIES = freeze2({ amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' });
  exports.HTML_ENTITIES = freeze2({
    lt: "<",
    gt: ">",
    amp: "&",
    quot: '"',
    apos: "'",
    Agrave: "",
    Aacute: "",
    Acirc: "",
    Atilde: "",
    Auml: "",
    Aring: "",
    AElig: "",
    Ccedil: "",
    Egrave: "",
    Eacute: "",
    Ecirc: "",
    Euml: "",
    Igrave: "",
    Iacute: "",
    Icirc: "",
    Iuml: "",
    ETH: "",
    Ntilde: "",
    Ograve: "",
    Oacute: "",
    Ocirc: "",
    Otilde: "",
    Ouml: "",
    Oslash: "",
    Ugrave: "",
    Uacute: "",
    Ucirc: "",
    Uuml: "",
    Yacute: "",
    THORN: "",
    szlig: "",
    agrave: "",
    aacute: "",
    acirc: "",
    atilde: "",
    auml: "",
    aring: "",
    aelig: "",
    ccedil: "",
    egrave: "",
    eacute: "",
    ecirc: "",
    euml: "",
    igrave: "",
    iacute: "",
    icirc: "",
    iuml: "",
    eth: "",
    ntilde: "",
    ograve: "",
    oacute: "",
    ocirc: "",
    otilde: "",
    ouml: "",
    oslash: "",
    ugrave: "",
    uacute: "",
    ucirc: "",
    uuml: "",
    yacute: "",
    thorn: "",
    yuml: "",
    nbsp: "",
    iexcl: "",
    cent: "",
    pound: "",
    curren: "",
    yen: "",
    brvbar: "",
    sect: "",
    uml: "",
    copy: "",
    ordf: "",
    laquo: "",
    not: "",
    shy: "",
    reg: "",
    macr: "",
    deg: "",
    plusmn: "",
    sup2: "",
    sup3: "",
    acute: "",
    micro: "",
    para: "",
    middot: "",
    cedil: "",
    sup1: "",
    ordm: "",
    raquo: "",
    frac14: "",
    frac12: "",
    frac34: "",
    iquest: "",
    times: "",
    divide: "",
    forall: "",
    part: "",
    exist: "",
    empty: "",
    nabla: "",
    isin: "",
    notin: "",
    ni: "",
    prod: "",
    sum: "",
    minus: "",
    lowast: "",
    radic: "",
    prop: "",
    infin: "",
    ang: "",
    and: "",
    or: "",
    cap: "",
    cup: "",
    "int": "",
    there4: "",
    sim: "",
    cong: "",
    asymp: "",
    ne: "",
    equiv: "",
    le: "",
    ge: "",
    sub: "",
    sup: "",
    nsub: "",
    sube: "",
    supe: "",
    oplus: "",
    otimes: "",
    perp: "",
    sdot: "",
    Alpha: "",
    Beta: "",
    Gamma: "",
    Delta: "",
    Epsilon: "",
    Zeta: "",
    Eta: "",
    Theta: "",
    Iota: "",
    Kappa: "",
    Lambda: "",
    Mu: "",
    Nu: "",
    Xi: "",
    Omicron: "",
    Pi: "",
    Rho: "",
    Sigma: "",
    Tau: "",
    Upsilon: "",
    Phi: "",
    Chi: "",
    Psi: "",
    Omega: "",
    alpha: "",
    beta: "",
    gamma: "",
    delta: "",
    epsilon: "",
    zeta: "",
    eta: "",
    theta: "",
    iota: "",
    kappa: "",
    lambda: "",
    mu: "",
    nu: "",
    xi: "",
    omicron: "",
    pi: "",
    rho: "",
    sigmaf: "",
    sigma: "",
    tau: "",
    upsilon: "",
    phi: "",
    chi: "",
    psi: "",
    omega: "",
    thetasym: "",
    upsih: "",
    piv: "",
    OElig: "",
    oelig: "",
    Scaron: "",
    scaron: "",
    Yuml: "",
    fnof: "",
    circ: "",
    tilde: "",
    ensp: "",
    emsp: "",
    thinsp: "",
    zwnj: "",
    zwj: "",
    lrm: "",
    rlm: "",
    ndash: "",
    mdash: "",
    lsquo: "",
    rsquo: "",
    sbquo: "",
    ldquo: "",
    rdquo: "",
    bdquo: "",
    dagger: "",
    Dagger: "",
    bull: "",
    hellip: "",
    permil: "",
    prime: "",
    Prime: "",
    lsaquo: "",
    rsaquo: "",
    oline: "",
    euro: "",
    trade: "",
    larr: "",
    uarr: "",
    rarr: "",
    darr: "",
    harr: "",
    crarr: "",
    lceil: "",
    rceil: "",
    lfloor: "",
    rfloor: "",
    loz: "",
    spades: "",
    clubs: "",
    hearts: "",
    diams: ""
  });
  exports.entityMap = exports.HTML_ENTITIES;
})(entities$1);
var sax$1 = {};
var NAMESPACE$1 = conventions$2.NAMESPACE;
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
var S_TAG = 0;
var S_ATTR = 1;
var S_ATTR_SPACE = 2;
var S_EQ = 3;
var S_ATTR_NOQUOT_VALUE = 4;
var S_ATTR_END = 5;
var S_TAG_SPACE = 6;
var S_TAG_CLOSE = 7;
function ParseError$1(message, locator) {
  this.message = message;
  this.locator = locator;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ParseError$1);
}
ParseError$1.prototype = new Error();
ParseError$1.prototype.name = ParseError$1.name;
function XMLReader$1() {
}
XMLReader$1.prototype = {
  parse: function(source, defaultNSMap, entityMap) {
    var domBuilder = this.domBuilder;
    domBuilder.startDocument();
    _copy(defaultNSMap, defaultNSMap = {});
    parse$2(
      source,
      defaultNSMap,
      entityMap,
      domBuilder,
      this.errorHandler
    );
    domBuilder.endDocument();
  }
};
function parse$2(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
  function fixedFromCharCode(code) {
    if (code > 65535) {
      code -= 65536;
      var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    } else {
      return String.fromCharCode(code);
    }
  }
  function entityReplacer(a3) {
    var k2 = a3.slice(1, -1);
    if (k2 in entityMap) {
      return entityMap[k2];
    } else if (k2.charAt(0) === "#") {
      return fixedFromCharCode(parseInt(k2.substr(1).replace("x", "0x")));
    } else {
      errorHandler.error("entity not found:" + a3);
      return a3;
    }
  }
  function appendText(end3) {
    if (end3 > start3) {
      var xt = source.substring(start3, end3).replace(/&#?\w+;/g, entityReplacer);
      locator && position3(start3);
      domBuilder.characters(xt, 0, end3 - start3);
      start3 = end3;
    }
  }
  function position3(p2, m2) {
    while (p2 >= lineEnd && (m2 = linePattern.exec(source))) {
      lineStart = m2.index;
      lineEnd = lineStart + m2[0].length;
      locator.lineNumber++;
    }
    locator.columnNumber = p2 - lineStart + 1;
  }
  var lineStart = 0;
  var lineEnd = 0;
  var linePattern = /.*(?:\r\n?|\n)|.*$/g;
  var locator = domBuilder.locator;
  var parseStack = [{ currentNSMap: defaultNSMapCopy }];
  var closeMap = {};
  var start3 = 0;
  while (true) {
    try {
      var tagStart = source.indexOf("<", start3);
      if (tagStart < 0) {
        if (!source.substr(start3).match(/^\s*$/)) {
          var doc = domBuilder.doc;
          var text = doc.createTextNode(source.substr(start3));
          doc.appendChild(text);
          domBuilder.currentElement = text;
        }
        return;
      }
      if (tagStart > start3) {
        appendText(tagStart);
      }
      switch (source.charAt(tagStart + 1)) {
        case "/":
          var end2 = source.indexOf(">", tagStart + 3);
          var tagName = source.substring(tagStart + 2, end2).replace(/[ \t\n\r]+$/g, "");
          var config2 = parseStack.pop();
          if (end2 < 0) {
            tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
            errorHandler.error("end tag name: " + tagName + " is not complete:" + config2.tagName);
            end2 = tagStart + 1 + tagName.length;
          } else if (tagName.match(/\s</)) {
            tagName = tagName.replace(/[\s<].*/, "");
            errorHandler.error("end tag name: " + tagName + " maybe not complete");
            end2 = tagStart + 1 + tagName.length;
          }
          var localNSMap = config2.localNSMap;
          var endMatch = config2.tagName == tagName;
          var endIgnoreCaseMach = endMatch || config2.tagName && config2.tagName.toLowerCase() == tagName.toLowerCase();
          if (endIgnoreCaseMach) {
            domBuilder.endElement(config2.uri, config2.localName, tagName);
            if (localNSMap) {
              for (var prefix2 in localNSMap) {
                if (Object.prototype.hasOwnProperty.call(localNSMap, prefix2)) {
                  domBuilder.endPrefixMapping(prefix2);
                }
              }
            }
            if (!endMatch) {
              errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config2.tagName);
            }
          } else {
            parseStack.push(config2);
          }
          end2++;
          break;
        case "?":
          locator && position3(tagStart);
          end2 = parseInstruction(source, tagStart, domBuilder);
          break;
        case "!":
          locator && position3(tagStart);
          end2 = parseDCC(source, tagStart, domBuilder, errorHandler);
          break;
        default:
          locator && position3(tagStart);
          var el2 = new ElementAttributes();
          var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
          var end2 = parseElementStartPart(source, tagStart, el2, currentNSMap, entityReplacer, errorHandler);
          var len2 = el2.length;
          if (!el2.closed && fixSelfClosed(source, end2, el2.tagName, closeMap)) {
            el2.closed = true;
            if (!entityMap.nbsp) {
              errorHandler.warning("unclosed xml attribute");
            }
          }
          if (locator && len2) {
            var locator2 = copyLocator(locator, {});
            for (var i = 0; i < len2; i++) {
              var a2 = el2[i];
              position3(a2.offset);
              a2.locator = copyLocator(locator, {});
            }
            domBuilder.locator = locator2;
            if (appendElement$1(el2, domBuilder, currentNSMap)) {
              parseStack.push(el2);
            }
            domBuilder.locator = locator;
          } else {
            if (appendElement$1(el2, domBuilder, currentNSMap)) {
              parseStack.push(el2);
            }
          }
          if (NAMESPACE$1.isHTML(el2.uri) && !el2.closed) {
            end2 = parseHtmlSpecialContent(source, end2, el2.tagName, entityReplacer, domBuilder);
          } else {
            end2++;
          }
      }
    } catch (e2) {
      if (e2 instanceof ParseError$1) {
        throw e2;
      }
      errorHandler.error("element parse error: " + e2);
      end2 = -1;
    }
    if (end2 > start3) {
      start3 = end2;
    } else {
      appendText(Math.max(tagStart, start3) + 1);
    }
  }
}
function copyLocator(f2, t3) {
  t3.lineNumber = f2.lineNumber;
  t3.columnNumber = f2.columnNumber;
  return t3;
}
function parseElementStartPart(source, start3, el2, currentNSMap, entityReplacer, errorHandler) {
  function addAttribute(qname, value2, startIndex) {
    if (el2.attributeNames.hasOwnProperty(qname)) {
      errorHandler.fatalError("Attribute " + qname + " redefined");
    }
    el2.addValue(qname, value2, startIndex);
  }
  var attrName;
  var value;
  var p2 = ++start3;
  var s = S_TAG;
  while (true) {
    var c2 = source.charAt(p2);
    switch (c2) {
      case "=":
        if (s === S_ATTR) {
          attrName = source.slice(start3, p2);
          s = S_EQ;
        } else if (s === S_ATTR_SPACE) {
          s = S_EQ;
        } else {
          throw new Error("attribute equal must after attrName");
        }
        break;
      case "'":
      case '"':
        if (s === S_EQ || s === S_ATTR) {
          if (s === S_ATTR) {
            errorHandler.warning('attribute value must after "="');
            attrName = source.slice(start3, p2);
          }
          start3 = p2 + 1;
          p2 = source.indexOf(c2, start3);
          if (p2 > 0) {
            value = source.slice(start3, p2).replace(/&#?\w+;/g, entityReplacer);
            addAttribute(attrName, value, start3 - 1);
            s = S_ATTR_END;
          } else {
            throw new Error("attribute value no end '" + c2 + "' match");
          }
        } else if (s == S_ATTR_NOQUOT_VALUE) {
          value = source.slice(start3, p2).replace(/&#?\w+;/g, entityReplacer);
          addAttribute(attrName, value, start3);
          errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c2 + ")!!");
          start3 = p2 + 1;
          s = S_ATTR_END;
        } else {
          throw new Error('attribute value must after "="');
        }
        break;
      case "/":
        switch (s) {
          case S_TAG:
            el2.setTagName(source.slice(start3, p2));
          case S_ATTR_END:
          case S_TAG_SPACE:
          case S_TAG_CLOSE:
            s = S_TAG_CLOSE;
            el2.closed = true;
          case S_ATTR_NOQUOT_VALUE:
          case S_ATTR:
          case S_ATTR_SPACE:
            break;
          default:
            throw new Error("attribute invalid close char('/')");
        }
        break;
      case "":
        errorHandler.error("unexpected end of input");
        if (s == S_TAG) {
          el2.setTagName(source.slice(start3, p2));
        }
        return p2;
      case ">":
        switch (s) {
          case S_TAG:
            el2.setTagName(source.slice(start3, p2));
          case S_ATTR_END:
          case S_TAG_SPACE:
          case S_TAG_CLOSE:
            break;
          case S_ATTR_NOQUOT_VALUE:
          case S_ATTR:
            value = source.slice(start3, p2);
            if (value.slice(-1) === "/") {
              el2.closed = true;
              value = value.slice(0, -1);
            }
          case S_ATTR_SPACE:
            if (s === S_ATTR_SPACE) {
              value = attrName;
            }
            if (s == S_ATTR_NOQUOT_VALUE) {
              errorHandler.warning('attribute "' + value + '" missed quot(")!');
              addAttribute(attrName, value.replace(/&#?\w+;/g, entityReplacer), start3);
            } else {
              if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
              }
              addAttribute(value, value, start3);
            }
            break;
          case S_EQ:
            throw new Error("attribute value missed!!");
        }
        return p2;
      case "":
        c2 = " ";
      default:
        if (c2 <= " ") {
          switch (s) {
            case S_TAG:
              el2.setTagName(source.slice(start3, p2));
              s = S_TAG_SPACE;
              break;
            case S_ATTR:
              attrName = source.slice(start3, p2);
              s = S_ATTR_SPACE;
              break;
            case S_ATTR_NOQUOT_VALUE:
              var value = source.slice(start3, p2).replace(/&#?\w+;/g, entityReplacer);
              errorHandler.warning('attribute "' + value + '" missed quot(")!!');
              addAttribute(attrName, value, start3);
            case S_ATTR_END:
              s = S_TAG_SPACE;
              break;
          }
        } else {
          switch (s) {
            case S_ATTR_SPACE:
              el2.tagName;
              if (!NAMESPACE$1.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
              }
              addAttribute(attrName, attrName, start3);
              start3 = p2;
              s = S_ATTR;
              break;
            case S_ATTR_END:
              errorHandler.warning('attribute space is required"' + attrName + '"!!');
            case S_TAG_SPACE:
              s = S_ATTR;
              start3 = p2;
              break;
            case S_EQ:
              s = S_ATTR_NOQUOT_VALUE;
              start3 = p2;
              break;
            case S_TAG_CLOSE:
              throw new Error("elements closed character '/' and '>' must be connected to");
          }
        }
    }
    p2++;
  }
}
function appendElement$1(el2, domBuilder, currentNSMap) {
  var tagName = el2.tagName;
  var localNSMap = null;
  var i = el2.length;
  while (i--) {
    var a2 = el2[i];
    var qName = a2.qName;
    var value = a2.value;
    var nsp = qName.indexOf(":");
    if (nsp > 0) {
      var prefix2 = a2.prefix = qName.slice(0, nsp);
      var localName = qName.slice(nsp + 1);
      var nsPrefix = prefix2 === "xmlns" && localName;
    } else {
      localName = qName;
      prefix2 = null;
      nsPrefix = qName === "xmlns" && "";
    }
    a2.localName = localName;
    if (nsPrefix !== false) {
      if (localNSMap == null) {
        localNSMap = {};
        _copy(currentNSMap, currentNSMap = {});
      }
      currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
      a2.uri = NAMESPACE$1.XMLNS;
      domBuilder.startPrefixMapping(nsPrefix, value);
    }
  }
  var i = el2.length;
  while (i--) {
    a2 = el2[i];
    var prefix2 = a2.prefix;
    if (prefix2) {
      if (prefix2 === "xml") {
        a2.uri = NAMESPACE$1.XML;
      }
      if (prefix2 !== "xmlns") {
        a2.uri = currentNSMap[prefix2 || ""];
      }
    }
  }
  var nsp = tagName.indexOf(":");
  if (nsp > 0) {
    prefix2 = el2.prefix = tagName.slice(0, nsp);
    localName = el2.localName = tagName.slice(nsp + 1);
  } else {
    prefix2 = null;
    localName = el2.localName = tagName;
  }
  var ns = el2.uri = currentNSMap[prefix2 || ""];
  domBuilder.startElement(ns, localName, tagName, el2);
  if (el2.closed) {
    domBuilder.endElement(ns, localName, tagName);
    if (localNSMap) {
      for (prefix2 in localNSMap) {
        if (Object.prototype.hasOwnProperty.call(localNSMap, prefix2)) {
          domBuilder.endPrefixMapping(prefix2);
        }
      }
    }
  } else {
    el2.currentNSMap = currentNSMap;
    el2.localNSMap = localNSMap;
    return true;
  }
}
function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
  if (/^(?:script|textarea)$/i.test(tagName)) {
    var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
    var text = source.substring(elStartEnd + 1, elEndStart);
    if (/[&<]/.test(text)) {
      if (/^script$/i.test(tagName)) {
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
      text = text.replace(/&#?\w+;/g, entityReplacer);
      domBuilder.characters(text, 0, text.length);
      return elEndStart;
    }
  }
  return elStartEnd + 1;
}
function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
  var pos = closeMap[tagName];
  if (pos == null) {
    pos = source.lastIndexOf("</" + tagName + ">");
    if (pos < elStartEnd) {
      pos = source.lastIndexOf("</" + tagName);
    }
    closeMap[tagName] = pos;
  }
  return pos < elStartEnd;
}
function _copy(source, target) {
  for (var n2 in source) {
    if (Object.prototype.hasOwnProperty.call(source, n2)) {
      target[n2] = source[n2];
    }
  }
}
function parseDCC(source, start3, domBuilder, errorHandler) {
  var next2 = source.charAt(start3 + 2);
  switch (next2) {
    case "-":
      if (source.charAt(start3 + 3) === "-") {
        var end2 = source.indexOf("-->", start3 + 4);
        if (end2 > start3) {
          domBuilder.comment(source, start3 + 4, end2 - start3 - 4);
          return end2 + 3;
        } else {
          errorHandler.error("Unclosed comment");
          return -1;
        }
      } else {
        return -1;
      }
    default:
      if (source.substr(start3 + 3, 6) == "CDATA[") {
        var end2 = source.indexOf("]]>", start3 + 9);
        domBuilder.startCDATA();
        domBuilder.characters(source, start3 + 9, end2 - start3 - 9);
        domBuilder.endCDATA();
        return end2 + 3;
      }
      var matchs = split(source, start3);
      var len2 = matchs.length;
      if (len2 > 1 && /!doctype/i.test(matchs[0][0])) {
        var name = matchs[1][0];
        var pubid = false;
        var sysid = false;
        if (len2 > 3) {
          if (/^public$/i.test(matchs[2][0])) {
            pubid = matchs[3][0];
            sysid = len2 > 4 && matchs[4][0];
          } else if (/^system$/i.test(matchs[2][0])) {
            sysid = matchs[3][0];
          }
        }
        var lastMatch = matchs[len2 - 1];
        domBuilder.startDTD(name, pubid, sysid);
        domBuilder.endDTD();
        return lastMatch.index + lastMatch[0].length;
      }
  }
  return -1;
}
function parseInstruction(source, start3, domBuilder) {
  var end2 = source.indexOf("?>", start3);
  if (end2) {
    var match2 = source.substring(start3, end2).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
    if (match2) {
      match2[0].length;
      domBuilder.processingInstruction(match2[1], match2[2]);
      return end2 + 2;
    } else {
      return -1;
    }
  }
  return -1;
}
function ElementAttributes() {
  this.attributeNames = {};
}
ElementAttributes.prototype = {
  setTagName: function(tagName) {
    if (!tagNamePattern.test(tagName)) {
      throw new Error("invalid tagName:" + tagName);
    }
    this.tagName = tagName;
  },
  addValue: function(qName, value, offset3) {
    if (!tagNamePattern.test(qName)) {
      throw new Error("invalid attribute:" + qName);
    }
    this.attributeNames[qName] = this.length;
    this[this.length++] = { qName, value, offset: offset3 };
  },
  length: 0,
  getLocalName: function(i) {
    return this[i].localName;
  },
  getLocator: function(i) {
    return this[i].locator;
  },
  getQName: function(i) {
    return this[i].qName;
  },
  getURI: function(i) {
    return this[i].uri;
  },
  getValue: function(i) {
    return this[i].value;
  }
  //	,getIndex:function(uri, localName)){
  //		if(localName){
  //			
  //		}else{
  //			var qName = uri
  //		}
  //	},
  //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  //	getType:function(uri,localName){}
  //	getType:function(i){},
};
function split(source, start3) {
  var match2;
  var buf = [];
  var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  reg.lastIndex = start3;
  reg.exec(source);
  while (match2 = reg.exec(source)) {
    buf.push(match2);
    if (match2[1])
      return buf;
  }
}
sax$1.XMLReader = XMLReader$1;
sax$1.ParseError = ParseError$1;
var conventions = conventions$2;
var dom = dom$1;
var entities = entities$1;
var sax = sax$1;
var DOMImplementation = dom.DOMImplementation;
var NAMESPACE = conventions.NAMESPACE;
var ParseError = sax.ParseError;
var XMLReader = sax.XMLReader;
function DOMParser$1(options) {
  this.options = options || { locator: {} };
}
DOMParser$1.prototype.parseFromString = function(source, mimeType) {
  var options = this.options;
  var sax2 = new XMLReader();
  var domBuilder = options.domBuilder || new DOMHandler();
  var errorHandler = options.errorHandler;
  var locator = options.locator;
  var defaultNSMap = options.xmlns || {};
  var isHTML = /\/x?html?$/.test(mimeType);
  var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
  if (locator) {
    domBuilder.setDocumentLocator(locator);
  }
  sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
  sax2.domBuilder = options.domBuilder || domBuilder;
  if (isHTML) {
    defaultNSMap[""] = NAMESPACE.HTML;
  }
  defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
  if (source && typeof source === "string") {
    sax2.parse(source, defaultNSMap, entityMap);
  } else {
    sax2.errorHandler.error("invalid doc source");
  }
  return domBuilder.doc;
};
function buildErrorHandler(errorImpl, domBuilder, locator) {
  if (!errorImpl) {
    if (domBuilder instanceof DOMHandler) {
      return domBuilder;
    }
    errorImpl = domBuilder;
  }
  var errorHandler = {};
  var isCallback = errorImpl instanceof Function;
  locator = locator || {};
  function build(key) {
    var fn2 = errorImpl[key];
    if (!fn2 && isCallback) {
      fn2 = errorImpl.length == 2 ? function(msg) {
        errorImpl(key, msg);
      } : errorImpl;
    }
    errorHandler[key] = fn2 && function(msg) {
      fn2("[xmldom " + key + "]	" + msg + _locator(locator));
    } || function() {
    };
  }
  build("warning");
  build("error");
  build("fatalError");
  return errorHandler;
}
function DOMHandler() {
  this.cdata = false;
}
function position$1(locator, node2) {
  node2.lineNumber = locator.lineNumber;
  node2.columnNumber = locator.columnNumber;
}
DOMHandler.prototype = {
  startDocument: function() {
    this.doc = new DOMImplementation().createDocument(null, null, null);
    if (this.locator) {
      this.doc.documentURI = this.locator.systemId;
    }
  },
  startElement: function(namespaceURI, localName, qName, attrs) {
    var doc = this.doc;
    var el2 = doc.createElementNS(namespaceURI, qName || localName);
    var len2 = attrs.length;
    appendElement(this, el2);
    this.currentElement = el2;
    this.locator && position$1(this.locator, el2);
    for (var i = 0; i < len2; i++) {
      var namespaceURI = attrs.getURI(i);
      var value = attrs.getValue(i);
      var qName = attrs.getQName(i);
      var attr = doc.createAttributeNS(namespaceURI, qName);
      this.locator && position$1(attrs.getLocator(i), attr);
      attr.value = attr.nodeValue = value;
      el2.setAttributeNode(attr);
    }
  },
  endElement: function(namespaceURI, localName, qName) {
    var current = this.currentElement;
    current.tagName;
    this.currentElement = current.parentNode;
  },
  startPrefixMapping: function(prefix2, uri) {
  },
  endPrefixMapping: function(prefix2) {
  },
  processingInstruction: function(target, data) {
    var ins = this.doc.createProcessingInstruction(target, data);
    this.locator && position$1(this.locator, ins);
    appendElement(this, ins);
  },
  ignorableWhitespace: function(ch2, start3, length2) {
  },
  characters: function(chars, start3, length2) {
    chars = _toString.apply(this, arguments);
    if (chars) {
      if (this.cdata) {
        var charNode = this.doc.createCDATASection(chars);
      } else {
        var charNode = this.doc.createTextNode(chars);
      }
      if (this.currentElement) {
        this.currentElement.appendChild(charNode);
      } else if (/^\s*$/.test(chars)) {
        this.doc.appendChild(charNode);
      }
      this.locator && position$1(this.locator, charNode);
    }
  },
  skippedEntity: function(name) {
  },
  endDocument: function() {
    this.doc.normalize();
  },
  setDocumentLocator: function(locator) {
    if (this.locator = locator) {
      locator.lineNumber = 0;
    }
  },
  //LexicalHandler
  comment: function(chars, start3, length2) {
    chars = _toString.apply(this, arguments);
    var comm = this.doc.createComment(chars);
    this.locator && position$1(this.locator, comm);
    appendElement(this, comm);
  },
  startCDATA: function() {
    this.cdata = true;
  },
  endCDATA: function() {
    this.cdata = false;
  },
  startDTD: function(name, publicId, systemId) {
    var impl = this.doc.implementation;
    if (impl && impl.createDocumentType) {
      var dt = impl.createDocumentType(name, publicId, systemId);
      this.locator && position$1(this.locator, dt);
      appendElement(this, dt);
      this.doc.doctype = dt;
    }
  },
  /**
   * @see org.xml.sax.ErrorHandler
   * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
   */
  warning: function(error) {
    console.warn("[xmldom warning]	" + error, _locator(this.locator));
  },
  error: function(error) {
    console.error("[xmldom error]	" + error, _locator(this.locator));
  },
  fatalError: function(error) {
    throw new ParseError(error, this.locator);
  }
};
function _locator(l2) {
  if (l2) {
    return "\n@" + (l2.systemId || "") + "#[line:" + l2.lineNumber + ",col:" + l2.columnNumber + "]";
  }
}
function _toString(chars, start3, length2) {
  if (typeof chars == "string") {
    return chars.substr(start3, length2);
  } else {
    if (chars.length >= start3 + length2 || start3) {
      return new java.lang.String(chars, start3, length2) + "";
    }
    return chars;
  }
}
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
  DOMHandler.prototype[key] = function() {
    return null;
  };
});
function appendElement(hander, node2) {
  if (!hander.currentElement) {
    hander.doc.appendChild(node2);
  } else {
    hander.currentElement.appendChild(node2);
  }
}
domParser.__DOMHandler = DOMHandler;
domParser.DOMParser = DOMParser$1;
domParser.DOMImplementation = dom.DOMImplementation;
domParser.XMLSerializer = dom.XMLSerializer;
var DOMParser = domParser.DOMParser;
/*! @name mpd-parser @version 0.21.1 @license Apache-2.0 */
var isObject$2 = function isObject(obj) {
  return !!obj && typeof obj === "object";
};
var merge$1 = function merge() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  return objects.reduce(function(result, source) {
    if (typeof source !== "object") {
      return result;
    }
    Object.keys(source).forEach(function(key) {
      if (Array.isArray(result[key]) && Array.isArray(source[key])) {
        result[key] = result[key].concat(source[key]);
      } else if (isObject$2(result[key]) && isObject$2(source[key])) {
        result[key] = merge(result[key], source[key]);
      } else {
        result[key] = source[key];
      }
    });
    return result;
  }, {});
};
var values$1 = function values(o) {
  return Object.keys(o).map(function(k2) {
    return o[k2];
  });
};
var range = function range2(start3, end2) {
  var result = [];
  for (var i = start3; i < end2; i++) {
    result.push(i);
  }
  return result;
};
var flatten$2 = function flatten(lists) {
  return lists.reduce(function(x, y2) {
    return x.concat(y2);
  }, []);
};
var from = function from2(list) {
  if (!list.length) {
    return [];
  }
  var result = [];
  for (var i = 0; i < list.length; i++) {
    result.push(list[i]);
  }
  return result;
};
var findIndexes = function findIndexes2(l2, key) {
  return l2.reduce(function(a2, e2, i) {
    if (e2[key]) {
      a2.push(i);
    }
    return a2;
  }, []);
};
var findIndex$1 = function findIndex(list, matchingFunction) {
  for (var i = 0; i < list.length; i++) {
    if (matchingFunction(list[i])) {
      return i;
    }
  }
  return -1;
};
var union = function union2(lists, keyFunction) {
  return values$1(lists.reduce(function(acc, list) {
    list.forEach(function(el2) {
      acc[keyFunction(el2)] = el2;
    });
    return acc;
  }, {}));
};
var errors = {
  INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
  DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
  DASH_INVALID_XML: "DASH_INVALID_XML",
  NO_BASE_URL: "NO_BASE_URL",
  MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
  SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
  UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
};
var urlTypeToSegment = function urlTypeToSegment2(_ref) {
  var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? "" : _ref$baseUrl, _ref$source = _ref.source, source = _ref$source === void 0 ? "" : _ref$source, _ref$range = _ref.range, range3 = _ref$range === void 0 ? "" : _ref$range, _ref$indexRange = _ref.indexRange, indexRange = _ref$indexRange === void 0 ? "" : _ref$indexRange;
  var segment = {
    uri: source,
    resolvedUri: resolveUrl$1(baseUrl || "", source)
  };
  if (range3 || indexRange) {
    var rangeStr = range3 ? range3 : indexRange;
    var ranges = rangeStr.split("-");
    var startRange = window_1.BigInt ? window_1.BigInt(ranges[0]) : parseInt(ranges[0], 10);
    var endRange = window_1.BigInt ? window_1.BigInt(ranges[1]) : parseInt(ranges[1], 10);
    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === "bigint") {
      startRange = Number(startRange);
    }
    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === "bigint") {
      endRange = Number(endRange);
    }
    var length2;
    if (typeof endRange === "bigint" || typeof startRange === "bigint") {
      length2 = window_1.BigInt(endRange) - window_1.BigInt(startRange) + window_1.BigInt(1);
    } else {
      length2 = endRange - startRange + 1;
    }
    if (typeof length2 === "bigint" && length2 < Number.MAX_SAFE_INTEGER) {
      length2 = Number(length2);
    }
    segment.byterange = {
      length: length2,
      offset: startRange
    };
  }
  return segment;
};
var byteRangeToString = function byteRangeToString2(byterange) {
  var endRange;
  if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
    endRange = window_1.BigInt(byterange.offset) + window_1.BigInt(byterange.length) - window_1.BigInt(1);
  } else {
    endRange = byterange.offset + byterange.length - 1;
  }
  return byterange.offset + "-" + endRange;
};
var parseEndNumber = function parseEndNumber2(endNumber) {
  if (endNumber && typeof endNumber !== "number") {
    endNumber = parseInt(endNumber, 10);
  }
  if (isNaN(endNumber)) {
    return null;
  }
  return endNumber;
};
var segmentRange = {
  /**
   * Returns the entire range of available segments for a static MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  static: function _static(attributes) {
    var duration5 = attributes.duration, _attributes$timescale = attributes.timescale, timescale2 = _attributes$timescale === void 0 ? 1 : _attributes$timescale, sourceDuration = attributes.sourceDuration, periodDuration = attributes.periodDuration;
    var endNumber = parseEndNumber(attributes.endNumber);
    var segmentDuration = duration5 / timescale2;
    if (typeof endNumber === "number") {
      return {
        start: 0,
        end: endNumber
      };
    }
    if (typeof periodDuration === "number") {
      return {
        start: 0,
        end: periodDuration / segmentDuration
      };
    }
    return {
      start: 0,
      end: sourceDuration / segmentDuration
    };
  },
  /**
   * Returns the current live window range of available segments for a dynamic MPD
   *
   * @param {Object} attributes
   *        Inheritied MPD attributes
   * @return {{ start: number, end: number }}
   *         The start and end numbers for available segments
   */
  dynamic: function dynamic(attributes) {
    var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime2 = attributes.availabilityStartTime, _attributes$timescale2 = attributes.timescale, timescale2 = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, duration5 = attributes.duration, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp, _attributes$timeShift = attributes.timeShiftBufferDepth, timeShiftBufferDepth2 = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;
    var endNumber = parseEndNumber(attributes.endNumber);
    var now = (NOW + clientOffset) / 1e3;
    var periodStartWC = availabilityStartTime2 + periodStart;
    var periodEndWC = now + minimumUpdatePeriod2;
    var periodDuration = periodEndWC - periodStartWC;
    var segmentCount = Math.ceil(periodDuration * timescale2 / duration5);
    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth2) * timescale2 / duration5);
    var availableEnd = Math.floor((now - periodStartWC) * timescale2 / duration5);
    return {
      start: Math.max(0, availableStart),
      end: typeof endNumber === "number" ? endNumber : Math.min(segmentCount, availableEnd)
    };
  }
};
var toSegments = function toSegments2(attributes) {
  return function(number) {
    var duration5 = attributes.duration, _attributes$timescale3 = attributes.timescale, timescale2 = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3, periodStart = attributes.periodStart, _attributes$startNumb = attributes.startNumber, startNumber2 = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;
    return {
      number: startNumber2 + number,
      duration: duration5 / timescale2,
      timeline: periodStart,
      time: number * duration5
    };
  };
};
var parseByDuration = function parseByDuration2(attributes) {
  var type2 = attributes.type, duration5 = attributes.duration, _attributes$timescale4 = attributes.timescale, timescale2 = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4, periodDuration = attributes.periodDuration, sourceDuration = attributes.sourceDuration;
  var _segmentRange$type = segmentRange[type2](attributes), start3 = _segmentRange$type.start, end2 = _segmentRange$type.end;
  var segments = range(start3, end2).map(toSegments(attributes));
  if (type2 === "static") {
    var index2 = segments.length - 1;
    var sectionDuration = typeof periodDuration === "number" ? periodDuration : sourceDuration;
    segments[index2].duration = sectionDuration - duration5 / timescale2 * index2;
  }
  return segments;
};
var segmentsFromBase = function segmentsFromBase2(attributes) {
  var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ, sourceDuration = attributes.sourceDuration, _attributes$indexRang = attributes.indexRange, indexRange = _attributes$indexRang === void 0 ? "" : _attributes$indexRang, periodStart = attributes.periodStart, presentationTime = attributes.presentationTime, _attributes$number = attributes.number, number = _attributes$number === void 0 ? 0 : _attributes$number, duration5 = attributes.duration;
  if (!baseUrl) {
    throw new Error(errors.NO_BASE_URL);
  }
  var initSegment = urlTypeToSegment({
    baseUrl,
    source: initialization.sourceURL,
    range: initialization.range
  });
  var segment = urlTypeToSegment({
    baseUrl,
    source: baseUrl,
    indexRange
  });
  segment.map = initSegment;
  if (duration5) {
    var segmentTimeInfo = parseByDuration(attributes);
    if (segmentTimeInfo.length) {
      segment.duration = segmentTimeInfo[0].duration;
      segment.timeline = segmentTimeInfo[0].timeline;
    }
  } else if (sourceDuration) {
    segment.duration = sourceDuration;
    segment.timeline = periodStart;
  }
  segment.presentationTime = presentationTime || periodStart;
  segment.number = number;
  return [segment];
};
var addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {
  var initSegment = playlist.sidx.map ? playlist.sidx.map : null;
  var sourceDuration = playlist.sidx.duration;
  var timeline = playlist.timeline || 0;
  var sidxByteRange = playlist.sidx.byterange;
  var sidxEnd = sidxByteRange.offset + sidxByteRange.length;
  var timescale2 = sidx.timescale;
  var mediaReferences = sidx.references.filter(function(r3) {
    return r3.referenceType !== 1;
  });
  var segments = [];
  var type2 = playlist.endList ? "static" : "dynamic";
  var periodStart = playlist.sidx.timeline;
  var presentationTime = periodStart;
  var number = playlist.mediaSequence || 0;
  var startIndex;
  if (typeof sidx.firstOffset === "bigint") {
    startIndex = window_1.BigInt(sidxEnd) + sidx.firstOffset;
  } else {
    startIndex = sidxEnd + sidx.firstOffset;
  }
  for (var i = 0; i < mediaReferences.length; i++) {
    var reference2 = sidx.references[i];
    var size = reference2.referencedSize;
    var duration5 = reference2.subsegmentDuration;
    var endIndex = void 0;
    if (typeof startIndex === "bigint") {
      endIndex = startIndex + window_1.BigInt(size) - window_1.BigInt(1);
    } else {
      endIndex = startIndex + size - 1;
    }
    var indexRange = startIndex + "-" + endIndex;
    var attributes = {
      baseUrl,
      timescale: timescale2,
      timeline,
      periodStart,
      presentationTime,
      number,
      duration: duration5,
      sourceDuration,
      indexRange,
      type: type2
    };
    var segment = segmentsFromBase(attributes)[0];
    if (initSegment) {
      segment.map = initSegment;
    }
    segments.push(segment);
    if (typeof startIndex === "bigint") {
      startIndex += window_1.BigInt(size);
    } else {
      startIndex += size;
    }
    presentationTime += duration5 / timescale2;
    number++;
  }
  playlist.segments = segments;
  return playlist;
};
var SUPPORTED_MEDIA_TYPES = ["AUDIO", "SUBTITLES"];
var TIME_FUDGE = 1 / 60;
var getUniqueTimelineStarts = function getUniqueTimelineStarts2(timelineStarts) {
  return union(timelineStarts, function(_ref) {
    var timeline = _ref.timeline;
    return timeline;
  }).sort(function(a2, b2) {
    return a2.timeline > b2.timeline ? 1 : -1;
  });
};
var findPlaylistWithName = function findPlaylistWithName2(playlists, name) {
  for (var i = 0; i < playlists.length; i++) {
    if (playlists[i].attributes.NAME === name) {
      return playlists[i];
    }
  }
  return null;
};
var getMediaGroupPlaylists = function getMediaGroupPlaylists2(manifest) {
  var mediaGroupPlaylists = [];
  forEachMediaGroup$1(manifest, SUPPORTED_MEDIA_TYPES, function(properties2, type2, group, label) {
    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties2.playlists || []);
  });
  return mediaGroupPlaylists;
};
var updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist2(_ref2) {
  var playlist = _ref2.playlist, mediaSequence = _ref2.mediaSequence;
  playlist.mediaSequence = mediaSequence;
  playlist.segments.forEach(function(segment, index2) {
    segment.number = playlist.mediaSequence + index2;
  });
};
var updateSequenceNumbers = function updateSequenceNumbers2(_ref3) {
  var oldPlaylists = _ref3.oldPlaylists, newPlaylists = _ref3.newPlaylists, timelineStarts = _ref3.timelineStarts;
  newPlaylists.forEach(function(playlist) {
    playlist.discontinuitySequence = findIndex$1(timelineStarts, function(_ref4) {
      var timeline = _ref4.timeline;
      return timeline === playlist.timeline;
    });
    var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
    if (!oldPlaylist) {
      return;
    }
    if (playlist.sidx) {
      return;
    }
    var firstNewSegment = playlist.segments[0];
    var oldMatchingSegmentIndex = findIndex$1(oldPlaylist.segments, function(oldSegment) {
      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;
    });
    if (oldMatchingSegmentIndex === -1) {
      updateMediaSequenceForPlaylist({
        playlist,
        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
      });
      playlist.segments[0].discontinuity = true;
      playlist.discontinuityStarts.unshift(0);
      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {
        playlist.discontinuitySequence--;
      }
      return;
    }
    var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
      firstNewSegment.discontinuity = true;
      playlist.discontinuityStarts.unshift(0);
      playlist.discontinuitySequence--;
    }
    updateMediaSequenceForPlaylist({
      playlist,
      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
    });
  });
};
var positionManifestOnTimeline = function positionManifestOnTimeline2(_ref5) {
  var oldManifest = _ref5.oldManifest, newManifest = _ref5.newManifest;
  var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));
  var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest));
  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);
  updateSequenceNumbers({
    oldPlaylists,
    newPlaylists,
    timelineStarts: newManifest.timelineStarts
  });
  return newManifest;
};
var generateSidxKey = function generateSidxKey2(sidx) {
  return sidx && sidx.uri + "-" + byteRangeToString(sidx.byterange);
};
var mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists2(playlists) {
  var mergedPlaylists = values$1(playlists.reduce(function(acc, playlist) {
    var name = playlist.attributes.id + (playlist.attributes.lang || "");
    if (!acc[name]) {
      acc[name] = playlist;
      acc[name].attributes.timelineStarts = [];
    } else {
      if (playlist.segments) {
        var _acc$name$segments;
        if (playlist.segments[0]) {
          playlist.segments[0].discontinuity = true;
        }
        (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);
      }
      if (playlist.attributes.contentProtection) {
        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
      }
    }
    acc[name].attributes.timelineStarts.push({
      // Although they represent the same number, it's important to have both to make it
      // compatible with HLS potentially having a similar attribute.
      start: playlist.attributes.periodStart,
      timeline: playlist.attributes.periodStart
    });
    return acc;
  }, {}));
  return mergedPlaylists.map(function(playlist) {
    playlist.discontinuityStarts = findIndexes(playlist.segments || [], "discontinuity");
    return playlist;
  });
};
var addSidxSegmentsToPlaylist2 = function addSidxSegmentsToPlaylist3(playlist, sidxMapping) {
  var sidxKey = generateSidxKey(playlist.sidx);
  var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
  if (sidxMatch) {
    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
  }
  return playlist;
};
var addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists2(playlists, sidxMapping) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  if (!Object.keys(sidxMapping).length) {
    return playlists;
  }
  for (var i in playlists) {
    playlists[i] = addSidxSegmentsToPlaylist2(playlists[i], sidxMapping);
  }
  return playlists;
};
var formatAudioPlaylist = function formatAudioPlaylist2(_ref, isAudioOnly3) {
  var _attributes;
  var attributes = _ref.attributes, segments = _ref.segments, sidx = _ref.sidx, mediaSequence = _ref.mediaSequence, discontinuitySequence = _ref.discontinuitySequence, discontinuityStarts = _ref.discontinuityStarts;
  var playlist = {
    attributes: (_attributes = {
      NAME: attributes.id,
      BANDWIDTH: attributes.bandwidth,
      CODECS: attributes.codecs
    }, _attributes["PROGRAM-ID"] = 1, _attributes),
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: "",
    targetDuration: attributes.duration,
    discontinuitySequence,
    discontinuityStarts,
    timelineStarts: attributes.timelineStarts,
    mediaSequence,
    segments
  };
  if (attributes.contentProtection) {
    playlist.contentProtection = attributes.contentProtection;
  }
  if (sidx) {
    playlist.sidx = sidx;
  }
  if (isAudioOnly3) {
    playlist.attributes.AUDIO = "audio";
    playlist.attributes.SUBTITLES = "subs";
  }
  return playlist;
};
var formatVttPlaylist = function formatVttPlaylist2(_ref2) {
  var _m3u8Attributes;
  var attributes = _ref2.attributes, segments = _ref2.segments, mediaSequence = _ref2.mediaSequence, discontinuityStarts = _ref2.discontinuityStarts, discontinuitySequence = _ref2.discontinuitySequence;
  if (typeof segments === "undefined") {
    segments = [{
      uri: attributes.baseUrl,
      timeline: attributes.periodStart,
      resolvedUri: attributes.baseUrl || "",
      duration: attributes.sourceDuration,
      number: 0
    }];
    attributes.duration = attributes.sourceDuration;
  }
  var m3u8Attributes = (_m3u8Attributes = {
    NAME: attributes.id,
    BANDWIDTH: attributes.bandwidth
  }, _m3u8Attributes["PROGRAM-ID"] = 1, _m3u8Attributes);
  if (attributes.codecs) {
    m3u8Attributes.CODECS = attributes.codecs;
  }
  return {
    attributes: m3u8Attributes,
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: attributes.baseUrl || "",
    targetDuration: attributes.duration,
    timelineStarts: attributes.timelineStarts,
    discontinuityStarts,
    discontinuitySequence,
    mediaSequence,
    segments
  };
};
var organizeAudioPlaylists = function organizeAudioPlaylists2(playlists, sidxMapping, isAudioOnly3) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  if (isAudioOnly3 === void 0) {
    isAudioOnly3 = false;
  }
  var mainPlaylist;
  var formattedPlaylists = playlists.reduce(function(a2, playlist) {
    var role = playlist.attributes.role && playlist.attributes.role.value || "";
    var language = playlist.attributes.lang || "";
    var label = playlist.attributes.label || "main";
    if (language && !playlist.attributes.label) {
      var roleLabel = role ? " (" + role + ")" : "";
      label = "" + playlist.attributes.lang + roleLabel;
    }
    if (!a2[label]) {
      a2[label] = {
        language,
        autoselect: true,
        default: role === "main",
        playlists: [],
        uri: ""
      };
    }
    var formatted = addSidxSegmentsToPlaylist2(formatAudioPlaylist(playlist, isAudioOnly3), sidxMapping);
    a2[label].playlists.push(formatted);
    if (typeof mainPlaylist === "undefined" && role === "main") {
      mainPlaylist = playlist;
      mainPlaylist.default = true;
    }
    return a2;
  }, {});
  if (!mainPlaylist) {
    var firstLabel = Object.keys(formattedPlaylists)[0];
    formattedPlaylists[firstLabel].default = true;
  }
  return formattedPlaylists;
};
var organizeVttPlaylists = function organizeVttPlaylists2(playlists, sidxMapping) {
  if (sidxMapping === void 0) {
    sidxMapping = {};
  }
  return playlists.reduce(function(a2, playlist) {
    var label = playlist.attributes.lang || "text";
    if (!a2[label]) {
      a2[label] = {
        language: label,
        default: false,
        autoselect: false,
        playlists: [],
        uri: ""
      };
    }
    a2[label].playlists.push(addSidxSegmentsToPlaylist2(formatVttPlaylist(playlist), sidxMapping));
    return a2;
  }, {});
};
var organizeCaptionServices = function organizeCaptionServices2(captionServices) {
  return captionServices.reduce(function(svcObj, svc) {
    if (!svc) {
      return svcObj;
    }
    svc.forEach(function(service) {
      var channel = service.channel, language = service.language;
      svcObj[language] = {
        autoselect: false,
        default: false,
        instreamId: channel,
        language
      };
      if (service.hasOwnProperty("aspectRatio")) {
        svcObj[language].aspectRatio = service.aspectRatio;
      }
      if (service.hasOwnProperty("easyReader")) {
        svcObj[language].easyReader = service.easyReader;
      }
      if (service.hasOwnProperty("3D")) {
        svcObj[language]["3D"] = service["3D"];
      }
    });
    return svcObj;
  }, {});
};
var formatVideoPlaylist = function formatVideoPlaylist2(_ref3) {
  var _attributes2;
  var attributes = _ref3.attributes, segments = _ref3.segments, sidx = _ref3.sidx, discontinuityStarts = _ref3.discontinuityStarts;
  var playlist = {
    attributes: (_attributes2 = {
      NAME: attributes.id,
      AUDIO: "audio",
      SUBTITLES: "subs",
      RESOLUTION: {
        width: attributes.width,
        height: attributes.height
      },
      CODECS: attributes.codecs,
      BANDWIDTH: attributes.bandwidth
    }, _attributes2["PROGRAM-ID"] = 1, _attributes2),
    uri: "",
    endList: attributes.type === "static",
    timeline: attributes.periodStart,
    resolvedUri: "",
    targetDuration: attributes.duration,
    discontinuityStarts,
    timelineStarts: attributes.timelineStarts,
    segments
  };
  if (attributes.contentProtection) {
    playlist.contentProtection = attributes.contentProtection;
  }
  if (sidx) {
    playlist.sidx = sidx;
  }
  return playlist;
};
var videoOnly = function videoOnly2(_ref4) {
  var attributes = _ref4.attributes;
  return attributes.mimeType === "video/mp4" || attributes.mimeType === "video/webm" || attributes.contentType === "video";
};
var audioOnly = function audioOnly2(_ref5) {
  var attributes = _ref5.attributes;
  return attributes.mimeType === "audio/mp4" || attributes.mimeType === "audio/webm" || attributes.contentType === "audio";
};
var vttOnly = function vttOnly2(_ref6) {
  var attributes = _ref6.attributes;
  return attributes.mimeType === "text/vtt" || attributes.contentType === "text";
};
var addMediaSequenceValues = function addMediaSequenceValues2(playlists, timelineStarts) {
  playlists.forEach(function(playlist) {
    playlist.mediaSequence = 0;
    playlist.discontinuitySequence = findIndex$1(timelineStarts, function(_ref7) {
      var timeline = _ref7.timeline;
      return timeline === playlist.timeline;
    });
    if (!playlist.segments) {
      return;
    }
    playlist.segments.forEach(function(segment, index2) {
      segment.number = index2;
    });
  });
};
var flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists2(mediaGroupObject) {
  if (!mediaGroupObject) {
    return [];
  }
  return Object.keys(mediaGroupObject).reduce(function(acc, label) {
    var labelContents = mediaGroupObject[label];
    return acc.concat(labelContents.playlists);
  }, []);
};
var toM3u8 = function toM3u82(_ref8) {
  var _mediaGroups;
  var dashPlaylists = _ref8.dashPlaylists, locations = _ref8.locations, _ref8$sidxMapping = _ref8.sidxMapping, sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping, previousManifest = _ref8.previousManifest;
  if (!dashPlaylists.length) {
    return {};
  }
  var _dashPlaylists$0$attr = dashPlaylists[0].attributes, duration5 = _dashPlaylists$0$attr.sourceDuration, type2 = _dashPlaylists$0$attr.type, suggestedPresentationDelay2 = _dashPlaylists$0$attr.suggestedPresentationDelay, minimumUpdatePeriod2 = _dashPlaylists$0$attr.minimumUpdatePeriod;
  var videoPlaylists2 = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);
  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));
  var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));
  var captions = dashPlaylists.map(function(playlist) {
    return playlist.attributes.captionServices;
  }).filter(Boolean);
  var manifest = {
    allowCache: true,
    discontinuityStarts: [],
    segments: [],
    endList: true,
    mediaGroups: (_mediaGroups = {
      AUDIO: {},
      VIDEO: {}
    }, _mediaGroups["CLOSED-CAPTIONS"] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),
    uri: "",
    duration: duration5,
    playlists: addSidxSegmentsToPlaylists(videoPlaylists2, sidxMapping)
  };
  if (minimumUpdatePeriod2 >= 0) {
    manifest.minimumUpdatePeriod = minimumUpdatePeriod2 * 1e3;
  }
  if (locations) {
    manifest.locations = locations;
  }
  if (type2 === "dynamic") {
    manifest.suggestedPresentationDelay = suggestedPresentationDelay2;
  }
  var isAudioOnly3 = manifest.playlists.length === 0;
  var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly3) : null;
  var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
  var formattedPlaylists = videoPlaylists2.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));
  var playlistTimelineStarts = formattedPlaylists.map(function(_ref9) {
    var timelineStarts = _ref9.timelineStarts;
    return timelineStarts;
  });
  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);
  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
  if (organizedAudioGroup) {
    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
  }
  if (organizedVttGroup) {
    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
  }
  if (captions.length) {
    manifest.mediaGroups["CLOSED-CAPTIONS"].cc = organizeCaptionServices(captions);
  }
  if (previousManifest) {
    return positionManifestOnTimeline({
      oldManifest: previousManifest,
      newManifest: manifest
    });
  }
  return manifest;
};
var getLiveRValue = function getLiveRValue2(attributes, time2, duration5) {
  var NOW = attributes.NOW, clientOffset = attributes.clientOffset, availabilityStartTime2 = attributes.availabilityStartTime, _attributes$timescale = attributes.timescale, timescale2 = _attributes$timescale === void 0 ? 1 : _attributes$timescale, _attributes$periodSta = attributes.periodStart, periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta, _attributes$minimumUp = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;
  var now = (NOW + clientOffset) / 1e3;
  var periodStartWC = availabilityStartTime2 + periodStart;
  var periodEndWC = now + minimumUpdatePeriod2;
  var periodDuration = periodEndWC - periodStartWC;
  return Math.ceil((periodDuration * timescale2 - time2) / duration5);
};
var parseByTimeline = function parseByTimeline2(attributes, segmentTimeline) {
  var type2 = attributes.type, _attributes$minimumUp2 = attributes.minimumUpdatePeriod, minimumUpdatePeriod2 = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2, _attributes$media = attributes.media, media = _attributes$media === void 0 ? "" : _attributes$media, sourceDuration = attributes.sourceDuration, _attributes$timescale2 = attributes.timescale, timescale2 = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2, _attributes$startNumb = attributes.startNumber, startNumber2 = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb, timeline = attributes.periodStart;
  var segments = [];
  var time2 = -1;
  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
    var S2 = segmentTimeline[sIndex];
    var duration5 = S2.d;
    var repeat = S2.r || 0;
    var segmentTime = S2.t || 0;
    if (time2 < 0) {
      time2 = segmentTime;
    }
    if (segmentTime && segmentTime > time2) {
      time2 = segmentTime;
    }
    var count2 = void 0;
    if (repeat < 0) {
      var nextS = sIndex + 1;
      if (nextS === segmentTimeline.length) {
        if (type2 === "dynamic" && minimumUpdatePeriod2 > 0 && media.indexOf("$Number$") > 0) {
          count2 = getLiveRValue(attributes, time2, duration5);
        } else {
          count2 = (sourceDuration * timescale2 - time2) / duration5;
        }
      } else {
        count2 = (segmentTimeline[nextS].t - time2) / duration5;
      }
    } else {
      count2 = repeat + 1;
    }
    var end2 = startNumber2 + segments.length + count2;
    var number = startNumber2 + segments.length;
    while (number < end2) {
      segments.push({
        number,
        duration: duration5 / timescale2,
        time: time2,
        timeline
      });
      time2 += duration5;
      number++;
    }
  }
  return segments;
};
var identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
var identifierReplacement = function identifierReplacement2(values3) {
  return function(match2, identifier2, format, width3) {
    if (match2 === "$$") {
      return "$";
    }
    if (typeof values3[identifier2] === "undefined") {
      return match2;
    }
    var value = "" + values3[identifier2];
    if (identifier2 === "RepresentationID") {
      return value;
    }
    if (!format) {
      width3 = 1;
    } else {
      width3 = parseInt(width3, 10);
    }
    if (value.length >= width3) {
      return value;
    }
    return "" + new Array(width3 - value.length + 1).join("0") + value;
  };
};
var constructTemplateUrl = function constructTemplateUrl2(url, values3) {
  return url.replace(identifierPattern, identifierReplacement(values3));
};
var parseTemplateInfo = function parseTemplateInfo2(attributes, segmentTimeline) {
  if (!attributes.duration && !segmentTimeline) {
    return [{
      number: attributes.startNumber || 1,
      duration: attributes.sourceDuration,
      time: 0,
      timeline: attributes.periodStart
    }];
  }
  if (attributes.duration) {
    return parseByDuration(attributes);
  }
  return parseByTimeline(attributes, segmentTimeline);
};
var segmentsFromTemplate = function segmentsFromTemplate2(attributes, segmentTimeline) {
  var templateValues = {
    RepresentationID: attributes.id,
    Bandwidth: attributes.bandwidth || 0
  };
  var _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {
    sourceURL: "",
    range: ""
  } : _attributes$initializ;
  var mapSegment = urlTypeToSegment({
    baseUrl: attributes.baseUrl,
    source: constructTemplateUrl(initialization.sourceURL, templateValues),
    range: initialization.range
  });
  var segments = parseTemplateInfo(attributes, segmentTimeline);
  return segments.map(function(segment) {
    templateValues.Number = segment.number;
    templateValues.Time = segment.time;
    var uri = constructTemplateUrl(attributes.media || "", templateValues);
    var timescale2 = attributes.timescale || 1;
    var presentationTimeOffset2 = attributes.presentationTimeOffset || 0;
    var presentationTime = (
      // Even if the @t attribute is not specified for the segment, segment.time is
      // calculated in mpd-parser prior to this, so it's assumed to be available.
      attributes.periodStart + (segment.time - presentationTimeOffset2) / timescale2
    );
    var map = {
      uri,
      timeline: segment.timeline,
      duration: segment.duration,
      resolvedUri: resolveUrl$1(attributes.baseUrl || "", uri),
      map: mapSegment,
      number: segment.number,
      presentationTime
    };
    return map;
  });
};
var SegmentURLToSegmentObject = function SegmentURLToSegmentObject2(attributes, segmentUrl) {
  var baseUrl = attributes.baseUrl, _attributes$initializ = attributes.initialization, initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;
  var initSegment = urlTypeToSegment({
    baseUrl,
    source: initialization.sourceURL,
    range: initialization.range
  });
  var segment = urlTypeToSegment({
    baseUrl,
    source: segmentUrl.media,
    range: segmentUrl.mediaRange
  });
  segment.map = initSegment;
  return segment;
};
var segmentsFromList = function segmentsFromList2(attributes, segmentTimeline) {
  var duration5 = attributes.duration, _attributes$segmentUr = attributes.segmentUrls, segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr, periodStart = attributes.periodStart;
  if (!duration5 && !segmentTimeline || duration5 && segmentTimeline) {
    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);
  }
  var segmentUrlMap = segmentUrls.map(function(segmentUrlObject) {
    return SegmentURLToSegmentObject(attributes, segmentUrlObject);
  });
  var segmentTimeInfo;
  if (duration5) {
    segmentTimeInfo = parseByDuration(attributes);
  }
  if (segmentTimeline) {
    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);
  }
  var segments = segmentTimeInfo.map(function(segmentTime, index2) {
    if (segmentUrlMap[index2]) {
      var segment = segmentUrlMap[index2];
      var timescale2 = attributes.timescale || 1;
      var presentationTimeOffset2 = attributes.presentationTimeOffset || 0;
      segment.timeline = segmentTime.timeline;
      segment.duration = segmentTime.duration;
      segment.number = segmentTime.number;
      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset2) / timescale2;
      return segment;
    }
  }).filter(function(segment) {
    return segment;
  });
  return segments;
};
var generateSegments = function generateSegments2(_ref) {
  var attributes = _ref.attributes, segmentInfo = _ref.segmentInfo;
  var segmentAttributes;
  var segmentsFn;
  if (segmentInfo.template) {
    segmentsFn = segmentsFromTemplate;
    segmentAttributes = merge$1(attributes, segmentInfo.template);
  } else if (segmentInfo.base) {
    segmentsFn = segmentsFromBase;
    segmentAttributes = merge$1(attributes, segmentInfo.base);
  } else if (segmentInfo.list) {
    segmentsFn = segmentsFromList;
    segmentAttributes = merge$1(attributes, segmentInfo.list);
  }
  var segmentsInfo = {
    attributes
  };
  if (!segmentsFn) {
    return segmentsInfo;
  }
  var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
  if (segmentAttributes.duration) {
    var _segmentAttributes = segmentAttributes, duration5 = _segmentAttributes.duration, _segmentAttributes$ti = _segmentAttributes.timescale, timescale2 = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;
    segmentAttributes.duration = duration5 / timescale2;
  } else if (segments.length) {
    segmentAttributes.duration = segments.reduce(function(max2, segment) {
      return Math.max(max2, Math.ceil(segment.duration));
    }, 0);
  } else {
    segmentAttributes.duration = 0;
  }
  segmentsInfo.attributes = segmentAttributes;
  segmentsInfo.segments = segments;
  if (segmentInfo.base && segmentAttributes.indexRange) {
    segmentsInfo.sidx = segments[0];
    segmentsInfo.segments = [];
  }
  return segmentsInfo;
};
var toPlaylists = function toPlaylists2(representations) {
  return representations.map(generateSegments);
};
var findChildren = function findChildren2(element, name) {
  return from(element.childNodes).filter(function(_ref) {
    var tagName = _ref.tagName;
    return tagName === name;
  });
};
var getContent = function getContent2(element) {
  return element.textContent.trim();
};
var parseDuration = function parseDuration2(str) {
  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
  var SECONDS_IN_DAY = 24 * 60 * 60;
  var SECONDS_IN_HOUR = 60 * 60;
  var SECONDS_IN_MIN = 60;
  var durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
  var match2 = durationRegex.exec(str);
  if (!match2) {
    return 0;
  }
  var _match$slice = match2.slice(1), year = _match$slice[0], month = _match$slice[1], day = _match$slice[2], hour = _match$slice[3], minute = _match$slice[4], second = _match$slice[5];
  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
};
var parseDate = function parseDate2(str) {
  var dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
  if (dateRegex.test(str)) {
    str += "Z";
  }
  return Date.parse(str);
};
var parsers = {
  /**
   * Specifies the duration of the entire Media Presentation. Format is a duration string
   * as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  mediaPresentationDuration: function mediaPresentationDuration(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the Segment availability start time for all Segments referred to in this
   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability
   * time. Format is a date string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The date as seconds from unix epoch
   */
  availabilityStartTime: function availabilityStartTime(value) {
    return parseDate(value) / 1e3;
  },
  /**
   * Specifies the smallest period between potential changes to the MPD. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  minimumUpdatePeriod: function minimumUpdatePeriod(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the suggested presentation delay. Format is a
   * duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  suggestedPresentationDelay: function suggestedPresentationDelay(value) {
    return parseDuration(value);
  },
  /**
   * specifices the type of mpd. Can be either "static" or "dynamic"
   *
   * @param {string} value
   *        value of attribute as a string
   *
   * @return {string}
   *         The type as a string
   */
  type: function type(value) {
    return value;
  },
  /**
   * Specifies the duration of the smallest time shifting buffer for any Representation
   * in the MPD. Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  timeShiftBufferDepth: function timeShiftBufferDepth(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.
   * Format is a duration string as specified in ISO 8601
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The duration in seconds
   */
  start: function start2(value) {
    return parseDuration(value);
  },
  /**
   * Specifies the width of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed width
   */
  width: function width2(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the height of the visual presentation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed height
   */
  height: function height2(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the bitrate of the representation
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed bandwidth
   */
  bandwidth: function bandwidth(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the number of the first Media Segment in this Representation in the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  startNumber: function startNumber(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the timescale in units per seconds
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed timescale
   */
  timescale: function timescale(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the presentationTimeOffset.
   *
   * @param {string} value
   *        value of the attribute as a string
   *
   * @return {number}
   *         The parsed presentationTimeOffset
   */
  presentationTimeOffset: function presentationTimeOffset(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the constant approximate Segment duration
   * NOTE: The <Period> element also contains an @duration attribute. This duration
   *       specifies the duration of the Period. This attribute is currently not
   *       supported by the rest of the parser, however we still check for it to prevent
   *       errors.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  duration: function duration(value) {
    var parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue)) {
      return parseDuration(value);
    }
    return parsedValue;
  },
  /**
   * Specifies the Segment duration, in units of the value of the @timescale.
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed duration
   */
  d: function d(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the MPD start time, in @timescale units, the first Segment in the series
   * starts relative to the beginning of the Period
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed time
   */
  t: function t2(value) {
    return parseInt(value, 10);
  },
  /**
   * Specifies the repeat count of the number of following contiguous Segments with the
   * same duration expressed by the value of @d
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {number}
   *         The parsed number
   */
  r: function r(value) {
    return parseInt(value, 10);
  },
  /**
   * Default parser for all other attributes. Acts as a no-op and just returns the value
   * as a string
   *
   * @param {string} value
   *        value of attribute as a string
   * @return {string}
   *         Unparsed value
   */
  DEFAULT: function DEFAULT(value) {
    return value;
  }
};
var parseAttributes2 = function parseAttributes3(el2) {
  if (!(el2 && el2.attributes)) {
    return {};
  }
  return from(el2.attributes).reduce(function(a2, e2) {
    var parseFn = parsers[e2.name] || parsers.DEFAULT;
    a2[e2.name] = parseFn(e2.value);
    return a2;
  }, {});
};
var keySystemsMap = {
  "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
  "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
  "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
  "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
};
var buildBaseUrls = function buildBaseUrls2(referenceUrls, baseUrlElements) {
  if (!baseUrlElements.length) {
    return referenceUrls;
  }
  return flatten$2(referenceUrls.map(function(reference2) {
    return baseUrlElements.map(function(baseUrlElement) {
      return resolveUrl$1(reference2, getContent(baseUrlElement));
    });
  }));
};
var getSegmentInformation = function getSegmentInformation2(adaptationSet) {
  var segmentTemplate = findChildren(adaptationSet, "SegmentTemplate")[0];
  var segmentList = findChildren(adaptationSet, "SegmentList")[0];
  var segmentUrls = segmentList && findChildren(segmentList, "SegmentURL").map(function(s) {
    return merge$1({
      tag: "SegmentURL"
    }, parseAttributes2(s));
  });
  var segmentBase = findChildren(adaptationSet, "SegmentBase")[0];
  var segmentTimelineParentNode = segmentList || segmentTemplate;
  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, "SegmentTimeline")[0];
  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, "Initialization")[0];
  var template = segmentTemplate && parseAttributes2(segmentTemplate);
  if (template && segmentInitialization) {
    template.initialization = segmentInitialization && parseAttributes2(segmentInitialization);
  } else if (template && template.initialization) {
    template.initialization = {
      sourceURL: template.initialization
    };
  }
  var segmentInfo = {
    template,
    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, "S").map(function(s) {
      return parseAttributes2(s);
    }),
    list: segmentList && merge$1(parseAttributes2(segmentList), {
      segmentUrls,
      initialization: parseAttributes2(segmentInitialization)
    }),
    base: segmentBase && merge$1(parseAttributes2(segmentBase), {
      initialization: parseAttributes2(segmentInitialization)
    })
  };
  Object.keys(segmentInfo).forEach(function(key) {
    if (!segmentInfo[key]) {
      delete segmentInfo[key];
    }
  });
  return segmentInfo;
};
var inheritBaseUrls = function inheritBaseUrls2(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {
  return function(representation) {
    var repBaseUrlElements = findChildren(representation, "BaseURL");
    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
    var attributes = merge$1(adaptationSetAttributes, parseAttributes2(representation));
    var representationSegmentInfo = getSegmentInformation(representation);
    return repBaseUrls.map(function(baseUrl) {
      return {
        segmentInfo: merge$1(adaptationSetSegmentInfo, representationSegmentInfo),
        attributes: merge$1(attributes, {
          baseUrl
        })
      };
    });
  };
};
var generateKeySystemInformation = function generateKeySystemInformation2(contentProtectionNodes) {
  return contentProtectionNodes.reduce(function(acc, node2) {
    var attributes = parseAttributes2(node2);
    if (attributes.schemeIdUri) {
      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();
    }
    var keySystem = keySystemsMap[attributes.schemeIdUri];
    if (keySystem) {
      acc[keySystem] = {
        attributes
      };
      var psshNode = findChildren(node2, "cenc:pssh")[0];
      if (psshNode) {
        var pssh = getContent(psshNode);
        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);
      }
    }
    return acc;
  }, {});
};
var parseCaptionServiceMetadata = function parseCaptionServiceMetadata2(service) {
  if (service.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
    var values3 = typeof service.value !== "string" ? [] : service.value.split(";");
    return values3.map(function(value) {
      var channel;
      var language;
      language = value;
      if (/^CC\d=/.test(value)) {
        var _value$split = value.split("=");
        channel = _value$split[0];
        language = _value$split[1];
      } else if (/^CC\d$/.test(value)) {
        channel = value;
      }
      return {
        channel,
        language
      };
    });
  } else if (service.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
    var _values = typeof service.value !== "string" ? [] : service.value.split(";");
    return _values.map(function(value) {
      var flags = {
        // service or channel number 1-63
        "channel": void 0,
        // language is a 3ALPHA per ISO 639.2/B
        // field is required
        "language": void 0,
        // BIT 1/0 or ?
        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown
        "aspectRatio": 1,
        // BIT 1/0
        // easy reader flag indicated the text is tailed to the needs of beginning readers
        // default 0, or off
        "easyReader": 0,
        // BIT 1/0
        // If 3d metadata is present (CEA-708.1) then 1
        // default 0
        "3D": 0
      };
      if (/=/.test(value)) {
        var _value$split2 = value.split("="), channel = _value$split2[0], _value$split2$ = _value$split2[1], opts = _value$split2$ === void 0 ? "" : _value$split2$;
        flags.channel = channel;
        flags.language = value;
        opts.split(",").forEach(function(opt) {
          var _opt$split = opt.split(":"), name = _opt$split[0], val = _opt$split[1];
          if (name === "lang") {
            flags.language = val;
          } else if (name === "er") {
            flags.easyReader = Number(val);
          } else if (name === "war") {
            flags.aspectRatio = Number(val);
          } else if (name === "3D") {
            flags["3D"] = Number(val);
          }
        });
      } else {
        flags.language = value;
      }
      if (flags.channel) {
        flags.channel = "SERVICE" + flags.channel;
      }
      return flags;
    });
  }
};
var toRepresentations = function toRepresentations2(periodAttributes, periodBaseUrls, periodSegmentInfo) {
  return function(adaptationSet) {
    var adaptationSetAttributes = parseAttributes2(adaptationSet);
    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, "BaseURL"));
    var role = findChildren(adaptationSet, "Role")[0];
    var roleAttributes = {
      role: parseAttributes2(role)
    };
    var attrs = merge$1(periodAttributes, adaptationSetAttributes, roleAttributes);
    var accessibility = findChildren(adaptationSet, "Accessibility")[0];
    var captionServices = parseCaptionServiceMetadata(parseAttributes2(accessibility));
    if (captionServices) {
      attrs = merge$1(attrs, {
        captionServices
      });
    }
    var label = findChildren(adaptationSet, "Label")[0];
    if (label && label.childNodes.length) {
      var labelVal = label.childNodes[0].nodeValue.trim();
      attrs = merge$1(attrs, {
        label: labelVal
      });
    }
    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, "ContentProtection"));
    if (Object.keys(contentProtection).length) {
      attrs = merge$1(attrs, {
        contentProtection
      });
    }
    var segmentInfo = getSegmentInformation(adaptationSet);
    var representations = findChildren(adaptationSet, "Representation");
    var adaptationSetSegmentInfo = merge$1(periodSegmentInfo, segmentInfo);
    return flatten$2(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
  };
};
var toAdaptationSets = function toAdaptationSets2(mpdAttributes, mpdBaseUrls) {
  return function(period, index2) {
    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, "BaseURL"));
    var periodAttributes = merge$1(mpdAttributes, {
      periodStart: period.attributes.start
    });
    if (typeof period.attributes.duration === "number") {
      periodAttributes.periodDuration = period.attributes.duration;
    }
    var adaptationSets = findChildren(period.node, "AdaptationSet");
    var periodSegmentInfo = getSegmentInformation(period.node);
    return flatten$2(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
  };
};
var getPeriodStart = function getPeriodStart2(_ref) {
  var attributes = _ref.attributes, priorPeriodAttributes = _ref.priorPeriodAttributes, mpdType = _ref.mpdType;
  if (typeof attributes.start === "number") {
    return attributes.start;
  }
  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === "number" && typeof priorPeriodAttributes.duration === "number") {
    return priorPeriodAttributes.start + priorPeriodAttributes.duration;
  }
  if (!priorPeriodAttributes && mpdType === "static") {
    return 0;
  }
  return null;
};
var inheritAttributes = function inheritAttributes2(mpd, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$manifestUri = _options.manifestUri, manifestUri = _options$manifestUri === void 0 ? "" : _options$manifestUri, _options$NOW = _options.NOW, NOW = _options$NOW === void 0 ? Date.now() : _options$NOW, _options$clientOffset = _options.clientOffset, clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;
  var periodNodes = findChildren(mpd, "Period");
  if (!periodNodes.length) {
    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);
  }
  var locations = findChildren(mpd, "Location");
  var mpdAttributes = parseAttributes2(mpd);
  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, "BaseURL"));
  mpdAttributes.type = mpdAttributes.type || "static";
  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
  mpdAttributes.NOW = NOW;
  mpdAttributes.clientOffset = clientOffset;
  if (locations.length) {
    mpdAttributes.locations = locations.map(getContent);
  }
  var periods = [];
  periodNodes.forEach(function(node2, index2) {
    var attributes = parseAttributes2(node2);
    var priorPeriod = periods[index2 - 1];
    attributes.start = getPeriodStart({
      attributes,
      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
      mpdType: mpdAttributes.type
    });
    periods.push({
      node: node2,
      attributes
    });
  });
  return {
    locations: mpdAttributes.locations,
    representationInfo: flatten$2(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))
  };
};
var stringToMpdXml = function stringToMpdXml2(manifestString) {
  if (manifestString === "") {
    throw new Error(errors.DASH_EMPTY_MANIFEST);
  }
  var parser2 = new DOMParser();
  var xml;
  var mpd;
  try {
    xml = parser2.parseFromString(manifestString, "application/xml");
    mpd = xml && xml.documentElement.tagName === "MPD" ? xml.documentElement : null;
  } catch (e2) {
  }
  if (!mpd || mpd && mpd.getElementsByTagName("parsererror").length > 0) {
    throw new Error(errors.DASH_INVALID_XML);
  }
  return mpd;
};
var parseUTCTimingScheme = function parseUTCTimingScheme2(mpd) {
  var UTCTimingNode = findChildren(mpd, "UTCTiming")[0];
  if (!UTCTimingNode) {
    return null;
  }
  var attributes = parseAttributes2(UTCTimingNode);
  switch (attributes.schemeIdUri) {
    case "urn:mpeg:dash:utc:http-head:2014":
    case "urn:mpeg:dash:utc:http-head:2012":
      attributes.method = "HEAD";
      break;
    case "urn:mpeg:dash:utc:http-xsdate:2014":
    case "urn:mpeg:dash:utc:http-iso:2014":
    case "urn:mpeg:dash:utc:http-xsdate:2012":
    case "urn:mpeg:dash:utc:http-iso:2012":
      attributes.method = "GET";
      break;
    case "urn:mpeg:dash:utc:direct:2014":
    case "urn:mpeg:dash:utc:direct:2012":
      attributes.method = "DIRECT";
      attributes.value = Date.parse(attributes.value);
      break;
    case "urn:mpeg:dash:utc:http-ntp:2014":
    case "urn:mpeg:dash:utc:ntp:2014":
    case "urn:mpeg:dash:utc:sntp:2014":
    default:
      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);
  }
  return attributes;
};
var parse$1 = function parse(manifestString, options) {
  if (options === void 0) {
    options = {};
  }
  var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);
  var playlists = toPlaylists(parsedManifestInfo.representationInfo);
  return toM3u8({
    dashPlaylists: playlists,
    locations: parsedManifestInfo.locations,
    sidxMapping: options.sidxMapping,
    previousManifest: options.previousManifest
  });
};
var parseUTCTiming = function parseUTCTiming2(manifestString) {
  return parseUTCTimingScheme(stringToMpdXml(manifestString));
};
var MAX_UINT32 = Math.pow(2, 32);
var getUint64$1 = function(uint8) {
  var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
  var value;
  if (dv.getBigUint64) {
    value = dv.getBigUint64(0);
    if (value < Number.MAX_SAFE_INTEGER) {
      return Number(value);
    }
    return value;
  }
  return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
};
var numbers = {
  getUint64: getUint64$1,
  MAX_UINT32
};
var getUint64 = numbers.getUint64;
var parseSidx = function(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
    version: data[0],
    flags: new Uint8Array(data.subarray(1, 4)),
    references: [],
    referenceId: view.getUint32(4),
    timescale: view.getUint32(8)
  }, i = 12;
  if (result.version === 0) {
    result.earliestPresentationTime = view.getUint32(i);
    result.firstOffset = view.getUint32(i + 4);
    i += 8;
  } else {
    result.earliestPresentationTime = getUint64(data.subarray(i));
    result.firstOffset = getUint64(data.subarray(i + 8));
    i += 16;
  }
  i += 2;
  var referenceCount = view.getUint16(i);
  i += 2;
  for (; referenceCount > 0; i += 12, referenceCount--) {
    result.references.push({
      referenceType: (data[i] & 128) >>> 7,
      referencedSize: view.getUint32(i) & 2147483647,
      subsegmentDuration: view.getUint32(i + 4),
      startsWithSap: !!(data[i + 8] & 128),
      sapType: (data[i + 8] & 112) >>> 4,
      sapDeltaTime: view.getUint32(i + 8) & 268435455
    });
  }
  return result;
};
var parseSidx_1 = parseSidx;
var ID3 = toUint8([73, 68, 51]);
var getId3Size = function getId3Size2(bytes, offset3) {
  if (offset3 === void 0) {
    offset3 = 0;
  }
  bytes = toUint8(bytes);
  var flags = bytes[offset3 + 5];
  var returnSize = bytes[offset3 + 6] << 21 | bytes[offset3 + 7] << 14 | bytes[offset3 + 8] << 7 | bytes[offset3 + 9];
  var footerPresent = (flags & 16) >> 4;
  if (footerPresent) {
    return returnSize + 20;
  }
  return returnSize + 10;
};
var getId3Offset = function getId3Offset2(bytes, offset3) {
  if (offset3 === void 0) {
    offset3 = 0;
  }
  bytes = toUint8(bytes);
  if (bytes.length - offset3 < 10 || !bytesMatch(bytes, ID3, {
    offset: offset3
  })) {
    return offset3;
  }
  offset3 += getId3Size(bytes, offset3);
  return getId3Offset2(bytes, offset3);
};
var normalizePath$1 = function normalizePath(path) {
  if (typeof path === "string") {
    return stringToBytes(path);
  }
  if (typeof path === "number") {
    return path;
  }
  return path;
};
var normalizePaths$1 = function normalizePaths(paths) {
  if (!Array.isArray(paths)) {
    return [normalizePath$1(paths)];
  }
  return paths.map(function(p2) {
    return normalizePath$1(p2);
  });
};
var findBox = function findBox2(bytes, paths, complete) {
  if (complete === void 0) {
    complete = false;
  }
  paths = normalizePaths$1(paths);
  bytes = toUint8(bytes);
  var results = [];
  if (!paths.length) {
    return results;
  }
  var i = 0;
  while (i < bytes.length) {
    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
    var type2 = bytes.subarray(i + 4, i + 8);
    if (size === 0) {
      break;
    }
    var end2 = i + size;
    if (end2 > bytes.length) {
      if (complete) {
        break;
      }
      end2 = bytes.length;
    }
    var data = bytes.subarray(i + 8, end2);
    if (bytesMatch(type2, paths[0])) {
      if (paths.length === 1) {
        results.push(data);
      } else {
        results.push.apply(results, findBox2(data, paths.slice(1), complete));
      }
    }
    i = end2;
  }
  return results;
};
var EBML_TAGS = {
  EBML: toUint8([26, 69, 223, 163]),
  DocType: toUint8([66, 130]),
  Segment: toUint8([24, 83, 128, 103]),
  SegmentInfo: toUint8([21, 73, 169, 102]),
  Tracks: toUint8([22, 84, 174, 107]),
  Track: toUint8([174]),
  TrackNumber: toUint8([215]),
  DefaultDuration: toUint8([35, 227, 131]),
  TrackEntry: toUint8([174]),
  TrackType: toUint8([131]),
  FlagDefault: toUint8([136]),
  CodecID: toUint8([134]),
  CodecPrivate: toUint8([99, 162]),
  VideoTrack: toUint8([224]),
  AudioTrack: toUint8([225]),
  // Not used yet, but will be used for live webm/mkv
  // see https://www.matroska.org/technical/basics.html#block-structure
  // see https://www.matroska.org/technical/basics.html#simpleblock-structure
  Cluster: toUint8([31, 67, 182, 117]),
  Timestamp: toUint8([231]),
  TimestampScale: toUint8([42, 215, 177]),
  BlockGroup: toUint8([160]),
  BlockDuration: toUint8([155]),
  Block: toUint8([161]),
  SimpleBlock: toUint8([163])
};
var LENGTH_TABLE = [128, 64, 32, 16, 8, 4, 2, 1];
var getLength = function getLength2(byte) {
  var len2 = 1;
  for (var i = 0; i < LENGTH_TABLE.length; i++) {
    if (byte & LENGTH_TABLE[i]) {
      break;
    }
    len2++;
  }
  return len2;
};
var getvint = function getvint2(bytes, offset3, removeLength, signed) {
  if (removeLength === void 0) {
    removeLength = true;
  }
  if (signed === void 0) {
    signed = false;
  }
  var length2 = getLength(bytes[offset3]);
  var valueBytes = bytes.subarray(offset3, offset3 + length2);
  if (removeLength) {
    valueBytes = Array.prototype.slice.call(bytes, offset3, offset3 + length2);
    valueBytes[0] ^= LENGTH_TABLE[length2 - 1];
  }
  return {
    length: length2,
    value: bytesToNumber(valueBytes, {
      signed
    }),
    bytes: valueBytes
  };
};
var normalizePath2 = function normalizePath3(path) {
  if (typeof path === "string") {
    return path.match(/.{1,2}/g).map(function(p2) {
      return normalizePath3(p2);
    });
  }
  if (typeof path === "number") {
    return numberToBytes(path);
  }
  return path;
};
var normalizePaths2 = function normalizePaths3(paths) {
  if (!Array.isArray(paths)) {
    return [normalizePath2(paths)];
  }
  return paths.map(function(p2) {
    return normalizePath2(p2);
  });
};
var getInfinityDataSize = function getInfinityDataSize2(id2, bytes, offset3) {
  if (offset3 >= bytes.length) {
    return bytes.length;
  }
  var innerid = getvint(bytes, offset3, false);
  if (bytesMatch(id2.bytes, innerid.bytes)) {
    return offset3;
  }
  var dataHeader = getvint(bytes, offset3 + innerid.length);
  return getInfinityDataSize2(id2, bytes, offset3 + dataHeader.length + dataHeader.value + innerid.length);
};
var findEbml = function findEbml2(bytes, paths) {
  paths = normalizePaths2(paths);
  bytes = toUint8(bytes);
  var results = [];
  if (!paths.length) {
    return results;
  }
  var i = 0;
  while (i < bytes.length) {
    var id2 = getvint(bytes, i, false);
    var dataHeader = getvint(bytes, i + id2.length);
    var dataStart = i + id2.length + dataHeader.length;
    if (dataHeader.value === 127) {
      dataHeader.value = getInfinityDataSize(id2, bytes, dataStart);
      if (dataHeader.value !== bytes.length) {
        dataHeader.value -= dataStart;
      }
    }
    var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
    var data = bytes.subarray(dataStart, dataEnd);
    if (bytesMatch(paths[0], id2.bytes)) {
      if (paths.length === 1) {
        results.push(data);
      } else {
        results = results.concat(findEbml2(data, paths.slice(1)));
      }
    }
    var totalLength = id2.length + dataHeader.length + data.length;
    i += totalLength;
  }
  return results;
};
var NAL_TYPE_ONE = toUint8([0, 0, 0, 1]);
var NAL_TYPE_TWO = toUint8([0, 0, 1]);
var EMULATION_PREVENTION = toUint8([0, 0, 3]);
var discardEmulationPreventionBytes = function discardEmulationPreventionBytes2(bytes) {
  var positions2 = [];
  var i = 1;
  while (i < bytes.length - 2) {
    if (bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {
      positions2.push(i + 2);
      i++;
    }
    i++;
  }
  if (positions2.length === 0) {
    return bytes;
  }
  var newLength = bytes.length - positions2.length;
  var newData = new Uint8Array(newLength);
  var sourceIndex = 0;
  for (i = 0; i < newLength; sourceIndex++, i++) {
    if (sourceIndex === positions2[0]) {
      sourceIndex++;
      positions2.shift();
    }
    newData[i] = bytes[sourceIndex];
  }
  return newData;
};
var findNal = function findNal2(bytes, dataType, types, nalLimit) {
  if (nalLimit === void 0) {
    nalLimit = Infinity;
  }
  bytes = toUint8(bytes);
  types = [].concat(types);
  var i = 0;
  var nalStart;
  var nalsFound = 0;
  while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
    var nalOffset = void 0;
    if (bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) {
      nalOffset = 4;
    } else if (bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) {
      nalOffset = 3;
    }
    if (!nalOffset) {
      i++;
      continue;
    }
    nalsFound++;
    if (nalStart) {
      return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
    }
    var nalType = void 0;
    if (dataType === "h264") {
      nalType = bytes[i + nalOffset] & 31;
    } else if (dataType === "h265") {
      nalType = bytes[i + nalOffset] >> 1 & 63;
    }
    if (types.indexOf(nalType) !== -1) {
      nalStart = i + nalOffset;
    }
    i += nalOffset + (dataType === "h264" ? 1 : 2);
  }
  return bytes.subarray(0, 0);
};
var findH264Nal = function findH264Nal2(bytes, type2, nalLimit) {
  return findNal(bytes, "h264", type2, nalLimit);
};
var findH265Nal = function findH265Nal2(bytes, type2, nalLimit) {
  return findNal(bytes, "h265", type2, nalLimit);
};
var CONSTANTS = {
  // "webm" string literal in hex
  "webm": toUint8([119, 101, 98, 109]),
  // "matroska" string literal in hex
  "matroska": toUint8([109, 97, 116, 114, 111, 115, 107, 97]),
  // "fLaC" string literal in hex
  "flac": toUint8([102, 76, 97, 67]),
  // "OggS" string literal in hex
  "ogg": toUint8([79, 103, 103, 83]),
  // ac-3 sync byte, also works for ec-3 as that is simply a codec
  // of ac-3
  "ac3": toUint8([11, 119]),
  // "RIFF" string literal in hex used for wav and avi
  "riff": toUint8([82, 73, 70, 70]),
  // "AVI" string literal in hex
  "avi": toUint8([65, 86, 73]),
  // "WAVE" string literal in hex
  "wav": toUint8([87, 65, 86, 69]),
  // "ftyp3g" string literal in hex
  "3gp": toUint8([102, 116, 121, 112, 51, 103]),
  // "ftyp" string literal in hex
  "mp4": toUint8([102, 116, 121, 112]),
  // "styp" string literal in hex
  "fmp4": toUint8([115, 116, 121, 112]),
  // "ftypqt" string literal in hex
  "mov": toUint8([102, 116, 121, 112, 113, 116]),
  // moov string literal in hex
  "moov": toUint8([109, 111, 111, 118]),
  // moof string literal in hex
  "moof": toUint8([109, 111, 111, 102])
};
var _isLikely = {
  aac: function aac(bytes) {
    var offset3 = getId3Offset(bytes);
    return bytesMatch(bytes, [255, 16], {
      offset: offset3,
      mask: [255, 22]
    });
  },
  mp3: function mp3(bytes) {
    var offset3 = getId3Offset(bytes);
    return bytesMatch(bytes, [255, 2], {
      offset: offset3,
      mask: [255, 6]
    });
  },
  webm: function webm(bytes) {
    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
    return bytesMatch(docType, CONSTANTS.webm);
  },
  mkv: function mkv(bytes) {
    var docType = findEbml(bytes, [EBML_TAGS.EBML, EBML_TAGS.DocType])[0];
    return bytesMatch(docType, CONSTANTS.matroska);
  },
  mp4: function mp4(bytes) {
    if (_isLikely["3gp"](bytes) || _isLikely.mov(bytes)) {
      return false;
    }
    if (bytesMatch(bytes, CONSTANTS.mp4, {
      offset: 4
    }) || bytesMatch(bytes, CONSTANTS.fmp4, {
      offset: 4
    })) {
      return true;
    }
    if (bytesMatch(bytes, CONSTANTS.moof, {
      offset: 4
    }) || bytesMatch(bytes, CONSTANTS.moov, {
      offset: 4
    })) {
      return true;
    }
  },
  mov: function mov(bytes) {
    return bytesMatch(bytes, CONSTANTS.mov, {
      offset: 4
    });
  },
  "3gp": function gp(bytes) {
    return bytesMatch(bytes, CONSTANTS["3gp"], {
      offset: 4
    });
  },
  ac3: function ac3(bytes) {
    var offset3 = getId3Offset(bytes);
    return bytesMatch(bytes, CONSTANTS.ac3, {
      offset: offset3
    });
  },
  ts: function ts(bytes) {
    if (bytes.length < 189 && bytes.length >= 1) {
      return bytes[0] === 71;
    }
    var i = 0;
    while (i + 188 < bytes.length && i < 188) {
      if (bytes[i] === 71 && bytes[i + 188] === 71) {
        return true;
      }
      i += 1;
    }
    return false;
  },
  flac: function flac(bytes) {
    var offset3 = getId3Offset(bytes);
    return bytesMatch(bytes, CONSTANTS.flac, {
      offset: offset3
    });
  },
  ogg: function ogg(bytes) {
    return bytesMatch(bytes, CONSTANTS.ogg);
  },
  avi: function avi(bytes) {
    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.avi, {
      offset: 8
    });
  },
  wav: function wav(bytes) {
    return bytesMatch(bytes, CONSTANTS.riff) && bytesMatch(bytes, CONSTANTS.wav, {
      offset: 8
    });
  },
  "h264": function h264(bytes) {
    return findH264Nal(bytes, 7, 3).length;
  },
  "h265": function h265(bytes) {
    return findH265Nal(bytes, [32, 33], 3).length;
  }
};
var isLikelyTypes = Object.keys(_isLikely).filter(function(t3) {
  return t3 !== "ts" && t3 !== "h264" && t3 !== "h265";
}).concat(["ts", "h264", "h265"]);
isLikelyTypes.forEach(function(type2) {
  var isLikelyFn = _isLikely[type2];
  _isLikely[type2] = function(bytes) {
    return isLikelyFn(toUint8(bytes));
  };
});
var isLikely = _isLikely;
var detectContainerForBytes = function detectContainerForBytes2(bytes) {
  bytes = toUint8(bytes);
  for (var i = 0; i < isLikelyTypes.length; i++) {
    var type2 = isLikelyTypes[i];
    if (isLikely[type2](bytes)) {
      return type2;
    }
  }
  return "";
};
var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment2(bytes) {
  return findBox(bytes, ["moof"]).length > 0;
};
var ONE_SECOND_IN_TS = 9e4, secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds;
secondsToVideoTs = function(seconds) {
  return seconds * ONE_SECOND_IN_TS;
};
secondsToAudioTs = function(seconds, sampleRate) {
  return seconds * sampleRate;
};
videoTsToSeconds = function(timestamp) {
  return timestamp / ONE_SECOND_IN_TS;
};
audioTsToSeconds = function(timestamp, sampleRate) {
  return timestamp / sampleRate;
};
audioTsToVideoTs = function(timestamp, sampleRate) {
  return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
};
videoTsToAudioTs = function(timestamp, sampleRate) {
  return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
};
metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
  return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
};
var clock = {
  ONE_SECOND_IN_TS,
  secondsToVideoTs,
  secondsToAudioTs,
  videoTsToSeconds,
  audioTsToSeconds,
  audioTsToVideoTs,
  videoTsToAudioTs,
  metadataTsToSeconds
};
/**
 * @license
 * Video.js 7.20.3 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
var version$5 = "7.20.3";
var hooks_ = {};
var hooks = function hooks2(type2, fn2) {
  hooks_[type2] = hooks_[type2] || [];
  if (fn2) {
    hooks_[type2] = hooks_[type2].concat(fn2);
  }
  return hooks_[type2];
};
var hook = function hook2(type2, fn2) {
  hooks(type2, fn2);
};
var removeHook = function removeHook2(type2, fn2) {
  var index2 = hooks(type2).indexOf(fn2);
  if (index2 <= -1) {
    return false;
  }
  hooks_[type2] = hooks_[type2].slice();
  hooks_[type2].splice(index2, 1);
  return true;
};
var hookOnce = function hookOnce2(type2, fn2) {
  hooks(type2, [].concat(fn2).map(function(original) {
    var wrapper = function wrapper2() {
      removeHook(type2, wrapper2);
      return original.apply(void 0, arguments);
    };
    return wrapper;
  }));
};
var FullscreenApi = {
  prefixed: true
};
var apiMap = [
  ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"],
  // WebKit
  ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"],
  // Mozilla
  ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen"],
  // Microsoft
  ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen"]
];
var specApi = apiMap[0];
var browserApi;
for (var i = 0; i < apiMap.length; i++) {
  if (apiMap[i][1] in document_1) {
    browserApi = apiMap[i];
    break;
  }
}
if (browserApi) {
  for (var _i = 0; _i < browserApi.length; _i++) {
    FullscreenApi[specApi[_i]] = browserApi[_i];
  }
  FullscreenApi.prefixed = browserApi[0] !== specApi[0];
}
var history = [];
var LogByTypeFactory = function LogByTypeFactory2(name, log2) {
  return function(type2, level, args) {
    var lvl = log2.levels[level];
    var lvlRegExp = new RegExp("^(" + lvl + ")$");
    if (type2 !== "log") {
      args.unshift(type2.toUpperCase() + ":");
    }
    args.unshift(name + ":");
    if (history) {
      history.push([].concat(args));
      var splice = history.length - 1e3;
      history.splice(0, splice > 0 ? splice : 0);
    }
    if (!window_1.console) {
      return;
    }
    var fn2 = window_1.console[type2];
    if (!fn2 && type2 === "debug") {
      fn2 = window_1.console.info || window_1.console.log;
    }
    if (!fn2 || !lvl || !lvlRegExp.test(type2)) {
      return;
    }
    fn2[Array.isArray(args) ? "apply" : "call"](window_1.console, args);
  };
};
function createLogger$1(name) {
  var level = "info";
  var logByType;
  var log2 = function log3() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    logByType("log", level, args);
  };
  logByType = LogByTypeFactory(name, log2);
  log2.createLogger = function(subname) {
    return createLogger$1(name + ": " + subname);
  };
  log2.levels = {
    all: "debug|log|warn|error",
    off: "",
    debug: "debug|log|warn|error",
    info: "log|warn|error",
    warn: "warn|error",
    error: "error",
    DEFAULT: level
  };
  log2.level = function(lvl) {
    if (typeof lvl === "string") {
      if (!log2.levels.hasOwnProperty(lvl)) {
        throw new Error('"' + lvl + '" in not a valid log level');
      }
      level = lvl;
    }
    return level;
  };
  log2.history = function() {
    return history ? [].concat(history) : [];
  };
  log2.history.filter = function(fname) {
    return (history || []).filter(function(historyItem) {
      return new RegExp(".*" + fname + ".*").test(historyItem[0]);
    });
  };
  log2.history.clear = function() {
    if (history) {
      history.length = 0;
    }
  };
  log2.history.disable = function() {
    if (history !== null) {
      history.length = 0;
      history = null;
    }
  };
  log2.history.enable = function() {
    if (history === null) {
      history = [];
    }
  };
  log2.error = function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return logByType("error", level, args);
  };
  log2.warn = function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return logByType("warn", level, args);
  };
  log2.debug = function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return logByType("debug", level, args);
  };
  return log2;
}
var log$1 = createLogger$1("VIDEOJS");
var createLogger = log$1.createLogger;
var toString2 = Object.prototype.toString;
var keys = function keys2(object) {
  return isObject$1(object) ? Object.keys(object) : [];
};
function each(object, fn2) {
  keys(object).forEach(function(key) {
    return fn2(object[key], key);
  });
}
function reduce(object, fn2, initial) {
  if (initial === void 0) {
    initial = 0;
  }
  return keys(object).reduce(function(accum, key) {
    return fn2(accum, object[key], key);
  }, initial);
}
function assign$1(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }
  if (Object.assign) {
    return _extends$8.apply(void 0, [target].concat(sources));
  }
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    each(source, function(value, key) {
      target[key] = value;
    });
  });
  return target;
}
function isObject$1(value) {
  return !!value && typeof value === "object";
}
function isPlain(value) {
  return isObject$1(value) && toString2.call(value) === "[object Object]" && value.constructor === Object;
}
function computedStyle(el2, prop3) {
  if (!el2 || !prop3) {
    return "";
  }
  if (typeof window_1.getComputedStyle === "function") {
    var computedStyleValue;
    try {
      computedStyleValue = window_1.getComputedStyle(el2);
    } catch (e2) {
      return "";
    }
    return computedStyleValue ? computedStyleValue.getPropertyValue(prop3) || computedStyleValue[prop3] : "";
  }
  return "";
}
var USER_AGENT = window_1.navigator && window_1.navigator.userAgent || "";
var webkitVersionMap = /AppleWebKit\/([\d.]+)/i.exec(USER_AGENT);
var appleWebkitVersion = webkitVersionMap ? parseFloat(webkitVersionMap.pop()) : null;
var IS_IPOD = /iPod/i.test(USER_AGENT);
var IOS_VERSION = function() {
  var match2 = USER_AGENT.match(/OS (\d+)_/i);
  if (match2 && match2[1]) {
    return match2[1];
  }
  return null;
}();
var IS_ANDROID = /Android/i.test(USER_AGENT);
var ANDROID_VERSION = function() {
  var match2 = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
  if (!match2) {
    return null;
  }
  var major = match2[1] && parseFloat(match2[1]);
  var minor = match2[2] && parseFloat(match2[2]);
  if (major && minor) {
    return parseFloat(match2[1] + "." + match2[2]);
  } else if (major) {
    return major;
  }
  return null;
}();
var IS_NATIVE_ANDROID = IS_ANDROID && ANDROID_VERSION < 5 && appleWebkitVersion < 537;
var IS_FIREFOX = /Firefox/i.test(USER_AGENT);
var IS_EDGE = /Edg/i.test(USER_AGENT);
var IS_CHROME = !IS_EDGE && (/Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT));
var CHROME_VERSION = function() {
  var match2 = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
  if (match2 && match2[2]) {
    return parseFloat(match2[2]);
  }
  return null;
}();
var IE_VERSION = function() {
  var result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
  var version2 = result && parseFloat(result[1]);
  if (!version2 && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
    version2 = 11;
  }
  return version2;
}();
var IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
var IS_WINDOWS = /Windows/i.test(USER_AGENT);
var TOUCH_ENABLED = Boolean(isReal() && ("ontouchstart" in window_1 || window_1.navigator.maxTouchPoints || window_1.DocumentTouch && window_1.document instanceof window_1.DocumentTouch));
var IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
var IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
var IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
var IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
var browser$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  IS_IPOD,
  IOS_VERSION,
  IS_ANDROID,
  ANDROID_VERSION,
  IS_NATIVE_ANDROID,
  IS_FIREFOX,
  IS_EDGE,
  IS_CHROME,
  CHROME_VERSION,
  IE_VERSION,
  IS_SAFARI,
  IS_WINDOWS,
  TOUCH_ENABLED,
  IS_IPAD,
  IS_IPHONE,
  IS_IOS,
  IS_ANY_SAFARI
});
function isNonBlankString(str) {
  return typeof str === "string" && Boolean(str.trim());
}
function throwIfWhitespace(str) {
  if (str.indexOf(" ") >= 0) {
    throw new Error("class has illegal whitespace characters");
  }
}
function classRegExp(className) {
  return new RegExp("(^|\\s)" + className + "($|\\s)");
}
function isReal() {
  return document_1 === window_1.document;
}
function isEl(value) {
  return isObject$1(value) && value.nodeType === 1;
}
function isInFrame() {
  try {
    return window_1.parent !== window_1.self;
  } catch (x) {
    return true;
  }
}
function createQuerier(method) {
  return function(selector, context) {
    if (!isNonBlankString(selector)) {
      return document_1[method](null);
    }
    if (isNonBlankString(context)) {
      context = document_1.querySelector(context);
    }
    var ctx = isEl(context) ? context : document_1;
    return ctx[method] && ctx[method](selector);
  };
}
function createEl(tagName, properties2, attributes, content) {
  if (tagName === void 0) {
    tagName = "div";
  }
  if (properties2 === void 0) {
    properties2 = {};
  }
  if (attributes === void 0) {
    attributes = {};
  }
  var el2 = document_1.createElement(tagName);
  Object.getOwnPropertyNames(properties2).forEach(function(propName) {
    var val = properties2[propName];
    if (propName.indexOf("aria-") !== -1 || propName === "role" || propName === "type") {
      log$1.warn("Setting attributes in the second argument of createEl()\nhas been deprecated. Use the third argument instead.\n" + ("createEl(type, properties, attributes). Attempting to set " + propName + " to " + val + "."));
      el2.setAttribute(propName, val);
    } else if (propName === "textContent") {
      textContent(el2, val);
    } else if (el2[propName] !== val || propName === "tabIndex") {
      el2[propName] = val;
    }
  });
  Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
    el2.setAttribute(attrName, attributes[attrName]);
  });
  if (content) {
    appendContent(el2, content);
  }
  return el2;
}
function textContent(el2, text) {
  if (typeof el2.textContent === "undefined") {
    el2.innerText = text;
  } else {
    el2.textContent = text;
  }
  return el2;
}
function prependTo(child, parent) {
  if (parent.firstChild) {
    parent.insertBefore(child, parent.firstChild);
  } else {
    parent.appendChild(child);
  }
}
function hasClass(element, classToCheck) {
  throwIfWhitespace(classToCheck);
  if (element.classList) {
    return element.classList.contains(classToCheck);
  }
  return classRegExp(classToCheck).test(element.className);
}
function addClass(element, classToAdd) {
  if (element.classList) {
    element.classList.add(classToAdd);
  } else if (!hasClass(element, classToAdd)) {
    element.className = (element.className + " " + classToAdd).trim();
  }
  return element;
}
function removeClass(element, classToRemove) {
  if (!element) {
    log$1.warn("removeClass was called with an element that doesn't exist");
    return null;
  }
  if (element.classList) {
    element.classList.remove(classToRemove);
  } else {
    throwIfWhitespace(classToRemove);
    element.className = element.className.split(/\s+/).filter(function(c2) {
      return c2 !== classToRemove;
    }).join(" ");
  }
  return element;
}
function toggleClass(element, classToToggle, predicate) {
  var has = hasClass(element, classToToggle);
  if (typeof predicate === "function") {
    predicate = predicate(element, classToToggle);
  }
  if (typeof predicate !== "boolean") {
    predicate = !has;
  }
  if (predicate === has) {
    return;
  }
  if (predicate) {
    addClass(element, classToToggle);
  } else {
    removeClass(element, classToToggle);
  }
  return element;
}
function setAttributes(el2, attributes) {
  Object.getOwnPropertyNames(attributes).forEach(function(attrName) {
    var attrValue = attributes[attrName];
    if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) {
      el2.removeAttribute(attrName);
    } else {
      el2.setAttribute(attrName, attrValue === true ? "" : attrValue);
    }
  });
}
function getAttributes(tag) {
  var obj = {};
  var knownBooleans = ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,";
  if (tag && tag.attributes && tag.attributes.length > 0) {
    var attrs = tag.attributes;
    for (var i = attrs.length - 1; i >= 0; i--) {
      var attrName = attrs[i].name;
      var attrVal = attrs[i].value;
      if (typeof tag[attrName] === "boolean" || knownBooleans.indexOf("," + attrName + ",") !== -1) {
        attrVal = attrVal !== null ? true : false;
      }
      obj[attrName] = attrVal;
    }
  }
  return obj;
}
function getAttribute(el2, attribute) {
  return el2.getAttribute(attribute);
}
function setAttribute(el2, attribute, value) {
  el2.setAttribute(attribute, value);
}
function removeAttribute(el2, attribute) {
  el2.removeAttribute(attribute);
}
function blockTextSelection() {
  document_1.body.focus();
  document_1.onselectstart = function() {
    return false;
  };
}
function unblockTextSelection() {
  document_1.onselectstart = function() {
    return true;
  };
}
function getBoundingClientRect(el2) {
  if (el2 && el2.getBoundingClientRect && el2.parentNode) {
    var rect = el2.getBoundingClientRect();
    var result = {};
    ["bottom", "height", "left", "right", "top", "width"].forEach(function(k2) {
      if (rect[k2] !== void 0) {
        result[k2] = rect[k2];
      }
    });
    if (!result.height) {
      result.height = parseFloat(computedStyle(el2, "height"));
    }
    if (!result.width) {
      result.width = parseFloat(computedStyle(el2, "width"));
    }
    return result;
  }
}
function findPosition(el2) {
  if (!el2 || el2 && !el2.offsetParent) {
    return {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
  }
  var width3 = el2.offsetWidth;
  var height3 = el2.offsetHeight;
  var left2 = 0;
  var top2 = 0;
  while (el2.offsetParent && el2 !== document_1[FullscreenApi.fullscreenElement]) {
    left2 += el2.offsetLeft;
    top2 += el2.offsetTop;
    el2 = el2.offsetParent;
  }
  return {
    left: left2,
    top: top2,
    width: width3,
    height: height3
  };
}
function getPointerPosition(el2, event) {
  var translated = {
    x: 0,
    y: 0
  };
  if (IS_IOS) {
    var item = el2;
    while (item && item.nodeName.toLowerCase() !== "html") {
      var transform3 = computedStyle(item, "transform");
      if (/^matrix/.test(transform3)) {
        var values3 = transform3.slice(7, -1).split(/,\s/).map(Number);
        translated.x += values3[4];
        translated.y += values3[5];
      } else if (/^matrix3d/.test(transform3)) {
        var _values = transform3.slice(9, -1).split(/,\s/).map(Number);
        translated.x += _values[12];
        translated.y += _values[13];
      }
      item = item.parentNode;
    }
  }
  var position3 = {};
  var boxTarget = findPosition(event.target);
  var box = findPosition(el2);
  var boxW = box.width;
  var boxH = box.height;
  var offsetY = event.offsetY - (box.top - boxTarget.top);
  var offsetX = event.offsetX - (box.left - boxTarget.left);
  if (event.changedTouches) {
    offsetX = event.changedTouches[0].pageX - box.left;
    offsetY = event.changedTouches[0].pageY + box.top;
    if (IS_IOS) {
      offsetX -= translated.x;
      offsetY -= translated.y;
    }
  }
  position3.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
  position3.x = Math.max(0, Math.min(1, offsetX / boxW));
  return position3;
}
function isTextNode(value) {
  return isObject$1(value) && value.nodeType === 3;
}
function emptyEl(el2) {
  while (el2.firstChild) {
    el2.removeChild(el2.firstChild);
  }
  return el2;
}
function normalizeContent(content) {
  if (typeof content === "function") {
    content = content();
  }
  return (Array.isArray(content) ? content : [content]).map(function(value) {
    if (typeof value === "function") {
      value = value();
    }
    if (isEl(value) || isTextNode(value)) {
      return value;
    }
    if (typeof value === "string" && /\S/.test(value)) {
      return document_1.createTextNode(value);
    }
  }).filter(function(value) {
    return value;
  });
}
function appendContent(el2, content) {
  normalizeContent(content).forEach(function(node2) {
    return el2.appendChild(node2);
  });
  return el2;
}
function insertContent(el2, content) {
  return appendContent(emptyEl(el2), content);
}
function isSingleLeftClick(event) {
  if (event.button === void 0 && event.buttons === void 0) {
    return true;
  }
  if (event.button === 0 && event.buttons === void 0) {
    return true;
  }
  if (event.type === "mouseup" && event.button === 0 && event.buttons === 0) {
    return true;
  }
  if (event.button !== 0 || event.buttons !== 1) {
    return false;
  }
  return true;
}
var $ = createQuerier("querySelector");
var $$ = createQuerier("querySelectorAll");
var Dom = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isReal,
  isEl,
  isInFrame,
  createEl,
  textContent,
  prependTo,
  hasClass,
  addClass,
  removeClass,
  toggleClass,
  setAttributes,
  getAttributes,
  getAttribute,
  setAttribute,
  removeAttribute,
  blockTextSelection,
  unblockTextSelection,
  getBoundingClientRect,
  findPosition,
  getPointerPosition,
  isTextNode,
  emptyEl,
  normalizeContent,
  appendContent,
  insertContent,
  isSingleLeftClick,
  $,
  $$
});
var _windowLoaded = false;
var videojs$1;
var autoSetup = function autoSetup2() {
  if (videojs$1.options.autoSetup === false) {
    return;
  }
  var vids = Array.prototype.slice.call(document_1.getElementsByTagName("video"));
  var audios = Array.prototype.slice.call(document_1.getElementsByTagName("audio"));
  var divs = Array.prototype.slice.call(document_1.getElementsByTagName("video-js"));
  var mediaEls = vids.concat(audios, divs);
  if (mediaEls && mediaEls.length > 0) {
    for (var i = 0, e2 = mediaEls.length; i < e2; i++) {
      var mediaEl = mediaEls[i];
      if (mediaEl && mediaEl.getAttribute) {
        if (mediaEl.player === void 0) {
          var options = mediaEl.getAttribute("data-setup");
          if (options !== null) {
            videojs$1(mediaEl);
          }
        }
      } else {
        autoSetupTimeout(1);
        break;
      }
    }
  } else if (!_windowLoaded) {
    autoSetupTimeout(1);
  }
};
function autoSetupTimeout(wait, vjs) {
  if (!isReal()) {
    return;
  }
  if (vjs) {
    videojs$1 = vjs;
  }
  window_1.setTimeout(autoSetup, wait);
}
function setWindowLoaded() {
  _windowLoaded = true;
  window_1.removeEventListener("load", setWindowLoaded);
}
if (isReal()) {
  if (document_1.readyState === "complete") {
    setWindowLoaded();
  } else {
    window_1.addEventListener("load", setWindowLoaded);
  }
}
var createStyleElement = function createStyleElement2(className) {
  var style2 = document_1.createElement("style");
  style2.className = className;
  return style2;
};
var setTextContent = function setTextContent2(el2, content) {
  if (el2.styleSheet) {
    el2.styleSheet.cssText = content;
  } else {
    el2.textContent = content;
  }
};
var _initialGuid = 3;
var _guid = _initialGuid;
function newGUID() {
  return _guid++;
}
var FakeWeakMap;
if (!window_1.WeakMap) {
  FakeWeakMap = /* @__PURE__ */ function() {
    function FakeWeakMap2() {
      this.vdata = "vdata" + Math.floor(window_1.performance && window_1.performance.now() || Date.now());
      this.data = {};
    }
    var _proto = FakeWeakMap2.prototype;
    _proto.set = function set4(key, value) {
      var access = key[this.vdata] || newGUID();
      if (!key[this.vdata]) {
        key[this.vdata] = access;
      }
      this.data[access] = value;
      return this;
    };
    _proto.get = function get8(key) {
      var access = key[this.vdata];
      if (access) {
        return this.data[access];
      }
      log$1("We have no data for this element", key);
      return void 0;
    };
    _proto.has = function has(key) {
      var access = key[this.vdata];
      return access in this.data;
    };
    _proto["delete"] = function _delete(key) {
      var access = key[this.vdata];
      if (access) {
        delete this.data[access];
        delete key[this.vdata];
      }
    };
    return FakeWeakMap2;
  }();
}
var DomData = window_1.WeakMap ? /* @__PURE__ */ new WeakMap() : new FakeWeakMap();
function _cleanUpEvents(elem, type2) {
  if (!DomData.has(elem)) {
    return;
  }
  var data = DomData.get(elem);
  if (data.handlers[type2].length === 0) {
    delete data.handlers[type2];
    if (elem.removeEventListener) {
      elem.removeEventListener(type2, data.dispatcher, false);
    } else if (elem.detachEvent) {
      elem.detachEvent("on" + type2, data.dispatcher);
    }
  }
  if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
    delete data.handlers;
    delete data.dispatcher;
    delete data.disabled;
  }
  if (Object.getOwnPropertyNames(data).length === 0) {
    DomData["delete"](elem);
  }
}
function _handleMultipleEvents(fn2, elem, types, callback2) {
  types.forEach(function(type2) {
    fn2(elem, type2, callback2);
  });
}
function fixEvent(event) {
  if (event.fixed_) {
    return event;
  }
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
    var old = event || window_1.event;
    event = {};
    for (var key in old) {
      if (key !== "layerX" && key !== "layerY" && key !== "keyLocation" && key !== "webkitMovementX" && key !== "webkitMovementY" && key !== "path") {
        if (!(key === "returnValue" && old.preventDefault)) {
          event[key] = old[key];
        }
      }
    }
    if (!event.target) {
      event.target = event.srcElement || document_1;
    }
    if (!event.relatedTarget) {
      event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
    }
    event.preventDefault = function() {
      if (old.preventDefault) {
        old.preventDefault();
      }
      event.returnValue = false;
      old.returnValue = false;
      event.defaultPrevented = true;
    };
    event.defaultPrevented = false;
    event.stopPropagation = function() {
      if (old.stopPropagation) {
        old.stopPropagation();
      }
      event.cancelBubble = true;
      old.cancelBubble = true;
      event.isPropagationStopped = returnTrue;
    };
    event.isPropagationStopped = returnFalse;
    event.stopImmediatePropagation = function() {
      if (old.stopImmediatePropagation) {
        old.stopImmediatePropagation();
      }
      event.isImmediatePropagationStopped = returnTrue;
      event.stopPropagation();
    };
    event.isImmediatePropagationStopped = returnFalse;
    if (event.clientX !== null && event.clientX !== void 0) {
      var doc = document_1.documentElement;
      var body = document_1.body;
      event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }
    event.which = event.charCode || event.keyCode;
    if (event.button !== null && event.button !== void 0) {
      event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
    }
  }
  event.fixed_ = true;
  return event;
}
var _supportsPassive;
var supportsPassive = function supportsPassive2() {
  if (typeof _supportsPassive !== "boolean") {
    _supportsPassive = false;
    try {
      var opts = Object.defineProperty({}, "passive", {
        get: function get8() {
          _supportsPassive = true;
        }
      });
      window_1.addEventListener("test", null, opts);
      window_1.removeEventListener("test", null, opts);
    } catch (e2) {
    }
  }
  return _supportsPassive;
};
var passiveEvents = ["touchstart", "touchmove"];
function on(elem, type2, fn2) {
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(on, elem, type2, fn2);
  }
  if (!DomData.has(elem)) {
    DomData.set(elem, {});
  }
  var data = DomData.get(elem);
  if (!data.handlers) {
    data.handlers = {};
  }
  if (!data.handlers[type2]) {
    data.handlers[type2] = [];
  }
  if (!fn2.guid) {
    fn2.guid = newGUID();
  }
  data.handlers[type2].push(fn2);
  if (!data.dispatcher) {
    data.disabled = false;
    data.dispatcher = function(event, hash2) {
      if (data.disabled) {
        return;
      }
      event = fixEvent(event);
      var handlers = data.handlers[event.type];
      if (handlers) {
        var handlersCopy = handlers.slice(0);
        for (var m2 = 0, n2 = handlersCopy.length; m2 < n2; m2++) {
          if (event.isImmediatePropagationStopped()) {
            break;
          } else {
            try {
              handlersCopy[m2].call(elem, event, hash2);
            } catch (e2) {
              log$1.error(e2);
            }
          }
        }
      }
    };
  }
  if (data.handlers[type2].length === 1) {
    if (elem.addEventListener) {
      var options = false;
      if (supportsPassive() && passiveEvents.indexOf(type2) > -1) {
        options = {
          passive: true
        };
      }
      elem.addEventListener(type2, data.dispatcher, options);
    } else if (elem.attachEvent) {
      elem.attachEvent("on" + type2, data.dispatcher);
    }
  }
}
function off(elem, type2, fn2) {
  if (!DomData.has(elem)) {
    return;
  }
  var data = DomData.get(elem);
  if (!data.handlers) {
    return;
  }
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(off, elem, type2, fn2);
  }
  var removeType = function removeType2(el2, t4) {
    data.handlers[t4] = [];
    _cleanUpEvents(el2, t4);
  };
  if (type2 === void 0) {
    for (var t3 in data.handlers) {
      if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t3)) {
        removeType(elem, t3);
      }
    }
    return;
  }
  var handlers = data.handlers[type2];
  if (!handlers) {
    return;
  }
  if (!fn2) {
    removeType(elem, type2);
    return;
  }
  if (fn2.guid) {
    for (var n2 = 0; n2 < handlers.length; n2++) {
      if (handlers[n2].guid === fn2.guid) {
        handlers.splice(n2--, 1);
      }
    }
  }
  _cleanUpEvents(elem, type2);
}
function trigger$1(elem, event, hash2) {
  var elemData = DomData.has(elem) ? DomData.get(elem) : {};
  var parent = elem.parentNode || elem.ownerDocument;
  if (typeof event === "string") {
    event = {
      type: event,
      target: elem
    };
  } else if (!event.target) {
    event.target = elem;
  }
  event = fixEvent(event);
  if (elemData.dispatcher) {
    elemData.dispatcher.call(elem, event, hash2);
  }
  if (parent && !event.isPropagationStopped() && event.bubbles === true) {
    trigger$1.call(null, parent, event, hash2);
  } else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
    if (!DomData.has(event.target)) {
      DomData.set(event.target, {});
    }
    var targetData = DomData.get(event.target);
    if (event.target[event.type]) {
      targetData.disabled = true;
      if (typeof event.target[event.type] === "function") {
        event.target[event.type]();
      }
      targetData.disabled = false;
    }
  }
  return !event.defaultPrevented;
}
function one(elem, type2, fn2) {
  if (Array.isArray(type2)) {
    return _handleMultipleEvents(one, elem, type2, fn2);
  }
  var func = function func2() {
    off(elem, type2, func2);
    fn2.apply(this, arguments);
  };
  func.guid = fn2.guid = fn2.guid || newGUID();
  on(elem, type2, func);
}
function any(elem, type2, fn2) {
  var func = function func2() {
    off(elem, type2, func2);
    fn2.apply(this, arguments);
  };
  func.guid = fn2.guid = fn2.guid || newGUID();
  on(elem, type2, func);
}
var Events = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixEvent,
  on,
  off,
  trigger: trigger$1,
  one,
  any
});
var UPDATE_REFRESH_INTERVAL = 30;
var bind = function bind2(context, fn2, uid) {
  if (!fn2.guid) {
    fn2.guid = newGUID();
  }
  var bound = fn2.bind(context);
  bound.guid = uid ? uid + "_" + fn2.guid : fn2.guid;
  return bound;
};
var throttle$1 = function throttle(fn2, wait) {
  var last = window_1.performance.now();
  var throttled = function throttled2() {
    var now = window_1.performance.now();
    if (now - last >= wait) {
      fn2.apply(void 0, arguments);
      last = now;
    }
  };
  return throttled;
};
var debounce = function debounce2(func, wait, immediate2, context) {
  if (context === void 0) {
    context = window_1;
  }
  var timeout;
  var cancel = function cancel2() {
    context.clearTimeout(timeout);
    timeout = null;
  };
  var debounced = function debounced2() {
    var self2 = this;
    var args = arguments;
    var _later = function later() {
      timeout = null;
      _later = null;
      if (!immediate2) {
        func.apply(self2, args);
      }
    };
    if (!timeout && immediate2) {
      func.apply(self2, args);
    }
    context.clearTimeout(timeout);
    timeout = context.setTimeout(_later, wait);
  };
  debounced.cancel = cancel;
  return debounced;
};
var EventTarget$2 = function EventTarget() {
};
EventTarget$2.prototype.allowedEvents_ = {};
EventTarget$2.prototype.on = function(type2, fn2) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  on(this, type2, fn2);
  this.addEventListener = ael;
};
EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;
EventTarget$2.prototype.off = function(type2, fn2) {
  off(this, type2, fn2);
};
EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;
EventTarget$2.prototype.one = function(type2, fn2) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  one(this, type2, fn2);
  this.addEventListener = ael;
};
EventTarget$2.prototype.any = function(type2, fn2) {
  var ael = this.addEventListener;
  this.addEventListener = function() {
  };
  any(this, type2, fn2);
  this.addEventListener = ael;
};
EventTarget$2.prototype.trigger = function(event) {
  var type2 = event.type || event;
  if (typeof event === "string") {
    event = {
      type: type2
    };
  }
  event = fixEvent(event);
  if (this.allowedEvents_[type2] && this["on" + type2]) {
    this["on" + type2](event);
  }
  trigger$1(this, event);
};
EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;
var EVENT_MAP;
EventTarget$2.prototype.queueTrigger = function(event) {
  var _this = this;
  if (!EVENT_MAP) {
    EVENT_MAP = /* @__PURE__ */ new Map();
  }
  var type2 = event.type || event;
  var map = EVENT_MAP.get(this);
  if (!map) {
    map = /* @__PURE__ */ new Map();
    EVENT_MAP.set(this, map);
  }
  var oldTimeout = map.get(type2);
  map["delete"](type2);
  window_1.clearTimeout(oldTimeout);
  var timeout = window_1.setTimeout(function() {
    if (map.size === 0) {
      map = null;
      EVENT_MAP["delete"](_this);
    }
    _this.trigger(event);
  }, 0);
  map.set(type2, timeout);
};
var objName = function objName2(obj) {
  if (typeof obj.name === "function") {
    return obj.name();
  }
  if (typeof obj.name === "string") {
    return obj.name;
  }
  if (obj.name_) {
    return obj.name_;
  }
  if (obj.constructor && obj.constructor.name) {
    return obj.constructor.name;
  }
  return typeof obj;
};
var isEvented = function isEvented2(object) {
  return object instanceof EventTarget$2 || !!object.eventBusEl_ && ["on", "one", "off", "trigger"].every(function(k2) {
    return typeof object[k2] === "function";
  });
};
var addEventedCallback = function addEventedCallback2(target, callback2) {
  if (isEvented(target)) {
    callback2();
  } else {
    if (!target.eventedCallbacks) {
      target.eventedCallbacks = [];
    }
    target.eventedCallbacks.push(callback2);
  }
};
var isValidEventType = function isValidEventType2(type2) {
  return (
    // The regex here verifies that the `type` contains at least one non-
    // whitespace character.
    typeof type2 === "string" && /\S/.test(type2) || Array.isArray(type2) && !!type2.length
  );
};
var validateTarget = function validateTarget2(target, obj, fnName) {
  if (!target || !target.nodeName && !isEvented(target)) {
    throw new Error("Invalid target for " + objName(obj) + "#" + fnName + "; must be a DOM node or evented object.");
  }
};
var validateEventType = function validateEventType2(type2, obj, fnName) {
  if (!isValidEventType(type2)) {
    throw new Error("Invalid event type for " + objName(obj) + "#" + fnName + "; must be a non-empty string or array.");
  }
};
var validateListener = function validateListener2(listener, obj, fnName) {
  if (typeof listener !== "function") {
    throw new Error("Invalid listener for " + objName(obj) + "#" + fnName + "; must be a function.");
  }
};
var normalizeListenArgs = function normalizeListenArgs2(self2, args, fnName) {
  var isTargetingSelf = args.length < 3 || args[0] === self2 || args[0] === self2.eventBusEl_;
  var target;
  var type2;
  var listener;
  if (isTargetingSelf) {
    target = self2.eventBusEl_;
    if (args.length >= 3) {
      args.shift();
    }
    type2 = args[0];
    listener = args[1];
  } else {
    target = args[0];
    type2 = args[1];
    listener = args[2];
  }
  validateTarget(target, self2, fnName);
  validateEventType(type2, self2, fnName);
  validateListener(listener, self2, fnName);
  listener = bind(self2, listener);
  return {
    isTargetingSelf,
    target,
    type: type2,
    listener
  };
};
var listen = function listen2(target, method, type2, listener) {
  validateTarget(target, target, method);
  if (target.nodeName) {
    Events[method](target, type2, listener);
  } else {
    target[method](type2, listener);
  }
};
var EventedMixin = {
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  on: function on2() {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var _normalizeListenArgs = normalizeListenArgs(this, args, "on"), isTargetingSelf = _normalizeListenArgs.isTargetingSelf, target = _normalizeListenArgs.target, type2 = _normalizeListenArgs.type, listener = _normalizeListenArgs.listener;
    listen(target, "on", type2, listener);
    if (!isTargetingSelf) {
      var removeListenerOnDispose = function removeListenerOnDispose2() {
        return _this.off(target, type2, listener);
      };
      removeListenerOnDispose.guid = listener.guid;
      var removeRemoverOnTargetDispose = function removeRemoverOnTargetDispose2() {
        return _this.off("dispose", removeListenerOnDispose);
      };
      removeRemoverOnTargetDispose.guid = listener.guid;
      listen(this, "on", "dispose", removeListenerOnDispose);
      listen(target, "on", "dispose", removeRemoverOnTargetDispose);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will be called once per event and then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  one: function one2() {
    var _this2 = this;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var _normalizeListenArgs2 = normalizeListenArgs(this, args, "one"), isTargetingSelf = _normalizeListenArgs2.isTargetingSelf, target = _normalizeListenArgs2.target, type2 = _normalizeListenArgs2.type, listener = _normalizeListenArgs2.listener;
    if (isTargetingSelf) {
      listen(target, "one", type2, listener);
    } else {
      var wrapper = function wrapper2() {
        _this2.off(target, type2, wrapper2);
        for (var _len3 = arguments.length, largs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          largs[_key3] = arguments[_key3];
        }
        listener.apply(null, largs);
      };
      wrapper.guid = listener.guid;
      listen(target, "one", type2, wrapper);
    }
  },
  /**
   * Add a listener to an event (or events) on this object or another evented
   * object. The listener will only be called once for the first event that is triggered
   * then removed.
   *
   * @param  {string|Array|Element|Object} targetOrType
   *         If this is a string or array, it represents the event type(s)
   *         that will trigger the listener.
   *
   *         Another evented object can be passed here instead, which will
   *         cause the listener to listen for events on _that_ object.
   *
   *         In either case, the listener's `this` value will be bound to
   *         this object.
   *
   * @param  {string|Array|Function} typeOrListener
   *         If the first argument was a string or array, this should be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function.
   */
  any: function any2() {
    var _this3 = this;
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    var _normalizeListenArgs3 = normalizeListenArgs(this, args, "any"), isTargetingSelf = _normalizeListenArgs3.isTargetingSelf, target = _normalizeListenArgs3.target, type2 = _normalizeListenArgs3.type, listener = _normalizeListenArgs3.listener;
    if (isTargetingSelf) {
      listen(target, "any", type2, listener);
    } else {
      var wrapper = function wrapper2() {
        _this3.off(target, type2, wrapper2);
        for (var _len5 = arguments.length, largs = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          largs[_key5] = arguments[_key5];
        }
        listener.apply(null, largs);
      };
      wrapper.guid = listener.guid;
      listen(target, "any", type2, wrapper);
    }
  },
  /**
   * Removes listener(s) from event(s) on an evented object.
   *
   * @param  {string|Array|Element|Object} [targetOrType]
   *         If this is a string or array, it represents the event type(s).
   *
   *         Another evented object can be passed here instead, in which case
   *         ALL 3 arguments are _required_.
   *
   * @param  {string|Array|Function} [typeOrListener]
   *         If the first argument was a string or array, this may be the
   *         listener function. Otherwise, this is a string or array of event
   *         type(s).
   *
   * @param  {Function} [listener]
   *         If the first argument was another evented object, this will be
   *         the listener function; otherwise, _all_ listeners bound to the
   *         event type(s) will be removed.
   */
  off: function off$1(targetOrType, typeOrListener, listener) {
    if (!targetOrType || isValidEventType(targetOrType)) {
      off(this.eventBusEl_, targetOrType, typeOrListener);
    } else {
      var target = targetOrType;
      var type2 = typeOrListener;
      validateTarget(target, this, "off");
      validateEventType(type2, this, "off");
      validateListener(listener, this, "off");
      listener = bind(this, listener);
      this.off("dispose", listener);
      if (target.nodeName) {
        off(target, type2, listener);
        off(target, "dispose", listener);
      } else if (isEvented(target)) {
        target.off(type2, listener);
        target.off("dispose", listener);
      }
    }
  },
  /**
   * Fire an event on this evented object, causing its listeners to be called.
   *
   * @param   {string|Object} event
   *          An event type or an object with a type property.
   *
   * @param   {Object} [hash]
   *          An additional object to pass along to listeners.
   *
   * @return {boolean}
   *          Whether or not the default behavior was prevented.
   */
  trigger: function trigger$1$1(event, hash2) {
    validateTarget(this.eventBusEl_, this, "trigger");
    var type2 = event && typeof event !== "string" ? event.type : event;
    if (!isValidEventType(type2)) {
      var error = "Invalid event type for " + objName(this) + "#trigger; must be a non-empty string or object with a type key that has a non-empty value.";
      if (event) {
        (this.log || log$1).error(error);
      } else {
        throw new Error(error);
      }
    }
    return trigger$1(this.eventBusEl_, event, hash2);
  }
};
function evented(target, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, eventBusKey = _options.eventBusKey;
  if (eventBusKey) {
    if (!target[eventBusKey].nodeName) {
      throw new Error('The eventBusKey "' + eventBusKey + '" does not refer to an element.');
    }
    target.eventBusEl_ = target[eventBusKey];
  } else {
    target.eventBusEl_ = createEl("span", {
      className: "vjs-event-bus"
    });
  }
  assign$1(target, EventedMixin);
  if (target.eventedCallbacks) {
    target.eventedCallbacks.forEach(function(callback2) {
      callback2();
    });
  }
  target.on("dispose", function() {
    target.off();
    [target, target.el_, target.eventBusEl_].forEach(function(val) {
      if (val && DomData.has(val)) {
        DomData["delete"](val);
      }
    });
    window_1.setTimeout(function() {
      target.eventBusEl_ = null;
    }, 0);
  });
  return target;
}
var StatefulMixin = {
  /**
   * A hash containing arbitrary keys and values representing the state of
   * the object.
   *
   * @type {Object}
   */
  state: {},
  /**
   * Set the state of an object by mutating its
   * {@link module:stateful~StatefulMixin.state|state} object in place.
   *
   * @fires   module:stateful~StatefulMixin#statechanged
   * @param   {Object|Function} stateUpdates
   *          A new set of properties to shallow-merge into the plugin state.
   *          Can be a plain object or a function returning a plain object.
   *
   * @return {Object|undefined}
   *          An object containing changes that occurred. If no changes
   *          occurred, returns `undefined`.
   */
  setState: function setState(stateUpdates) {
    var _this = this;
    if (typeof stateUpdates === "function") {
      stateUpdates = stateUpdates();
    }
    var changes;
    each(stateUpdates, function(value, key) {
      if (_this.state[key] !== value) {
        changes = changes || {};
        changes[key] = {
          from: _this.state[key],
          to: value
        };
      }
      _this.state[key] = value;
    });
    if (changes && isEvented(this)) {
      this.trigger({
        changes,
        type: "statechanged"
      });
    }
    return changes;
  }
};
function stateful(target, defaultState) {
  assign$1(target, StatefulMixin);
  target.state = assign$1({}, target.state, defaultState);
  if (typeof target.handleStateChanged === "function" && isEvented(target)) {
    target.on("statechanged", target.handleStateChanged);
  }
  return target;
}
var toLowerCase = function toLowerCase2(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w2) {
    return w2.toLowerCase();
  });
};
var toTitleCase$1 = function toTitleCase(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w2) {
    return w2.toUpperCase();
  });
};
var titleCaseEquals = function titleCaseEquals2(str1, str2) {
  return toTitleCase$1(str1) === toTitleCase$1(str2);
};
function mergeOptions$3() {
  var result = {};
  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
    sources[_key] = arguments[_key];
  }
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    each(source, function(value, key) {
      if (!isPlain(value)) {
        result[key] = value;
        return;
      }
      if (!isPlain(result[key])) {
        result[key] = {};
      }
      result[key] = mergeOptions$3(result[key], value);
    });
  });
  return result;
}
var MapSham = /* @__PURE__ */ function() {
  function MapSham2() {
    this.map_ = {};
  }
  var _proto = MapSham2.prototype;
  _proto.has = function has(key) {
    return key in this.map_;
  };
  _proto["delete"] = function _delete(key) {
    var has = this.has(key);
    delete this.map_[key];
    return has;
  };
  _proto.set = function set4(key, value) {
    this.map_[key] = value;
    return this;
  };
  _proto.forEach = function forEach2(callback2, thisArg) {
    for (var key in this.map_) {
      callback2.call(thisArg, this.map_[key], key, this);
    }
  };
  return MapSham2;
}();
var Map$1 = window_1.Map ? window_1.Map : MapSham;
var SetSham = /* @__PURE__ */ function() {
  function SetSham2() {
    this.set_ = {};
  }
  var _proto = SetSham2.prototype;
  _proto.has = function has(key) {
    return key in this.set_;
  };
  _proto["delete"] = function _delete(key) {
    var has = this.has(key);
    delete this.set_[key];
    return has;
  };
  _proto.add = function add3(key) {
    this.set_[key] = 1;
    return this;
  };
  _proto.forEach = function forEach2(callback2, thisArg) {
    for (var key in this.set_) {
      callback2.call(thisArg, key, key, this);
    }
  };
  return SetSham2;
}();
var Set$1 = window_1.Set ? window_1.Set : SetSham;
var Component$1 = /* @__PURE__ */ function() {
  function Component2(player, options, ready) {
    var _this = this;
    if (!player && this.play) {
      this.player_ = player = this;
    } else {
      this.player_ = player;
    }
    this.isDisposed_ = false;
    this.parentComponent_ = null;
    this.options_ = mergeOptions$3({}, this.options_);
    options = this.options_ = mergeOptions$3(this.options_, options);
    this.id_ = options.id || options.el && options.el.id;
    if (!this.id_) {
      var id2 = player && player.id && player.id() || "no_player";
      this.id_ = id2 + "_component_" + newGUID();
    }
    this.name_ = options.name || null;
    if (options.el) {
      this.el_ = options.el;
    } else if (options.createEl !== false) {
      this.el_ = this.createEl();
    }
    if (options.className && this.el_) {
      options.className.split(" ").forEach(function(c2) {
        return _this.addClass(c2);
      });
    }
    if (options.evented !== false) {
      evented(this, {
        eventBusKey: this.el_ ? "el_" : null
      });
      this.handleLanguagechange = this.handleLanguagechange.bind(this);
      this.on(this.player_, "languagechange", this.handleLanguagechange);
    }
    stateful(this, this.constructor.defaultState);
    this.children_ = [];
    this.childIndex_ = {};
    this.childNameIndex_ = {};
    this.setTimeoutIds_ = new Set$1();
    this.setIntervalIds_ = new Set$1();
    this.rafIds_ = new Set$1();
    this.namedRafs_ = new Map$1();
    this.clearingTimersOnDispose_ = false;
    if (options.initChildren !== false) {
      this.initChildren();
    }
    this.ready(ready);
    if (options.reportTouchActivity !== false) {
      this.enableTouchActivity();
    }
  }
  var _proto = Component2.prototype;
  _proto.dispose = function dispose(options) {
    if (options === void 0) {
      options = {};
    }
    if (this.isDisposed_) {
      return;
    }
    if (this.readyQueue_) {
      this.readyQueue_.length = 0;
    }
    this.trigger({
      type: "dispose",
      bubbles: false
    });
    this.isDisposed_ = true;
    if (this.children_) {
      for (var i = this.children_.length - 1; i >= 0; i--) {
        if (this.children_[i].dispose) {
          this.children_[i].dispose();
        }
      }
    }
    this.children_ = null;
    this.childIndex_ = null;
    this.childNameIndex_ = null;
    this.parentComponent_ = null;
    if (this.el_) {
      if (this.el_.parentNode) {
        if (options.restoreEl) {
          this.el_.parentNode.replaceChild(options.restoreEl, this.el_);
        } else {
          this.el_.parentNode.removeChild(this.el_);
        }
      }
      this.el_ = null;
    }
    this.player_ = null;
  };
  _proto.isDisposed = function isDisposed() {
    return Boolean(this.isDisposed_);
  };
  _proto.player = function player() {
    return this.player_;
  };
  _proto.options = function options(obj) {
    if (!obj) {
      return this.options_;
    }
    this.options_ = mergeOptions$3(this.options_, obj);
    return this.options_;
  };
  _proto.el = function el2() {
    return this.el_;
  };
  _proto.createEl = function createEl$1(tagName, properties2, attributes) {
    return createEl(tagName, properties2, attributes);
  };
  _proto.localize = function localize(string, tokens, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = string;
    }
    var code = this.player_.language && this.player_.language();
    var languages = this.player_.languages && this.player_.languages();
    var language = languages && languages[code];
    var primaryCode = code && code.split("-")[0];
    var primaryLang = languages && languages[primaryCode];
    var localizedString = defaultValue;
    if (language && language[string]) {
      localizedString = language[string];
    } else if (primaryLang && primaryLang[string]) {
      localizedString = primaryLang[string];
    }
    if (tokens) {
      localizedString = localizedString.replace(/\{(\d+)\}/g, function(match2, index2) {
        var value = tokens[index2 - 1];
        var ret = value;
        if (typeof value === "undefined") {
          ret = match2;
        }
        return ret;
      });
    }
    return localizedString;
  };
  _proto.handleLanguagechange = function handleLanguagechange() {
  };
  _proto.contentEl = function contentEl() {
    return this.contentEl_ || this.el_;
  };
  _proto.id = function id2() {
    return this.id_;
  };
  _proto.name = function name() {
    return this.name_;
  };
  _proto.children = function children() {
    return this.children_;
  };
  _proto.getChildById = function getChildById(id2) {
    return this.childIndex_[id2];
  };
  _proto.getChild = function getChild(name) {
    if (!name) {
      return;
    }
    return this.childNameIndex_[name];
  };
  _proto.getDescendant = function getDescendant() {
    for (var _len = arguments.length, names2 = new Array(_len), _key = 0; _key < _len; _key++) {
      names2[_key] = arguments[_key];
    }
    names2 = names2.reduce(function(acc, n2) {
      return acc.concat(n2);
    }, []);
    var currentChild = this;
    for (var i = 0; i < names2.length; i++) {
      currentChild = currentChild.getChild(names2[i]);
      if (!currentChild || !currentChild.getChild) {
        return;
      }
    }
    return currentChild;
  };
  _proto.addChild = function addChild(child, options, index2) {
    if (options === void 0) {
      options = {};
    }
    if (index2 === void 0) {
      index2 = this.children_.length;
    }
    var component;
    var componentName;
    if (typeof child === "string") {
      componentName = toTitleCase$1(child);
      var componentClassName = options.componentClass || componentName;
      options.name = componentName;
      var ComponentClass = Component2.getComponent(componentClassName);
      if (!ComponentClass) {
        throw new Error("Component " + componentClassName + " does not exist");
      }
      if (typeof ComponentClass !== "function") {
        return null;
      }
      component = new ComponentClass(this.player_ || this, options);
    } else {
      component = child;
    }
    if (component.parentComponent_) {
      component.parentComponent_.removeChild(component);
    }
    this.children_.splice(index2, 0, component);
    component.parentComponent_ = this;
    if (typeof component.id === "function") {
      this.childIndex_[component.id()] = component;
    }
    componentName = componentName || component.name && toTitleCase$1(component.name());
    if (componentName) {
      this.childNameIndex_[componentName] = component;
      this.childNameIndex_[toLowerCase(componentName)] = component;
    }
    if (typeof component.el === "function" && component.el()) {
      var refNode = null;
      if (this.children_[index2 + 1]) {
        if (this.children_[index2 + 1].el_) {
          refNode = this.children_[index2 + 1].el_;
        } else if (isEl(this.children_[index2 + 1])) {
          refNode = this.children_[index2 + 1];
        }
      }
      this.contentEl().insertBefore(component.el(), refNode);
    }
    return component;
  };
  _proto.removeChild = function removeChild(component) {
    if (typeof component === "string") {
      component = this.getChild(component);
    }
    if (!component || !this.children_) {
      return;
    }
    var childFound = false;
    for (var i = this.children_.length - 1; i >= 0; i--) {
      if (this.children_[i] === component) {
        childFound = true;
        this.children_.splice(i, 1);
        break;
      }
    }
    if (!childFound) {
      return;
    }
    component.parentComponent_ = null;
    this.childIndex_[component.id()] = null;
    this.childNameIndex_[toTitleCase$1(component.name())] = null;
    this.childNameIndex_[toLowerCase(component.name())] = null;
    var compEl = component.el();
    if (compEl && compEl.parentNode === this.contentEl()) {
      this.contentEl().removeChild(component.el());
    }
  };
  _proto.initChildren = function initChildren() {
    var _this2 = this;
    var children = this.options_.children;
    if (children) {
      var parentOptions = this.options_;
      var handleAdd = function handleAdd2(child) {
        var name = child.name;
        var opts = child.opts;
        if (parentOptions[name] !== void 0) {
          opts = parentOptions[name];
        }
        if (opts === false) {
          return;
        }
        if (opts === true) {
          opts = {};
        }
        opts.playerOptions = _this2.options_.playerOptions;
        var newChild = _this2.addChild(name, opts);
        if (newChild) {
          _this2[name] = newChild;
        }
      };
      var workingChildren;
      var Tech2 = Component2.getComponent("Tech");
      if (Array.isArray(children)) {
        workingChildren = children;
      } else {
        workingChildren = Object.keys(children);
      }
      workingChildren.concat(Object.keys(this.options_).filter(function(child) {
        return !workingChildren.some(function(wchild) {
          if (typeof wchild === "string") {
            return child === wchild;
          }
          return child === wchild.name;
        });
      })).map(function(child) {
        var name;
        var opts;
        if (typeof child === "string") {
          name = child;
          opts = children[name] || _this2.options_[name] || {};
        } else {
          name = child.name;
          opts = child;
        }
        return {
          name,
          opts
        };
      }).filter(function(child) {
        var c2 = Component2.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
        return c2 && !Tech2.isTech(c2);
      }).forEach(handleAdd);
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "";
  };
  _proto.ready = function ready(fn2, sync) {
    if (sync === void 0) {
      sync = false;
    }
    if (!fn2) {
      return;
    }
    if (!this.isReady_) {
      this.readyQueue_ = this.readyQueue_ || [];
      this.readyQueue_.push(fn2);
      return;
    }
    if (sync) {
      fn2.call(this);
    } else {
      this.setTimeout(fn2, 1);
    }
  };
  _proto.triggerReady = function triggerReady() {
    this.isReady_ = true;
    this.setTimeout(function() {
      var readyQueue = this.readyQueue_;
      this.readyQueue_ = [];
      if (readyQueue && readyQueue.length > 0) {
        readyQueue.forEach(function(fn2) {
          fn2.call(this);
        }, this);
      }
      this.trigger("ready");
    }, 1);
  };
  _proto.$ = function $$12(selector, context) {
    return $(selector, context || this.contentEl());
  };
  _proto.$$ = function $$$1(selector, context) {
    return $$(selector, context || this.contentEl());
  };
  _proto.hasClass = function hasClass$1(classToCheck) {
    return hasClass(this.el_, classToCheck);
  };
  _proto.addClass = function addClass$1(classToAdd) {
    addClass(this.el_, classToAdd);
  };
  _proto.removeClass = function removeClass$1(classToRemove) {
    removeClass(this.el_, classToRemove);
  };
  _proto.toggleClass = function toggleClass$1(classToToggle, predicate) {
    toggleClass(this.el_, classToToggle, predicate);
  };
  _proto.show = function show() {
    this.removeClass("vjs-hidden");
  };
  _proto.hide = function hide2() {
    this.addClass("vjs-hidden");
  };
  _proto.lockShowing = function lockShowing() {
    this.addClass("vjs-lock-showing");
  };
  _proto.unlockShowing = function unlockShowing() {
    this.removeClass("vjs-lock-showing");
  };
  _proto.getAttribute = function getAttribute$1(attribute) {
    return getAttribute(this.el_, attribute);
  };
  _proto.setAttribute = function setAttribute$1(attribute, value) {
    setAttribute(this.el_, attribute, value);
  };
  _proto.removeAttribute = function removeAttribute$1(attribute) {
    removeAttribute(this.el_, attribute);
  };
  _proto.width = function width3(num, skipListeners) {
    return this.dimension("width", num, skipListeners);
  };
  _proto.height = function height3(num, skipListeners) {
    return this.dimension("height", num, skipListeners);
  };
  _proto.dimensions = function dimensions(width3, height3) {
    this.width(width3, true);
    this.height(height3);
  };
  _proto.dimension = function dimension(widthOrHeight, num, skipListeners) {
    if (num !== void 0) {
      if (num === null || num !== num) {
        num = 0;
      }
      if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) {
        this.el_.style[widthOrHeight] = num;
      } else if (num === "auto") {
        this.el_.style[widthOrHeight] = "";
      } else {
        this.el_.style[widthOrHeight] = num + "px";
      }
      if (!skipListeners) {
        this.trigger("componentresize");
      }
      return;
    }
    if (!this.el_) {
      return 0;
    }
    var val = this.el_.style[widthOrHeight];
    var pxIndex = val.indexOf("px");
    if (pxIndex !== -1) {
      return parseInt(val.slice(0, pxIndex), 10);
    }
    return parseInt(this.el_["offset" + toTitleCase$1(widthOrHeight)], 10);
  };
  _proto.currentDimension = function currentDimension(widthOrHeight) {
    var computedWidthOrHeight = 0;
    if (widthOrHeight !== "width" && widthOrHeight !== "height") {
      throw new Error("currentDimension only accepts width or height value");
    }
    computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
    computedWidthOrHeight = parseFloat(computedWidthOrHeight);
    if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
      var rule = "offset" + toTitleCase$1(widthOrHeight);
      computedWidthOrHeight = this.el_[rule];
    }
    return computedWidthOrHeight;
  };
  _proto.currentDimensions = function currentDimensions() {
    return {
      width: this.currentDimension("width"),
      height: this.currentDimension("height")
    };
  };
  _proto.currentWidth = function currentWidth() {
    return this.currentDimension("width");
  };
  _proto.currentHeight = function currentHeight() {
    return this.currentDimension("height");
  };
  _proto.focus = function focus2() {
    this.el_.focus();
  };
  _proto.blur = function blur() {
    this.el_.blur();
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    if (this.player_) {
      if (!keycode.isEventKey(event, "Tab")) {
        event.stopPropagation();
      }
      this.player_.handleKeyDown(event);
    }
  };
  _proto.handleKeyPress = function handleKeyPress(event) {
    this.handleKeyDown(event);
  };
  _proto.emitTapEvents = function emitTapEvents() {
    var touchStart = 0;
    var firstTouch = null;
    var tapMovementThreshold = 10;
    var touchTimeThreshold = 200;
    var couldBeTap;
    this.on("touchstart", function(event) {
      if (event.touches.length === 1) {
        firstTouch = {
          pageX: event.touches[0].pageX,
          pageY: event.touches[0].pageY
        };
        touchStart = window_1.performance.now();
        couldBeTap = true;
      }
    });
    this.on("touchmove", function(event) {
      if (event.touches.length > 1) {
        couldBeTap = false;
      } else if (firstTouch) {
        var xdiff = event.touches[0].pageX - firstTouch.pageX;
        var ydiff = event.touches[0].pageY - firstTouch.pageY;
        var touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
        if (touchDistance > tapMovementThreshold) {
          couldBeTap = false;
        }
      }
    });
    var noTap = function noTap2() {
      couldBeTap = false;
    };
    this.on("touchleave", noTap);
    this.on("touchcancel", noTap);
    this.on("touchend", function(event) {
      firstTouch = null;
      if (couldBeTap === true) {
        var touchTime = window_1.performance.now() - touchStart;
        if (touchTime < touchTimeThreshold) {
          event.preventDefault();
          this.trigger("tap");
        }
      }
    });
  };
  _proto.enableTouchActivity = function enableTouchActivity() {
    if (!this.player() || !this.player().reportUserActivity) {
      return;
    }
    var report = bind(this.player(), this.player().reportUserActivity);
    var touchHolding;
    this.on("touchstart", function() {
      report();
      this.clearInterval(touchHolding);
      touchHolding = this.setInterval(report, 250);
    });
    var touchEnd = function touchEnd2(event) {
      report();
      this.clearInterval(touchHolding);
    };
    this.on("touchmove", report);
    this.on("touchend", touchEnd);
    this.on("touchcancel", touchEnd);
  };
  _proto.setTimeout = function setTimeout2(fn2, timeout) {
    var _this3 = this;
    var timeoutId;
    fn2 = bind(this, fn2);
    this.clearTimersOnDispose_();
    timeoutId = window_1.setTimeout(function() {
      if (_this3.setTimeoutIds_.has(timeoutId)) {
        _this3.setTimeoutIds_["delete"](timeoutId);
      }
      fn2();
    }, timeout);
    this.setTimeoutIds_.add(timeoutId);
    return timeoutId;
  };
  _proto.clearTimeout = function clearTimeout2(timeoutId) {
    if (this.setTimeoutIds_.has(timeoutId)) {
      this.setTimeoutIds_["delete"](timeoutId);
      window_1.clearTimeout(timeoutId);
    }
    return timeoutId;
  };
  _proto.setInterval = function setInterval2(fn2, interval) {
    fn2 = bind(this, fn2);
    this.clearTimersOnDispose_();
    var intervalId = window_1.setInterval(fn2, interval);
    this.setIntervalIds_.add(intervalId);
    return intervalId;
  };
  _proto.clearInterval = function clearInterval2(intervalId) {
    if (this.setIntervalIds_.has(intervalId)) {
      this.setIntervalIds_["delete"](intervalId);
      window_1.clearInterval(intervalId);
    }
    return intervalId;
  };
  _proto.requestAnimationFrame = function requestAnimationFrame2(fn2) {
    var _this4 = this;
    if (!this.supportsRaf_) {
      return this.setTimeout(fn2, 1e3 / 60);
    }
    this.clearTimersOnDispose_();
    var id2;
    fn2 = bind(this, fn2);
    id2 = window_1.requestAnimationFrame(function() {
      if (_this4.rafIds_.has(id2)) {
        _this4.rafIds_["delete"](id2);
      }
      fn2();
    });
    this.rafIds_.add(id2);
    return id2;
  };
  _proto.requestNamedAnimationFrame = function requestNamedAnimationFrame(name, fn2) {
    var _this5 = this;
    if (this.namedRafs_.has(name)) {
      return;
    }
    this.clearTimersOnDispose_();
    fn2 = bind(this, fn2);
    var id2 = this.requestAnimationFrame(function() {
      fn2();
      if (_this5.namedRafs_.has(name)) {
        _this5.namedRafs_["delete"](name);
      }
    });
    this.namedRafs_.set(name, id2);
    return name;
  };
  _proto.cancelNamedAnimationFrame = function cancelNamedAnimationFrame(name) {
    if (!this.namedRafs_.has(name)) {
      return;
    }
    this.cancelAnimationFrame(this.namedRafs_.get(name));
    this.namedRafs_["delete"](name);
  };
  _proto.cancelAnimationFrame = function cancelAnimationFrame2(id2) {
    if (!this.supportsRaf_) {
      return this.clearTimeout(id2);
    }
    if (this.rafIds_.has(id2)) {
      this.rafIds_["delete"](id2);
      window_1.cancelAnimationFrame(id2);
    }
    return id2;
  };
  _proto.clearTimersOnDispose_ = function clearTimersOnDispose_() {
    var _this6 = this;
    if (this.clearingTimersOnDispose_) {
      return;
    }
    this.clearingTimersOnDispose_ = true;
    this.one("dispose", function() {
      [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(function(_ref) {
        var idName = _ref[0], cancelName = _ref[1];
        _this6[idName].forEach(function(val, key) {
          return _this6[cancelName](key);
        });
      });
      _this6.clearingTimersOnDispose_ = false;
    });
  };
  Component2.registerComponent = function registerComponent(name, ComponentToRegister) {
    if (typeof name !== "string" || !name) {
      throw new Error('Illegal component name, "' + name + '"; must be a non-empty string.');
    }
    var Tech2 = Component2.getComponent("Tech");
    var isTech = Tech2 && Tech2.isTech(ComponentToRegister);
    var isComp = Component2 === ComponentToRegister || Component2.prototype.isPrototypeOf(ComponentToRegister.prototype);
    if (isTech || !isComp) {
      var reason;
      if (isTech) {
        reason = "techs must be registered using Tech.registerTech()";
      } else {
        reason = "must be a Component subclass";
      }
      throw new Error('Illegal component, "' + name + '"; ' + reason + ".");
    }
    name = toTitleCase$1(name);
    if (!Component2.components_) {
      Component2.components_ = {};
    }
    var Player2 = Component2.getComponent("Player");
    if (name === "Player" && Player2 && Player2.players) {
      var players = Player2.players;
      var playerNames = Object.keys(players);
      if (players && playerNames.length > 0 && playerNames.map(function(pname) {
        return players[pname];
      }).every(Boolean)) {
        throw new Error("Can not register Player component after player has been created.");
      }
    }
    Component2.components_[name] = ComponentToRegister;
    Component2.components_[toLowerCase(name)] = ComponentToRegister;
    return ComponentToRegister;
  };
  Component2.getComponent = function getComponent(name) {
    if (!name || !Component2.components_) {
      return;
    }
    return Component2.components_[name];
  };
  return Component2;
}();
Component$1.prototype.supportsRaf_ = typeof window_1.requestAnimationFrame === "function" && typeof window_1.cancelAnimationFrame === "function";
Component$1.registerComponent("Component", Component$1);
function rangeCheck(fnName, index2, maxIndex) {
  if (typeof index2 !== "number" || index2 < 0 || index2 > maxIndex) {
    throw new Error("Failed to execute '" + fnName + "' on 'TimeRanges': The index provided (" + index2 + ") is non-numeric or out of bounds (0-" + maxIndex + ").");
  }
}
function getRange(fnName, valueIndex, ranges, rangeIndex) {
  rangeCheck(fnName, rangeIndex, ranges.length - 1);
  return ranges[rangeIndex][valueIndex];
}
function createTimeRangesObj(ranges) {
  var timeRangesObj;
  if (ranges === void 0 || ranges.length === 0) {
    timeRangesObj = {
      length: 0,
      start: function start3() {
        throw new Error("This TimeRanges object is empty");
      },
      end: function end2() {
        throw new Error("This TimeRanges object is empty");
      }
    };
  } else {
    timeRangesObj = {
      length: ranges.length,
      start: getRange.bind(null, "start", 0, ranges),
      end: getRange.bind(null, "end", 1, ranges)
    };
  }
  if (window_1.Symbol && window_1.Symbol.iterator) {
    timeRangesObj[window_1.Symbol.iterator] = function() {
      return (ranges || []).values();
    };
  }
  return timeRangesObj;
}
function createTimeRanges(start3, end2) {
  if (Array.isArray(start3)) {
    return createTimeRangesObj(start3);
  } else if (start3 === void 0 || end2 === void 0) {
    return createTimeRangesObj();
  }
  return createTimeRangesObj([[start3, end2]]);
}
function bufferedPercent(buffered, duration5) {
  var bufferedDuration = 0;
  var start3;
  var end2;
  if (!duration5) {
    return 0;
  }
  if (!buffered || !buffered.length) {
    buffered = createTimeRanges(0, 0);
  }
  for (var i = 0; i < buffered.length; i++) {
    start3 = buffered.start(i);
    end2 = buffered.end(i);
    if (end2 > duration5) {
      end2 = duration5;
    }
    bufferedDuration += end2 - start3;
  }
  return bufferedDuration / duration5;
}
function MediaError(value) {
  if (value instanceof MediaError) {
    return value;
  }
  if (typeof value === "number") {
    this.code = value;
  } else if (typeof value === "string") {
    this.message = value;
  } else if (isObject$1(value)) {
    if (typeof value.code === "number") {
      this.code = value.code;
    }
    assign$1(this, value);
  }
  if (!this.message) {
    this.message = MediaError.defaultMessages[this.code] || "";
  }
}
MediaError.prototype.code = 0;
MediaError.prototype.message = "";
MediaError.prototype.status = null;
MediaError.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"];
MediaError.defaultMessages = {
  1: "You aborted the media playback",
  2: "A network error caused the media download to fail part-way.",
  3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
  4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
  5: "The media is encrypted and we do not have the keys to decrypt it."
};
for (var errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
  MediaError[MediaError.errorTypes[errNum]] = errNum;
  MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
}
function isPromise$1(value) {
  return value !== void 0 && value !== null && typeof value.then === "function";
}
function silencePromise(value) {
  if (isPromise$1(value)) {
    value.then(null, function(e2) {
    });
  }
}
var trackToJson_ = function trackToJson_2(track) {
  var ret = ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce(function(acc, prop3, i) {
    if (track[prop3]) {
      acc[prop3] = track[prop3];
    }
    return acc;
  }, {
    cues: track.cues && Array.prototype.map.call(track.cues, function(cue) {
      return {
        startTime: cue.startTime,
        endTime: cue.endTime,
        text: cue.text,
        id: cue.id
      };
    })
  });
  return ret;
};
var textTracksToJson = function textTracksToJson2(tech) {
  var trackEls = tech.$$("track");
  var trackObjs = Array.prototype.map.call(trackEls, function(t3) {
    return t3.track;
  });
  var tracks = Array.prototype.map.call(trackEls, function(trackEl) {
    var json = trackToJson_(trackEl.track);
    if (trackEl.src) {
      json.src = trackEl.src;
    }
    return json;
  });
  return tracks.concat(Array.prototype.filter.call(tech.textTracks(), function(track) {
    return trackObjs.indexOf(track) === -1;
  }).map(trackToJson_));
};
var jsonToTextTracks = function jsonToTextTracks2(json, tech) {
  json.forEach(function(track) {
    var addedTrack = tech.addRemoteTextTrack(track).track;
    if (!track.src && track.cues) {
      track.cues.forEach(function(cue) {
        return addedTrack.addCue(cue);
      });
    }
  });
  return tech.textTracks();
};
var textTrackConverter = {
  textTracksToJson,
  jsonToTextTracks,
  trackToJson_
};
var MODAL_CLASS_NAME = "vjs-modal-dialog";
var ModalDialog = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ModalDialog2, _Component);
  function ModalDialog2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleKeyDown_ = function(e2) {
      return _this.handleKeyDown(e2);
    };
    _this.close_ = function(e2) {
      return _this.close(e2);
    };
    _this.opened_ = _this.hasBeenOpened_ = _this.hasBeenFilled_ = false;
    _this.closeable(!_this.options_.uncloseable);
    _this.content(_this.options_.content);
    _this.contentEl_ = createEl("div", {
      className: MODAL_CLASS_NAME + "-content"
    }, {
      role: "document"
    });
    _this.descEl_ = createEl("p", {
      className: MODAL_CLASS_NAME + "-description vjs-control-text",
      id: _this.el().getAttribute("aria-describedby")
    });
    textContent(_this.descEl_, _this.description());
    _this.el_.appendChild(_this.descEl_);
    _this.el_.appendChild(_this.contentEl_);
    return _this;
  }
  var _proto = ModalDialog2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: this.buildCSSClass(),
      tabIndex: -1
    }, {
      "aria-describedby": this.id() + "_description",
      "aria-hidden": "true",
      "aria-label": this.label(),
      "role": "dialog"
    });
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.descEl_ = null;
    this.previouslyActiveEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return MODAL_CLASS_NAME + " vjs-hidden " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.label = function label() {
    return this.localize(this.options_.label || "Modal Window");
  };
  _proto.description = function description() {
    var desc = this.options_.description || this.localize("This is a modal window.");
    if (this.closeable()) {
      desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
    }
    return desc;
  };
  _proto.open = function open() {
    if (!this.opened_) {
      var player = this.player();
      this.trigger("beforemodalopen");
      this.opened_ = true;
      if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) {
        this.fill();
      }
      this.wasPlaying_ = !player.paused();
      if (this.options_.pauseOnOpen && this.wasPlaying_) {
        player.pause();
      }
      this.on("keydown", this.handleKeyDown_);
      this.hadControls_ = player.controls();
      player.controls(false);
      this.show();
      this.conditionalFocus_();
      this.el().setAttribute("aria-hidden", "false");
      this.trigger("modalopen");
      this.hasBeenOpened_ = true;
    }
  };
  _proto.opened = function opened(value) {
    if (typeof value === "boolean") {
      this[value ? "open" : "close"]();
    }
    return this.opened_;
  };
  _proto.close = function close() {
    if (!this.opened_) {
      return;
    }
    var player = this.player();
    this.trigger("beforemodalclose");
    this.opened_ = false;
    if (this.wasPlaying_ && this.options_.pauseOnOpen) {
      player.play();
    }
    this.off("keydown", this.handleKeyDown_);
    if (this.hadControls_) {
      player.controls(true);
    }
    this.hide();
    this.el().setAttribute("aria-hidden", "true");
    this.trigger("modalclose");
    this.conditionalBlur_();
    if (this.options_.temporary) {
      this.dispose();
    }
  };
  _proto.closeable = function closeable(value) {
    if (typeof value === "boolean") {
      var closeable2 = this.closeable_ = !!value;
      var close = this.getChild("closeButton");
      if (closeable2 && !close) {
        var temp = this.contentEl_;
        this.contentEl_ = this.el_;
        close = this.addChild("closeButton", {
          controlText: "Close Modal Dialog"
        });
        this.contentEl_ = temp;
        this.on(close, "close", this.close_);
      }
      if (!closeable2 && close) {
        this.off(close, "close", this.close_);
        this.removeChild(close);
        close.dispose();
      }
    }
    return this.closeable_;
  };
  _proto.fill = function fill() {
    this.fillWith(this.content());
  };
  _proto.fillWith = function fillWith(content) {
    var contentEl = this.contentEl();
    var parentEl = contentEl.parentNode;
    var nextSiblingEl = contentEl.nextSibling;
    this.trigger("beforemodalfill");
    this.hasBeenFilled_ = true;
    parentEl.removeChild(contentEl);
    this.empty();
    insertContent(contentEl, content);
    this.trigger("modalfill");
    if (nextSiblingEl) {
      parentEl.insertBefore(contentEl, nextSiblingEl);
    } else {
      parentEl.appendChild(contentEl);
    }
    var closeButton = this.getChild("closeButton");
    if (closeButton) {
      parentEl.appendChild(closeButton.el_);
    }
  };
  _proto.empty = function empty2() {
    this.trigger("beforemodalempty");
    emptyEl(this.contentEl());
    this.trigger("modalempty");
  };
  _proto.content = function content(value) {
    if (typeof value !== "undefined") {
      this.content_ = value;
    }
    return this.content_;
  };
  _proto.conditionalFocus_ = function conditionalFocus_() {
    var activeEl = document_1.activeElement;
    var playerEl = this.player_.el_;
    this.previouslyActiveEl_ = null;
    if (playerEl.contains(activeEl) || playerEl === activeEl) {
      this.previouslyActiveEl_ = activeEl;
      this.focus();
    }
  };
  _proto.conditionalBlur_ = function conditionalBlur_() {
    if (this.previouslyActiveEl_) {
      this.previouslyActiveEl_.focus();
      this.previouslyActiveEl_ = null;
    }
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    event.stopPropagation();
    if (keycode.isEventKey(event, "Escape") && this.closeable()) {
      event.preventDefault();
      this.close();
      return;
    }
    if (!keycode.isEventKey(event, "Tab")) {
      return;
    }
    var focusableEls = this.focusableEls_();
    var activeEl = this.el_.querySelector(":focus");
    var focusIndex;
    for (var i = 0; i < focusableEls.length; i++) {
      if (activeEl === focusableEls[i]) {
        focusIndex = i;
        break;
      }
    }
    if (document_1.activeElement === this.el_) {
      focusIndex = 0;
    }
    if (event.shiftKey && focusIndex === 0) {
      focusableEls[focusableEls.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
      focusableEls[0].focus();
      event.preventDefault();
    }
  };
  _proto.focusableEls_ = function focusableEls_() {
    var allChildren = this.el_.querySelectorAll("*");
    return Array.prototype.filter.call(allChildren, function(child) {
      return (child instanceof window_1.HTMLAnchorElement || child instanceof window_1.HTMLAreaElement) && child.hasAttribute("href") || (child instanceof window_1.HTMLInputElement || child instanceof window_1.HTMLSelectElement || child instanceof window_1.HTMLTextAreaElement || child instanceof window_1.HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof window_1.HTMLIFrameElement || child instanceof window_1.HTMLObjectElement || child instanceof window_1.HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable");
    });
  };
  return ModalDialog2;
}(Component$1);
ModalDialog.prototype.options_ = {
  pauseOnOpen: true,
  temporary: true
};
Component$1.registerComponent("ModalDialog", ModalDialog);
var TrackList = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(TrackList2, _EventTarget);
  function TrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    _this = _EventTarget.call(this) || this;
    _this.tracks_ = [];
    Object.defineProperty(_assertThisInitialized(_this), "length", {
      get: function get8() {
        return this.tracks_.length;
      }
    });
    for (var i = 0; i < tracks.length; i++) {
      _this.addTrack(tracks[i]);
    }
    return _this;
  }
  var _proto = TrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    var index2 = this.tracks_.length;
    if (!("" + index2 in this)) {
      Object.defineProperty(this, index2, {
        get: function get8() {
          return this.tracks_[index2];
        }
      });
    }
    if (this.tracks_.indexOf(track) === -1) {
      this.tracks_.push(track);
      this.trigger({
        track,
        type: "addtrack",
        target: this
      });
    }
    track.labelchange_ = function() {
      _this2.trigger({
        track,
        type: "labelchange",
        target: _this2
      });
    };
    if (isEvented(track)) {
      track.addEventListener("labelchange", track.labelchange_);
    }
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    var track;
    for (var i = 0, l2 = this.length; i < l2; i++) {
      if (this[i] === rtrack) {
        track = this[i];
        if (track.off) {
          track.off();
        }
        this.tracks_.splice(i, 1);
        break;
      }
    }
    if (!track) {
      return;
    }
    this.trigger({
      track,
      type: "removetrack",
      target: this
    });
  };
  _proto.getTrackById = function getTrackById(id2) {
    var result = null;
    for (var i = 0, l2 = this.length; i < l2; i++) {
      var track = this[i];
      if (track.id === id2) {
        result = track;
        break;
      }
    }
    return result;
  };
  return TrackList2;
}(EventTarget$2);
TrackList.prototype.allowedEvents_ = {
  change: "change",
  addtrack: "addtrack",
  removetrack: "removetrack",
  labelchange: "labelchange"
};
for (var event in TrackList.prototype.allowedEvents_) {
  TrackList.prototype["on" + event] = null;
}
var disableOthers$1 = function disableOthers(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    list[i].enabled = false;
  }
};
var AudioTrackList = /* @__PURE__ */ function(_TrackList) {
  _inheritsLoose(AudioTrackList2, _TrackList);
  function AudioTrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].enabled) {
        disableOthers$1(tracks, tracks[i]);
        break;
      }
    }
    _this = _TrackList.call(this, tracks) || this;
    _this.changing_ = false;
    return _this;
  }
  var _proto = AudioTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    if (track.enabled) {
      disableOthers$1(this, track);
    }
    _TrackList.prototype.addTrack.call(this, track);
    if (!track.addEventListener) {
      return;
    }
    track.enabledChange_ = function() {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers$1(_this2, track);
      _this2.changing_ = false;
      _this2.trigger("change");
    };
    track.addEventListener("enabledchange", track.enabledChange_);
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener && rtrack.enabledChange_) {
      rtrack.removeEventListener("enabledchange", rtrack.enabledChange_);
      rtrack.enabledChange_ = null;
    }
  };
  return AudioTrackList2;
}(TrackList);
var disableOthers2 = function disableOthers3(list, track) {
  for (var i = 0; i < list.length; i++) {
    if (!Object.keys(list[i]).length || track.id === list[i].id) {
      continue;
    }
    list[i].selected = false;
  }
};
var VideoTrackList = /* @__PURE__ */ function(_TrackList) {
  _inheritsLoose(VideoTrackList2, _TrackList);
  function VideoTrackList2(tracks) {
    var _this;
    if (tracks === void 0) {
      tracks = [];
    }
    for (var i = tracks.length - 1; i >= 0; i--) {
      if (tracks[i].selected) {
        disableOthers2(tracks, tracks[i]);
        break;
      }
    }
    _this = _TrackList.call(this, tracks) || this;
    _this.changing_ = false;
    Object.defineProperty(_assertThisInitialized(_this), "selectedIndex", {
      get: function get8() {
        for (var _i = 0; _i < this.length; _i++) {
          if (this[_i].selected) {
            return _i;
          }
        }
        return -1;
      },
      set: function set4() {
      }
    });
    return _this;
  }
  var _proto = VideoTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this2 = this;
    if (track.selected) {
      disableOthers2(this, track);
    }
    _TrackList.prototype.addTrack.call(this, track);
    if (!track.addEventListener) {
      return;
    }
    track.selectedChange_ = function() {
      if (_this2.changing_) {
        return;
      }
      _this2.changing_ = true;
      disableOthers2(_this2, track);
      _this2.changing_ = false;
      _this2.trigger("change");
    };
    track.addEventListener("selectedchange", track.selectedChange_);
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener && rtrack.selectedChange_) {
      rtrack.removeEventListener("selectedchange", rtrack.selectedChange_);
      rtrack.selectedChange_ = null;
    }
  };
  return VideoTrackList2;
}(TrackList);
var TextTrackList = /* @__PURE__ */ function(_TrackList) {
  _inheritsLoose(TextTrackList2, _TrackList);
  function TextTrackList2() {
    return _TrackList.apply(this, arguments) || this;
  }
  var _proto = TextTrackList2.prototype;
  _proto.addTrack = function addTrack(track) {
    var _this = this;
    _TrackList.prototype.addTrack.call(this, track);
    if (!this.queueChange_) {
      this.queueChange_ = function() {
        return _this.queueTrigger("change");
      };
    }
    if (!this.triggerSelectedlanguagechange) {
      this.triggerSelectedlanguagechange_ = function() {
        return _this.trigger("selectedlanguagechange");
      };
    }
    track.addEventListener("modechange", this.queueChange_);
    var nonLanguageTextTrackKind = ["metadata", "chapters"];
    if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) {
      track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
    }
  };
  _proto.removeTrack = function removeTrack(rtrack) {
    _TrackList.prototype.removeTrack.call(this, rtrack);
    if (rtrack.removeEventListener) {
      if (this.queueChange_) {
        rtrack.removeEventListener("modechange", this.queueChange_);
      }
      if (this.selectedlanguagechange_) {
        rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_);
      }
    }
  };
  return TextTrackList2;
}(TrackList);
var HtmlTrackElementList = /* @__PURE__ */ function() {
  function HtmlTrackElementList2(trackElements) {
    if (trackElements === void 0) {
      trackElements = [];
    }
    this.trackElements_ = [];
    Object.defineProperty(this, "length", {
      get: function get8() {
        return this.trackElements_.length;
      }
    });
    for (var i = 0, length2 = trackElements.length; i < length2; i++) {
      this.addTrackElement_(trackElements[i]);
    }
  }
  var _proto = HtmlTrackElementList2.prototype;
  _proto.addTrackElement_ = function addTrackElement_(trackElement) {
    var index2 = this.trackElements_.length;
    if (!("" + index2 in this)) {
      Object.defineProperty(this, index2, {
        get: function get8() {
          return this.trackElements_[index2];
        }
      });
    }
    if (this.trackElements_.indexOf(trackElement) === -1) {
      this.trackElements_.push(trackElement);
    }
  };
  _proto.getTrackElementByTrack_ = function getTrackElementByTrack_(track) {
    var trackElement_;
    for (var i = 0, length2 = this.trackElements_.length; i < length2; i++) {
      if (track === this.trackElements_[i].track) {
        trackElement_ = this.trackElements_[i];
        break;
      }
    }
    return trackElement_;
  };
  _proto.removeTrackElement_ = function removeTrackElement_(trackElement) {
    for (var i = 0, length2 = this.trackElements_.length; i < length2; i++) {
      if (trackElement === this.trackElements_[i]) {
        if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === "function") {
          this.trackElements_[i].track.off();
        }
        if (typeof this.trackElements_[i].off === "function") {
          this.trackElements_[i].off();
        }
        this.trackElements_.splice(i, 1);
        break;
      }
    }
  };
  return HtmlTrackElementList2;
}();
var TextTrackCueList = /* @__PURE__ */ function() {
  function TextTrackCueList2(cues) {
    TextTrackCueList2.prototype.setCues_.call(this, cues);
    Object.defineProperty(this, "length", {
      get: function get8() {
        return this.length_;
      }
    });
  }
  var _proto = TextTrackCueList2.prototype;
  _proto.setCues_ = function setCues_(cues) {
    var oldLength = this.length || 0;
    var i = 0;
    var l2 = cues.length;
    this.cues_ = cues;
    this.length_ = cues.length;
    var defineProp = function defineProp2(index2) {
      if (!("" + index2 in this)) {
        Object.defineProperty(this, "" + index2, {
          get: function get8() {
            return this.cues_[index2];
          }
        });
      }
    };
    if (oldLength < l2) {
      i = oldLength;
      for (; i < l2; i++) {
        defineProp.call(this, i);
      }
    }
  };
  _proto.getCueById = function getCueById(id2) {
    var result = null;
    for (var i = 0, l2 = this.length; i < l2; i++) {
      var cue = this[i];
      if (cue.id === id2) {
        result = cue;
        break;
      }
    }
    return result;
  };
  return TextTrackCueList2;
}();
var VideoTrackKind = {
  alternative: "alternative",
  captions: "captions",
  main: "main",
  sign: "sign",
  subtitles: "subtitles",
  commentary: "commentary"
};
var AudioTrackKind = {
  "alternative": "alternative",
  "descriptions": "descriptions",
  "main": "main",
  "main-desc": "main-desc",
  "translation": "translation",
  "commentary": "commentary"
};
var TextTrackKind = {
  subtitles: "subtitles",
  captions: "captions",
  descriptions: "descriptions",
  chapters: "chapters",
  metadata: "metadata"
};
var TextTrackMode = {
  disabled: "disabled",
  hidden: "hidden",
  showing: "showing"
};
var Track = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(Track2, _EventTarget);
  function Track2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    var trackProps = {
      id: options.id || "vjs_track_" + newGUID(),
      kind: options.kind || "",
      language: options.language || ""
    };
    var label = options.label || "";
    var _loop = function _loop2(key2) {
      Object.defineProperty(_assertThisInitialized(_this), key2, {
        get: function get8() {
          return trackProps[key2];
        },
        set: function set4() {
        }
      });
    };
    for (var key in trackProps) {
      _loop(key);
    }
    Object.defineProperty(_assertThisInitialized(_this), "label", {
      get: function get8() {
        return label;
      },
      set: function set4(newLabel) {
        if (newLabel !== label) {
          label = newLabel;
          this.trigger("labelchange");
        }
      }
    });
    return _this;
  }
  return Track2;
}(EventTarget$2);
var parseUrl = function parseUrl2(url) {
  var props = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"];
  var a2 = document_1.createElement("a");
  a2.href = url;
  var details = {};
  for (var i = 0; i < props.length; i++) {
    details[props[i]] = a2[props[i]];
  }
  if (details.protocol === "http:") {
    details.host = details.host.replace(/:80$/, "");
  }
  if (details.protocol === "https:") {
    details.host = details.host.replace(/:443$/, "");
  }
  if (!details.protocol) {
    details.protocol = window_1.location.protocol;
  }
  if (!details.host) {
    details.host = window_1.location.host;
  }
  return details;
};
var getAbsoluteURL = function getAbsoluteURL2(url) {
  if (!url.match(/^https?:\/\//)) {
    var a2 = document_1.createElement("a");
    a2.href = url;
    url = a2.href;
  }
  return url;
};
var getFileExtension = function getFileExtension2(path) {
  if (typeof path === "string") {
    var splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
    var pathParts = splitPathRe.exec(path);
    if (pathParts) {
      return pathParts.pop().toLowerCase();
    }
  }
  return "";
};
var isCrossOrigin = function isCrossOrigin2(url, winLoc) {
  if (winLoc === void 0) {
    winLoc = window_1.location;
  }
  var urlInfo = parseUrl(url);
  var srcProtocol = urlInfo.protocol === ":" ? winLoc.protocol : urlInfo.protocol;
  var crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
  return crossOrigin;
};
var Url = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  parseUrl,
  getAbsoluteURL,
  getFileExtension,
  isCrossOrigin
});
var parseCues = function parseCues2(srcContent, track) {
  var parser2 = new window_1.WebVTT.Parser(window_1, window_1.vttjs, window_1.WebVTT.StringDecoder());
  var errors2 = [];
  parser2.oncue = function(cue) {
    track.addCue(cue);
  };
  parser2.onparsingerror = function(error) {
    errors2.push(error);
  };
  parser2.onflush = function() {
    track.trigger({
      type: "loadeddata",
      target: track
    });
  };
  parser2.parse(srcContent);
  if (errors2.length > 0) {
    if (window_1.console && window_1.console.groupCollapsed) {
      window_1.console.groupCollapsed("Text Track parsing errors for " + track.src);
    }
    errors2.forEach(function(error) {
      return log$1.error(error);
    });
    if (window_1.console && window_1.console.groupEnd) {
      window_1.console.groupEnd();
    }
  }
  parser2.flush();
};
var loadTrack = function loadTrack2(src, track) {
  var opts = {
    uri: src
  };
  var crossOrigin = isCrossOrigin(src);
  if (crossOrigin) {
    opts.cors = crossOrigin;
  }
  var withCredentials = track.tech_.crossOrigin() === "use-credentials";
  if (withCredentials) {
    opts.withCredentials = withCredentials;
  }
  libExports(opts, bind(this, function(err, response, responseBody) {
    if (err) {
      return log$1.error(err, response);
    }
    track.loaded_ = true;
    if (typeof window_1.WebVTT !== "function") {
      if (track.tech_) {
        track.tech_.any(["vttjsloaded", "vttjserror"], function(event) {
          if (event.type === "vttjserror") {
            log$1.error("vttjs failed to load, stopping trying to process " + track.src);
            return;
          }
          return parseCues(responseBody, track);
        });
      }
    } else {
      parseCues(responseBody, track);
    }
  }));
};
var TextTrack = /* @__PURE__ */ function(_Track) {
  _inheritsLoose(TextTrack2, _Track);
  function TextTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (!options.tech) {
      throw new Error("A tech was not provided.");
    }
    var settings = mergeOptions$3(options, {
      kind: TextTrackKind[options.kind] || "subtitles",
      language: options.language || options.srclang || ""
    });
    var mode = TextTrackMode[settings.mode] || "disabled";
    var default_ = settings["default"];
    if (settings.kind === "metadata" || settings.kind === "chapters") {
      mode = "hidden";
    }
    _this = _Track.call(this, settings) || this;
    _this.tech_ = settings.tech;
    _this.cues_ = [];
    _this.activeCues_ = [];
    _this.preload_ = _this.tech_.preloadTextTracks !== false;
    var cues = new TextTrackCueList(_this.cues_);
    var activeCues = new TextTrackCueList(_this.activeCues_);
    var changed = false;
    _this.timeupdateHandler = bind(_assertThisInitialized(_this), function(event) {
      if (event === void 0) {
        event = {};
      }
      if (this.tech_.isDisposed()) {
        return;
      }
      if (!this.tech_.isReady_) {
        if (event.type !== "timeupdate") {
          this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
        }
        return;
      }
      this.activeCues = this.activeCues;
      if (changed) {
        this.trigger("cuechange");
        changed = false;
      }
      if (event.type !== "timeupdate") {
        this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
      }
    });
    var disposeHandler = function disposeHandler2() {
      _this.stopTracking();
    };
    _this.tech_.one("dispose", disposeHandler);
    if (mode !== "disabled") {
      _this.startTracking();
    }
    Object.defineProperties(_assertThisInitialized(_this), {
      /**
       * @memberof TextTrack
       * @member {boolean} default
       *         If this track was set to be on or off by default. Cannot be changed after
       *         creation.
       * @instance
       *
       * @readonly
       */
      "default": {
        get: function get8() {
          return default_;
        },
        set: function set4() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {string} mode
       *         Set the mode of this TextTrack to a valid {@link TextTrack~Mode}. Will
       *         not be set if setting to an invalid mode.
       * @instance
       *
       * @fires TextTrack#modechange
       */
      mode: {
        get: function get8() {
          return mode;
        },
        set: function set4(newMode) {
          if (!TextTrackMode[newMode]) {
            return;
          }
          if (mode === newMode) {
            return;
          }
          mode = newMode;
          if (!this.preload_ && mode !== "disabled" && this.cues.length === 0) {
            loadTrack(this.src, this);
          }
          this.stopTracking();
          if (mode !== "disabled") {
            this.startTracking();
          }
          this.trigger("modechange");
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} cues
       *         The text track cue list for this TextTrack.
       * @instance
       */
      cues: {
        get: function get8() {
          if (!this.loaded_) {
            return null;
          }
          return cues;
        },
        set: function set4() {
        }
      },
      /**
       * @memberof TextTrack
       * @member {TextTrackCueList} activeCues
       *         The list text track cues that are currently active for this TextTrack.
       * @instance
       */
      activeCues: {
        get: function get8() {
          if (!this.loaded_) {
            return null;
          }
          if (this.cues.length === 0) {
            return activeCues;
          }
          var ct = this.tech_.currentTime();
          var active = [];
          for (var i = 0, l2 = this.cues.length; i < l2; i++) {
            var cue = this.cues[i];
            if (cue.startTime <= ct && cue.endTime >= ct) {
              active.push(cue);
            } else if (cue.startTime === cue.endTime && cue.startTime <= ct && cue.startTime + 0.5 >= ct) {
              active.push(cue);
            }
          }
          changed = false;
          if (active.length !== this.activeCues_.length) {
            changed = true;
          } else {
            for (var _i = 0; _i < active.length; _i++) {
              if (this.activeCues_.indexOf(active[_i]) === -1) {
                changed = true;
              }
            }
          }
          this.activeCues_ = active;
          activeCues.setCues_(this.activeCues_);
          return activeCues;
        },
        // /!\ Keep this setter empty (see the timeupdate handler above)
        set: function set4() {
        }
      }
    });
    if (settings.src) {
      _this.src = settings.src;
      if (!_this.preload_) {
        _this.loaded_ = true;
      }
      if (_this.preload_ || settings.kind !== "subtitles" && settings.kind !== "captions") {
        loadTrack(_this.src, _assertThisInitialized(_this));
      }
    } else {
      _this.loaded_ = true;
    }
    return _this;
  }
  var _proto = TextTrack2.prototype;
  _proto.startTracking = function startTracking() {
    this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
    this.tech_.on("timeupdate", this.timeupdateHandler);
  };
  _proto.stopTracking = function stopTracking() {
    if (this.rvf_) {
      this.tech_.cancelVideoFrameCallback(this.rvf_);
      this.rvf_ = void 0;
    }
    this.tech_.off("timeupdate", this.timeupdateHandler);
  };
  _proto.addCue = function addCue(originalCue) {
    var cue = originalCue;
    if (window_1.vttjs && !(originalCue instanceof window_1.vttjs.VTTCue)) {
      cue = new window_1.vttjs.VTTCue(originalCue.startTime, originalCue.endTime, originalCue.text);
      for (var prop3 in originalCue) {
        if (!(prop3 in cue)) {
          cue[prop3] = originalCue[prop3];
        }
      }
      cue.id = originalCue.id;
      cue.originalCue_ = originalCue;
    }
    var tracks = this.tech_.textTracks();
    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] !== this) {
        tracks[i].removeCue(cue);
      }
    }
    this.cues_.push(cue);
    this.cues.setCues_(this.cues_);
  };
  _proto.removeCue = function removeCue(_removeCue) {
    var i = this.cues_.length;
    while (i--) {
      var cue = this.cues_[i];
      if (cue === _removeCue || cue.originalCue_ && cue.originalCue_ === _removeCue) {
        this.cues_.splice(i, 1);
        this.cues.setCues_(this.cues_);
        break;
      }
    }
  };
  return TextTrack2;
}(Track);
TextTrack.prototype.allowedEvents_ = {
  cuechange: "cuechange"
};
var AudioTrack = /* @__PURE__ */ function(_Track) {
  _inheritsLoose(AudioTrack2, _Track);
  function AudioTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    var settings = mergeOptions$3(options, {
      kind: AudioTrackKind[options.kind] || ""
    });
    _this = _Track.call(this, settings) || this;
    var enabled = false;
    Object.defineProperty(_assertThisInitialized(_this), "enabled", {
      get: function get8() {
        return enabled;
      },
      set: function set4(newEnabled) {
        if (typeof newEnabled !== "boolean" || newEnabled === enabled) {
          return;
        }
        enabled = newEnabled;
        this.trigger("enabledchange");
      }
    });
    if (settings.enabled) {
      _this.enabled = settings.enabled;
    }
    _this.loaded_ = true;
    return _this;
  }
  return AudioTrack2;
}(Track);
var VideoTrack = /* @__PURE__ */ function(_Track) {
  _inheritsLoose(VideoTrack2, _Track);
  function VideoTrack2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    var settings = mergeOptions$3(options, {
      kind: VideoTrackKind[options.kind] || ""
    });
    _this = _Track.call(this, settings) || this;
    var selected = false;
    Object.defineProperty(_assertThisInitialized(_this), "selected", {
      get: function get8() {
        return selected;
      },
      set: function set4(newSelected) {
        if (typeof newSelected !== "boolean" || newSelected === selected) {
          return;
        }
        selected = newSelected;
        this.trigger("selectedchange");
      }
    });
    if (settings.selected) {
      _this.selected = settings.selected;
    }
    return _this;
  }
  return VideoTrack2;
}(Track);
var NONE = 0;
var LOADING = 1;
var LOADED = 2;
var ERROR = 3;
var HTMLTrackElement = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(HTMLTrackElement2, _EventTarget);
  function HTMLTrackElement2(options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    var readyState;
    var track = new TextTrack(options);
    _this.kind = track.kind;
    _this.src = track.src;
    _this.srclang = track.language;
    _this.label = track.label;
    _this["default"] = track["default"];
    Object.defineProperties(_assertThisInitialized(_this), {
      /**
       * @memberof HTMLTrackElement
       * @member {HTMLTrackElement~ReadyState} readyState
       *         The current ready state of the track element.
       * @instance
       */
      readyState: {
        get: function get8() {
          return readyState;
        }
      },
      /**
       * @memberof HTMLTrackElement
       * @member {TextTrack} track
       *         The underlying TextTrack object.
       * @instance
       *
       */
      track: {
        get: function get8() {
          return track;
        }
      }
    });
    readyState = NONE;
    track.addEventListener("loadeddata", function() {
      readyState = LOADED;
      _this.trigger({
        type: "load",
        target: _assertThisInitialized(_this)
      });
    });
    return _this;
  }
  return HTMLTrackElement2;
}(EventTarget$2);
HTMLTrackElement.prototype.allowedEvents_ = {
  load: "load"
};
HTMLTrackElement.NONE = NONE;
HTMLTrackElement.LOADING = LOADING;
HTMLTrackElement.LOADED = LOADED;
HTMLTrackElement.ERROR = ERROR;
var NORMAL = {
  audio: {
    ListClass: AudioTrackList,
    TrackClass: AudioTrack,
    capitalName: "Audio"
  },
  video: {
    ListClass: VideoTrackList,
    TrackClass: VideoTrack,
    capitalName: "Video"
  },
  text: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: "Text"
  }
};
Object.keys(NORMAL).forEach(function(type2) {
  NORMAL[type2].getterName = type2 + "Tracks";
  NORMAL[type2].privateName = type2 + "Tracks_";
});
var REMOTE = {
  remoteText: {
    ListClass: TextTrackList,
    TrackClass: TextTrack,
    capitalName: "RemoteText",
    getterName: "remoteTextTracks",
    privateName: "remoteTextTracks_"
  },
  remoteTextEl: {
    ListClass: HtmlTrackElementList,
    TrackClass: HTMLTrackElement,
    capitalName: "RemoteTextTrackEls",
    getterName: "remoteTextTrackEls",
    privateName: "remoteTextTrackEls_"
  }
};
var ALL = _extends$8({}, NORMAL, REMOTE);
REMOTE.names = Object.keys(REMOTE);
NORMAL.names = Object.keys(NORMAL);
ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
function createTrackHelper(self2, kind, label, language, options) {
  if (options === void 0) {
    options = {};
  }
  var tracks = self2.textTracks();
  options.kind = kind;
  if (label) {
    options.label = label;
  }
  if (language) {
    options.language = language;
  }
  options.tech = self2;
  var track = new ALL.text.TrackClass(options);
  tracks.addTrack(track);
  return track;
}
var Tech = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Tech2, _Component);
  function Tech2(options, ready) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (ready === void 0) {
      ready = function ready2() {
      };
    }
    options.reportTouchActivity = false;
    _this = _Component.call(this, null, options, ready) || this;
    _this.onDurationChange_ = function(e2) {
      return _this.onDurationChange(e2);
    };
    _this.trackProgress_ = function(e2) {
      return _this.trackProgress(e2);
    };
    _this.trackCurrentTime_ = function(e2) {
      return _this.trackCurrentTime(e2);
    };
    _this.stopTrackingCurrentTime_ = function(e2) {
      return _this.stopTrackingCurrentTime(e2);
    };
    _this.disposeSourceHandler_ = function(e2) {
      return _this.disposeSourceHandler(e2);
    };
    _this.queuedHanders_ = /* @__PURE__ */ new Set();
    _this.hasStarted_ = false;
    _this.on("playing", function() {
      this.hasStarted_ = true;
    });
    _this.on("loadstart", function() {
      this.hasStarted_ = false;
    });
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      if (options && options[props.getterName]) {
        _this[props.privateName] = options[props.getterName];
      }
    });
    if (!_this.featuresProgressEvents) {
      _this.manualProgressOn();
    }
    if (!_this.featuresTimeupdateEvents) {
      _this.manualTimeUpdatesOn();
    }
    ["Text", "Audio", "Video"].forEach(function(track) {
      if (options["native" + track + "Tracks"] === false) {
        _this["featuresNative" + track + "Tracks"] = false;
      }
    });
    if (options.nativeCaptions === false || options.nativeTextTracks === false) {
      _this.featuresNativeTextTracks = false;
    } else if (options.nativeCaptions === true || options.nativeTextTracks === true) {
      _this.featuresNativeTextTracks = true;
    }
    if (!_this.featuresNativeTextTracks) {
      _this.emulateTextTracks();
    }
    _this.preloadTextTracks = options.preloadTextTracks !== false;
    _this.autoRemoteTextTracks_ = new ALL.text.ListClass();
    _this.initTrackListeners();
    if (!options.nativeControlsForTouch) {
      _this.emitTapEvents();
    }
    if (_this.constructor) {
      _this.name_ = _this.constructor.name || "Unknown Tech";
    }
    return _this;
  }
  var _proto = Tech2.prototype;
  _proto.triggerSourceset = function triggerSourceset(src) {
    var _this2 = this;
    if (!this.isReady_) {
      this.one("ready", function() {
        return _this2.setTimeout(function() {
          return _this2.triggerSourceset(src);
        }, 1);
      });
    }
    this.trigger({
      src,
      type: "sourceset"
    });
  };
  _proto.manualProgressOn = function manualProgressOn() {
    this.on("durationchange", this.onDurationChange_);
    this.manualProgress = true;
    this.one("ready", this.trackProgress_);
  };
  _proto.manualProgressOff = function manualProgressOff() {
    this.manualProgress = false;
    this.stopTrackingProgress();
    this.off("durationchange", this.onDurationChange_);
  };
  _proto.trackProgress = function trackProgress(event) {
    this.stopTrackingProgress();
    this.progressInterval = this.setInterval(bind(this, function() {
      var numBufferedPercent = this.bufferedPercent();
      if (this.bufferedPercent_ !== numBufferedPercent) {
        this.trigger("progress");
      }
      this.bufferedPercent_ = numBufferedPercent;
      if (numBufferedPercent === 1) {
        this.stopTrackingProgress();
      }
    }), 500);
  };
  _proto.onDurationChange = function onDurationChange(event) {
    this.duration_ = this.duration();
  };
  _proto.buffered = function buffered() {
    return createTimeRanges(0, 0);
  };
  _proto.bufferedPercent = function bufferedPercent$1() {
    return bufferedPercent(this.buffered(), this.duration_);
  };
  _proto.stopTrackingProgress = function stopTrackingProgress() {
    this.clearInterval(this.progressInterval);
  };
  _proto.manualTimeUpdatesOn = function manualTimeUpdatesOn() {
    this.manualTimeUpdates = true;
    this.on("play", this.trackCurrentTime_);
    this.on("pause", this.stopTrackingCurrentTime_);
  };
  _proto.manualTimeUpdatesOff = function manualTimeUpdatesOff() {
    this.manualTimeUpdates = false;
    this.stopTrackingCurrentTime();
    this.off("play", this.trackCurrentTime_);
    this.off("pause", this.stopTrackingCurrentTime_);
  };
  _proto.trackCurrentTime = function trackCurrentTime() {
    if (this.currentTimeInterval) {
      this.stopTrackingCurrentTime();
    }
    this.currentTimeInterval = this.setInterval(function() {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }, 250);
  };
  _proto.stopTrackingCurrentTime = function stopTrackingCurrentTime() {
    this.clearInterval(this.currentTimeInterval);
    this.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: true
    });
  };
  _proto.dispose = function dispose() {
    this.clearTracks(NORMAL.names);
    if (this.manualProgress) {
      this.manualProgressOff();
    }
    if (this.manualTimeUpdates) {
      this.manualTimeUpdatesOff();
    }
    _Component.prototype.dispose.call(this);
  };
  _proto.clearTracks = function clearTracks(types) {
    var _this3 = this;
    types = [].concat(types);
    types.forEach(function(type2) {
      var list = _this3[type2 + "Tracks"]() || [];
      var i = list.length;
      while (i--) {
        var track = list[i];
        if (type2 === "text") {
          _this3.removeRemoteTextTrack(track);
        }
        list.removeTrack(track);
      }
    });
  };
  _proto.cleanupAutoTextTracks = function cleanupAutoTextTracks() {
    var list = this.autoRemoteTextTracks_ || [];
    var i = list.length;
    while (i--) {
      var track = list[i];
      this.removeRemoteTextTrack(track);
    }
  };
  _proto.reset = function reset3() {
  };
  _proto.crossOrigin = function crossOrigin() {
  };
  _proto.setCrossOrigin = function setCrossOrigin() {
  };
  _proto.error = function error(err) {
    if (err !== void 0) {
      this.error_ = new MediaError(err);
      this.trigger("error");
    }
    return this.error_;
  };
  _proto.played = function played() {
    if (this.hasStarted_) {
      return createTimeRanges(0, 0);
    }
    return createTimeRanges();
  };
  _proto.play = function play() {
  };
  _proto.setScrubbing = function setScrubbing() {
  };
  _proto.scrubbing = function scrubbing() {
  };
  _proto.setCurrentTime = function setCurrentTime() {
    if (this.manualTimeUpdates) {
      this.trigger({
        type: "timeupdate",
        target: this,
        manuallyTriggered: true
      });
    }
  };
  _proto.initTrackListeners = function initTrackListeners() {
    var _this4 = this;
    NORMAL.names.forEach(function(name) {
      var props = NORMAL[name];
      var trackListChanges = function trackListChanges2() {
        _this4.trigger(name + "trackchange");
      };
      var tracks = _this4[props.getterName]();
      tracks.addEventListener("removetrack", trackListChanges);
      tracks.addEventListener("addtrack", trackListChanges);
      _this4.on("dispose", function() {
        tracks.removeEventListener("removetrack", trackListChanges);
        tracks.removeEventListener("addtrack", trackListChanges);
      });
    });
  };
  _proto.addWebVttScript_ = function addWebVttScript_() {
    var _this5 = this;
    if (window_1.WebVTT) {
      return;
    }
    if (document_1.body.contains(this.el())) {
      if (!this.options_["vtt.js"] && isPlain(browserIndexExports) && Object.keys(browserIndexExports).length > 0) {
        this.trigger("vttjsloaded");
        return;
      }
      var script = document_1.createElement("script");
      script.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js";
      script.onload = function() {
        _this5.trigger("vttjsloaded");
      };
      script.onerror = function() {
        _this5.trigger("vttjserror");
      };
      this.on("dispose", function() {
        script.onload = null;
        script.onerror = null;
      });
      window_1.WebVTT = true;
      this.el().parentNode.appendChild(script);
    } else {
      this.ready(this.addWebVttScript_);
    }
  };
  _proto.emulateTextTracks = function emulateTextTracks() {
    var _this6 = this;
    var tracks = this.textTracks();
    var remoteTracks = this.remoteTextTracks();
    var handleAddTrack = function handleAddTrack2(e2) {
      return tracks.addTrack(e2.track);
    };
    var handleRemoveTrack = function handleRemoveTrack2(e2) {
      return tracks.removeTrack(e2.track);
    };
    remoteTracks.on("addtrack", handleAddTrack);
    remoteTracks.on("removetrack", handleRemoveTrack);
    this.addWebVttScript_();
    var updateDisplay = function updateDisplay2() {
      return _this6.trigger("texttrackchange");
    };
    var textTracksChanges = function textTracksChanges2() {
      updateDisplay();
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        track.removeEventListener("cuechange", updateDisplay);
        if (track.mode === "showing") {
          track.addEventListener("cuechange", updateDisplay);
        }
      }
    };
    textTracksChanges();
    tracks.addEventListener("change", textTracksChanges);
    tracks.addEventListener("addtrack", textTracksChanges);
    tracks.addEventListener("removetrack", textTracksChanges);
    this.on("dispose", function() {
      remoteTracks.off("addtrack", handleAddTrack);
      remoteTracks.off("removetrack", handleRemoveTrack);
      tracks.removeEventListener("change", textTracksChanges);
      tracks.removeEventListener("addtrack", textTracksChanges);
      tracks.removeEventListener("removetrack", textTracksChanges);
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        track.removeEventListener("cuechange", updateDisplay);
      }
    });
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (!kind) {
      throw new Error("TextTrack kind is required but was not provided");
    }
    return createTrackHelper(this, kind, label, language);
  };
  _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
    var track = mergeOptions$3(options, {
      tech: this
    });
    return new REMOTE.remoteTextEl.TrackClass(track);
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var _this7 = this;
    if (options === void 0) {
      options = {};
    }
    var htmlTrackElement = this.createRemoteTextTrack(options);
    if (manualCleanup !== true && manualCleanup !== false) {
      log$1.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js');
      manualCleanup = true;
    }
    this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
    this.remoteTextTracks().addTrack(htmlTrackElement.track);
    if (manualCleanup !== true) {
      this.ready(function() {
        return _this7.autoRemoteTextTracks_.addTrack(htmlTrackElement.track);
      });
    }
    return htmlTrackElement;
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    var trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
    this.remoteTextTrackEls().removeTrackElement_(trackElement);
    this.remoteTextTracks().removeTrack(track);
    this.autoRemoteTextTracks_.removeTrack(track);
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return {};
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    var PromiseClass = this.options_.Promise || window_1.Promise;
    if (PromiseClass) {
      return PromiseClass.reject();
    }
  };
  _proto.disablePictureInPicture = function disablePictureInPicture() {
    return true;
  };
  _proto.setDisablePictureInPicture = function setDisablePictureInPicture() {
  };
  _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb2) {
    var _this8 = this;
    var id2 = newGUID();
    if (!this.isReady_ || this.paused()) {
      this.queuedHanders_.add(id2);
      this.one("playing", function() {
        if (_this8.queuedHanders_.has(id2)) {
          _this8.queuedHanders_["delete"](id2);
          cb2();
        }
      });
    } else {
      this.requestNamedAnimationFrame(id2, cb2);
    }
    return id2;
  };
  _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id2) {
    if (this.queuedHanders_.has(id2)) {
      this.queuedHanders_["delete"](id2);
    } else {
      this.cancelNamedAnimationFrame(id2);
    }
  };
  _proto.setPoster = function setPoster() {
  };
  _proto.playsinline = function playsinline() {
  };
  _proto.setPlaysinline = function setPlaysinline() {
  };
  _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks() {
  };
  _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks() {
  };
  _proto.canPlayType = function canPlayType3() {
    return "";
  };
  Tech2.canPlayType = function canPlayType3() {
    return "";
  };
  Tech2.canPlaySource = function canPlaySource(srcObj, options) {
    return Tech2.canPlayType(srcObj.type);
  };
  Tech2.isTech = function isTech(component) {
    return component.prototype instanceof Tech2 || component instanceof Tech2 || component === Tech2;
  };
  Tech2.registerTech = function registerTech(name, tech) {
    if (!Tech2.techs_) {
      Tech2.techs_ = {};
    }
    if (!Tech2.isTech(tech)) {
      throw new Error("Tech " + name + " must be a Tech");
    }
    if (!Tech2.canPlayType) {
      throw new Error("Techs must have a static canPlayType method on them");
    }
    if (!Tech2.canPlaySource) {
      throw new Error("Techs must have a static canPlaySource method on them");
    }
    name = toTitleCase$1(name);
    Tech2.techs_[name] = tech;
    Tech2.techs_[toLowerCase(name)] = tech;
    if (name !== "Tech") {
      Tech2.defaultTechOrder_.push(name);
    }
    return tech;
  };
  Tech2.getTech = function getTech(name) {
    if (!name) {
      return;
    }
    if (Tech2.techs_ && Tech2.techs_[name]) {
      return Tech2.techs_[name];
    }
    name = toTitleCase$1(name);
    if (window_1 && window_1.videojs && window_1.videojs[name]) {
      log$1.warn("The " + name + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)");
      return window_1.videojs[name];
    }
  };
  return Tech2;
}(Component$1);
ALL.names.forEach(function(name) {
  var props = ALL[name];
  Tech.prototype[props.getterName] = function() {
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});
Tech.prototype.featuresVolumeControl = true;
Tech.prototype.featuresMuteControl = true;
Tech.prototype.featuresFullscreenResize = false;
Tech.prototype.featuresPlaybackRate = false;
Tech.prototype.featuresProgressEvents = false;
Tech.prototype.featuresSourceset = false;
Tech.prototype.featuresTimeupdateEvents = false;
Tech.prototype.featuresNativeTextTracks = false;
Tech.prototype.featuresVideoFrameCallback = false;
Tech.withSourceHandlers = function(_Tech) {
  _Tech.registerSourceHandler = function(handler, index2) {
    var handlers = _Tech.sourceHandlers;
    if (!handlers) {
      handlers = _Tech.sourceHandlers = [];
    }
    if (index2 === void 0) {
      index2 = handlers.length;
    }
    handlers.splice(index2, 0, handler);
  };
  _Tech.canPlayType = function(type2) {
    var handlers = _Tech.sourceHandlers || [];
    var can;
    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canPlayType(type2);
      if (can) {
        return can;
      }
    }
    return "";
  };
  _Tech.selectSourceHandler = function(source, options) {
    var handlers = _Tech.sourceHandlers || [];
    var can;
    for (var i = 0; i < handlers.length; i++) {
      can = handlers[i].canHandleSource(source, options);
      if (can) {
        return handlers[i];
      }
    }
    return null;
  };
  _Tech.canPlaySource = function(srcObj, options) {
    var sh2 = _Tech.selectSourceHandler(srcObj, options);
    if (sh2) {
      return sh2.canHandleSource(srcObj, options);
    }
    return "";
  };
  var deferrable = ["seekable", "seeking", "duration"];
  deferrable.forEach(function(fnName) {
    var originalFn = this[fnName];
    if (typeof originalFn !== "function") {
      return;
    }
    this[fnName] = function() {
      if (this.sourceHandler_ && this.sourceHandler_[fnName]) {
        return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
      }
      return originalFn.apply(this, arguments);
    };
  }, _Tech.prototype);
  _Tech.prototype.setSource = function(source) {
    var sh2 = _Tech.selectSourceHandler(source, this.options_);
    if (!sh2) {
      if (_Tech.nativeSourceHandler) {
        sh2 = _Tech.nativeSourceHandler;
      } else {
        log$1.error("No source handler found for the current source.");
      }
    }
    this.disposeSourceHandler();
    this.off("dispose", this.disposeSourceHandler_);
    if (sh2 !== _Tech.nativeSourceHandler) {
      this.currentSource_ = source;
    }
    this.sourceHandler_ = sh2.handleSource(source, this, this.options_);
    this.one("dispose", this.disposeSourceHandler_);
  };
  _Tech.prototype.disposeSourceHandler = function() {
    if (this.currentSource_) {
      this.clearTracks(["audio", "video"]);
      this.currentSource_ = null;
    }
    this.cleanupAutoTextTracks();
    if (this.sourceHandler_) {
      if (this.sourceHandler_.dispose) {
        this.sourceHandler_.dispose();
      }
      this.sourceHandler_ = null;
    }
  };
};
Component$1.registerComponent("Tech", Tech);
Tech.registerTech("Tech", Tech);
Tech.defaultTechOrder_ = [];
var middlewares = {};
var middlewareInstances = {};
var TERMINATOR = {};
function use(type2, middleware2) {
  middlewares[type2] = middlewares[type2] || [];
  middlewares[type2].push(middleware2);
}
function setSource(player, src, next2) {
  player.setTimeout(function() {
    return setSourceHelper(src, middlewares[src.type], next2, player);
  }, 1);
}
function setTech(middleware2, tech) {
  middleware2.forEach(function(mw) {
    return mw.setTech && mw.setTech(tech);
  });
}
function get(middleware2, tech, method) {
  return middleware2.reduceRight(middlewareIterator(method), tech[method]());
}
function set(middleware2, tech, method, arg) {
  return tech[method](middleware2.reduce(middlewareIterator(method), arg));
}
function mediate(middleware2, tech, method, arg) {
  if (arg === void 0) {
    arg = null;
  }
  var callMethod = "call" + toTitleCase$1(method);
  var middlewareValue = middleware2.reduce(middlewareIterator(callMethod), arg);
  var terminated = middlewareValue === TERMINATOR;
  var returnValue = terminated ? null : tech[method](middlewareValue);
  executeRight(middleware2, method, returnValue, terminated);
  return returnValue;
}
var allowedGetters = {
  buffered: 1,
  currentTime: 1,
  duration: 1,
  muted: 1,
  played: 1,
  paused: 1,
  seekable: 1,
  volume: 1,
  ended: 1
};
var allowedSetters = {
  setCurrentTime: 1,
  setMuted: 1,
  setVolume: 1
};
var allowedMediators = {
  play: 1,
  pause: 1
};
function middlewareIterator(method) {
  return function(value, mw) {
    if (value === TERMINATOR) {
      return TERMINATOR;
    }
    if (mw[method]) {
      return mw[method](value);
    }
    return value;
  };
}
function executeRight(mws, method, value, terminated) {
  for (var i = mws.length - 1; i >= 0; i--) {
    var mw = mws[i];
    if (mw[method]) {
      mw[method](terminated, value);
    }
  }
}
function clearCacheForPlayer(player) {
  middlewareInstances[player.id()] = null;
}
function getOrCreateFactory(player, mwFactory) {
  var mws = middlewareInstances[player.id()];
  var mw = null;
  if (mws === void 0 || mws === null) {
    mw = mwFactory(player);
    middlewareInstances[player.id()] = [[mwFactory, mw]];
    return mw;
  }
  for (var i = 0; i < mws.length; i++) {
    var _mws$i = mws[i], mwf = _mws$i[0], mwi = _mws$i[1];
    if (mwf !== mwFactory) {
      continue;
    }
    mw = mwi;
  }
  if (mw === null) {
    mw = mwFactory(player);
    mws.push([mwFactory, mw]);
  }
  return mw;
}
function setSourceHelper(src, middleware2, next2, player, acc, lastRun) {
  if (src === void 0) {
    src = {};
  }
  if (middleware2 === void 0) {
    middleware2 = [];
  }
  if (acc === void 0) {
    acc = [];
  }
  if (lastRun === void 0) {
    lastRun = false;
  }
  var _middleware = middleware2, mwFactory = _middleware[0], mwrest = _middleware.slice(1);
  if (typeof mwFactory === "string") {
    setSourceHelper(src, middlewares[mwFactory], next2, player, acc, lastRun);
  } else if (mwFactory) {
    var mw = getOrCreateFactory(player, mwFactory);
    if (!mw.setSource) {
      acc.push(mw);
      return setSourceHelper(src, mwrest, next2, player, acc, lastRun);
    }
    mw.setSource(assign$1({}, src), function(err, _src) {
      if (err) {
        return setSourceHelper(src, mwrest, next2, player, acc, lastRun);
      }
      acc.push(mw);
      setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next2, player, acc, lastRun);
    });
  } else if (mwrest.length) {
    setSourceHelper(src, mwrest, next2, player, acc, lastRun);
  } else if (lastRun) {
    next2(src, acc);
  } else {
    setSourceHelper(src, middlewares["*"], next2, player, acc, true);
  }
}
var MimetypesKind = {
  opus: "video/ogg",
  ogv: "video/ogg",
  mp4: "video/mp4",
  mov: "video/mp4",
  m4v: "video/mp4",
  mkv: "video/x-matroska",
  m4a: "audio/mp4",
  mp3: "audio/mpeg",
  aac: "audio/aac",
  caf: "audio/x-caf",
  flac: "audio/flac",
  oga: "audio/ogg",
  wav: "audio/wav",
  m3u8: "application/x-mpegURL",
  mpd: "application/dash+xml",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  gif: "image/gif",
  png: "image/png",
  svg: "image/svg+xml",
  webp: "image/webp"
};
var getMimetype = function getMimetype2(src) {
  if (src === void 0) {
    src = "";
  }
  var ext = getFileExtension(src);
  var mimetype = MimetypesKind[ext.toLowerCase()];
  return mimetype || "";
};
var findMimetype = function findMimetype2(player, src) {
  if (!src) {
    return "";
  }
  if (player.cache_.source.src === src && player.cache_.source.type) {
    return player.cache_.source.type;
  }
  var matchingSources = player.cache_.sources.filter(function(s2) {
    return s2.src === src;
  });
  if (matchingSources.length) {
    return matchingSources[0].type;
  }
  var sources = player.$$("source");
  for (var i = 0; i < sources.length; i++) {
    var s = sources[i];
    if (s.type && s.src && s.src === src) {
      return s.type;
    }
  }
  return getMimetype(src);
};
var filterSource = function filterSource2(src) {
  if (Array.isArray(src)) {
    var newsrc = [];
    src.forEach(function(srcobj) {
      srcobj = filterSource2(srcobj);
      if (Array.isArray(srcobj)) {
        newsrc = newsrc.concat(srcobj);
      } else if (isObject$1(srcobj)) {
        newsrc.push(srcobj);
      }
    });
    src = newsrc;
  } else if (typeof src === "string" && src.trim()) {
    src = [fixSource({
      src
    })];
  } else if (isObject$1(src) && typeof src.src === "string" && src.src && src.src.trim()) {
    src = [fixSource(src)];
  } else {
    src = [];
  }
  return src;
};
function fixSource(src) {
  if (!src.type) {
    var mimetype = getMimetype(src.src);
    if (mimetype) {
      src.type = mimetype;
    }
  }
  return src;
}
var MediaLoader = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(MediaLoader2, _Component);
  function MediaLoader2(player, options, ready) {
    var _this;
    var options_ = mergeOptions$3({
      createEl: false
    }, options);
    _this = _Component.call(this, player, options_, ready) || this;
    if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) {
      for (var i = 0, j2 = options.playerOptions.techOrder; i < j2.length; i++) {
        var techName = toTitleCase$1(j2[i]);
        var tech = Tech.getTech(techName);
        if (!techName) {
          tech = Component$1.getComponent(techName);
        }
        if (tech && tech.isSupported()) {
          player.loadTech_(techName);
          break;
        }
      }
    } else {
      player.src(options.playerOptions.sources);
    }
    return _this;
  }
  return MediaLoader2;
}(Component$1);
Component$1.registerComponent("MediaLoader", MediaLoader);
var ClickableComponent = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ClickableComponent2, _Component);
  function ClickableComponent2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    if (_this.options_.controlText) {
      _this.controlText(_this.options_.controlText);
    }
    _this.handleMouseOver_ = function(e2) {
      return _this.handleMouseOver(e2);
    };
    _this.handleMouseOut_ = function(e2) {
      return _this.handleMouseOut(e2);
    };
    _this.handleClick_ = function(e2) {
      return _this.handleClick(e2);
    };
    _this.handleKeyDown_ = function(e2) {
      return _this.handleKeyDown(e2);
    };
    _this.emitTapEvents();
    _this.enable();
    return _this;
  }
  var _proto = ClickableComponent2.prototype;
  _proto.createEl = function createEl$1(tag, props, attributes) {
    if (tag === void 0) {
      tag = "div";
    }
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    props = assign$1({
      className: this.buildCSSClass(),
      tabIndex: 0
    }, props);
    if (tag === "button") {
      log$1.error("Creating a ClickableComponent with an HTML element of " + tag + " is not supported; use a Button instead.");
    }
    attributes = assign$1({
      role: "button"
    }, attributes);
    this.tabIndex_ = props.tabIndex;
    var el2 = createEl(tag, props, attributes);
    el2.appendChild(createEl("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": true
    }));
    this.createControlTextEl(el2);
    return el2;
  };
  _proto.dispose = function dispose() {
    this.controlTextEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.createControlTextEl = function createControlTextEl(el2) {
    this.controlTextEl_ = createEl("span", {
      className: "vjs-control-text"
    }, {
      // let the screen reader user know that the text of the element may change
      "aria-live": "polite"
    });
    if (el2) {
      el2.appendChild(this.controlTextEl_);
    }
    this.controlText(this.controlText_, el2);
    return this.controlTextEl_;
  };
  _proto.controlText = function controlText(text, el2) {
    if (el2 === void 0) {
      el2 = this.el();
    }
    if (text === void 0) {
      return this.controlText_ || "Need Text";
    }
    var localizedText = this.localize(text);
    this.controlText_ = text;
    textContent(this.controlTextEl_, localizedText);
    if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) {
      el2.setAttribute("title", localizedText);
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-control vjs-button " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.enable = function enable() {
    if (!this.enabled_) {
      this.enabled_ = true;
      this.removeClass("vjs-disabled");
      this.el_.setAttribute("aria-disabled", "false");
      if (typeof this.tabIndex_ !== "undefined") {
        this.el_.setAttribute("tabIndex", this.tabIndex_);
      }
      this.on(["tap", "click"], this.handleClick_);
      this.on("keydown", this.handleKeyDown_);
    }
  };
  _proto.disable = function disable() {
    this.enabled_ = false;
    this.addClass("vjs-disabled");
    this.el_.setAttribute("aria-disabled", "true");
    if (typeof this.tabIndex_ !== "undefined") {
      this.el_.removeAttribute("tabIndex");
    }
    this.off("mouseover", this.handleMouseOver_);
    this.off("mouseout", this.handleMouseOut_);
    this.off(["tap", "click"], this.handleClick_);
    this.off("keydown", this.handleKeyDown_);
  };
  _proto.handleLanguagechange = function handleLanguagechange() {
    this.controlText(this.controlText_);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.options_.clickHandler) {
      this.options_.clickHandler.call(this, arguments);
    }
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    if (keycode.isEventKey(event, "Space") || keycode.isEventKey(event, "Enter")) {
      event.preventDefault();
      event.stopPropagation();
      this.trigger("click");
    } else {
      _Component.prototype.handleKeyDown.call(this, event);
    }
  };
  return ClickableComponent2;
}(Component$1);
Component$1.registerComponent("ClickableComponent", ClickableComponent);
var PosterImage = /* @__PURE__ */ function(_ClickableComponent) {
  _inheritsLoose(PosterImage2, _ClickableComponent);
  function PosterImage2(player, options) {
    var _this;
    _this = _ClickableComponent.call(this, player, options) || this;
    _this.update();
    _this.update_ = function(e2) {
      return _this.update(e2);
    };
    player.on("posterchange", _this.update_);
    return _this;
  }
  var _proto = PosterImage2.prototype;
  _proto.dispose = function dispose() {
    this.player().off("posterchange", this.update_);
    _ClickableComponent.prototype.dispose.call(this);
  };
  _proto.createEl = function createEl$1() {
    var el2 = createEl("div", {
      className: "vjs-poster",
      // Don't want poster to be tabbable.
      tabIndex: -1
    });
    return el2;
  };
  _proto.update = function update2(event) {
    var url = this.player().poster();
    this.setSrc(url);
    if (url) {
      this.show();
    } else {
      this.hide();
    }
  };
  _proto.setSrc = function setSrc(url) {
    var backgroundImage = "";
    if (url) {
      backgroundImage = 'url("' + url + '")';
    }
    this.el_.style.backgroundImage = backgroundImage;
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.controls()) {
      return;
    }
    var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
    if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where
    // calling .focus() on the video element causes the video to go black,
    // so we avoid it in that specific case
    !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
      this.player_.tech(true).focus();
    }
    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  };
  return PosterImage2;
}(ClickableComponent);
Component$1.registerComponent("PosterImage", PosterImage);
var darkGray = "#222";
var lightGray = "#ccc";
var fontMap = {
  monospace: "monospace",
  sansSerif: "sans-serif",
  serif: "serif",
  monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
  monospaceSerif: '"Courier New", monospace',
  proportionalSansSerif: "sans-serif",
  proportionalSerif: "serif",
  casual: '"Comic Sans MS", Impact, fantasy',
  script: '"Monotype Corsiva", cursive',
  smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
};
function constructColor(color2, opacity) {
  var hex;
  if (color2.length === 4) {
    hex = color2[1] + color2[1] + color2[2] + color2[2] + color2[3] + color2[3];
  } else if (color2.length === 7) {
    hex = color2.slice(1);
  } else {
    throw new Error("Invalid color code provided, " + color2 + "; must be formatted as e.g. #f0e or #f604e2.");
  }
  return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
}
function tryUpdateStyle(el2, style2, rule) {
  try {
    el2.style[style2] = rule;
  } catch (e2) {
    return;
  }
}
var TextTrackDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TextTrackDisplay2, _Component);
  function TextTrackDisplay2(player, options, ready) {
    var _this;
    _this = _Component.call(this, player, options, ready) || this;
    var updateDisplayHandler = function updateDisplayHandler2(e2) {
      return _this.updateDisplay(e2);
    };
    player.on("loadstart", function(e2) {
      return _this.toggleDisplay(e2);
    });
    player.on("texttrackchange", updateDisplayHandler);
    player.on("loadedmetadata", function(e2) {
      return _this.preselectTrack(e2);
    });
    player.ready(bind(_assertThisInitialized(_this), function() {
      if (player.tech_ && player.tech_.featuresNativeTextTracks) {
        this.hide();
        return;
      }
      player.on("fullscreenchange", updateDisplayHandler);
      player.on("playerresize", updateDisplayHandler);
      window_1.addEventListener("orientationchange", updateDisplayHandler);
      player.on("dispose", function() {
        return window_1.removeEventListener("orientationchange", updateDisplayHandler);
      });
      var tracks = this.options_.playerOptions.tracks || [];
      for (var i = 0; i < tracks.length; i++) {
        this.player_.addRemoteTextTrack(tracks[i], true);
      }
      this.preselectTrack();
    }));
    return _this;
  }
  var _proto = TextTrackDisplay2.prototype;
  _proto.preselectTrack = function preselectTrack() {
    var modes = {
      captions: 1,
      subtitles: 1
    };
    var trackList = this.player_.textTracks();
    var userPref = this.player_.cache_.selectedLanguage;
    var firstDesc;
    var firstCaptions;
    var preferredTrack;
    for (var i = 0; i < trackList.length; i++) {
      var track = trackList[i];
      if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
        if (track.kind === userPref.kind) {
          preferredTrack = track;
        } else if (!preferredTrack) {
          preferredTrack = track;
        }
      } else if (userPref && !userPref.enabled) {
        preferredTrack = null;
        firstDesc = null;
        firstCaptions = null;
      } else if (track["default"]) {
        if (track.kind === "descriptions" && !firstDesc) {
          firstDesc = track;
        } else if (track.kind in modes && !firstCaptions) {
          firstCaptions = track;
        }
      }
    }
    if (preferredTrack) {
      preferredTrack.mode = "showing";
    } else if (firstCaptions) {
      firstCaptions.mode = "showing";
    } else if (firstDesc) {
      firstDesc.mode = "showing";
    }
  };
  _proto.toggleDisplay = function toggleDisplay() {
    if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) {
      this.hide();
    } else {
      this.show();
    }
  };
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-text-track-display"
    }, {
      "translate": "yes",
      "aria-live": "off",
      "aria-atomic": "true"
    });
  };
  _proto.clearDisplay = function clearDisplay() {
    if (typeof window_1.WebVTT === "function") {
      window_1.WebVTT.processCues(window_1, [], this.el_);
    }
  };
  _proto.updateDisplay = function updateDisplay() {
    var tracks = this.player_.textTracks();
    var allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
    this.clearDisplay();
    if (allowMultipleShowingTracks) {
      var showingTracks = [];
      for (var _i = 0; _i < tracks.length; ++_i) {
        var track = tracks[_i];
        if (track.mode !== "showing") {
          continue;
        }
        showingTracks.push(track);
      }
      this.updateForTrack(showingTracks);
      return;
    }
    var descriptionsTrack = null;
    var captionsSubtitlesTrack = null;
    var i = tracks.length;
    while (i--) {
      var _track = tracks[i];
      if (_track.mode === "showing") {
        if (_track.kind === "descriptions") {
          descriptionsTrack = _track;
        } else {
          captionsSubtitlesTrack = _track;
        }
      }
    }
    if (captionsSubtitlesTrack) {
      if (this.getAttribute("aria-live") !== "off") {
        this.setAttribute("aria-live", "off");
      }
      this.updateForTrack(captionsSubtitlesTrack);
    } else if (descriptionsTrack) {
      if (this.getAttribute("aria-live") !== "assertive") {
        this.setAttribute("aria-live", "assertive");
      }
      this.updateForTrack(descriptionsTrack);
    }
  };
  _proto.updateDisplayState = function updateDisplayState(track) {
    var overrides = this.player_.textTrackSettings.getValues();
    var cues = track.activeCues;
    var i = cues.length;
    while (i--) {
      var cue = cues[i];
      if (!cue) {
        continue;
      }
      var cueDiv = cue.displayState;
      if (overrides.color) {
        cueDiv.firstChild.style.color = overrides.color;
      }
      if (overrides.textOpacity) {
        tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity));
      }
      if (overrides.backgroundColor) {
        cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
      }
      if (overrides.backgroundOpacity) {
        tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
      }
      if (overrides.windowColor) {
        if (overrides.windowOpacity) {
          tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity));
        } else {
          cueDiv.style.backgroundColor = overrides.windowColor;
        }
      }
      if (overrides.edgeStyle) {
        if (overrides.edgeStyle === "dropshadow") {
          cueDiv.firstChild.style.textShadow = "2px 2px 3px " + darkGray + ", 2px 2px 4px " + darkGray + ", 2px 2px 5px " + darkGray;
        } else if (overrides.edgeStyle === "raised") {
          cueDiv.firstChild.style.textShadow = "1px 1px " + darkGray + ", 2px 2px " + darkGray + ", 3px 3px " + darkGray;
        } else if (overrides.edgeStyle === "depressed") {
          cueDiv.firstChild.style.textShadow = "1px 1px " + lightGray + ", 0 1px " + lightGray + ", -1px -1px " + darkGray + ", 0 -1px " + darkGray;
        } else if (overrides.edgeStyle === "uniform") {
          cueDiv.firstChild.style.textShadow = "0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray + ", 0 0 4px " + darkGray;
        }
      }
      if (overrides.fontPercent && overrides.fontPercent !== 1) {
        var fontSize2 = window_1.parseFloat(cueDiv.style.fontSize);
        cueDiv.style.fontSize = fontSize2 * overrides.fontPercent + "px";
        cueDiv.style.height = "auto";
        cueDiv.style.top = "auto";
      }
      if (overrides.fontFamily && overrides.fontFamily !== "default") {
        if (overrides.fontFamily === "small-caps") {
          cueDiv.firstChild.style.fontVariant = "small-caps";
        } else {
          cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
        }
      }
    }
  };
  _proto.updateForTrack = function updateForTrack(tracks) {
    if (!Array.isArray(tracks)) {
      tracks = [tracks];
    }
    if (typeof window_1.WebVTT !== "function" || tracks.every(function(track2) {
      return !track2.activeCues;
    })) {
      return;
    }
    var cues = [];
    for (var i = 0; i < tracks.length; ++i) {
      var track = tracks[i];
      for (var j2 = 0; j2 < track.activeCues.length; ++j2) {
        cues.push(track.activeCues[j2]);
      }
    }
    window_1.WebVTT.processCues(window_1, cues, this.el_);
    for (var _i2 = 0; _i2 < tracks.length; ++_i2) {
      var _track2 = tracks[_i2];
      for (var _j = 0; _j < _track2.activeCues.length; ++_j) {
        var cueEl = _track2.activeCues[_j].displayState;
        addClass(cueEl, "vjs-text-track-cue");
        addClass(cueEl, "vjs-text-track-cue-" + (_track2.language ? _track2.language : _i2));
        if (_track2.language) {
          setAttribute(cueEl, "lang", _track2.language);
        }
      }
      if (this.player_.textTrackSettings) {
        this.updateDisplayState(_track2);
      }
    }
  };
  return TextTrackDisplay2;
}(Component$1);
Component$1.registerComponent("TextTrackDisplay", TextTrackDisplay);
var LoadingSpinner = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(LoadingSpinner2, _Component);
  function LoadingSpinner2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = LoadingSpinner2.prototype;
  _proto.createEl = function createEl$1() {
    var isAudio = this.player_.isAudio();
    var playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
    var controlText = createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize("{1} is loading.", [playerType])
    });
    var el2 = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-loading-spinner",
      dir: "ltr"
    });
    el2.appendChild(controlText);
    return el2;
  };
  return LoadingSpinner2;
}(Component$1);
Component$1.registerComponent("LoadingSpinner", LoadingSpinner);
var Button2 = /* @__PURE__ */ function(_ClickableComponent) {
  _inheritsLoose(Button3, _ClickableComponent);
  function Button3() {
    return _ClickableComponent.apply(this, arguments) || this;
  }
  var _proto = Button3.prototype;
  _proto.createEl = function createEl$1(tag, props, attributes) {
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    tag = "button";
    props = assign$1({
      className: this.buildCSSClass()
    }, props);
    attributes = assign$1({
      // Necessary since the default button type is "submit"
      type: "button"
    }, attributes);
    var el2 = createEl(tag, props, attributes);
    el2.appendChild(createEl("span", {
      className: "vjs-icon-placeholder"
    }, {
      "aria-hidden": true
    }));
    this.createControlTextEl(el2);
    return el2;
  };
  _proto.addChild = function addChild(child, options) {
    if (options === void 0) {
      options = {};
    }
    var className = this.constructor.name;
    log$1.warn("Adding an actionable (user controllable) child to a Button (" + className + ") is not supported; use a ClickableComponent instead.");
    return Component$1.prototype.addChild.call(this, child, options);
  };
  _proto.enable = function enable() {
    _ClickableComponent.prototype.enable.call(this);
    this.el_.removeAttribute("disabled");
  };
  _proto.disable = function disable() {
    _ClickableComponent.prototype.disable.call(this);
    this.el_.setAttribute("disabled", "disabled");
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    if (keycode.isEventKey(event, "Space") || keycode.isEventKey(event, "Enter")) {
      event.stopPropagation();
      return;
    }
    _ClickableComponent.prototype.handleKeyDown.call(this, event);
  };
  return Button3;
}(ClickableComponent);
Component$1.registerComponent("Button", Button2);
var BigPlayButton = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(BigPlayButton2, _Button);
  function BigPlayButton2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.mouseused_ = false;
    _this.on("mousedown", function(e2) {
      return _this.handleMouseDown(e2);
    });
    return _this;
  }
  var _proto = BigPlayButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-big-play-button";
  };
  _proto.handleClick = function handleClick(event) {
    var playPromise = this.player_.play();
    if (this.mouseused_ && event.clientX && event.clientY) {
      var sourceIsEncrypted = this.player_.usingPlugin("eme") && this.player_.eme.sessions && this.player_.eme.sessions.length > 0;
      silencePromise(playPromise);
      if (this.player_.tech(true) && // We've observed a bug in IE and Edge when playing back DRM content where
      // calling .focus() on the video element causes the video to go black,
      // so we avoid it in that specific case
      !((IE_VERSION || IS_EDGE) && sourceIsEncrypted)) {
        this.player_.tech(true).focus();
      }
      return;
    }
    var cb2 = this.player_.getChild("controlBar");
    var playToggle = cb2 && cb2.getChild("playToggle");
    if (!playToggle) {
      this.player_.tech(true).focus();
      return;
    }
    var playFocus = function playFocus2() {
      return playToggle.focus();
    };
    if (isPromise$1(playPromise)) {
      playPromise.then(playFocus, function() {
      });
    } else {
      this.setTimeout(playFocus, 1);
    }
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    this.mouseused_ = false;
    _Button.prototype.handleKeyDown.call(this, event);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    this.mouseused_ = true;
  };
  return BigPlayButton2;
}(Button2);
BigPlayButton.prototype.controlText_ = "Play Video";
Component$1.registerComponent("BigPlayButton", BigPlayButton);
var CloseButton = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(CloseButton2, _Button);
  function CloseButton2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.controlText(options && options.controlText || _this.localize("Close"));
    return _this;
  }
  var _proto = CloseButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-close-button " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    this.trigger({
      type: "close",
      bubbles: false
    });
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    if (keycode.isEventKey(event, "Esc")) {
      event.preventDefault();
      event.stopPropagation();
      this.trigger("click");
    } else {
      _Button.prototype.handleKeyDown.call(this, event);
    }
  };
  return CloseButton2;
}(Button2);
Component$1.registerComponent("CloseButton", CloseButton);
var PlayToggle = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(PlayToggle2, _Button);
  function PlayToggle2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Button.call(this, player, options) || this;
    options.replay = options.replay === void 0 || options.replay;
    _this.on(player, "play", function(e2) {
      return _this.handlePlay(e2);
    });
    _this.on(player, "pause", function(e2) {
      return _this.handlePause(e2);
    });
    if (options.replay) {
      _this.on(player, "ended", function(e2) {
        return _this.handleEnded(e2);
      });
    }
    return _this;
  }
  var _proto = PlayToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-play-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.player_.paused()) {
      silencePromise(this.player_.play());
    } else {
      this.player_.pause();
    }
  };
  _proto.handleSeeked = function handleSeeked(event) {
    this.removeClass("vjs-ended");
    if (this.player_.paused()) {
      this.handlePause(event);
    } else {
      this.handlePlay(event);
    }
  };
  _proto.handlePlay = function handlePlay(event) {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-paused");
    this.addClass("vjs-playing");
    this.controlText("Pause");
  };
  _proto.handlePause = function handlePause(event) {
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.controlText("Play");
  };
  _proto.handleEnded = function handleEnded(event) {
    var _this2 = this;
    this.removeClass("vjs-playing");
    this.addClass("vjs-ended");
    this.controlText("Replay");
    this.one(this.player_, "seeked", function(e2) {
      return _this2.handleSeeked(e2);
    });
  };
  return PlayToggle2;
}(Button2);
PlayToggle.prototype.controlText_ = "Play";
Component$1.registerComponent("PlayToggle", PlayToggle);
var defaultImplementation = function defaultImplementation2(seconds, guide) {
  seconds = seconds < 0 ? 0 : seconds;
  var s = Math.floor(seconds % 60);
  var m2 = Math.floor(seconds / 60 % 60);
  var h2 = Math.floor(seconds / 3600);
  var gm = Math.floor(guide / 60 % 60);
  var gh2 = Math.floor(guide / 3600);
  if (isNaN(seconds) || seconds === Infinity) {
    h2 = m2 = s = "-";
  }
  h2 = h2 > 0 || gh2 > 0 ? h2 + ":" : "";
  m2 = ((h2 || gm >= 10) && m2 < 10 ? "0" + m2 : m2) + ":";
  s = s < 10 ? "0" + s : s;
  return h2 + m2 + s;
};
var implementation = defaultImplementation;
function setFormatTime(customImplementation) {
  implementation = customImplementation;
}
function resetFormatTime() {
  implementation = defaultImplementation;
}
function formatTime(seconds, guide) {
  if (guide === void 0) {
    guide = seconds;
  }
  return implementation(seconds, guide);
}
var TimeDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TimeDisplay2, _Component);
  function TimeDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.on(player, ["timeupdate", "ended"], function(e2) {
      return _this.updateContent(e2);
    });
    _this.updateTextNode_();
    return _this;
  }
  var _proto = TimeDisplay2.prototype;
  _proto.createEl = function createEl$1() {
    var className = this.buildCSSClass();
    var el2 = _Component.prototype.createEl.call(this, "div", {
      className: className + " vjs-time-control vjs-control"
    });
    var span = createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize(this.labelText_) + ""
    }, {
      role: "presentation"
    });
    el2.appendChild(span);
    this.contentEl_ = createEl("span", {
      className: className + "-display"
    }, {
      // tell screen readers not to automatically read the time as it changes
      "aria-live": "off",
      // span elements have no implicit role, but some screen readers (notably VoiceOver)
      // treat them as a break between items in the DOM when using arrow keys
      // (or left-to-right swipes on iOS) to read contents of a page. Using
      // role='presentation' causes VoiceOver to NOT treat this span as a break.
      "role": "presentation"
    });
    el2.appendChild(this.contentEl_);
    return el2;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.textNode_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.updateTextNode_ = function updateTextNode_(time2) {
    var _this2 = this;
    if (time2 === void 0) {
      time2 = 0;
    }
    time2 = formatTime(time2);
    if (this.formattedTime_ === time2) {
      return;
    }
    this.formattedTime_ = time2;
    this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", function() {
      if (!_this2.contentEl_) {
        return;
      }
      var oldNode = _this2.textNode_;
      if (oldNode && _this2.contentEl_.firstChild !== oldNode) {
        oldNode = null;
        log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.");
      }
      _this2.textNode_ = document_1.createTextNode(_this2.formattedTime_);
      if (!_this2.textNode_) {
        return;
      }
      if (oldNode) {
        _this2.contentEl_.replaceChild(_this2.textNode_, oldNode);
      } else {
        _this2.contentEl_.appendChild(_this2.textNode_);
      }
    });
  };
  _proto.updateContent = function updateContent(event) {
  };
  return TimeDisplay2;
}(Component$1);
TimeDisplay.prototype.labelText_ = "Time";
TimeDisplay.prototype.controlText_ = "Time";
Component$1.registerComponent("TimeDisplay", TimeDisplay);
var CurrentTimeDisplay = /* @__PURE__ */ function(_TimeDisplay) {
  _inheritsLoose(CurrentTimeDisplay2, _TimeDisplay);
  function CurrentTimeDisplay2() {
    return _TimeDisplay.apply(this, arguments) || this;
  }
  var _proto = CurrentTimeDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-current-time";
  };
  _proto.updateContent = function updateContent(event) {
    var time2;
    if (this.player_.ended()) {
      time2 = this.player_.duration();
    } else {
      time2 = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    }
    this.updateTextNode_(time2);
  };
  return CurrentTimeDisplay2;
}(TimeDisplay);
CurrentTimeDisplay.prototype.labelText_ = "Current Time";
CurrentTimeDisplay.prototype.controlText_ = "Current Time";
Component$1.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
var DurationDisplay = /* @__PURE__ */ function(_TimeDisplay) {
  _inheritsLoose(DurationDisplay2, _TimeDisplay);
  function DurationDisplay2(player, options) {
    var _this;
    _this = _TimeDisplay.call(this, player, options) || this;
    var updateContent = function updateContent2(e2) {
      return _this.updateContent(e2);
    };
    _this.on(player, "durationchange", updateContent);
    _this.on(player, "loadstart", updateContent);
    _this.on(player, "loadedmetadata", updateContent);
    return _this;
  }
  var _proto = DurationDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-duration";
  };
  _proto.updateContent = function updateContent(event) {
    var duration5 = this.player_.duration();
    this.updateTextNode_(duration5);
  };
  return DurationDisplay2;
}(TimeDisplay);
DurationDisplay.prototype.labelText_ = "Duration";
DurationDisplay.prototype.controlText_ = "Duration";
Component$1.registerComponent("DurationDisplay", DurationDisplay);
var TimeDivider = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TimeDivider2, _Component);
  function TimeDivider2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = TimeDivider2.prototype;
  _proto.createEl = function createEl2() {
    var el2 = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-time-control vjs-time-divider"
    }, {
      // this element and its contents can be hidden from assistive techs since
      // it is made extraneous by the announcement of the control text
      // for the current time and duration displays
      "aria-hidden": true
    });
    var div = _Component.prototype.createEl.call(this, "div");
    var span = _Component.prototype.createEl.call(this, "span", {
      textContent: "/"
    });
    div.appendChild(span);
    el2.appendChild(div);
    return el2;
  };
  return TimeDivider2;
}(Component$1);
Component$1.registerComponent("TimeDivider", TimeDivider);
var RemainingTimeDisplay = /* @__PURE__ */ function(_TimeDisplay) {
  _inheritsLoose(RemainingTimeDisplay2, _TimeDisplay);
  function RemainingTimeDisplay2(player, options) {
    var _this;
    _this = _TimeDisplay.call(this, player, options) || this;
    _this.on(player, "durationchange", function(e2) {
      return _this.updateContent(e2);
    });
    return _this;
  }
  var _proto = RemainingTimeDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-remaining-time";
  };
  _proto.createEl = function createEl$1() {
    var el2 = _TimeDisplay.prototype.createEl.call(this);
    if (this.options_.displayNegative !== false) {
      el2.insertBefore(createEl("span", {}, {
        "aria-hidden": true
      }, "-"), this.contentEl_);
    }
    return el2;
  };
  _proto.updateContent = function updateContent(event) {
    if (typeof this.player_.duration() !== "number") {
      return;
    }
    var time2;
    if (this.player_.ended()) {
      time2 = 0;
    } else if (this.player_.remainingTimeDisplay) {
      time2 = this.player_.remainingTimeDisplay();
    } else {
      time2 = this.player_.remainingTime();
    }
    this.updateTextNode_(time2);
  };
  return RemainingTimeDisplay2;
}(TimeDisplay);
RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
Component$1.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
var LiveDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(LiveDisplay2, _Component);
  function LiveDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.updateShowing();
    _this.on(_this.player(), "durationchange", function(e2) {
      return _this.updateShowing(e2);
    });
    return _this;
  }
  var _proto = LiveDisplay2.prototype;
  _proto.createEl = function createEl$1() {
    var el2 = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-live-control vjs-control"
    });
    this.contentEl_ = createEl("div", {
      className: "vjs-live-display"
    }, {
      "aria-live": "off"
    });
    this.contentEl_.appendChild(createEl("span", {
      className: "vjs-control-text",
      textContent: this.localize("Stream Type") + ""
    }));
    this.contentEl_.appendChild(document_1.createTextNode(this.localize("LIVE")));
    el2.appendChild(this.contentEl_);
    return el2;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.updateShowing = function updateShowing(event) {
    if (this.player().duration() === Infinity) {
      this.show();
    } else {
      this.hide();
    }
  };
  return LiveDisplay2;
}(Component$1);
Component$1.registerComponent("LiveDisplay", LiveDisplay);
var SeekToLive = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(SeekToLive2, _Button);
  function SeekToLive2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.updateLiveEdgeStatus();
    if (_this.player_.liveTracker) {
      _this.updateLiveEdgeStatusHandler_ = function(e2) {
        return _this.updateLiveEdgeStatus(e2);
      };
      _this.on(_this.player_.liveTracker, "liveedgechange", _this.updateLiveEdgeStatusHandler_);
    }
    return _this;
  }
  var _proto = SeekToLive2.prototype;
  _proto.createEl = function createEl$1() {
    var el2 = _Button.prototype.createEl.call(this, "button", {
      className: "vjs-seek-to-live-control vjs-control"
    });
    this.textEl_ = createEl("span", {
      className: "vjs-seek-to-live-text",
      textContent: this.localize("LIVE")
    }, {
      "aria-hidden": "true"
    });
    el2.appendChild(this.textEl_);
    return el2;
  };
  _proto.updateLiveEdgeStatus = function updateLiveEdgeStatus() {
    if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
      this.setAttribute("aria-disabled", true);
      this.addClass("vjs-at-live-edge");
      this.controlText("Seek to live, currently playing live");
    } else {
      this.setAttribute("aria-disabled", false);
      this.removeClass("vjs-at-live-edge");
      this.controlText("Seek to live, currently behind live");
    }
  };
  _proto.handleClick = function handleClick() {
    this.player_.liveTracker.seekToLiveEdge();
  };
  _proto.dispose = function dispose() {
    if (this.player_.liveTracker) {
      this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
    }
    this.textEl_ = null;
    _Button.prototype.dispose.call(this);
  };
  return SeekToLive2;
}(Button2);
SeekToLive.prototype.controlText_ = "Seek to live, currently playing live";
Component$1.registerComponent("SeekToLive", SeekToLive);
var clamp = function clamp2(number, min2, max2) {
  number = Number(number);
  return Math.min(max2, Math.max(min2, isNaN(number) ? min2 : number));
};
var Slider = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Slider2, _Component);
  function Slider2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleMouseDown_ = function(e2) {
      return _this.handleMouseDown(e2);
    };
    _this.handleMouseUp_ = function(e2) {
      return _this.handleMouseUp(e2);
    };
    _this.handleKeyDown_ = function(e2) {
      return _this.handleKeyDown(e2);
    };
    _this.handleClick_ = function(e2) {
      return _this.handleClick(e2);
    };
    _this.handleMouseMove_ = function(e2) {
      return _this.handleMouseMove(e2);
    };
    _this.update_ = function(e2) {
      return _this.update(e2);
    };
    _this.bar = _this.getChild(_this.options_.barName);
    _this.vertical(!!_this.options_.vertical);
    _this.enable();
    return _this;
  }
  var _proto = Slider2.prototype;
  _proto.enabled = function enabled() {
    return this.enabled_;
  };
  _proto.enable = function enable() {
    if (this.enabled()) {
      return;
    }
    this.on("mousedown", this.handleMouseDown_);
    this.on("touchstart", this.handleMouseDown_);
    this.on("keydown", this.handleKeyDown_);
    this.on("click", this.handleClick_);
    this.on(this.player_, "controlsvisible", this.update);
    if (this.playerEvent) {
      this.on(this.player_, this.playerEvent, this.update);
    }
    this.removeClass("disabled");
    this.setAttribute("tabindex", 0);
    this.enabled_ = true;
  };
  _proto.disable = function disable() {
    if (!this.enabled()) {
      return;
    }
    var doc = this.bar.el_.ownerDocument;
    this.off("mousedown", this.handleMouseDown_);
    this.off("touchstart", this.handleMouseDown_);
    this.off("keydown", this.handleKeyDown_);
    this.off("click", this.handleClick_);
    this.off(this.player_, "controlsvisible", this.update_);
    this.off(doc, "mousemove", this.handleMouseMove_);
    this.off(doc, "mouseup", this.handleMouseUp_);
    this.off(doc, "touchmove", this.handleMouseMove_);
    this.off(doc, "touchend", this.handleMouseUp_);
    this.removeAttribute("tabindex");
    this.addClass("disabled");
    if (this.playerEvent) {
      this.off(this.player_, this.playerEvent, this.update);
    }
    this.enabled_ = false;
  };
  _proto.createEl = function createEl2(type2, props, attributes) {
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    props.className = props.className + " vjs-slider";
    props = assign$1({
      tabIndex: 0
    }, props);
    attributes = assign$1({
      "role": "slider",
      "aria-valuenow": 0,
      "aria-valuemin": 0,
      "aria-valuemax": 100,
      "tabIndex": 0
    }, attributes);
    return _Component.prototype.createEl.call(this, type2, props, attributes);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.bar.el_.ownerDocument;
    if (event.type === "mousedown") {
      event.preventDefault();
    }
    if (event.type === "touchstart" && !IS_CHROME) {
      event.preventDefault();
    }
    blockTextSelection();
    this.addClass("vjs-sliding");
    this.trigger("slideractive");
    this.on(doc, "mousemove", this.handleMouseMove_);
    this.on(doc, "mouseup", this.handleMouseUp_);
    this.on(doc, "touchmove", this.handleMouseMove_);
    this.on(doc, "touchend", this.handleMouseUp_);
    this.handleMouseMove(event, true);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
  };
  _proto.handleMouseUp = function handleMouseUp() {
    var doc = this.bar.el_.ownerDocument;
    unblockTextSelection();
    this.removeClass("vjs-sliding");
    this.trigger("sliderinactive");
    this.off(doc, "mousemove", this.handleMouseMove_);
    this.off(doc, "mouseup", this.handleMouseUp_);
    this.off(doc, "touchmove", this.handleMouseMove_);
    this.off(doc, "touchend", this.handleMouseUp_);
    this.update();
  };
  _proto.update = function update2() {
    var _this2 = this;
    if (!this.el_ || !this.bar) {
      return;
    }
    var progress = this.getProgress();
    if (progress === this.progress_) {
      return progress;
    }
    this.progress_ = progress;
    this.requestNamedAnimationFrame("Slider#update", function() {
      var sizeKey = _this2.vertical() ? "height" : "width";
      _this2.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + "%";
    });
    return progress;
  };
  _proto.getProgress = function getProgress() {
    return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
  };
  _proto.calculateDistance = function calculateDistance(event) {
    var position3 = getPointerPosition(this.el_, event);
    if (this.vertical()) {
      return position3.y;
    }
    return position3.x;
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    if (keycode.isEventKey(event, "Left") || keycode.isEventKey(event, "Down")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepBack();
    } else if (keycode.isEventKey(event, "Right") || keycode.isEventKey(event, "Up")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepForward();
    } else {
      _Component.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.handleClick = function handleClick(event) {
    event.stopPropagation();
    event.preventDefault();
  };
  _proto.vertical = function vertical2(bool) {
    if (bool === void 0) {
      return this.vertical_ || false;
    }
    this.vertical_ = !!bool;
    if (this.vertical_) {
      this.addClass("vjs-slider-vertical");
    } else {
      this.addClass("vjs-slider-horizontal");
    }
  };
  return Slider2;
}(Component$1);
Component$1.registerComponent("Slider", Slider);
var percentify = function percentify2(time2, end2) {
  return clamp(time2 / end2 * 100, 0, 100).toFixed(2) + "%";
};
var LoadProgressBar = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(LoadProgressBar2, _Component);
  function LoadProgressBar2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.partEls_ = [];
    _this.on(player, "progress", function(e2) {
      return _this.update(e2);
    });
    return _this;
  }
  var _proto = LoadProgressBar2.prototype;
  _proto.createEl = function createEl$1() {
    var el2 = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-load-progress"
    });
    var wrapper = createEl("span", {
      className: "vjs-control-text"
    });
    var loadedText = createEl("span", {
      textContent: this.localize("Loaded")
    });
    var separator = document_1.createTextNode(": ");
    this.percentageEl_ = createEl("span", {
      className: "vjs-control-text-loaded-percentage",
      textContent: "0%"
    });
    el2.appendChild(wrapper);
    wrapper.appendChild(loadedText);
    wrapper.appendChild(separator);
    wrapper.appendChild(this.percentageEl_);
    return el2;
  };
  _proto.dispose = function dispose() {
    this.partEls_ = null;
    this.percentageEl_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.update = function update2(event) {
    var _this2 = this;
    this.requestNamedAnimationFrame("LoadProgressBar#update", function() {
      var liveTracker = _this2.player_.liveTracker;
      var buffered = _this2.player_.buffered();
      var duration5 = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : _this2.player_.duration();
      var bufferedEnd = _this2.player_.bufferedEnd();
      var children = _this2.partEls_;
      var percent = percentify(bufferedEnd, duration5);
      if (_this2.percent_ !== percent) {
        _this2.el_.style.width = percent;
        textContent(_this2.percentageEl_, percent);
        _this2.percent_ = percent;
      }
      for (var i = 0; i < buffered.length; i++) {
        var start3 = buffered.start(i);
        var end2 = buffered.end(i);
        var part = children[i];
        if (!part) {
          part = _this2.el_.appendChild(createEl());
          children[i] = part;
        }
        if (part.dataset.start === start3 && part.dataset.end === end2) {
          continue;
        }
        part.dataset.start = start3;
        part.dataset.end = end2;
        part.style.left = percentify(start3, bufferedEnd);
        part.style.width = percentify(end2 - start3, bufferedEnd);
      }
      for (var _i = children.length; _i > buffered.length; _i--) {
        _this2.el_.removeChild(children[_i - 1]);
      }
      children.length = buffered.length;
    });
  };
  return LoadProgressBar2;
}(Component$1);
Component$1.registerComponent("LoadProgressBar", LoadProgressBar);
var TimeTooltip = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(TimeTooltip2, _Component);
  function TimeTooltip2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle$1(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = TimeTooltip2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-time-tooltip"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update2(seekBarRect, seekBarPoint, content) {
    var tooltipRect = findPosition(this.el_);
    var playerRect = getBoundingClientRect(this.player_.el());
    var seekBarPointPx = seekBarRect.width * seekBarPoint;
    if (!playerRect || !tooltipRect) {
      return;
    }
    var spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
    var spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
    var pullTooltipBy = tooltipRect.width / 2;
    if (spaceLeftOfPoint < pullTooltipBy) {
      pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
    } else if (spaceRightOfPoint < pullTooltipBy) {
      pullTooltipBy = spaceRightOfPoint;
    }
    if (pullTooltipBy < 0) {
      pullTooltipBy = 0;
    } else if (pullTooltipBy > tooltipRect.width) {
      pullTooltipBy = tooltipRect.width;
    }
    pullTooltipBy = Math.round(pullTooltipBy);
    this.el_.style.right = "-" + pullTooltipBy + "px";
    this.write(content);
  };
  _proto.write = function write2(content) {
    textContent(this.el_, content);
  };
  _proto.updateTime = function updateTime(seekBarRect, seekBarPoint, time2, cb2) {
    var _this2 = this;
    this.requestNamedAnimationFrame("TimeTooltip#updateTime", function() {
      var content;
      var duration5 = _this2.player_.duration();
      if (_this2.player_.liveTracker && _this2.player_.liveTracker.isLive()) {
        var liveWindow = _this2.player_.liveTracker.liveWindow();
        var secondsBehind = liveWindow - seekBarPoint * liveWindow;
        content = (secondsBehind < 1 ? "" : "-") + formatTime(secondsBehind, liveWindow);
      } else {
        content = formatTime(time2, duration5);
      }
      _this2.update(seekBarRect, seekBarPoint, content);
      if (cb2) {
        cb2();
      }
    });
  };
  return TimeTooltip2;
}(Component$1);
Component$1.registerComponent("TimeTooltip", TimeTooltip);
var PlayProgressBar = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(PlayProgressBar2, _Component);
  function PlayProgressBar2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle$1(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = PlayProgressBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-play-progress vjs-slider-bar"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update2(seekBarRect, seekBarPoint) {
    var timeTooltip = this.getChild("timeTooltip");
    if (!timeTooltip) {
      return;
    }
    var time2 = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
    timeTooltip.updateTime(seekBarRect, seekBarPoint, time2);
  };
  return PlayProgressBar2;
}(Component$1);
PlayProgressBar.prototype.options_ = {
  children: []
};
if (!IS_IOS && !IS_ANDROID) {
  PlayProgressBar.prototype.options_.children.push("timeTooltip");
}
Component$1.registerComponent("PlayProgressBar", PlayProgressBar);
var MouseTimeDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(MouseTimeDisplay2, _Component);
  function MouseTimeDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle$1(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = MouseTimeDisplay2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  };
  _proto.update = function update2(seekBarRect, seekBarPoint) {
    var _this2 = this;
    var time2 = seekBarPoint * this.player_.duration();
    this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time2, function() {
      _this2.el_.style.left = seekBarRect.width * seekBarPoint + "px";
    });
  };
  return MouseTimeDisplay2;
}(Component$1);
MouseTimeDisplay.prototype.options_ = {
  children: ["timeTooltip"]
};
Component$1.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
var STEP_SECONDS = 5;
var PAGE_KEY_MULTIPLIER = 12;
var SeekBar = /* @__PURE__ */ function(_Slider) {
  _inheritsLoose(SeekBar2, _Slider);
  function SeekBar2(player, options) {
    var _this;
    _this = _Slider.call(this, player, options) || this;
    _this.setEventHandlers_();
    return _this;
  }
  var _proto = SeekBar2.prototype;
  _proto.setEventHandlers_ = function setEventHandlers_() {
    var _this2 = this;
    this.update_ = bind(this, this.update);
    this.update = throttle$1(this.update_, UPDATE_REFRESH_INTERVAL);
    this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
    if (this.player_.liveTracker) {
      this.on(this.player_.liveTracker, "liveedgechange", this.update);
    }
    this.updateInterval = null;
    this.enableIntervalHandler_ = function(e2) {
      return _this2.enableInterval_(e2);
    };
    this.disableIntervalHandler_ = function(e2) {
      return _this2.disableInterval_(e2);
    };
    this.on(this.player_, ["playing"], this.enableIntervalHandler_);
    this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
    if ("hidden" in document_1 && "visibilityState" in document_1) {
      this.on(document_1, "visibilitychange", this.toggleVisibility_);
    }
  };
  _proto.toggleVisibility_ = function toggleVisibility_(e2) {
    if (document_1.visibilityState === "hidden") {
      this.cancelNamedAnimationFrame("SeekBar#update");
      this.cancelNamedAnimationFrame("Slider#update");
      this.disableInterval_(e2);
    } else {
      if (!this.player_.ended() && !this.player_.paused()) {
        this.enableInterval_();
      }
      this.update();
    }
  };
  _proto.enableInterval_ = function enableInterval_() {
    if (this.updateInterval) {
      return;
    }
    this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
  };
  _proto.disableInterval_ = function disableInterval_(e2) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e2 && e2.type !== "ended") {
      return;
    }
    if (!this.updateInterval) {
      return;
    }
    this.clearInterval(this.updateInterval);
    this.updateInterval = null;
  };
  _proto.createEl = function createEl2() {
    return _Slider.prototype.createEl.call(this, "div", {
      className: "vjs-progress-holder"
    }, {
      "aria-label": this.localize("Progress Bar")
    });
  };
  _proto.update = function update2(event) {
    var _this3 = this;
    if (document_1.visibilityState === "hidden") {
      return;
    }
    var percent = _Slider.prototype.update.call(this);
    this.requestNamedAnimationFrame("SeekBar#update", function() {
      var currentTime = _this3.player_.ended() ? _this3.player_.duration() : _this3.getCurrentTime_();
      var liveTracker = _this3.player_.liveTracker;
      var duration5 = _this3.player_.duration();
      if (liveTracker && liveTracker.isLive()) {
        duration5 = _this3.player_.liveTracker.liveCurrentTime();
      }
      if (_this3.percent_ !== percent) {
        _this3.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
        _this3.percent_ = percent;
      }
      if (_this3.currentTime_ !== currentTime || _this3.duration_ !== duration5) {
        _this3.el_.setAttribute("aria-valuetext", _this3.localize("progress bar timing: currentTime={1} duration={2}", [formatTime(currentTime, duration5), formatTime(duration5, duration5)], "{1} of {2}"));
        _this3.currentTime_ = currentTime;
        _this3.duration_ = duration5;
      }
      if (_this3.bar) {
        _this3.bar.update(getBoundingClientRect(_this3.el()), _this3.getProgress());
      }
    });
    return percent;
  };
  _proto.userSeek_ = function userSeek_(ct) {
    if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
      this.player_.liveTracker.nextSeekedFromUser();
    }
    this.player_.currentTime(ct);
  };
  _proto.getCurrentTime_ = function getCurrentTime_() {
    return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
  };
  _proto.getPercent = function getPercent() {
    var currentTime = this.getCurrentTime_();
    var percent;
    var liveTracker = this.player_.liveTracker;
    if (liveTracker && liveTracker.isLive()) {
      percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
      if (liveTracker.atLiveEdge()) {
        percent = 1;
      }
    } else {
      percent = currentTime / this.player_.duration();
    }
    return percent;
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }
    event.stopPropagation();
    this.videoWasPlaying = !this.player_.paused();
    this.player_.pause();
    _Slider.prototype.handleMouseDown.call(this, event);
  };
  _proto.handleMouseMove = function handleMouseMove(event, mouseDown) {
    if (mouseDown === void 0) {
      mouseDown = false;
    }
    if (!isSingleLeftClick(event)) {
      return;
    }
    if (!mouseDown && !this.player_.scrubbing()) {
      this.player_.scrubbing(true);
    }
    var newTime;
    var distance3 = this.calculateDistance(event);
    var liveTracker = this.player_.liveTracker;
    if (!liveTracker || !liveTracker.isLive()) {
      newTime = distance3 * this.player_.duration();
      if (newTime === this.player_.duration()) {
        newTime = newTime - 0.1;
      }
    } else {
      if (distance3 >= 0.99) {
        liveTracker.seekToLiveEdge();
        return;
      }
      var seekableStart = liveTracker.seekableStart();
      var seekableEnd = liveTracker.liveCurrentTime();
      newTime = seekableStart + distance3 * liveTracker.liveWindow();
      if (newTime >= seekableEnd) {
        newTime = seekableEnd;
      }
      if (newTime <= seekableStart) {
        newTime = seekableStart + 0.1;
      }
      if (newTime === Infinity) {
        return;
      }
    }
    this.userSeek_(newTime);
  };
  _proto.enable = function enable() {
    _Slider.prototype.enable.call(this);
    var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
    if (!mouseTimeDisplay) {
      return;
    }
    mouseTimeDisplay.show();
  };
  _proto.disable = function disable() {
    _Slider.prototype.disable.call(this);
    var mouseTimeDisplay = this.getChild("mouseTimeDisplay");
    if (!mouseTimeDisplay) {
      return;
    }
    mouseTimeDisplay.hide();
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    _Slider.prototype.handleMouseUp.call(this, event);
    if (event) {
      event.stopPropagation();
    }
    this.player_.scrubbing(false);
    this.player_.trigger({
      type: "timeupdate",
      target: this,
      manuallyTriggered: true
    });
    if (this.videoWasPlaying) {
      silencePromise(this.player_.play());
    } else {
      this.update_();
    }
  };
  _proto.stepForward = function stepForward() {
    this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
  };
  _proto.stepBack = function stepBack() {
    this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
  };
  _proto.handleAction = function handleAction(event) {
    if (this.player_.paused()) {
      this.player_.play();
    } else {
      this.player_.pause();
    }
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    var liveTracker = this.player_.liveTracker;
    if (keycode.isEventKey(event, "Space") || keycode.isEventKey(event, "Enter")) {
      event.preventDefault();
      event.stopPropagation();
      this.handleAction(event);
    } else if (keycode.isEventKey(event, "Home")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(0);
    } else if (keycode.isEventKey(event, "End")) {
      event.preventDefault();
      event.stopPropagation();
      if (liveTracker && liveTracker.isLive()) {
        this.userSeek_(liveTracker.liveCurrentTime());
      } else {
        this.userSeek_(this.player_.duration());
      }
    } else if (/^[0-9]$/.test(keycode(event))) {
      event.preventDefault();
      event.stopPropagation();
      var gotoFraction = (keycode.codes[keycode(event)] - keycode.codes["0"]) * 10 / 100;
      if (liveTracker && liveTracker.isLive()) {
        this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction);
      } else {
        this.userSeek_(this.player_.duration() * gotoFraction);
      }
    } else if (keycode.isEventKey(event, "PgDn")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
    } else if (keycode.isEventKey(event, "PgUp")) {
      event.preventDefault();
      event.stopPropagation();
      this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
    } else {
      _Slider.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.dispose = function dispose() {
    this.disableInterval_();
    this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update);
    if (this.player_.liveTracker) {
      this.off(this.player_.liveTracker, "liveedgechange", this.update);
    }
    this.off(this.player_, ["playing"], this.enableIntervalHandler_);
    this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_);
    if ("hidden" in document_1 && "visibilityState" in document_1) {
      this.off(document_1, "visibilitychange", this.toggleVisibility_);
    }
    _Slider.prototype.dispose.call(this);
  };
  return SeekBar2;
}(Slider);
SeekBar.prototype.options_ = {
  children: ["loadProgressBar", "playProgressBar"],
  barName: "playProgressBar"
};
if (!IS_IOS && !IS_ANDROID) {
  SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
}
Component$1.registerComponent("SeekBar", SeekBar);
var ProgressControl = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ProgressControl2, _Component);
  function ProgressControl2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.handleMouseMove = throttle$1(bind(_assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
    _this.throttledHandleMouseSeek = throttle$1(bind(_assertThisInitialized(_this), _this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
    _this.handleMouseUpHandler_ = function(e2) {
      return _this.handleMouseUp(e2);
    };
    _this.handleMouseDownHandler_ = function(e2) {
      return _this.handleMouseDown(e2);
    };
    _this.enable();
    return _this;
  }
  var _proto = ProgressControl2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-progress-control vjs-control"
    });
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    var seekBar = this.getChild("seekBar");
    if (!seekBar) {
      return;
    }
    var playProgressBar = seekBar.getChild("playProgressBar");
    var mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
    if (!playProgressBar && !mouseTimeDisplay) {
      return;
    }
    var seekBarEl = seekBar.el();
    var seekBarRect = findPosition(seekBarEl);
    var seekBarPoint = getPointerPosition(seekBarEl, event).x;
    seekBarPoint = clamp(seekBarPoint, 0, 1);
    if (mouseTimeDisplay) {
      mouseTimeDisplay.update(seekBarRect, seekBarPoint);
    }
    if (playProgressBar) {
      playProgressBar.update(seekBarRect, seekBar.getProgress());
    }
  };
  _proto.handleMouseSeek = function handleMouseSeek(event) {
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseMove(event);
    }
  };
  _proto.enabled = function enabled() {
    return this.enabled_;
  };
  _proto.disable = function disable() {
    this.children().forEach(function(child) {
      return child.disable && child.disable();
    });
    if (!this.enabled()) {
      return;
    }
    this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_);
    this.off(this.el_, "mousemove", this.handleMouseMove);
    this.removeListenersAddedOnMousedownAndTouchstart();
    this.addClass("disabled");
    this.enabled_ = false;
    if (this.player_.scrubbing()) {
      var seekBar = this.getChild("seekBar");
      this.player_.scrubbing(false);
      if (seekBar.videoWasPlaying) {
        silencePromise(this.player_.play());
      }
    }
  };
  _proto.enable = function enable() {
    this.children().forEach(function(child) {
      return child.enable && child.enable();
    });
    if (this.enabled()) {
      return;
    }
    this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_);
    this.on(this.el_, "mousemove", this.handleMouseMove);
    this.removeClass("disabled");
    this.enabled_ = true;
  };
  _proto.removeListenersAddedOnMousedownAndTouchstart = function removeListenersAddedOnMousedownAndTouchstart() {
    var doc = this.el_.ownerDocument;
    this.off(doc, "mousemove", this.throttledHandleMouseSeek);
    this.off(doc, "touchmove", this.throttledHandleMouseSeek);
    this.off(doc, "mouseup", this.handleMouseUpHandler_);
    this.off(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseDown(event);
    }
    this.on(doc, "mousemove", this.throttledHandleMouseSeek);
    this.on(doc, "touchmove", this.throttledHandleMouseSeek);
    this.on(doc, "mouseup", this.handleMouseUpHandler_);
    this.on(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    var seekBar = this.getChild("seekBar");
    if (seekBar) {
      seekBar.handleMouseUp(event);
    }
    this.removeListenersAddedOnMousedownAndTouchstart();
  };
  return ProgressControl2;
}(Component$1);
ProgressControl.prototype.options_ = {
  children: ["seekBar"]
};
Component$1.registerComponent("ProgressControl", ProgressControl);
var PictureInPictureToggle = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(PictureInPictureToggle2, _Button);
  function PictureInPictureToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.on(player, ["enterpictureinpicture", "leavepictureinpicture"], function(e2) {
      return _this.handlePictureInPictureChange(e2);
    });
    _this.on(player, ["disablepictureinpicturechanged", "loadedmetadata"], function(e2) {
      return _this.handlePictureInPictureEnabledChange(e2);
    });
    _this.on(player, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], function() {
      var isSourceAudio = player.currentType().substring(0, 5) === "audio";
      if (isSourceAudio || player.audioPosterMode() || player.audioOnlyMode()) {
        if (player.isInPictureInPicture()) {
          player.exitPictureInPicture();
        }
        _this.hide();
      } else {
        _this.show();
      }
    });
    _this.disable();
    return _this;
  }
  var _proto = PictureInPictureToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-picture-in-picture-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handlePictureInPictureEnabledChange = function handlePictureInPictureEnabledChange() {
    if (document_1.pictureInPictureEnabled && this.player_.disablePictureInPicture() === false) {
      this.enable();
    } else {
      this.disable();
    }
  };
  _proto.handlePictureInPictureChange = function handlePictureInPictureChange(event) {
    if (this.player_.isInPictureInPicture()) {
      this.controlText("Exit Picture-in-Picture");
    } else {
      this.controlText("Picture-in-Picture");
    }
    this.handlePictureInPictureEnabledChange();
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.isInPictureInPicture()) {
      this.player_.requestPictureInPicture();
    } else {
      this.player_.exitPictureInPicture();
    }
  };
  return PictureInPictureToggle2;
}(Button2);
PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture";
Component$1.registerComponent("PictureInPictureToggle", PictureInPictureToggle);
var FullscreenToggle = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(FullscreenToggle2, _Button);
  function FullscreenToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    _this.on(player, "fullscreenchange", function(e2) {
      return _this.handleFullscreenChange(e2);
    });
    if (document_1[player.fsApi_.fullscreenEnabled] === false) {
      _this.disable();
    }
    return _this;
  }
  var _proto = FullscreenToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-fullscreen-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleFullscreenChange = function handleFullscreenChange(event) {
    if (this.player_.isFullscreen()) {
      this.controlText("Non-Fullscreen");
    } else {
      this.controlText("Fullscreen");
    }
  };
  _proto.handleClick = function handleClick(event) {
    if (!this.player_.isFullscreen()) {
      this.player_.requestFullscreen();
    } else {
      this.player_.exitFullscreen();
    }
  };
  return FullscreenToggle2;
}(Button2);
FullscreenToggle.prototype.controlText_ = "Fullscreen";
Component$1.registerComponent("FullscreenToggle", FullscreenToggle);
var checkVolumeSupport = function checkVolumeSupport2(self2, player) {
  if (player.tech_ && !player.tech_.featuresVolumeControl) {
    self2.addClass("vjs-hidden");
  }
  self2.on(player, "loadstart", function() {
    if (!player.tech_.featuresVolumeControl) {
      self2.addClass("vjs-hidden");
    } else {
      self2.removeClass("vjs-hidden");
    }
  });
};
var VolumeLevel = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VolumeLevel2, _Component);
  function VolumeLevel2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = VolumeLevel2.prototype;
  _proto.createEl = function createEl2() {
    var el2 = _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-level"
    });
    el2.appendChild(_Component.prototype.createEl.call(this, "span", {
      className: "vjs-control-text"
    }));
    return el2;
  };
  return VolumeLevel2;
}(Component$1);
Component$1.registerComponent("VolumeLevel", VolumeLevel);
var VolumeLevelTooltip = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VolumeLevelTooltip2, _Component);
  function VolumeLevelTooltip2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle$1(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = VolumeLevelTooltip2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-tooltip"
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.update = function update2(rangeBarRect, rangeBarPoint, vertical2, content) {
    if (!vertical2) {
      var tooltipRect = getBoundingClientRect(this.el_);
      var playerRect = getBoundingClientRect(this.player_.el());
      var volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
      if (!playerRect || !tooltipRect) {
        return;
      }
      var spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
      var spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
      var pullTooltipBy = tooltipRect.width / 2;
      if (spaceLeftOfPoint < pullTooltipBy) {
        pullTooltipBy += pullTooltipBy - spaceLeftOfPoint;
      } else if (spaceRightOfPoint < pullTooltipBy) {
        pullTooltipBy = spaceRightOfPoint;
      }
      if (pullTooltipBy < 0) {
        pullTooltipBy = 0;
      } else if (pullTooltipBy > tooltipRect.width) {
        pullTooltipBy = tooltipRect.width;
      }
      this.el_.style.right = "-" + pullTooltipBy + "px";
    }
    this.write(content + "%");
  };
  _proto.write = function write2(content) {
    textContent(this.el_, content);
  };
  _proto.updateVolume = function updateVolume(rangeBarRect, rangeBarPoint, vertical2, volume, cb2) {
    var _this2 = this;
    this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", function() {
      _this2.update(rangeBarRect, rangeBarPoint, vertical2, volume.toFixed(0));
      if (cb2) {
        cb2();
      }
    });
  };
  return VolumeLevelTooltip2;
}(Component$1);
Component$1.registerComponent("VolumeLevelTooltip", VolumeLevelTooltip);
var MouseVolumeLevelDisplay = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(MouseVolumeLevelDisplay2, _Component);
  function MouseVolumeLevelDisplay2(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    _this.update = throttle$1(bind(_assertThisInitialized(_this), _this.update), UPDATE_REFRESH_INTERVAL);
    return _this;
  }
  var _proto = MouseVolumeLevelDisplay2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-mouse-display"
    });
  };
  _proto.update = function update2(rangeBarRect, rangeBarPoint, vertical2) {
    var _this2 = this;
    var volume = 100 * rangeBarPoint;
    this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical2, volume, function() {
      if (vertical2) {
        _this2.el_.style.bottom = rangeBarRect.height * rangeBarPoint + "px";
      } else {
        _this2.el_.style.left = rangeBarRect.width * rangeBarPoint + "px";
      }
    });
  };
  return MouseVolumeLevelDisplay2;
}(Component$1);
MouseVolumeLevelDisplay.prototype.options_ = {
  children: ["volumeLevelTooltip"]
};
Component$1.registerComponent("MouseVolumeLevelDisplay", MouseVolumeLevelDisplay);
var VolumeBar = /* @__PURE__ */ function(_Slider) {
  _inheritsLoose(VolumeBar2, _Slider);
  function VolumeBar2(player, options) {
    var _this;
    _this = _Slider.call(this, player, options) || this;
    _this.on("slideractive", function(e2) {
      return _this.updateLastVolume_(e2);
    });
    _this.on(player, "volumechange", function(e2) {
      return _this.updateARIAAttributes(e2);
    });
    player.ready(function() {
      return _this.updateARIAAttributes();
    });
    return _this;
  }
  var _proto = VolumeBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Slider.prototype.createEl.call(this, "div", {
      className: "vjs-volume-bar vjs-slider-bar"
    }, {
      "aria-label": this.localize("Volume Level"),
      "aria-live": "polite"
    });
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    if (!isSingleLeftClick(event)) {
      return;
    }
    _Slider.prototype.handleMouseDown.call(this, event);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    var mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
    if (mouseVolumeLevelDisplay) {
      var volumeBarEl = this.el();
      var volumeBarRect = getBoundingClientRect(volumeBarEl);
      var vertical2 = this.vertical();
      var volumeBarPoint = getPointerPosition(volumeBarEl, event);
      volumeBarPoint = vertical2 ? volumeBarPoint.y : volumeBarPoint.x;
      volumeBarPoint = clamp(volumeBarPoint, 0, 1);
      mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical2);
    }
    if (!isSingleLeftClick(event)) {
      return;
    }
    this.checkMuted();
    this.player_.volume(this.calculateDistance(event));
  };
  _proto.checkMuted = function checkMuted() {
    if (this.player_.muted()) {
      this.player_.muted(false);
    }
  };
  _proto.getPercent = function getPercent() {
    if (this.player_.muted()) {
      return 0;
    }
    return this.player_.volume();
  };
  _proto.stepForward = function stepForward() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() + 0.1);
  };
  _proto.stepBack = function stepBack() {
    this.checkMuted();
    this.player_.volume(this.player_.volume() - 0.1);
  };
  _proto.updateARIAAttributes = function updateARIAAttributes(event) {
    var ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
    this.el_.setAttribute("aria-valuenow", ariaValue);
    this.el_.setAttribute("aria-valuetext", ariaValue + "%");
  };
  _proto.volumeAsPercentage_ = function volumeAsPercentage_() {
    return Math.round(this.player_.volume() * 100);
  };
  _proto.updateLastVolume_ = function updateLastVolume_() {
    var _this2 = this;
    var volumeBeforeDrag = this.player_.volume();
    this.one("sliderinactive", function() {
      if (_this2.player_.volume() === 0) {
        _this2.player_.lastVolume_(volumeBeforeDrag);
      }
    });
  };
  return VolumeBar2;
}(Slider);
VolumeBar.prototype.options_ = {
  children: ["volumeLevel"],
  barName: "volumeLevel"
};
if (!IS_IOS && !IS_ANDROID) {
  VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
}
VolumeBar.prototype.playerEvent = "volumechange";
Component$1.registerComponent("VolumeBar", VolumeBar);
var VolumeControl = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VolumeControl2, _Component);
  function VolumeControl2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    options.vertical = options.vertical || false;
    if (typeof options.volumeBar === "undefined" || isPlain(options.volumeBar)) {
      options.volumeBar = options.volumeBar || {};
      options.volumeBar.vertical = options.vertical;
    }
    _this = _Component.call(this, player, options) || this;
    checkVolumeSupport(_assertThisInitialized(_this), player);
    _this.throttledHandleMouseMove = throttle$1(bind(_assertThisInitialized(_this), _this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
    _this.handleMouseUpHandler_ = function(e2) {
      return _this.handleMouseUp(e2);
    };
    _this.on("mousedown", function(e2) {
      return _this.handleMouseDown(e2);
    });
    _this.on("touchstart", function(e2) {
      return _this.handleMouseDown(e2);
    });
    _this.on("mousemove", function(e2) {
      return _this.handleMouseMove(e2);
    });
    _this.on(_this.volumeBar, ["focus", "slideractive"], function() {
      _this.volumeBar.addClass("vjs-slider-active");
      _this.addClass("vjs-slider-active");
      _this.trigger("slideractive");
    });
    _this.on(_this.volumeBar, ["blur", "sliderinactive"], function() {
      _this.volumeBar.removeClass("vjs-slider-active");
      _this.removeClass("vjs-slider-active");
      _this.trigger("sliderinactive");
    });
    return _this;
  }
  var _proto = VolumeControl2.prototype;
  _proto.createEl = function createEl2() {
    var orientationClass = "vjs-volume-horizontal";
    if (this.options_.vertical) {
      orientationClass = "vjs-volume-vertical";
    }
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-control vjs-control " + orientationClass
    });
  };
  _proto.handleMouseDown = function handleMouseDown(event) {
    var doc = this.el_.ownerDocument;
    this.on(doc, "mousemove", this.throttledHandleMouseMove);
    this.on(doc, "touchmove", this.throttledHandleMouseMove);
    this.on(doc, "mouseup", this.handleMouseUpHandler_);
    this.on(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseUp = function handleMouseUp(event) {
    var doc = this.el_.ownerDocument;
    this.off(doc, "mousemove", this.throttledHandleMouseMove);
    this.off(doc, "touchmove", this.throttledHandleMouseMove);
    this.off(doc, "mouseup", this.handleMouseUpHandler_);
    this.off(doc, "touchend", this.handleMouseUpHandler_);
  };
  _proto.handleMouseMove = function handleMouseMove(event) {
    this.volumeBar.handleMouseMove(event);
  };
  return VolumeControl2;
}(Component$1);
VolumeControl.prototype.options_ = {
  children: ["volumeBar"]
};
Component$1.registerComponent("VolumeControl", VolumeControl);
var checkMuteSupport = function checkMuteSupport2(self2, player) {
  if (player.tech_ && !player.tech_.featuresMuteControl) {
    self2.addClass("vjs-hidden");
  }
  self2.on(player, "loadstart", function() {
    if (!player.tech_.featuresMuteControl) {
      self2.addClass("vjs-hidden");
    } else {
      self2.removeClass("vjs-hidden");
    }
  });
};
var MuteToggle = /* @__PURE__ */ function(_Button) {
  _inheritsLoose(MuteToggle2, _Button);
  function MuteToggle2(player, options) {
    var _this;
    _this = _Button.call(this, player, options) || this;
    checkMuteSupport(_assertThisInitialized(_this), player);
    _this.on(player, ["loadstart", "volumechange"], function(e2) {
      return _this.update(e2);
    });
    return _this;
  }
  var _proto = MuteToggle2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-mute-control " + _Button.prototype.buildCSSClass.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    var vol = this.player_.volume();
    var lastVolume = this.player_.lastVolume_();
    if (vol === 0) {
      var volumeToSet = lastVolume < 0.1 ? 0.1 : lastVolume;
      this.player_.volume(volumeToSet);
      this.player_.muted(false);
    } else {
      this.player_.muted(this.player_.muted() ? false : true);
    }
  };
  _proto.update = function update2(event) {
    this.updateIcon_();
    this.updateControlText_();
  };
  _proto.updateIcon_ = function updateIcon_() {
    var vol = this.player_.volume();
    var level = 3;
    if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) {
      this.player_.muted(this.player_.tech_.el_.muted);
    }
    if (vol === 0 || this.player_.muted()) {
      level = 0;
    } else if (vol < 0.33) {
      level = 1;
    } else if (vol < 0.67) {
      level = 2;
    }
    for (var i = 0; i < 4; i++) {
      removeClass(this.el_, "vjs-vol-" + i);
    }
    addClass(this.el_, "vjs-vol-" + level);
  };
  _proto.updateControlText_ = function updateControlText_() {
    var soundOff = this.player_.muted() || this.player_.volume() === 0;
    var text = soundOff ? "Unmute" : "Mute";
    if (this.controlText() !== text) {
      this.controlText(text);
    }
  };
  return MuteToggle2;
}(Button2);
MuteToggle.prototype.controlText_ = "Mute";
Component$1.registerComponent("MuteToggle", MuteToggle);
var VolumePanel = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VolumePanel2, _Component);
  function VolumePanel2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    if (typeof options.inline !== "undefined") {
      options.inline = options.inline;
    } else {
      options.inline = true;
    }
    if (typeof options.volumeControl === "undefined" || isPlain(options.volumeControl)) {
      options.volumeControl = options.volumeControl || {};
      options.volumeControl.vertical = !options.inline;
    }
    _this = _Component.call(this, player, options) || this;
    _this.handleKeyPressHandler_ = function(e2) {
      return _this.handleKeyPress(e2);
    };
    _this.on(player, ["loadstart"], function(e2) {
      return _this.volumePanelState_(e2);
    });
    _this.on(_this.muteToggle, "keyup", function(e2) {
      return _this.handleKeyPress(e2);
    });
    _this.on(_this.volumeControl, "keyup", function(e2) {
      return _this.handleVolumeControlKeyUp(e2);
    });
    _this.on("keydown", function(e2) {
      return _this.handleKeyPress(e2);
    });
    _this.on("mouseover", function(e2) {
      return _this.handleMouseOver(e2);
    });
    _this.on("mouseout", function(e2) {
      return _this.handleMouseOut(e2);
    });
    _this.on(_this.volumeControl, ["slideractive"], _this.sliderActive_);
    _this.on(_this.volumeControl, ["sliderinactive"], _this.sliderInactive_);
    return _this;
  }
  var _proto = VolumePanel2.prototype;
  _proto.sliderActive_ = function sliderActive_() {
    this.addClass("vjs-slider-active");
  };
  _proto.sliderInactive_ = function sliderInactive_() {
    this.removeClass("vjs-slider-active");
  };
  _proto.volumePanelState_ = function volumePanelState_() {
    if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) {
      this.addClass("vjs-hidden");
    }
    if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) {
      this.addClass("vjs-mute-toggle-only");
    }
  };
  _proto.createEl = function createEl2() {
    var orientationClass = "vjs-volume-panel-horizontal";
    if (!this.options_.inline) {
      orientationClass = "vjs-volume-panel-vertical";
    }
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-volume-panel vjs-control " + orientationClass
    });
  };
  _proto.dispose = function dispose() {
    this.handleMouseOut();
    _Component.prototype.dispose.call(this);
  };
  _proto.handleVolumeControlKeyUp = function handleVolumeControlKeyUp(event) {
    if (keycode.isEventKey(event, "Esc")) {
      this.muteToggle.focus();
    }
  };
  _proto.handleMouseOver = function handleMouseOver(event) {
    this.addClass("vjs-hover");
    on(document_1, "keyup", this.handleKeyPressHandler_);
  };
  _proto.handleMouseOut = function handleMouseOut(event) {
    this.removeClass("vjs-hover");
    off(document_1, "keyup", this.handleKeyPressHandler_);
  };
  _proto.handleKeyPress = function handleKeyPress(event) {
    if (keycode.isEventKey(event, "Esc")) {
      this.handleMouseOut();
    }
  };
  return VolumePanel2;
}(Component$1);
VolumePanel.prototype.options_ = {
  children: ["muteToggle", "volumeControl"]
};
Component$1.registerComponent("VolumePanel", VolumePanel);
var Menu2 = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Menu3, _Component);
  function Menu3(player, options) {
    var _this;
    _this = _Component.call(this, player, options) || this;
    if (options) {
      _this.menuButton_ = options.menuButton;
    }
    _this.focusedChild_ = -1;
    _this.on("keydown", function(e2) {
      return _this.handleKeyDown(e2);
    });
    _this.boundHandleBlur_ = function(e2) {
      return _this.handleBlur(e2);
    };
    _this.boundHandleTapClick_ = function(e2) {
      return _this.handleTapClick(e2);
    };
    return _this;
  }
  var _proto = Menu3.prototype;
  _proto.addEventListenerForItem = function addEventListenerForItem(component) {
    if (!(component instanceof Component$1)) {
      return;
    }
    this.on(component, "blur", this.boundHandleBlur_);
    this.on(component, ["tap", "click"], this.boundHandleTapClick_);
  };
  _proto.removeEventListenerForItem = function removeEventListenerForItem(component) {
    if (!(component instanceof Component$1)) {
      return;
    }
    this.off(component, "blur", this.boundHandleBlur_);
    this.off(component, ["tap", "click"], this.boundHandleTapClick_);
  };
  _proto.removeChild = function removeChild(component) {
    if (typeof component === "string") {
      component = this.getChild(component);
    }
    this.removeEventListenerForItem(component);
    _Component.prototype.removeChild.call(this, component);
  };
  _proto.addItem = function addItem(component) {
    var childComponent = this.addChild(component);
    if (childComponent) {
      this.addEventListenerForItem(childComponent);
    }
  };
  _proto.createEl = function createEl$1() {
    var contentElType = this.options_.contentElType || "ul";
    this.contentEl_ = createEl(contentElType, {
      className: "vjs-menu-content"
    });
    this.contentEl_.setAttribute("role", "menu");
    var el2 = _Component.prototype.createEl.call(this, "div", {
      append: this.contentEl_,
      className: "vjs-menu"
    });
    el2.appendChild(this.contentEl_);
    on(el2, "click", function(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    });
    return el2;
  };
  _proto.dispose = function dispose() {
    this.contentEl_ = null;
    this.boundHandleBlur_ = null;
    this.boundHandleTapClick_ = null;
    _Component.prototype.dispose.call(this);
  };
  _proto.handleBlur = function handleBlur(event) {
    var relatedTarget = event.relatedTarget || document_1.activeElement;
    if (!this.children().some(function(element) {
      return element.el() === relatedTarget;
    })) {
      var btn = this.menuButton_;
      if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) {
        btn.unpressButton();
      }
    }
  };
  _proto.handleTapClick = function handleTapClick(event) {
    if (this.menuButton_) {
      this.menuButton_.unpressButton();
      var childComponents = this.children();
      if (!Array.isArray(childComponents)) {
        return;
      }
      var foundComponent = childComponents.filter(function(component) {
        return component.el() === event.target;
      })[0];
      if (!foundComponent) {
        return;
      }
      if (foundComponent.name() !== "CaptionSettingsMenuItem") {
        this.menuButton_.focus();
      }
    }
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    if (keycode.isEventKey(event, "Left") || keycode.isEventKey(event, "Down")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepForward();
    } else if (keycode.isEventKey(event, "Right") || keycode.isEventKey(event, "Up")) {
      event.preventDefault();
      event.stopPropagation();
      this.stepBack();
    }
  };
  _proto.stepForward = function stepForward() {
    var stepChild = 0;
    if (this.focusedChild_ !== void 0) {
      stepChild = this.focusedChild_ + 1;
    }
    this.focus(stepChild);
  };
  _proto.stepBack = function stepBack() {
    var stepChild = 0;
    if (this.focusedChild_ !== void 0) {
      stepChild = this.focusedChild_ - 1;
    }
    this.focus(stepChild);
  };
  _proto.focus = function focus2(item) {
    if (item === void 0) {
      item = 0;
    }
    var children = this.children().slice();
    var haveTitle = children.length && children[0].hasClass("vjs-menu-title");
    if (haveTitle) {
      children.shift();
    }
    if (children.length > 0) {
      if (item < 0) {
        item = 0;
      } else if (item >= children.length) {
        item = children.length - 1;
      }
      this.focusedChild_ = item;
      children[item].el_.focus();
    }
  };
  return Menu3;
}(Component$1);
Component$1.registerComponent("Menu", Menu2);
var MenuButton = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(MenuButton2, _Component);
  function MenuButton2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _Component.call(this, player, options) || this;
    _this.menuButton_ = new Button2(player, options);
    _this.menuButton_.controlText(_this.controlText_);
    _this.menuButton_.el_.setAttribute("aria-haspopup", "true");
    var buttonClass = Button2.prototype.buildCSSClass();
    _this.menuButton_.el_.className = _this.buildCSSClass() + " " + buttonClass;
    _this.menuButton_.removeClass("vjs-control");
    _this.addChild(_this.menuButton_);
    _this.update();
    _this.enabled_ = true;
    var handleClick = function handleClick2(e2) {
      return _this.handleClick(e2);
    };
    _this.handleMenuKeyUp_ = function(e2) {
      return _this.handleMenuKeyUp(e2);
    };
    _this.on(_this.menuButton_, "tap", handleClick);
    _this.on(_this.menuButton_, "click", handleClick);
    _this.on(_this.menuButton_, "keydown", function(e2) {
      return _this.handleKeyDown(e2);
    });
    _this.on(_this.menuButton_, "mouseenter", function() {
      _this.addClass("vjs-hover");
      _this.menu.show();
      on(document_1, "keyup", _this.handleMenuKeyUp_);
    });
    _this.on("mouseleave", function(e2) {
      return _this.handleMouseLeave(e2);
    });
    _this.on("keydown", function(e2) {
      return _this.handleSubmenuKeyDown(e2);
    });
    return _this;
  }
  var _proto = MenuButton2.prototype;
  _proto.update = function update2() {
    var menu = this.createMenu();
    if (this.menu) {
      this.menu.dispose();
      this.removeChild(this.menu);
    }
    this.menu = menu;
    this.addChild(menu);
    this.buttonPressed_ = false;
    this.menuButton_.el_.setAttribute("aria-expanded", "false");
    if (this.items && this.items.length <= this.hideThreshold_) {
      this.hide();
      this.menu.contentEl_.removeAttribute("role");
    } else {
      this.show();
      this.menu.contentEl_.setAttribute("role", "menu");
    }
  };
  _proto.createMenu = function createMenu() {
    var menu = new Menu2(this.player_, {
      menuButton: this
    });
    this.hideThreshold_ = 0;
    if (this.options_.title) {
      var titleEl = createEl("li", {
        className: "vjs-menu-title",
        textContent: toTitleCase$1(this.options_.title),
        tabIndex: -1
      });
      var titleComponent = new Component$1(this.player_, {
        el: titleEl
      });
      menu.addItem(titleComponent);
    }
    this.items = this.createItems();
    if (this.items) {
      for (var i = 0; i < this.items.length; i++) {
        menu.addItem(this.items[i]);
      }
    }
    return menu;
  };
  _proto.createItems = function createItems() {
  };
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: this.buildWrapperCSSClass()
    }, {});
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    var menuButtonClass = "vjs-menu-button";
    if (this.options_.inline === true) {
      menuButtonClass += "-inline";
    } else {
      menuButtonClass += "-popup";
    }
    var buttonClass = Button2.prototype.buildCSSClass();
    return "vjs-menu-button " + menuButtonClass + " " + buttonClass + " " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    var menuButtonClass = "vjs-menu-button";
    if (this.options_.inline === true) {
      menuButtonClass += "-inline";
    } else {
      menuButtonClass += "-popup";
    }
    return "vjs-menu-button " + menuButtonClass + " " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.controlText = function controlText(text, el2) {
    if (el2 === void 0) {
      el2 = this.menuButton_.el();
    }
    return this.menuButton_.controlText(text, el2);
  };
  _proto.dispose = function dispose() {
    this.handleMouseLeave();
    _Component.prototype.dispose.call(this);
  };
  _proto.handleClick = function handleClick(event) {
    if (this.buttonPressed_) {
      this.unpressButton();
    } else {
      this.pressButton();
    }
  };
  _proto.handleMouseLeave = function handleMouseLeave(event) {
    this.removeClass("vjs-hover");
    off(document_1, "keyup", this.handleMenuKeyUp_);
  };
  _proto.focus = function focus2() {
    this.menuButton_.focus();
  };
  _proto.blur = function blur() {
    this.menuButton_.blur();
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    if (keycode.isEventKey(event, "Esc") || keycode.isEventKey(event, "Tab")) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      if (!keycode.isEventKey(event, "Tab")) {
        event.preventDefault();
        this.menuButton_.focus();
      }
    } else if (keycode.isEventKey(event, "Up") || keycode.isEventKey(event, "Down")) {
      if (!this.buttonPressed_) {
        event.preventDefault();
        this.pressButton();
      }
    }
  };
  _proto.handleMenuKeyUp = function handleMenuKeyUp(event) {
    if (keycode.isEventKey(event, "Esc") || keycode.isEventKey(event, "Tab")) {
      this.removeClass("vjs-hover");
    }
  };
  _proto.handleSubmenuKeyPress = function handleSubmenuKeyPress(event) {
    this.handleSubmenuKeyDown(event);
  };
  _proto.handleSubmenuKeyDown = function handleSubmenuKeyDown(event) {
    if (keycode.isEventKey(event, "Esc") || keycode.isEventKey(event, "Tab")) {
      if (this.buttonPressed_) {
        this.unpressButton();
      }
      if (!keycode.isEventKey(event, "Tab")) {
        event.preventDefault();
        this.menuButton_.focus();
      }
    }
  };
  _proto.pressButton = function pressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = true;
      this.menu.show();
      this.menu.lockShowing();
      this.menuButton_.el_.setAttribute("aria-expanded", "true");
      if (IS_IOS && isInFrame()) {
        return;
      }
      this.menu.focus();
    }
  };
  _proto.unpressButton = function unpressButton() {
    if (this.enabled_) {
      this.buttonPressed_ = false;
      this.menu.unlockShowing();
      this.menu.hide();
      this.menuButton_.el_.setAttribute("aria-expanded", "false");
    }
  };
  _proto.disable = function disable() {
    this.unpressButton();
    this.enabled_ = false;
    this.addClass("vjs-disabled");
    this.menuButton_.disable();
  };
  _proto.enable = function enable() {
    this.enabled_ = true;
    this.removeClass("vjs-disabled");
    this.menuButton_.enable();
  };
  return MenuButton2;
}(Component$1);
Component$1.registerComponent("MenuButton", MenuButton);
var TrackButton = /* @__PURE__ */ function(_MenuButton) {
  _inheritsLoose(TrackButton2, _MenuButton);
  function TrackButton2(player, options) {
    var _this;
    var tracks = options.tracks;
    _this = _MenuButton.call(this, player, options) || this;
    if (_this.items.length <= 1) {
      _this.hide();
    }
    if (!tracks) {
      return _assertThisInitialized(_this);
    }
    var updateHandler = bind(_assertThisInitialized(_this), _this.update);
    tracks.addEventListener("removetrack", updateHandler);
    tracks.addEventListener("addtrack", updateHandler);
    tracks.addEventListener("labelchange", updateHandler);
    _this.player_.on("ready", updateHandler);
    _this.player_.on("dispose", function() {
      tracks.removeEventListener("removetrack", updateHandler);
      tracks.removeEventListener("addtrack", updateHandler);
      tracks.removeEventListener("labelchange", updateHandler);
    });
    return _this;
  }
  return TrackButton2;
}(MenuButton);
Component$1.registerComponent("TrackButton", TrackButton);
var MenuKeys = ["Tab", "Esc", "Up", "Down", "Right", "Left"];
var MenuItem2 = /* @__PURE__ */ function(_ClickableComponent) {
  _inheritsLoose(MenuItem3, _ClickableComponent);
  function MenuItem3(player, options) {
    var _this;
    _this = _ClickableComponent.call(this, player, options) || this;
    _this.selectable = options.selectable;
    _this.isSelected_ = options.selected || false;
    _this.multiSelectable = options.multiSelectable;
    _this.selected(_this.isSelected_);
    if (_this.selectable) {
      if (_this.multiSelectable) {
        _this.el_.setAttribute("role", "menuitemcheckbox");
      } else {
        _this.el_.setAttribute("role", "menuitemradio");
      }
    } else {
      _this.el_.setAttribute("role", "menuitem");
    }
    return _this;
  }
  var _proto = MenuItem3.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    this.nonIconControl = true;
    var el2 = _ClickableComponent.prototype.createEl.call(this, "li", assign$1({
      className: "vjs-menu-item",
      tabIndex: -1
    }, props), attrs);
    el2.replaceChild(createEl("span", {
      className: "vjs-menu-item-text",
      textContent: this.localize(this.options_.label)
    }), el2.querySelector(".vjs-icon-placeholder"));
    return el2;
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    if (!MenuKeys.some(function(key) {
      return keycode.isEventKey(event, key);
    })) {
      _ClickableComponent.prototype.handleKeyDown.call(this, event);
    }
  };
  _proto.handleClick = function handleClick(event) {
    this.selected(true);
  };
  _proto.selected = function selected(_selected) {
    if (this.selectable) {
      if (_selected) {
        this.addClass("vjs-selected");
        this.el_.setAttribute("aria-checked", "true");
        this.controlText(", selected");
        this.isSelected_ = true;
      } else {
        this.removeClass("vjs-selected");
        this.el_.setAttribute("aria-checked", "false");
        this.controlText("");
        this.isSelected_ = false;
      }
    }
  };
  return MenuItem3;
}(ClickableComponent);
Component$1.registerComponent("MenuItem", MenuItem2);
var TextTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
  _inheritsLoose(TextTrackMenuItem2, _MenuItem);
  function TextTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var tracks = player.textTracks();
    options.label = track.label || track.language || "Unknown";
    options.selected = track.mode === "showing";
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.kinds = (options.kinds || [options.kind || _this.track.kind]).filter(Boolean);
    var changeHandler = function changeHandler2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this.handleTracksChange.apply(_assertThisInitialized(_this), args);
    };
    var selectedLanguageChangeHandler = function selectedLanguageChangeHandler2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this.handleSelectedLanguageChange.apply(_assertThisInitialized(_this), args);
    };
    player.on(["loadstart", "texttrackchange"], changeHandler);
    tracks.addEventListener("change", changeHandler);
    tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
    _this.on("dispose", function() {
      player.off(["loadstart", "texttrackchange"], changeHandler);
      tracks.removeEventListener("change", changeHandler);
      tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
    });
    if (tracks.onchange === void 0) {
      var event;
      _this.on(["tap", "click"], function() {
        if (typeof window_1.Event !== "object") {
          try {
            event = new window_1.Event("change");
          } catch (err) {
          }
        }
        if (!event) {
          event = document_1.createEvent("Event");
          event.initEvent("change", true, true);
        }
        tracks.dispatchEvent(event);
      });
    }
    _this.handleTracksChange();
    return _this;
  }
  var _proto = TextTrackMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    var referenceTrack = this.track;
    var tracks = this.player_.textTracks();
    _MenuItem.prototype.handleClick.call(this, event);
    if (!tracks) {
      return;
    }
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      if (this.kinds.indexOf(track.kind) === -1) {
        continue;
      }
      if (track === referenceTrack) {
        if (track.mode !== "showing") {
          track.mode = "showing";
        }
      } else if (track.mode !== "disabled") {
        track.mode = "disabled";
      }
    }
  };
  _proto.handleTracksChange = function handleTracksChange(event) {
    var shouldBeSelected = this.track.mode === "showing";
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  };
  _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    if (this.track.mode === "showing") {
      var selectedLanguage = this.player_.cache_.selectedLanguage;
      if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) {
        return;
      }
      this.player_.cache_.selectedLanguage = {
        enabled: true,
        language: this.track.language,
        kind: this.track.kind
      };
    }
  };
  _proto.dispose = function dispose() {
    this.track = null;
    _MenuItem.prototype.dispose.call(this);
  };
  return TextTrackMenuItem2;
}(MenuItem2);
Component$1.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
var OffTextTrackMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
  _inheritsLoose(OffTextTrackMenuItem2, _TextTrackMenuItem);
  function OffTextTrackMenuItem2(player, options) {
    options.track = {
      player,
      // it is no longer necessary to store `kind` or `kinds` on the track itself
      // since they are now stored in the `kinds` property of all instances of
      // TextTrackMenuItem, but this will remain for backwards compatibility
      kind: options.kind,
      kinds: options.kinds,
      "default": false,
      mode: "disabled"
    };
    if (!options.kinds) {
      options.kinds = [options.kind];
    }
    if (options.label) {
      options.track.label = options.label;
    } else {
      options.track.label = options.kinds.join(" and ") + " off";
    }
    options.selectable = true;
    options.multiSelectable = false;
    return _TextTrackMenuItem.call(this, player, options) || this;
  }
  var _proto = OffTextTrackMenuItem2.prototype;
  _proto.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var shouldBeSelected = true;
    for (var i = 0, l2 = tracks.length; i < l2; i++) {
      var track = tracks[i];
      if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === "showing") {
        shouldBeSelected = false;
        break;
      }
    }
    if (shouldBeSelected !== this.isSelected_) {
      this.selected(shouldBeSelected);
    }
  };
  _proto.handleSelectedLanguageChange = function handleSelectedLanguageChange(event) {
    var tracks = this.player().textTracks();
    var allHidden = true;
    for (var i = 0, l2 = tracks.length; i < l2; i++) {
      var track = tracks[i];
      if (["captions", "descriptions", "subtitles"].indexOf(track.kind) > -1 && track.mode === "showing") {
        allHidden = false;
        break;
      }
    }
    if (allHidden) {
      this.player_.cache_.selectedLanguage = {
        enabled: false
      };
    }
  };
  return OffTextTrackMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
var TextTrackButton = /* @__PURE__ */ function(_TrackButton) {
  _inheritsLoose(TextTrackButton2, _TrackButton);
  function TextTrackButton2(player, options) {
    if (options === void 0) {
      options = {};
    }
    options.tracks = player.textTracks();
    return _TrackButton.call(this, player, options) || this;
  }
  var _proto = TextTrackButton2.prototype;
  _proto.createItems = function createItems(items, TrackMenuItem) {
    if (items === void 0) {
      items = [];
    }
    if (TrackMenuItem === void 0) {
      TrackMenuItem = TextTrackMenuItem;
    }
    var label;
    if (this.label_) {
      label = this.label_ + " off";
    }
    items.push(new OffTextTrackMenuItem(this.player_, {
      kinds: this.kinds_,
      kind: this.kind_,
      label
    }));
    this.hideThreshold_ += 1;
    var tracks = this.player_.textTracks();
    if (!Array.isArray(this.kinds_)) {
      this.kinds_ = [this.kind_];
    }
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      if (this.kinds_.indexOf(track.kind) > -1) {
        var item = new TrackMenuItem(this.player_, {
          track,
          kinds: this.kinds_,
          kind: this.kind_,
          // MenuItem is selectable
          selectable: true,
          // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
          multiSelectable: false
        });
        item.addClass("vjs-" + track.kind + "-menu-item");
        items.push(item);
      }
    }
    return items;
  };
  return TextTrackButton2;
}(TrackButton);
Component$1.registerComponent("TextTrackButton", TextTrackButton);
var ChaptersTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
  _inheritsLoose(ChaptersTrackMenuItem2, _MenuItem);
  function ChaptersTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var cue = options.cue;
    var currentTime = player.currentTime();
    options.selectable = true;
    options.multiSelectable = false;
    options.label = cue.text;
    options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.cue = cue;
    return _this;
  }
  var _proto = ChaptersTrackMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player_.currentTime(this.cue.startTime);
  };
  return ChaptersTrackMenuItem2;
}(MenuItem2);
Component$1.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
var ChaptersButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(ChaptersButton2, _TextTrackButton);
  function ChaptersButton2(player, options, ready) {
    var _this;
    _this = _TextTrackButton.call(this, player, options, ready) || this;
    _this.selectCurrentItem_ = function() {
      _this.items.forEach(function(item) {
        item.selected(_this.track_.activeCues[0] === item.cue);
      });
    };
    return _this;
  }
  var _proto = ChaptersButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-chapters-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-chapters-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.update = function update2(event) {
    if (event && event.track && event.track.kind !== "chapters") {
      return;
    }
    var track = this.findChaptersTrack();
    if (track !== this.track_) {
      this.setTrack(track);
      _TextTrackButton.prototype.update.call(this);
    } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) {
      _TextTrackButton.prototype.update.call(this);
    }
  };
  _proto.setTrack = function setTrack(track) {
    if (this.track_ === track) {
      return;
    }
    if (!this.updateHandler_) {
      this.updateHandler_ = this.update.bind(this);
    }
    if (this.track_) {
      var remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
      if (remoteTextTrackEl) {
        remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
      }
      this.track_.removeEventListener("cuechange", this.selectCurrentItem_);
      this.track_ = null;
    }
    this.track_ = track;
    if (this.track_) {
      this.track_.mode = "hidden";
      var _remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
      if (_remoteTextTrackEl) {
        _remoteTextTrackEl.addEventListener("load", this.updateHandler_);
      }
      this.track_.addEventListener("cuechange", this.selectCurrentItem_);
    }
  };
  _proto.findChaptersTrack = function findChaptersTrack() {
    var tracks = this.player_.textTracks() || [];
    for (var i = tracks.length - 1; i >= 0; i--) {
      var track = tracks[i];
      if (track.kind === this.kind_) {
        return track;
      }
    }
  };
  _proto.getMenuCaption = function getMenuCaption() {
    if (this.track_ && this.track_.label) {
      return this.track_.label;
    }
    return this.localize(toTitleCase$1(this.kind_));
  };
  _proto.createMenu = function createMenu() {
    this.options_.title = this.getMenuCaption();
    return _TextTrackButton.prototype.createMenu.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!this.track_) {
      return items;
    }
    var cues = this.track_.cues;
    if (!cues) {
      return items;
    }
    for (var i = 0, l2 = cues.length; i < l2; i++) {
      var cue = cues[i];
      var mi2 = new ChaptersTrackMenuItem(this.player_, {
        track: this.track_,
        cue
      });
      items.push(mi2);
    }
    return items;
  };
  return ChaptersButton2;
}(TextTrackButton);
ChaptersButton.prototype.kind_ = "chapters";
ChaptersButton.prototype.controlText_ = "Chapters";
Component$1.registerComponent("ChaptersButton", ChaptersButton);
var DescriptionsButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(DescriptionsButton2, _TextTrackButton);
  function DescriptionsButton2(player, options, ready) {
    var _this;
    _this = _TextTrackButton.call(this, player, options, ready) || this;
    var tracks = player.textTracks();
    var changeHandler = bind(_assertThisInitialized(_this), _this.handleTracksChange);
    tracks.addEventListener("change", changeHandler);
    _this.on("dispose", function() {
      tracks.removeEventListener("change", changeHandler);
    });
    return _this;
  }
  var _proto = DescriptionsButton2.prototype;
  _proto.handleTracksChange = function handleTracksChange(event) {
    var tracks = this.player().textTracks();
    var disabled = false;
    for (var i = 0, l2 = tracks.length; i < l2; i++) {
      var track = tracks[i];
      if (track.kind !== this.kind_ && track.mode === "showing") {
        disabled = true;
        break;
      }
    }
    if (disabled) {
      this.disable();
    } else {
      this.enable();
    }
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-descriptions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-descriptions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  return DescriptionsButton2;
}(TextTrackButton);
DescriptionsButton.prototype.kind_ = "descriptions";
DescriptionsButton.prototype.controlText_ = "Descriptions";
Component$1.registerComponent("DescriptionsButton", DescriptionsButton);
var SubtitlesButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(SubtitlesButton2, _TextTrackButton);
  function SubtitlesButton2(player, options, ready) {
    return _TextTrackButton.call(this, player, options, ready) || this;
  }
  var _proto = SubtitlesButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-subtitles-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-subtitles-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  return SubtitlesButton2;
}(TextTrackButton);
SubtitlesButton.prototype.kind_ = "subtitles";
SubtitlesButton.prototype.controlText_ = "Subtitles";
Component$1.registerComponent("SubtitlesButton", SubtitlesButton);
var CaptionSettingsMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
  _inheritsLoose(CaptionSettingsMenuItem2, _TextTrackMenuItem);
  function CaptionSettingsMenuItem2(player, options) {
    var _this;
    options.track = {
      player,
      kind: options.kind,
      label: options.kind + " settings",
      selectable: false,
      "default": false,
      mode: "disabled"
    };
    options.selectable = false;
    options.name = "CaptionSettingsMenuItem";
    _this = _TextTrackMenuItem.call(this, player, options) || this;
    _this.addClass("vjs-texttrack-settings");
    _this.controlText(", opens " + options.kind + " settings dialog");
    return _this;
  }
  var _proto = CaptionSettingsMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    this.player().getChild("textTrackSettings").open();
  };
  return CaptionSettingsMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
var CaptionsButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(CaptionsButton2, _TextTrackButton);
  function CaptionsButton2(player, options, ready) {
    return _TextTrackButton.call(this, player, options, ready) || this;
  }
  var _proto = CaptionsButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-captions-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-captions-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
      items.push(new CaptionSettingsMenuItem(this.player_, {
        kind: this.kind_
      }));
      this.hideThreshold_ += 1;
    }
    return _TextTrackButton.prototype.createItems.call(this, items);
  };
  return CaptionsButton2;
}(TextTrackButton);
CaptionsButton.prototype.kind_ = "captions";
CaptionsButton.prototype.controlText_ = "Captions";
Component$1.registerComponent("CaptionsButton", CaptionsButton);
var SubsCapsMenuItem = /* @__PURE__ */ function(_TextTrackMenuItem) {
  _inheritsLoose(SubsCapsMenuItem2, _TextTrackMenuItem);
  function SubsCapsMenuItem2() {
    return _TextTrackMenuItem.apply(this, arguments) || this;
  }
  var _proto = SubsCapsMenuItem2.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    var el2 = _TextTrackMenuItem.prototype.createEl.call(this, type2, props, attrs);
    var parentSpan = el2.querySelector(".vjs-menu-item-text");
    if (this.options_.track.kind === "captions") {
      parentSpan.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
      parentSpan.appendChild(createEl("span", {
        className: "vjs-control-text",
        // space added as the text will visually flow with the
        // label
        textContent: " " + this.localize("Captions")
      }));
    }
    return el2;
  };
  return SubsCapsMenuItem2;
}(TextTrackMenuItem);
Component$1.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
var SubsCapsButton = /* @__PURE__ */ function(_TextTrackButton) {
  _inheritsLoose(SubsCapsButton2, _TextTrackButton);
  function SubsCapsButton2(player, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _TextTrackButton.call(this, player, options) || this;
    _this.label_ = "subtitles";
    if (["en", "en-us", "en-ca", "fr-ca"].indexOf(_this.player_.language_) > -1) {
      _this.label_ = "captions";
    }
    _this.menuButton_.controlText(toTitleCase$1(_this.label_));
    return _this;
  }
  var _proto = SubsCapsButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-subs-caps-button " + _TextTrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var items = [];
    if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
      items.push(new CaptionSettingsMenuItem(this.player_, {
        kind: this.label_
      }));
      this.hideThreshold_ += 1;
    }
    items = _TextTrackButton.prototype.createItems.call(this, items, SubsCapsMenuItem);
    return items;
  };
  return SubsCapsButton2;
}(TextTrackButton);
SubsCapsButton.prototype.kinds_ = ["captions", "subtitles"];
SubsCapsButton.prototype.controlText_ = "Subtitles";
Component$1.registerComponent("SubsCapsButton", SubsCapsButton);
var AudioTrackMenuItem = /* @__PURE__ */ function(_MenuItem) {
  _inheritsLoose(AudioTrackMenuItem2, _MenuItem);
  function AudioTrackMenuItem2(player, options) {
    var _this;
    var track = options.track;
    var tracks = player.audioTracks();
    options.label = track.label || track.language || "Unknown";
    options.selected = track.enabled;
    _this = _MenuItem.call(this, player, options) || this;
    _this.track = track;
    _this.addClass("vjs-" + track.kind + "-menu-item");
    var changeHandler = function changeHandler2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this.handleTracksChange.apply(_assertThisInitialized(_this), args);
    };
    tracks.addEventListener("change", changeHandler);
    _this.on("dispose", function() {
      tracks.removeEventListener("change", changeHandler);
    });
    return _this;
  }
  var _proto = AudioTrackMenuItem2.prototype;
  _proto.createEl = function createEl$1(type2, props, attrs) {
    var el2 = _MenuItem.prototype.createEl.call(this, type2, props, attrs);
    var parentSpan = el2.querySelector(".vjs-menu-item-text");
    if (this.options_.track.kind === "main-desc") {
      parentSpan.appendChild(createEl("span", {
        className: "vjs-icon-placeholder"
      }, {
        "aria-hidden": true
      }));
      parentSpan.appendChild(createEl("span", {
        className: "vjs-control-text",
        textContent: " " + this.localize("Descriptions")
      }));
    }
    return el2;
  };
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this, event);
    this.track.enabled = true;
    if (this.player_.tech_.featuresNativeAudioTracks) {
      var tracks = this.player_.audioTracks();
      for (var i = 0; i < tracks.length; i++) {
        var track = tracks[i];
        if (track === this.track) {
          continue;
        }
        track.enabled = track === this.track;
      }
    }
  };
  _proto.handleTracksChange = function handleTracksChange(event) {
    this.selected(this.track.enabled);
  };
  return AudioTrackMenuItem2;
}(MenuItem2);
Component$1.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
var AudioTrackButton = /* @__PURE__ */ function(_TrackButton) {
  _inheritsLoose(AudioTrackButton2, _TrackButton);
  function AudioTrackButton2(player, options) {
    if (options === void 0) {
      options = {};
    }
    options.tracks = player.audioTracks();
    return _TrackButton.call(this, player, options) || this;
  }
  var _proto = AudioTrackButton2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-audio-button " + _TrackButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-audio-button " + _TrackButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems(items) {
    if (items === void 0) {
      items = [];
    }
    this.hideThreshold_ = 1;
    var tracks = this.player_.audioTracks();
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      items.push(new AudioTrackMenuItem(this.player_, {
        track,
        // MenuItem is selectable
        selectable: true,
        // MenuItem is NOT multiSelectable (i.e. only one can be marked "selected" at a time)
        multiSelectable: false
      }));
    }
    return items;
  };
  return AudioTrackButton2;
}(TrackButton);
AudioTrackButton.prototype.controlText_ = "Audio Track";
Component$1.registerComponent("AudioTrackButton", AudioTrackButton);
var PlaybackRateMenuItem = /* @__PURE__ */ function(_MenuItem) {
  _inheritsLoose(PlaybackRateMenuItem2, _MenuItem);
  function PlaybackRateMenuItem2(player, options) {
    var _this;
    var label = options.rate;
    var rate = parseFloat(label, 10);
    options.label = label;
    options.selected = rate === player.playbackRate();
    options.selectable = true;
    options.multiSelectable = false;
    _this = _MenuItem.call(this, player, options) || this;
    _this.label = label;
    _this.rate = rate;
    _this.on(player, "ratechange", function(e2) {
      return _this.update(e2);
    });
    return _this;
  }
  var _proto = PlaybackRateMenuItem2.prototype;
  _proto.handleClick = function handleClick(event) {
    _MenuItem.prototype.handleClick.call(this);
    this.player().playbackRate(this.rate);
  };
  _proto.update = function update2(event) {
    this.selected(this.player().playbackRate() === this.rate);
  };
  return PlaybackRateMenuItem2;
}(MenuItem2);
PlaybackRateMenuItem.prototype.contentElType = "button";
Component$1.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
var PlaybackRateMenuButton = /* @__PURE__ */ function(_MenuButton) {
  _inheritsLoose(PlaybackRateMenuButton2, _MenuButton);
  function PlaybackRateMenuButton2(player, options) {
    var _this;
    _this = _MenuButton.call(this, player, options) || this;
    _this.menuButton_.el_.setAttribute("aria-describedby", _this.labelElId_);
    _this.updateVisibility();
    _this.updateLabel();
    _this.on(player, "loadstart", function(e2) {
      return _this.updateVisibility(e2);
    });
    _this.on(player, "ratechange", function(e2) {
      return _this.updateLabel(e2);
    });
    _this.on(player, "playbackrateschange", function(e2) {
      return _this.handlePlaybackRateschange(e2);
    });
    return _this;
  }
  var _proto = PlaybackRateMenuButton2.prototype;
  _proto.createEl = function createEl$1() {
    var el2 = _MenuButton.prototype.createEl.call(this);
    this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_;
    this.labelEl_ = createEl("div", {
      className: "vjs-playback-rate-value",
      id: this.labelElId_,
      textContent: "1x"
    });
    el2.appendChild(this.labelEl_);
    return el2;
  };
  _proto.dispose = function dispose() {
    this.labelEl_ = null;
    _MenuButton.prototype.dispose.call(this);
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-playback-rate " + _MenuButton.prototype.buildCSSClass.call(this);
  };
  _proto.buildWrapperCSSClass = function buildWrapperCSSClass() {
    return "vjs-playback-rate " + _MenuButton.prototype.buildWrapperCSSClass.call(this);
  };
  _proto.createItems = function createItems() {
    var rates = this.playbackRates();
    var items = [];
    for (var i = rates.length - 1; i >= 0; i--) {
      items.push(new PlaybackRateMenuItem(this.player(), {
        rate: rates[i] + "x"
      }));
    }
    return items;
  };
  _proto.updateARIAAttributes = function updateARIAAttributes() {
    this.el().setAttribute("aria-valuenow", this.player().playbackRate());
  };
  _proto.handleClick = function handleClick(event) {
    var currentRate = this.player().playbackRate();
    var rates = this.playbackRates();
    var currentIndex = rates.indexOf(currentRate);
    var newIndex = (currentIndex + 1) % rates.length;
    this.player().playbackRate(rates[newIndex]);
  };
  _proto.handlePlaybackRateschange = function handlePlaybackRateschange(event) {
    this.update();
  };
  _proto.playbackRates = function playbackRates() {
    var player = this.player();
    return player.playbackRates && player.playbackRates() || [];
  };
  _proto.playbackRateSupported = function playbackRateSupported() {
    return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
  };
  _proto.updateVisibility = function updateVisibility(event) {
    if (this.playbackRateSupported()) {
      this.removeClass("vjs-hidden");
    } else {
      this.addClass("vjs-hidden");
    }
  };
  _proto.updateLabel = function updateLabel(event) {
    if (this.playbackRateSupported()) {
      this.labelEl_.textContent = this.player().playbackRate() + "x";
    }
  };
  return PlaybackRateMenuButton2;
}(MenuButton);
PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
Component$1.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
var Spacer = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Spacer2, _Component);
  function Spacer2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = Spacer2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-spacer " + _Component.prototype.buildCSSClass.call(this);
  };
  _proto.createEl = function createEl2(tag, props, attributes) {
    if (tag === void 0) {
      tag = "div";
    }
    if (props === void 0) {
      props = {};
    }
    if (attributes === void 0) {
      attributes = {};
    }
    if (!props.className) {
      props.className = this.buildCSSClass();
    }
    return _Component.prototype.createEl.call(this, tag, props, attributes);
  };
  return Spacer2;
}(Component$1);
Component$1.registerComponent("Spacer", Spacer);
var CustomControlSpacer = /* @__PURE__ */ function(_Spacer) {
  _inheritsLoose(CustomControlSpacer2, _Spacer);
  function CustomControlSpacer2() {
    return _Spacer.apply(this, arguments) || this;
  }
  var _proto = CustomControlSpacer2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-custom-control-spacer " + _Spacer.prototype.buildCSSClass.call(this);
  };
  _proto.createEl = function createEl2() {
    return _Spacer.prototype.createEl.call(this, "div", {
      className: this.buildCSSClass(),
      // No-flex/table-cell mode requires there be some content
      // in the cell to fill the remaining space of the table.
      textContent: ""
    });
  };
  return CustomControlSpacer2;
}(Spacer);
Component$1.registerComponent("CustomControlSpacer", CustomControlSpacer);
var ControlBar = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ControlBar2, _Component);
  function ControlBar2() {
    return _Component.apply(this, arguments) || this;
  }
  var _proto = ControlBar2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "div", {
      className: "vjs-control-bar",
      dir: "ltr"
    });
  };
  return ControlBar2;
}(Component$1);
ControlBar.prototype.options_ = {
  children: ["playToggle", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle"]
};
if ("exitPictureInPicture" in document_1) {
  ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, "pictureInPictureToggle");
}
Component$1.registerComponent("ControlBar", ControlBar);
var ErrorDisplay = /* @__PURE__ */ function(_ModalDialog) {
  _inheritsLoose(ErrorDisplay2, _ModalDialog);
  function ErrorDisplay2(player, options) {
    var _this;
    _this = _ModalDialog.call(this, player, options) || this;
    _this.on(player, "error", function(e2) {
      return _this.open(e2);
    });
    return _this;
  }
  var _proto = ErrorDisplay2.prototype;
  _proto.buildCSSClass = function buildCSSClass() {
    return "vjs-error-display " + _ModalDialog.prototype.buildCSSClass.call(this);
  };
  _proto.content = function content() {
    var error = this.player().error();
    return error ? this.localize(error.message) : "";
  };
  return ErrorDisplay2;
}(ModalDialog);
ErrorDisplay.prototype.options_ = _extends$8({}, ModalDialog.prototype.options_, {
  pauseOnOpen: false,
  fillAlways: true,
  temporary: false,
  uncloseable: true
});
Component$1.registerComponent("ErrorDisplay", ErrorDisplay);
var LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings";
var COLOR_BLACK = ["#000", "Black"];
var COLOR_BLUE = ["#00F", "Blue"];
var COLOR_CYAN = ["#0FF", "Cyan"];
var COLOR_GREEN = ["#0F0", "Green"];
var COLOR_MAGENTA = ["#F0F", "Magenta"];
var COLOR_RED = ["#F00", "Red"];
var COLOR_WHITE = ["#FFF", "White"];
var COLOR_YELLOW = ["#FF0", "Yellow"];
var OPACITY_OPAQUE = ["1", "Opaque"];
var OPACITY_SEMI = ["0.5", "Semi-Transparent"];
var OPACITY_TRANS = ["0", "Transparent"];
var selectConfigs = {
  backgroundColor: {
    selector: ".vjs-bg-color > select",
    id: "captions-background-color-%s",
    label: "Color",
    options: [COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },
  backgroundOpacity: {
    selector: ".vjs-bg-opacity > select",
    id: "captions-background-opacity-%s",
    label: "Transparency",
    options: [OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS]
  },
  color: {
    selector: ".vjs-fg-color > select",
    id: "captions-foreground-color-%s",
    label: "Color",
    options: [COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN]
  },
  edgeStyle: {
    selector: ".vjs-edge-style > select",
    id: "%s",
    label: "Text Edge Style",
    options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Dropshadow"]]
  },
  fontFamily: {
    selector: ".vjs-font-family > select",
    id: "captions-font-family-%s",
    label: "Font Family",
    options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
  },
  fontPercent: {
    selector: ".vjs-font-percent > select",
    id: "captions-font-size-%s",
    label: "Font Size",
    options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
    "default": 2,
    parser: function parser(v2) {
      return v2 === "1.00" ? null : Number(v2);
    }
  },
  textOpacity: {
    selector: ".vjs-text-opacity > select",
    id: "captions-foreground-opacity-%s",
    label: "Transparency",
    options: [OPACITY_OPAQUE, OPACITY_SEMI]
  },
  // Options for this object are defined below.
  windowColor: {
    selector: ".vjs-window-color > select",
    id: "captions-window-color-%s",
    label: "Color"
  },
  // Options for this object are defined below.
  windowOpacity: {
    selector: ".vjs-window-opacity > select",
    id: "captions-window-opacity-%s",
    label: "Transparency",
    options: [OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE]
  }
};
selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
function parseOptionValue(value, parser2) {
  if (parser2) {
    value = parser2(value);
  }
  if (value && value !== "none") {
    return value;
  }
}
function getSelectedOptionValue(el2, parser2) {
  var value = el2.options[el2.options.selectedIndex].value;
  return parseOptionValue(value, parser2);
}
function setSelectedOption(el2, value, parser2) {
  if (!value) {
    return;
  }
  for (var i = 0; i < el2.options.length; i++) {
    if (parseOptionValue(el2.options[i].value, parser2) === value) {
      el2.selectedIndex = i;
      break;
    }
  }
}
var TextTrackSettings = /* @__PURE__ */ function(_ModalDialog) {
  _inheritsLoose(TextTrackSettings2, _ModalDialog);
  function TextTrackSettings2(player, options) {
    var _this;
    options.temporary = false;
    _this = _ModalDialog.call(this, player, options) || this;
    _this.updateDisplay = _this.updateDisplay.bind(_assertThisInitialized(_this));
    _this.fill();
    _this.hasBeenOpened_ = _this.hasBeenFilled_ = true;
    _this.endDialog = createEl("p", {
      className: "vjs-control-text",
      textContent: _this.localize("End of dialog window.")
    });
    _this.el().appendChild(_this.endDialog);
    _this.setDefaults();
    if (options.persistTextTrackSettings === void 0) {
      _this.options_.persistTextTrackSettings = _this.options_.playerOptions.persistTextTrackSettings;
    }
    _this.on(_this.$(".vjs-done-button"), "click", function() {
      _this.saveSettings();
      _this.close();
    });
    _this.on(_this.$(".vjs-default-button"), "click", function() {
      _this.setDefaults();
      _this.updateDisplay();
    });
    each(selectConfigs, function(config2) {
      _this.on(_this.$(config2.selector), "change", _this.updateDisplay);
    });
    if (_this.options_.persistTextTrackSettings) {
      _this.restoreSettings();
    }
    return _this;
  }
  var _proto = TextTrackSettings2.prototype;
  _proto.dispose = function dispose() {
    this.endDialog = null;
    _ModalDialog.prototype.dispose.call(this);
  };
  _proto.createElSelect_ = function createElSelect_(key, legendId, type2) {
    var _this2 = this;
    if (legendId === void 0) {
      legendId = "";
    }
    if (type2 === void 0) {
      type2 = "label";
    }
    var config2 = selectConfigs[key];
    var id2 = config2.id.replace("%s", this.id_);
    var selectLabelledbyIds = [legendId, id2].join(" ").trim();
    return ["<" + type2 + ' id="' + id2 + '" class="' + (type2 === "label" ? "vjs-label" : "") + '">', this.localize(config2.label), "</" + type2 + ">", '<select aria-labelledby="' + selectLabelledbyIds + '">'].concat(config2.options.map(function(o) {
      var optionId = id2 + "-" + o[1].replace(/\W+/g, "");
      return ['<option id="' + optionId + '" value="' + o[0] + '" ', 'aria-labelledby="' + selectLabelledbyIds + " " + optionId + '">', _this2.localize(o[1]), "</option>"].join("");
    })).concat("</select>").join("");
  };
  _proto.createElFgColor_ = function createElFgColor_() {
    var legendId = "captions-text-legend-" + this.id_;
    return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Text"), "</legend>", this.createElSelect_("color", legendId), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElBgColor_ = function createElBgColor_() {
    var legendId = "captions-background-" + this.id_;
    return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Background"), "</legend>", this.createElSelect_("backgroundColor", legendId), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElWinColor_ = function createElWinColor_() {
    var legendId = "captions-window-" + this.id_;
    return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + legendId + '">', this.localize("Window"), "</legend>", this.createElSelect_("windowColor", legendId), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", legendId), "</span>", "</fieldset>"].join("");
  };
  _proto.createElColors_ = function createElColors_() {
    return createEl("div", {
      className: "vjs-track-settings-colors",
      innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("")
    });
  };
  _proto.createElFont_ = function createElFont_() {
    return createEl("div", {
      className: "vjs-track-settings-font",
      innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("")
    });
  };
  _proto.createElControls_ = function createElControls_() {
    var defaultsDescription = this.localize("restore all settings to the default values");
    return createEl("div", {
      className: "vjs-track-settings-controls",
      innerHTML: ['<button type="button" class="vjs-default-button" title="' + defaultsDescription + '">', this.localize("Reset"), '<span class="vjs-control-text"> ' + defaultsDescription + "</span>", "</button>", '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"].join("")
    });
  };
  _proto.content = function content() {
    return [this.createElColors_(), this.createElFont_(), this.createElControls_()];
  };
  _proto.label = function label() {
    return this.localize("Caption Settings Dialog");
  };
  _proto.description = function description() {
    return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
  };
  _proto.buildCSSClass = function buildCSSClass() {
    return _ModalDialog.prototype.buildCSSClass.call(this) + " vjs-text-track-settings";
  };
  _proto.getValues = function getValues() {
    var _this3 = this;
    return reduce(selectConfigs, function(accum, config2, key) {
      var value = getSelectedOptionValue(_this3.$(config2.selector), config2.parser);
      if (value !== void 0) {
        accum[key] = value;
      }
      return accum;
    }, {});
  };
  _proto.setValues = function setValues(values3) {
    var _this4 = this;
    each(selectConfigs, function(config2, key) {
      setSelectedOption(_this4.$(config2.selector), values3[key], config2.parser);
    });
  };
  _proto.setDefaults = function setDefaults() {
    var _this5 = this;
    each(selectConfigs, function(config2) {
      var index2 = config2.hasOwnProperty("default") ? config2["default"] : 0;
      _this5.$(config2.selector).selectedIndex = index2;
    });
  };
  _proto.restoreSettings = function restoreSettings() {
    var values3;
    try {
      values3 = JSON.parse(window_1.localStorage.getItem(LOCAL_STORAGE_KEY$1));
    } catch (err) {
      log$1.warn(err);
    }
    if (values3) {
      this.setValues(values3);
    }
  };
  _proto.saveSettings = function saveSettings() {
    if (!this.options_.persistTextTrackSettings) {
      return;
    }
    var values3 = this.getValues();
    try {
      if (Object.keys(values3).length) {
        window_1.localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values3));
      } else {
        window_1.localStorage.removeItem(LOCAL_STORAGE_KEY$1);
      }
    } catch (err) {
      log$1.warn(err);
    }
  };
  _proto.updateDisplay = function updateDisplay() {
    var ttDisplay = this.player_.getChild("textTrackDisplay");
    if (ttDisplay) {
      ttDisplay.updateDisplay();
    }
  };
  _proto.conditionalBlur_ = function conditionalBlur_() {
    this.previouslyActiveEl_ = null;
    var cb2 = this.player_.controlBar;
    var subsCapsBtn = cb2 && cb2.subsCapsButton;
    var ccBtn = cb2 && cb2.captionsButton;
    if (subsCapsBtn) {
      subsCapsBtn.focus();
    } else if (ccBtn) {
      ccBtn.focus();
    }
  };
  return TextTrackSettings2;
}(ModalDialog);
Component$1.registerComponent("TextTrackSettings", TextTrackSettings);
var ResizeManager = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(ResizeManager2, _Component);
  function ResizeManager2(player, options) {
    var _this;
    var RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window_1.ResizeObserver;
    if (options.ResizeObserver === null) {
      RESIZE_OBSERVER_AVAILABLE = false;
    }
    var options_ = mergeOptions$3({
      createEl: !RESIZE_OBSERVER_AVAILABLE,
      reportTouchActivity: false
    }, options);
    _this = _Component.call(this, player, options_) || this;
    _this.ResizeObserver = options.ResizeObserver || window_1.ResizeObserver;
    _this.loadListener_ = null;
    _this.resizeObserver_ = null;
    _this.debouncedHandler_ = debounce(function() {
      _this.resizeHandler();
    }, 100, false, _assertThisInitialized(_this));
    if (RESIZE_OBSERVER_AVAILABLE) {
      _this.resizeObserver_ = new _this.ResizeObserver(_this.debouncedHandler_);
      _this.resizeObserver_.observe(player.el());
    } else {
      _this.loadListener_ = function() {
        if (!_this.el_ || !_this.el_.contentWindow) {
          return;
        }
        var debouncedHandler_ = _this.debouncedHandler_;
        var unloadListener_ = _this.unloadListener_ = function() {
          off(this, "resize", debouncedHandler_);
          off(this, "unload", unloadListener_);
          unloadListener_ = null;
        };
        on(_this.el_.contentWindow, "unload", unloadListener_);
        on(_this.el_.contentWindow, "resize", debouncedHandler_);
      };
      _this.one("load", _this.loadListener_);
    }
    return _this;
  }
  var _proto = ResizeManager2.prototype;
  _proto.createEl = function createEl2() {
    return _Component.prototype.createEl.call(this, "iframe", {
      className: "vjs-resize-manager",
      tabIndex: -1,
      title: this.localize("No content")
    }, {
      "aria-hidden": "true"
    });
  };
  _proto.resizeHandler = function resizeHandler() {
    if (!this.player_ || !this.player_.trigger) {
      return;
    }
    this.player_.trigger("playerresize");
  };
  _proto.dispose = function dispose() {
    if (this.debouncedHandler_) {
      this.debouncedHandler_.cancel();
    }
    if (this.resizeObserver_) {
      if (this.player_.el()) {
        this.resizeObserver_.unobserve(this.player_.el());
      }
      this.resizeObserver_.disconnect();
    }
    if (this.loadListener_) {
      this.off("load", this.loadListener_);
    }
    if (this.el_ && this.el_.contentWindow && this.unloadListener_) {
      this.unloadListener_.call(this.el_.contentWindow);
    }
    this.ResizeObserver = null;
    this.resizeObserver = null;
    this.debouncedHandler_ = null;
    this.loadListener_ = null;
    _Component.prototype.dispose.call(this);
  };
  return ResizeManager2;
}(Component$1);
Component$1.registerComponent("ResizeManager", ResizeManager);
var defaults$2 = {
  trackingThreshold: 20,
  liveTolerance: 15
};
var LiveTracker = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(LiveTracker2, _Component);
  function LiveTracker2(player, options) {
    var _this;
    var options_ = mergeOptions$3(defaults$2, options, {
      createEl: false
    });
    _this = _Component.call(this, player, options_) || this;
    _this.handleVisibilityChange_ = function(e2) {
      return _this.handleVisibilityChange(e2);
    };
    _this.trackLiveHandler_ = function() {
      return _this.trackLive_();
    };
    _this.handlePlay_ = function(e2) {
      return _this.handlePlay(e2);
    };
    _this.handleFirstTimeupdate_ = function(e2) {
      return _this.handleFirstTimeupdate(e2);
    };
    _this.handleSeeked_ = function(e2) {
      return _this.handleSeeked(e2);
    };
    _this.seekToLiveEdge_ = function(e2) {
      return _this.seekToLiveEdge(e2);
    };
    _this.reset_();
    _this.on(_this.player_, "durationchange", function(e2) {
      return _this.handleDurationchange(e2);
    });
    _this.on(_this.player_, "canplay", function() {
      return _this.toggleTracking();
    });
    if (IE_VERSION && "hidden" in document_1 && "visibilityState" in document_1) {
      _this.on(document_1, "visibilitychange", _this.handleVisibilityChange_);
    }
    return _this;
  }
  var _proto = LiveTracker2.prototype;
  _proto.handleVisibilityChange = function handleVisibilityChange2() {
    if (this.player_.duration() !== Infinity) {
      return;
    }
    if (document_1.hidden) {
      this.stopTracking();
    } else {
      this.startTracking();
    }
  };
  _proto.trackLive_ = function trackLive_() {
    var seekable3 = this.player_.seekable();
    if (!seekable3 || !seekable3.length) {
      return;
    }
    var newTime = Number(window_1.performance.now().toFixed(4));
    var deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1e3;
    this.lastTime_ = newTime;
    this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
    var liveCurrentTime = this.liveCurrentTime();
    var currentTime = this.player_.currentTime();
    var isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
    if (!this.timeupdateSeen_ || liveCurrentTime === Infinity) {
      isBehind = false;
    }
    if (isBehind !== this.behindLiveEdge_) {
      this.behindLiveEdge_ = isBehind;
      this.trigger("liveedgechange");
    }
  };
  _proto.handleDurationchange = function handleDurationchange() {
    this.toggleTracking();
  };
  _proto.toggleTracking = function toggleTracking() {
    if (this.player_.duration() === Infinity && this.liveWindow() >= this.options_.trackingThreshold) {
      if (this.player_.options_.liveui) {
        this.player_.addClass("vjs-liveui");
      }
      this.startTracking();
    } else {
      this.player_.removeClass("vjs-liveui");
      this.stopTracking();
    }
  };
  _proto.startTracking = function startTracking() {
    if (this.isTracking()) {
      return;
    }
    if (!this.timeupdateSeen_) {
      this.timeupdateSeen_ = this.player_.hasStarted();
    }
    this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
    this.trackLive_();
    this.on(this.player_, ["play", "pause"], this.trackLiveHandler_);
    if (!this.timeupdateSeen_) {
      this.one(this.player_, "play", this.handlePlay_);
      this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_);
    } else {
      this.on(this.player_, "seeked", this.handleSeeked_);
    }
  };
  _proto.handleFirstTimeupdate = function handleFirstTimeupdate() {
    this.timeupdateSeen_ = true;
    this.on(this.player_, "seeked", this.handleSeeked_);
  };
  _proto.handleSeeked = function handleSeeked() {
    var timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
    this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
    this.nextSeekedFromUser_ = false;
    this.trackLive_();
  };
  _proto.handlePlay = function handlePlay() {
    this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
  };
  _proto.reset_ = function reset_() {
    this.lastTime_ = -1;
    this.pastSeekEnd_ = 0;
    this.lastSeekEnd_ = -1;
    this.behindLiveEdge_ = true;
    this.timeupdateSeen_ = false;
    this.seekedBehindLive_ = false;
    this.nextSeekedFromUser_ = false;
    this.clearInterval(this.trackingInterval_);
    this.trackingInterval_ = null;
    this.off(this.player_, ["play", "pause"], this.trackLiveHandler_);
    this.off(this.player_, "seeked", this.handleSeeked_);
    this.off(this.player_, "play", this.handlePlay_);
    this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_);
    this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
  };
  _proto.nextSeekedFromUser = function nextSeekedFromUser() {
    this.nextSeekedFromUser_ = true;
  };
  _proto.stopTracking = function stopTracking() {
    if (!this.isTracking()) {
      return;
    }
    this.reset_();
    this.trigger("liveedgechange");
  };
  _proto.seekableEnd = function seekableEnd() {
    var seekable3 = this.player_.seekable();
    var seekableEnds = [];
    var i = seekable3 ? seekable3.length : 0;
    while (i--) {
      seekableEnds.push(seekable3.end(i));
    }
    return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : Infinity;
  };
  _proto.seekableStart = function seekableStart() {
    var seekable3 = this.player_.seekable();
    var seekableStarts = [];
    var i = seekable3 ? seekable3.length : 0;
    while (i--) {
      seekableStarts.push(seekable3.start(i));
    }
    return seekableStarts.length ? seekableStarts.sort()[0] : 0;
  };
  _proto.liveWindow = function liveWindow() {
    var liveCurrentTime = this.liveCurrentTime();
    if (liveCurrentTime === Infinity) {
      return 0;
    }
    return liveCurrentTime - this.seekableStart();
  };
  _proto.isLive = function isLive() {
    return this.isTracking();
  };
  _proto.atLiveEdge = function atLiveEdge() {
    return !this.behindLiveEdge();
  };
  _proto.liveCurrentTime = function liveCurrentTime() {
    return this.pastSeekEnd() + this.seekableEnd();
  };
  _proto.pastSeekEnd = function pastSeekEnd() {
    var seekableEnd = this.seekableEnd();
    if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) {
      this.pastSeekEnd_ = 0;
    }
    this.lastSeekEnd_ = seekableEnd;
    return this.pastSeekEnd_;
  };
  _proto.behindLiveEdge = function behindLiveEdge() {
    return this.behindLiveEdge_;
  };
  _proto.isTracking = function isTracking() {
    return typeof this.trackingInterval_ === "number";
  };
  _proto.seekToLiveEdge = function seekToLiveEdge() {
    this.seekedBehindLive_ = false;
    if (this.atLiveEdge()) {
      return;
    }
    this.nextSeekedFromUser_ = false;
    this.player_.currentTime(this.liveCurrentTime());
  };
  _proto.dispose = function dispose() {
    this.off(document_1, "visibilitychange", this.handleVisibilityChange_);
    this.stopTracking();
    _Component.prototype.dispose.call(this);
  };
  return LiveTracker2;
}(Component$1);
Component$1.registerComponent("LiveTracker", LiveTracker);
var sourcesetLoad = function sourcesetLoad2(tech) {
  var el2 = tech.el();
  if (el2.hasAttribute("src")) {
    tech.triggerSourceset(el2.src);
    return true;
  }
  var sources = tech.$$("source");
  var srcUrls = [];
  var src = "";
  if (!sources.length) {
    return false;
  }
  for (var i = 0; i < sources.length; i++) {
    var url = sources[i].src;
    if (url && srcUrls.indexOf(url) === -1) {
      srcUrls.push(url);
    }
  }
  if (!srcUrls.length) {
    return false;
  }
  if (srcUrls.length === 1) {
    src = srcUrls[0];
  }
  tech.triggerSourceset(src);
  return true;
};
var innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
  get: function get2() {
    return this.cloneNode(true).innerHTML;
  },
  set: function set2(v2) {
    var dummy = document_1.createElement(this.nodeName.toLowerCase());
    dummy.innerHTML = v2;
    var docFrag = document_1.createDocumentFragment();
    while (dummy.childNodes.length) {
      docFrag.appendChild(dummy.childNodes[0]);
    }
    this.innerText = "";
    window_1.Element.prototype.appendChild.call(this, docFrag);
    return this.innerHTML;
  }
});
var getDescriptor = function getDescriptor2(priority, prop3) {
  var descriptor = {};
  for (var i = 0; i < priority.length; i++) {
    descriptor = Object.getOwnPropertyDescriptor(priority[i], prop3);
    if (descriptor && descriptor.set && descriptor.get) {
      break;
    }
  }
  descriptor.enumerable = true;
  descriptor.configurable = true;
  return descriptor;
};
var getInnerHTMLDescriptor = function getInnerHTMLDescriptor2(tech) {
  return getDescriptor([tech.el(), window_1.HTMLMediaElement.prototype, window_1.Element.prototype, innerHTMLDescriptorPolyfill], "innerHTML");
};
var firstSourceWatch = function firstSourceWatch2(tech) {
  var el2 = tech.el();
  if (el2.resetSourceWatch_) {
    return;
  }
  var old = {};
  var innerDescriptor = getInnerHTMLDescriptor(tech);
  var appendWrapper = function appendWrapper2(appendFn) {
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var retval = appendFn.apply(el2, args);
      sourcesetLoad(tech);
      return retval;
    };
  };
  ["append", "appendChild", "insertAdjacentHTML"].forEach(function(k2) {
    if (!el2[k2]) {
      return;
    }
    old[k2] = el2[k2];
    el2[k2] = appendWrapper(old[k2]);
  });
  Object.defineProperty(el2, "innerHTML", mergeOptions$3(innerDescriptor, {
    set: appendWrapper(innerDescriptor.set)
  }));
  el2.resetSourceWatch_ = function() {
    el2.resetSourceWatch_ = null;
    Object.keys(old).forEach(function(k2) {
      el2[k2] = old[k2];
    });
    Object.defineProperty(el2, "innerHTML", innerDescriptor);
  };
  tech.one("sourceset", el2.resetSourceWatch_);
};
var srcDescriptorPolyfill = Object.defineProperty({}, "src", {
  get: function get3() {
    if (this.hasAttribute("src")) {
      return getAbsoluteURL(window_1.Element.prototype.getAttribute.call(this, "src"));
    }
    return "";
  },
  set: function set3(v2) {
    window_1.Element.prototype.setAttribute.call(this, "src", v2);
    return v2;
  }
});
var getSrcDescriptor = function getSrcDescriptor2(tech) {
  return getDescriptor([tech.el(), window_1.HTMLMediaElement.prototype, srcDescriptorPolyfill], "src");
};
var setupSourceset = function setupSourceset2(tech) {
  if (!tech.featuresSourceset) {
    return;
  }
  var el2 = tech.el();
  if (el2.resetSourceset_) {
    return;
  }
  var srcDescriptor = getSrcDescriptor(tech);
  var oldSetAttribute = el2.setAttribute;
  var oldLoad = el2.load;
  Object.defineProperty(el2, "src", mergeOptions$3(srcDescriptor, {
    set: function set4(v2) {
      var retval = srcDescriptor.set.call(el2, v2);
      tech.triggerSourceset(el2.src);
      return retval;
    }
  }));
  el2.setAttribute = function(n2, v2) {
    var retval = oldSetAttribute.call(el2, n2, v2);
    if (/src/i.test(n2)) {
      tech.triggerSourceset(el2.src);
    }
    return retval;
  };
  el2.load = function() {
    var retval = oldLoad.call(el2);
    if (!sourcesetLoad(tech)) {
      tech.triggerSourceset("");
      firstSourceWatch(tech);
    }
    return retval;
  };
  if (el2.currentSrc) {
    tech.triggerSourceset(el2.currentSrc);
  } else if (!sourcesetLoad(tech)) {
    firstSourceWatch(tech);
  }
  el2.resetSourceset_ = function() {
    el2.resetSourceset_ = null;
    el2.load = oldLoad;
    el2.setAttribute = oldSetAttribute;
    Object.defineProperty(el2, "src", srcDescriptor);
    if (el2.resetSourceWatch_) {
      el2.resetSourceWatch_();
    }
  };
};
var defineLazyProperty = function defineLazyProperty2(obj, key, getValue2, setter) {
  if (setter === void 0) {
    setter = true;
  }
  var set4 = function set5(value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      writable: true
    });
  };
  var options = {
    configurable: true,
    enumerable: true,
    get: function get8() {
      var value = getValue2();
      set4(value);
      return value;
    }
  };
  if (setter) {
    options.set = set4;
  }
  return Object.defineProperty(obj, key, options);
};
var Html5 = /* @__PURE__ */ function(_Tech) {
  _inheritsLoose(Html52, _Tech);
  function Html52(options, ready) {
    var _this;
    _this = _Tech.call(this, options, ready) || this;
    var source = options.source;
    var crossoriginTracks = false;
    _this.featuresVideoFrameCallback = _this.featuresVideoFrameCallback && _this.el_.tagName === "VIDEO";
    if (source && (_this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) {
      _this.setSource(source);
    } else {
      _this.handleLateInit_(_this.el_);
    }
    if (options.enableSourceset) {
      _this.setupSourcesetHandling_();
    }
    _this.isScrubbing_ = false;
    if (_this.el_.hasChildNodes()) {
      var nodes = _this.el_.childNodes;
      var nodesLength = nodes.length;
      var removeNodes = [];
      while (nodesLength--) {
        var node2 = nodes[nodesLength];
        var nodeName = node2.nodeName.toLowerCase();
        if (nodeName === "track") {
          if (!_this.featuresNativeTextTracks) {
            removeNodes.push(node2);
          } else {
            _this.remoteTextTrackEls().addTrackElement_(node2);
            _this.remoteTextTracks().addTrack(node2.track);
            _this.textTracks().addTrack(node2.track);
            if (!crossoriginTracks && !_this.el_.hasAttribute("crossorigin") && isCrossOrigin(node2.src)) {
              crossoriginTracks = true;
            }
          }
        }
      }
      for (var i = 0; i < removeNodes.length; i++) {
        _this.el_.removeChild(removeNodes[i]);
      }
    }
    _this.proxyNativeTracks_();
    if (_this.featuresNativeTextTracks && crossoriginTracks) {
      log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\nThis may prevent text tracks from loading.");
    }
    _this.restoreMetadataTracksInIOSNativePlayer_();
    if ((TOUCH_ENABLED || IS_IPHONE || IS_NATIVE_ANDROID) && options.nativeControlsForTouch === true) {
      _this.setControls(true);
    }
    _this.proxyWebkitFullscreen_();
    _this.triggerReady();
    return _this;
  }
  var _proto = Html52.prototype;
  _proto.dispose = function dispose() {
    if (this.el_ && this.el_.resetSourceset_) {
      this.el_.resetSourceset_();
    }
    Html52.disposeMediaElement(this.el_);
    this.options_ = null;
    _Tech.prototype.dispose.call(this);
  };
  _proto.setupSourcesetHandling_ = function setupSourcesetHandling_() {
    setupSourceset(this);
  };
  _proto.restoreMetadataTracksInIOSNativePlayer_ = function restoreMetadataTracksInIOSNativePlayer_() {
    var textTracks = this.textTracks();
    var metadataTracksPreFullscreenState;
    var takeMetadataTrackSnapshot = function takeMetadataTrackSnapshot2() {
      metadataTracksPreFullscreenState = [];
      for (var i = 0; i < textTracks.length; i++) {
        var track = textTracks[i];
        if (track.kind === "metadata") {
          metadataTracksPreFullscreenState.push({
            track,
            storedMode: track.mode
          });
        }
      }
    };
    takeMetadataTrackSnapshot();
    textTracks.addEventListener("change", takeMetadataTrackSnapshot);
    this.on("dispose", function() {
      return textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
    });
    var restoreTrackMode = function restoreTrackMode2() {
      for (var i = 0; i < metadataTracksPreFullscreenState.length; i++) {
        var storedTrack = metadataTracksPreFullscreenState[i];
        if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) {
          storedTrack.track.mode = storedTrack.storedMode;
        }
      }
      textTracks.removeEventListener("change", restoreTrackMode2);
    };
    this.on("webkitbeginfullscreen", function() {
      textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
      textTracks.removeEventListener("change", restoreTrackMode);
      textTracks.addEventListener("change", restoreTrackMode);
    });
    this.on("webkitendfullscreen", function() {
      textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
      textTracks.addEventListener("change", takeMetadataTrackSnapshot);
      textTracks.removeEventListener("change", restoreTrackMode);
    });
  };
  _proto.overrideNative_ = function overrideNative_(type2, override) {
    var _this2 = this;
    if (override !== this["featuresNative" + type2 + "Tracks"]) {
      return;
    }
    var lowerCaseType = type2.toLowerCase();
    if (this[lowerCaseType + "TracksListeners_"]) {
      Object.keys(this[lowerCaseType + "TracksListeners_"]).forEach(function(eventName) {
        var elTracks = _this2.el()[lowerCaseType + "Tracks"];
        elTracks.removeEventListener(eventName, _this2[lowerCaseType + "TracksListeners_"][eventName]);
      });
    }
    this["featuresNative" + type2 + "Tracks"] = !override;
    this[lowerCaseType + "TracksListeners_"] = null;
    this.proxyNativeTracksForType_(lowerCaseType);
  };
  _proto.overrideNativeAudioTracks = function overrideNativeAudioTracks(override) {
    this.overrideNative_("Audio", override);
  };
  _proto.overrideNativeVideoTracks = function overrideNativeVideoTracks(override) {
    this.overrideNative_("Video", override);
  };
  _proto.proxyNativeTracksForType_ = function proxyNativeTracksForType_(name) {
    var _this3 = this;
    var props = NORMAL[name];
    var elTracks = this.el()[props.getterName];
    var techTracks = this[props.getterName]();
    if (!this["featuresNative" + props.capitalName + "Tracks"] || !elTracks || !elTracks.addEventListener) {
      return;
    }
    var listeners = {
      change: function change(e2) {
        var event = {
          type: "change",
          target: techTracks,
          currentTarget: techTracks,
          srcElement: techTracks
        };
        techTracks.trigger(event);
        if (name === "text") {
          _this3[REMOTE.remoteText.getterName]().trigger(event);
        }
      },
      addtrack: function addtrack(e2) {
        techTracks.addTrack(e2.track);
      },
      removetrack: function removetrack(e2) {
        techTracks.removeTrack(e2.track);
      }
    };
    var removeOldTracks = function removeOldTracks2() {
      var removeTracks = [];
      for (var i = 0; i < techTracks.length; i++) {
        var found = false;
        for (var j2 = 0; j2 < elTracks.length; j2++) {
          if (elTracks[j2] === techTracks[i]) {
            found = true;
            break;
          }
        }
        if (!found) {
          removeTracks.push(techTracks[i]);
        }
      }
      while (removeTracks.length) {
        techTracks.removeTrack(removeTracks.shift());
      }
    };
    this[props.getterName + "Listeners_"] = listeners;
    Object.keys(listeners).forEach(function(eventName) {
      var listener = listeners[eventName];
      elTracks.addEventListener(eventName, listener);
      _this3.on("dispose", function(e2) {
        return elTracks.removeEventListener(eventName, listener);
      });
    });
    this.on("loadstart", removeOldTracks);
    this.on("dispose", function(e2) {
      return _this3.off("loadstart", removeOldTracks);
    });
  };
  _proto.proxyNativeTracks_ = function proxyNativeTracks_() {
    var _this4 = this;
    NORMAL.names.forEach(function(name) {
      _this4.proxyNativeTracksForType_(name);
    });
  };
  _proto.createEl = function createEl2() {
    var el2 = this.options_.tag;
    if (!el2 || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
      if (el2) {
        var clone2 = el2.cloneNode(true);
        if (el2.parentNode) {
          el2.parentNode.insertBefore(clone2, el2);
        }
        Html52.disposeMediaElement(el2);
        el2 = clone2;
      } else {
        el2 = document_1.createElement("video");
        var tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
        var attributes = mergeOptions$3({}, tagAttributes);
        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) {
          delete attributes.controls;
        }
        setAttributes(el2, assign$1(attributes, {
          id: this.options_.techId,
          "class": "vjs-tech"
        }));
      }
      el2.playerId = this.options_.playerId;
    }
    if (typeof this.options_.preload !== "undefined") {
      setAttribute(el2, "preload", this.options_.preload);
    }
    if (this.options_.disablePictureInPicture !== void 0) {
      el2.disablePictureInPicture = this.options_.disablePictureInPicture;
    }
    var settingsAttrs = ["loop", "muted", "playsinline", "autoplay"];
    for (var i = 0; i < settingsAttrs.length; i++) {
      var attr = settingsAttrs[i];
      var value = this.options_[attr];
      if (typeof value !== "undefined") {
        if (value) {
          setAttribute(el2, attr, attr);
        } else {
          removeAttribute(el2, attr);
        }
        el2[attr] = value;
      }
    }
    return el2;
  };
  _proto.handleLateInit_ = function handleLateInit_(el2) {
    if (el2.networkState === 0 || el2.networkState === 3) {
      return;
    }
    if (el2.readyState === 0) {
      var loadstartFired = false;
      var setLoadstartFired = function setLoadstartFired2() {
        loadstartFired = true;
      };
      this.on("loadstart", setLoadstartFired);
      var triggerLoadstart = function triggerLoadstart2() {
        if (!loadstartFired) {
          this.trigger("loadstart");
        }
      };
      this.on("loadedmetadata", triggerLoadstart);
      this.ready(function() {
        this.off("loadstart", setLoadstartFired);
        this.off("loadedmetadata", triggerLoadstart);
        if (!loadstartFired) {
          this.trigger("loadstart");
        }
      });
      return;
    }
    var eventsToTrigger = ["loadstart"];
    eventsToTrigger.push("loadedmetadata");
    if (el2.readyState >= 2) {
      eventsToTrigger.push("loadeddata");
    }
    if (el2.readyState >= 3) {
      eventsToTrigger.push("canplay");
    }
    if (el2.readyState >= 4) {
      eventsToTrigger.push("canplaythrough");
    }
    this.ready(function() {
      eventsToTrigger.forEach(function(type2) {
        this.trigger(type2);
      }, this);
    });
  };
  _proto.setScrubbing = function setScrubbing(isScrubbing) {
    this.isScrubbing_ = isScrubbing;
  };
  _proto.scrubbing = function scrubbing() {
    return this.isScrubbing_;
  };
  _proto.setCurrentTime = function setCurrentTime(seconds) {
    try {
      if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) {
        this.el_.fastSeek(seconds);
      } else {
        this.el_.currentTime = seconds;
      }
    } catch (e2) {
      log$1(e2, "Video is not ready. (Video.js)");
    }
  };
  _proto.duration = function duration5() {
    var _this5 = this;
    if (this.el_.duration === Infinity && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
      var checkProgress = function checkProgress2() {
        if (_this5.el_.currentTime > 0) {
          if (_this5.el_.duration === Infinity) {
            _this5.trigger("durationchange");
          }
          _this5.off("timeupdate", checkProgress2);
        }
      };
      this.on("timeupdate", checkProgress);
      return NaN;
    }
    return this.el_.duration || NaN;
  };
  _proto.width = function width3() {
    return this.el_.offsetWidth;
  };
  _proto.height = function height3() {
    return this.el_.offsetHeight;
  };
  _proto.proxyWebkitFullscreen_ = function proxyWebkitFullscreen_() {
    var _this6 = this;
    if (!("webkitDisplayingFullscreen" in this.el_)) {
      return;
    }
    var endFn = function endFn2() {
      this.trigger("fullscreenchange", {
        isFullscreen: false
      });
      if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) {
        this.el_.controls = false;
      }
    };
    var beginFn = function beginFn2() {
      if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
        this.one("webkitendfullscreen", endFn);
        this.trigger("fullscreenchange", {
          isFullscreen: true,
          // set a flag in case another tech triggers fullscreenchange
          nativeIOSFullscreen: true
        });
      }
    };
    this.on("webkitbeginfullscreen", beginFn);
    this.on("dispose", function() {
      _this6.off("webkitbeginfullscreen", beginFn);
      _this6.off("webkitendfullscreen", endFn);
    });
  };
  _proto.supportsFullScreen = function supportsFullScreen() {
    if (typeof this.el_.webkitEnterFullScreen === "function") {
      var userAgent = window_1.navigator && window_1.navigator.userAgent || "";
      if (/Android/.test(userAgent) || !/Chrome|Mac OS X 10.5/.test(userAgent)) {
        return true;
      }
    }
    return false;
  };
  _proto.enterFullScreen = function enterFullScreen() {
    var video2 = this.el_;
    if (video2.paused && video2.networkState <= video2.HAVE_METADATA) {
      silencePromise(this.el_.play());
      this.setTimeout(function() {
        video2.pause();
        try {
          video2.webkitEnterFullScreen();
        } catch (e2) {
          this.trigger("fullscreenerror", e2);
        }
      }, 0);
    } else {
      try {
        video2.webkitEnterFullScreen();
      } catch (e2) {
        this.trigger("fullscreenerror", e2);
      }
    }
  };
  _proto.exitFullScreen = function exitFullScreen() {
    if (!this.el_.webkitDisplayingFullscreen) {
      this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
      return;
    }
    this.el_.webkitExitFullScreen();
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    return this.el_.requestPictureInPicture();
  };
  _proto.requestVideoFrameCallback = function requestVideoFrameCallback(cb2) {
    if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
      return this.el_.requestVideoFrameCallback(cb2);
    }
    return _Tech.prototype.requestVideoFrameCallback.call(this, cb2);
  };
  _proto.cancelVideoFrameCallback = function cancelVideoFrameCallback(id2) {
    if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) {
      this.el_.cancelVideoFrameCallback(id2);
    } else {
      _Tech.prototype.cancelVideoFrameCallback.call(this, id2);
    }
  };
  _proto.src = function src(_src) {
    if (_src === void 0) {
      return this.el_.src;
    }
    this.setSrc(_src);
  };
  _proto.reset = function reset3() {
    Html52.resetMediaElement(this.el_);
  };
  _proto.currentSrc = function currentSrc() {
    if (this.currentSource_) {
      return this.currentSource_.src;
    }
    return this.el_.currentSrc;
  };
  _proto.setControls = function setControls(val) {
    this.el_.controls = !!val;
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.addTextTrack.call(this, kind, label, language);
    }
    return this.el_.addTextTrack(kind, label, language);
  };
  _proto.createRemoteTextTrack = function createRemoteTextTrack(options) {
    if (!this.featuresNativeTextTracks) {
      return _Tech.prototype.createRemoteTextTrack.call(this, options);
    }
    var htmlTrackElement = document_1.createElement("track");
    if (options.kind) {
      htmlTrackElement.kind = options.kind;
    }
    if (options.label) {
      htmlTrackElement.label = options.label;
    }
    if (options.language || options.srclang) {
      htmlTrackElement.srclang = options.language || options.srclang;
    }
    if (options["default"]) {
      htmlTrackElement["default"] = options["default"];
    }
    if (options.id) {
      htmlTrackElement.id = options.id;
    }
    if (options.src) {
      htmlTrackElement.src = options.src;
    }
    return htmlTrackElement;
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    var htmlTrackElement = _Tech.prototype.addRemoteTextTrack.call(this, options, manualCleanup);
    if (this.featuresNativeTextTracks) {
      this.el().appendChild(htmlTrackElement);
    }
    return htmlTrackElement;
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(track) {
    _Tech.prototype.removeRemoteTextTrack.call(this, track);
    if (this.featuresNativeTextTracks) {
      var tracks = this.$$("track");
      var i = tracks.length;
      while (i--) {
        if (track === tracks[i] || track === tracks[i].track) {
          this.el().removeChild(tracks[i]);
        }
      }
    }
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    if (typeof this.el().getVideoPlaybackQuality === "function") {
      return this.el().getVideoPlaybackQuality();
    }
    var videoPlaybackQuality = {};
    if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
      videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
      videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
    }
    if (window_1.performance && typeof window_1.performance.now === "function") {
      videoPlaybackQuality.creationTime = window_1.performance.now();
    } else if (window_1.performance && window_1.performance.timing && typeof window_1.performance.timing.navigationStart === "number") {
      videoPlaybackQuality.creationTime = window_1.Date.now() - window_1.performance.timing.navigationStart;
    }
    return videoPlaybackQuality;
  };
  return Html52;
}(Tech);
defineLazyProperty(Html5, "TEST_VID", function() {
  if (!isReal()) {
    return;
  }
  var video2 = document_1.createElement("video");
  var track = document_1.createElement("track");
  track.kind = "captions";
  track.srclang = "en";
  track.label = "English";
  video2.appendChild(track);
  return video2;
});
Html5.isSupported = function() {
  try {
    Html5.TEST_VID.volume = 0.5;
  } catch (e2) {
    return false;
  }
  return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
};
Html5.canPlayType = function(type2) {
  return Html5.TEST_VID.canPlayType(type2);
};
Html5.canPlaySource = function(srcObj, options) {
  return Html5.canPlayType(srcObj.type);
};
Html5.canControlVolume = function() {
  try {
    var volume = Html5.TEST_VID.volume;
    Html5.TEST_VID.volume = volume / 2 + 0.1;
    var canControl = volume !== Html5.TEST_VID.volume;
    if (canControl && IS_IOS) {
      window_1.setTimeout(function() {
        if (Html5 && Html5.prototype) {
          Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
        }
      });
      return false;
    }
    return canControl;
  } catch (e2) {
    return false;
  }
};
Html5.canMuteVolume = function() {
  try {
    var muted = Html5.TEST_VID.muted;
    Html5.TEST_VID.muted = !muted;
    if (Html5.TEST_VID.muted) {
      setAttribute(Html5.TEST_VID, "muted", "muted");
    } else {
      removeAttribute(Html5.TEST_VID, "muted", "muted");
    }
    return muted !== Html5.TEST_VID.muted;
  } catch (e2) {
    return false;
  }
};
Html5.canControlPlaybackRate = function() {
  if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) {
    return false;
  }
  try {
    var playbackRate = Html5.TEST_VID.playbackRate;
    Html5.TEST_VID.playbackRate = playbackRate / 2 + 0.1;
    return playbackRate !== Html5.TEST_VID.playbackRate;
  } catch (e2) {
    return false;
  }
};
Html5.canOverrideAttributes = function() {
  try {
    var noop2 = function noop3() {
    };
    Object.defineProperty(document_1.createElement("video"), "src", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(document_1.createElement("audio"), "src", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(document_1.createElement("video"), "innerHTML", {
      get: noop2,
      set: noop2
    });
    Object.defineProperty(document_1.createElement("audio"), "innerHTML", {
      get: noop2,
      set: noop2
    });
  } catch (e2) {
    return false;
  }
  return true;
};
Html5.supportsNativeTextTracks = function() {
  return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
};
Html5.supportsNativeVideoTracks = function() {
  return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
};
Html5.supportsNativeAudioTracks = function() {
  return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
};
Html5.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"];
[["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function(_ref) {
  var key = _ref[0], fn2 = _ref[1];
  defineLazyProperty(Html5.prototype, key, function() {
    return Html5[fn2]();
  }, true);
});
Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
Html5.prototype.movingMediaElementInDOM = !IS_IOS;
Html5.prototype.featuresFullscreenResize = true;
Html5.prototype.featuresProgressEvents = true;
Html5.prototype.featuresTimeupdateEvents = true;
Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);
var canPlayType;
Html5.patchCanPlayType = function() {
  if (ANDROID_VERSION >= 4 && !IS_FIREFOX && !IS_CHROME) {
    canPlayType = Html5.TEST_VID && Html5.TEST_VID.constructor.prototype.canPlayType;
    Html5.TEST_VID.constructor.prototype.canPlayType = function(type2) {
      var mpegurlRE = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
      if (type2 && mpegurlRE.test(type2)) {
        return "maybe";
      }
      return canPlayType.call(this, type2);
    };
  }
};
Html5.unpatchCanPlayType = function() {
  var r3 = Html5.TEST_VID.constructor.prototype.canPlayType;
  if (canPlayType) {
    Html5.TEST_VID.constructor.prototype.canPlayType = canPlayType;
  }
  return r3;
};
Html5.patchCanPlayType();
Html5.disposeMediaElement = function(el2) {
  if (!el2) {
    return;
  }
  if (el2.parentNode) {
    el2.parentNode.removeChild(el2);
  }
  while (el2.hasChildNodes()) {
    el2.removeChild(el2.firstChild);
  }
  el2.removeAttribute("src");
  if (typeof el2.load === "function") {
    (function() {
      try {
        el2.load();
      } catch (e2) {
      }
    })();
  }
};
Html5.resetMediaElement = function(el2) {
  if (!el2) {
    return;
  }
  var sources = el2.querySelectorAll("source");
  var i = sources.length;
  while (i--) {
    el2.removeChild(sources[i]);
  }
  el2.removeAttribute("src");
  if (typeof el2.load === "function") {
    (function() {
      try {
        el2.load();
      } catch (e2) {
      }
    })();
  }
};
[
  /**
   * Get the value of `muted` from the media element. `muted` indicates
   * that the volume for the media should be set to silent. This does not actually change
   * the `volume` attribute.
   *
   * @method Html5#muted
   * @return {boolean}
   *         - True if the value of `volume` should be ignored and the audio set to silent.
   *         - False if the value of `volume` should be used.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Get the value of `defaultMuted` from the media element. `defaultMuted` indicates
   * whether the media should start muted or not. Only changes the default state of the
   * media. `muted` and `defaultMuted` can have different values. {@link Html5#muted} indicates the
   * current state.
   *
   * @method Html5#defaultMuted
   * @return {boolean}
   *         - The value of `defaultMuted` from the media element.
   *         - True indicates that the media should start muted.
   *         - False indicates that the media should not start muted
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Get the value of `autoplay` from the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#autoplay
   * @return {boolean}
   *         - The value of `autoplay` from the media element.
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Get the value of `controls` from the media element. `controls` indicates
   * whether the native media controls should be shown or hidden.
   *
   * @method Html5#controls
   * @return {boolean}
   *         - The value of `controls` from the media element.
   *         - True indicates that native controls should be showing.
   *         - False indicates that native controls should be hidden.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-controls}
   */
  "controls",
  /**
   * Get the value of `loop` from the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#loop
   * @return {boolean}
   *         - The value of `loop` from the media element.
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Get the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#playsinline
   * @return {boolean}
   *         - The value of `playsinline` from the media element.
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(prop3) {
  Html5.prototype[prop3] = function() {
    return this.el_[prop3] || this.el_.hasAttribute(prop3);
  };
});
[
  /**
   * Set the value of `muted` on the media element. `muted` indicates that the current
   * audio level should be silent.
   *
   * @method Html5#setMuted
   * @param {boolean} muted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-muted}
   */
  "muted",
  /**
   * Set the value of `defaultMuted` on the media element. `defaultMuted` indicates that the current
   * audio level should be silent, but will only effect the muted level on initial playback..
   *
   * @method Html5.prototype.setDefaultMuted
   * @param {boolean} defaultMuted
   *        - True if the audio should be set to silent
   *        - False otherwise
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultmuted}
   */
  "defaultMuted",
  /**
   * Set the value of `autoplay` on the media element. `autoplay` indicates
   * that the media should start to play as soon as the page is ready.
   *
   * @method Html5#setAutoplay
   * @param {boolean} autoplay
   *         - True indicates that the media should start as soon as the page loads.
   *         - False indicates that the media should not start as soon as the page loads.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-autoplay}
   */
  "autoplay",
  /**
   * Set the value of `loop` on the media element. `loop` indicates
   * that the media should return to the start of the media and continue playing once
   * it reaches the end.
   *
   * @method Html5#setLoop
   * @param {boolean} loop
   *         - True indicates that playback should seek back to start once
   *           the end of a media is reached.
   *         - False indicates that playback should not loop back to the start when the
   *           end of the media is reached.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-loop}
   */
  "loop",
  /**
   * Set the value of `playsinline` from the media element. `playsinline` indicates
   * to the browser that non-fullscreen playback is preferred when fullscreen
   * playback is the native default, such as in iOS Safari.
   *
   * @method Html5#setPlaysinline
   * @param {boolean} playsinline
   *         - True indicates that the media should play inline.
   *         - False indicates that the media should not play inline.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-video-playsinline}
   */
  "playsinline"
].forEach(function(prop3) {
  Html5.prototype["set" + toTitleCase$1(prop3)] = function(v2) {
    this.el_[prop3] = v2;
    if (v2) {
      this.el_.setAttribute(prop3, prop3);
    } else {
      this.el_.removeAttribute(prop3);
    }
  };
});
[
  /**
   * Get the value of `paused` from the media element. `paused` indicates whether the media element
   * is currently paused or not.
   *
   * @method Html5#paused
   * @return {boolean}
   *         The value of `paused` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-paused}
   */
  "paused",
  /**
   * Get the value of `currentTime` from the media element. `currentTime` indicates
   * the current second that the media is at in playback.
   *
   * @method Html5#currentTime
   * @return {number}
   *         The value of `currentTime` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-currenttime}
   */
  "currentTime",
  /**
   * Get the value of `buffered` from the media element. `buffered` is a `TimeRange`
   * object that represents the parts of the media that are already downloaded and
   * available for playback.
   *
   * @method Html5#buffered
   * @return {TimeRange}
   *         The value of `buffered` from the media element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-buffered}
   */
  "buffered",
  /**
   * Get the value of `volume` from the media element. `volume` indicates
   * the current playback volume of audio for a media. `volume` will be a value from 0
   * (silent) to 1 (loudest and default).
   *
   * @method Html5#volume
   * @return {number}
   *         The value of `volume` from the media element. Value will be between 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Get the value of `poster` from the media element. `poster` indicates
   * that the url of an image file that can/will be shown when no media data is available.
   *
   * @method Html5#poster
   * @return {string}
   *         The value of `poster` from the media element. Value will be a url to an
   *         image.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-video-poster}
   */
  "poster",
  /**
   * Get the value of `preload` from the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#preload
   * @return {string}
   *         The value of `preload` from the media element. Will be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Get the value of the `error` from the media element. `error` indicates any
   * MediaError that may have occurred during playback. If error returns null there is no
   * current error.
   *
   * @method Html5#error
   * @return {MediaError|null}
   *         The value of `error` from the media element. Will be `MediaError` if there
   *         is a current error and null otherwise.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-error}
   */
  "error",
  /**
   * Get the value of `seeking` from the media element. `seeking` indicates whether the
   * media is currently seeking to a new position or not.
   *
   * @method Html5#seeking
   * @return {boolean}
   *         - The value of `seeking` from the media element.
   *         - True indicates that the media is currently seeking to a new position.
   *         - False indicates that the media is not seeking to a new position at this time.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seeking}
   */
  "seeking",
  /**
   * Get the value of `seekable` from the media element. `seekable` returns a
   * `TimeRange` object indicating ranges of time that can currently be `seeked` to.
   *
   * @method Html5#seekable
   * @return {TimeRange}
   *         The value of `seekable` from the media element. A `TimeRange` object
   *         indicating the current ranges of time that can be seeked to.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-seekable}
   */
  "seekable",
  /**
   * Get the value of `ended` from the media element. `ended` indicates whether
   * the media has reached the end or not.
   *
   * @method Html5#ended
   * @return {boolean}
   *         - The value of `ended` from the media element.
   *         - True indicates that the media has ended.
   *         - False indicates that the media has not ended.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-ended}
   */
  "ended",
  /**
   * Get the value of `playbackRate` from the media element. `playbackRate` indicates
   * the rate at which the media is currently playing back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#playbackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Get the value of `defaultPlaybackRate` from the media element. `defaultPlaybackRate` indicates
   * the rate at which the media is currently playing back. This value will not indicate the current
   * `playbackRate` after playback has started, use {@link Html5#playbackRate} for that.
   *
   * Examples:
   *   - if defaultPlaybackRate is set to 2, media will play twice as fast.
   *   - if defaultPlaybackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.defaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "defaultPlaybackRate",
  /**
   * Get the value of 'disablePictureInPicture' from the video element.
   *
   * @method Html5#disablePictureInPicture
   * @return {boolean} value
   *         - The value of `disablePictureInPicture` from the video element.
   *         - True indicates that the video can't be played in Picture-In-Picture mode
   *         - False indicates that the video can be played in Picture-In-Picture mode
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Get the value of `played` from the media element. `played` returns a `TimeRange`
   * object representing points in the media timeline that have been played.
   *
   * @method Html5#played
   * @return {TimeRange}
   *         The value of `played` from the media element. A `TimeRange` object indicating
   *         the ranges of time that have been played.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-played}
   */
  "played",
  /**
   * Get the value of `networkState` from the media element. `networkState` indicates
   * the current network state. It returns an enumeration from the following list:
   * - 0: NETWORK_EMPTY
   * - 1: NETWORK_IDLE
   * - 2: NETWORK_LOADING
   * - 3: NETWORK_NO_SOURCE
   *
   * @method Html5#networkState
   * @return {number}
   *         The value of `networkState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-networkstate}
   */
  "networkState",
  /**
   * Get the value of `readyState` from the media element. `readyState` indicates
   * the current state of the media element. It returns an enumeration from the
   * following list:
   * - 0: HAVE_NOTHING
   * - 1: HAVE_METADATA
   * - 2: HAVE_CURRENT_DATA
   * - 3: HAVE_FUTURE_DATA
   * - 4: HAVE_ENOUGH_DATA
   *
   * @method Html5#readyState
   * @return {number}
   *         The value of `readyState` from the media element. This will be a number
   *         from the list in the description.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#ready-states}
   */
  "readyState",
  /**
   * Get the value of `videoWidth` from the video element. `videoWidth` indicates
   * the current width of the video in css pixels.
   *
   * @method Html5#videoWidth
   * @return {number}
   *         The value of `videoWidth` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoWidth",
  /**
   * Get the value of `videoHeight` from the video element. `videoHeight` indicates
   * the current height of the video in css pixels.
   *
   * @method Html5#videoHeight
   * @return {number}
   *         The value of `videoHeight` from the video element. This will be a number
   *         in css pixels.
   *
   * @see [Spec] {@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-video-videowidth}
   */
  "videoHeight",
  /**
   * Get the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#crossOrigin
   * @return {string}
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(prop3) {
  Html5.prototype[prop3] = function() {
    return this.el_[prop3];
  };
});
[
  /**
   * Set the value of `volume` on the media element. `volume` indicates the current
   * audio level as a percentage in decimal form. This means that 1 is 100%, 0.5 is 50%, and
   * so on.
   *
   * @method Html5#setVolume
   * @param {number} percentAsDecimal
   *        The volume percent as a decimal. Valid range is from 0-1.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-a-volume}
   */
  "volume",
  /**
   * Set the value of `src` on the media element. `src` indicates the current
   * {@link Tech~SourceObject} for the media.
   *
   * @method Html5#setSrc
   * @param {Tech~SourceObject} src
   *        The source object to set as the current source.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-src}
   */
  "src",
  /**
   * Set the value of `poster` on the media element. `poster` is the url to
   * an image file that can/will be shown when no media data is available.
   *
   * @method Html5#setPoster
   * @param {string} poster
   *        The url to an image that should be used as the `poster` for the media
   *        element.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-poster}
   */
  "poster",
  /**
   * Set the value of `preload` on the media element. `preload` indicates
   * what should download before the media is interacted with. It can have the following
   * values:
   * - none: nothing should be downloaded
   * - metadata: poster and the first few frames of the media may be downloaded to get
   *   media dimensions and other metadata
   * - auto: allow the media and metadata for the media to be downloaded before
   *    interaction
   *
   * @method Html5#setPreload
   * @param {string} preload
   *         The value of `preload` to set on the media element. Must be 'none', 'metadata',
   *         or 'auto'.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#attr-media-preload}
   */
  "preload",
  /**
   * Set the value of `playbackRate` on the media element. `playbackRate` indicates
   * the rate at which the media should play back. Examples:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5#setPlaybackRate
   * @return {number}
   *         The value of `playbackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-playbackrate}
   */
  "playbackRate",
  /**
   * Set the value of `defaultPlaybackRate` on the media element. `defaultPlaybackRate` indicates
   * the rate at which the media should play back upon initial startup. Changing this value
   * after a video has started will do nothing. Instead you should used {@link Html5#setPlaybackRate}.
   *
   * Example Values:
   *   - if playbackRate is set to 2, media will play twice as fast.
   *   - if playbackRate is set to 0.5, media will play half as fast.
   *
   * @method Html5.prototype.setDefaultPlaybackRate
   * @return {number}
   *         The value of `defaultPlaybackRate` from the media element. A number indicating
   *         the current playback speed of the media, where 1 is normal speed.
   *
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-defaultplaybackrate}
   */
  "defaultPlaybackRate",
  /**
   * Prevents the browser from suggesting a Picture-in-Picture context menu
   * or to request Picture-in-Picture automatically in some cases.
   *
   * @method Html5#setDisablePictureInPicture
   * @param {boolean} value
   *         The true value will disable Picture-in-Picture mode.
   *
   * @see [Spec]{@link https://w3c.github.io/picture-in-picture/#disable-pip}
   */
  "disablePictureInPicture",
  /**
   * Set the value of `crossOrigin` from the media element. `crossOrigin` indicates
   * to the browser that should sent the cookies along with the requests for the
   * different assets/playlists
   *
   * @method Html5#setCrossOrigin
   * @param {string} crossOrigin
   *         - anonymous indicates that the media should not sent cookies.
   *         - use-credentials indicates that the media should sent cookies along the requests.
   *
   * @see [Spec]{@link https://html.spec.whatwg.org/#attr-media-crossorigin}
   */
  "crossOrigin"
].forEach(function(prop3) {
  Html5.prototype["set" + toTitleCase$1(prop3)] = function(v2) {
    this.el_[prop3] = v2;
  };
});
[
  /**
   * A wrapper around the media elements `pause` function. This will call the `HTML5`
   * media elements `pause` function.
   *
   * @method Html5#pause
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-pause}
   */
  "pause",
  /**
   * A wrapper around the media elements `load` function. This will call the `HTML5`s
   * media element `load` function.
   *
   * @method Html5#load
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-load}
   */
  "load",
  /**
   * A wrapper around the media elements `play` function. This will call the `HTML5`s
   * media element `play` function.
   *
   * @method Html5#play
   * @see [Spec]{@link https://www.w3.org/TR/html5/embedded-content-0.html#dom-media-play}
   */
  "play"
].forEach(function(prop3) {
  Html5.prototype[prop3] = function() {
    return this.el_[prop3]();
  };
});
Tech.withSourceHandlers(Html5);
Html5.nativeSourceHandler = {};
Html5.nativeSourceHandler.canPlayType = function(type2) {
  try {
    return Html5.TEST_VID.canPlayType(type2);
  } catch (e2) {
    return "";
  }
};
Html5.nativeSourceHandler.canHandleSource = function(source, options) {
  if (source.type) {
    return Html5.nativeSourceHandler.canPlayType(source.type);
  } else if (source.src) {
    var ext = getFileExtension(source.src);
    return Html5.nativeSourceHandler.canPlayType("video/" + ext);
  }
  return "";
};
Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
  tech.setSrc(source.src);
};
Html5.nativeSourceHandler.dispose = function() {
};
Html5.registerSourceHandler(Html5.nativeSourceHandler);
Tech.registerTech("Html5", Html5);
var TECH_EVENTS_RETRIGGER = [
  /**
   * Fired while the user agent is downloading media data.
   *
   * @event Player#progress
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `progress` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechProgress_
   * @fires Player#progress
   * @listens Tech#progress
   */
  "progress",
  /**
   * Fires when the loading of an audio/video is aborted.
   *
   * @event Player#abort
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `abort` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechAbort_
   * @fires Player#abort
   * @listens Tech#abort
   */
  "abort",
  /**
   * Fires when the browser is intentionally not getting media data.
   *
   * @event Player#suspend
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `suspend` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechSuspend_
   * @fires Player#suspend
   * @listens Tech#suspend
   */
  "suspend",
  /**
   * Fires when the current playlist is empty.
   *
   * @event Player#emptied
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `emptied` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechEmptied_
   * @fires Player#emptied
   * @listens Tech#emptied
   */
  "emptied",
  /**
   * Fires when the browser is trying to get media data, but data is not available.
   *
   * @event Player#stalled
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `stalled` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechStalled_
   * @fires Player#stalled
   * @listens Tech#stalled
   */
  "stalled",
  /**
   * Fires when the browser has loaded meta data for the audio/video.
   *
   * @event Player#loadedmetadata
   * @type {EventTarget~Event}
   */
  /**
   * Retrigger the `loadedmetadata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoadedmetadata_
   * @fires Player#loadedmetadata
   * @listens Tech#loadedmetadata
   */
  "loadedmetadata",
  /**
   * Fires when the browser has loaded the current frame of the audio/video.
   *
   * @event Player#loadeddata
   * @type {event}
   */
  /**
   * Retrigger the `loadeddata` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechLoaddeddata_
   * @fires Player#loadeddata
   * @listens Tech#loadeddata
   */
  "loadeddata",
  /**
   * Fires when the current playback position has changed.
   *
   * @event Player#timeupdate
   * @type {event}
   */
  /**
   * Retrigger the `timeupdate` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTimeUpdate_
   * @fires Player#timeupdate
   * @listens Tech#timeupdate
   */
  "timeupdate",
  /**
   * Fires when the video's intrinsic dimensions change
   *
   * @event Player#resize
   * @type {event}
   */
  /**
   * Retrigger the `resize` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechResize_
   * @fires Player#resize
   * @listens Tech#resize
   */
  "resize",
  /**
   * Fires when the volume has been changed
   *
   * @event Player#volumechange
   * @type {event}
   */
  /**
   * Retrigger the `volumechange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechVolumechange_
   * @fires Player#volumechange
   * @listens Tech#volumechange
   */
  "volumechange",
  /**
   * Fires when the text track has been changed
   *
   * @event Player#texttrackchange
   * @type {event}
   */
  /**
   * Retrigger the `texttrackchange` event that was triggered by the {@link Tech}.
   *
   * @private
   * @method Player#handleTechTexttrackchange_
   * @fires Player#texttrackchange
   * @listens Tech#texttrackchange
   */
  "texttrackchange"
];
var TECH_EVENTS_QUEUE = {
  canplay: "CanPlay",
  canplaythrough: "CanPlayThrough",
  playing: "Playing",
  seeked: "Seeked"
};
var BREAKPOINT_ORDER = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"];
var BREAKPOINT_CLASSES = {};
BREAKPOINT_ORDER.forEach(function(k2) {
  var v2 = k2.charAt(0) === "x" ? "x-" + k2.substring(1) : k2;
  BREAKPOINT_CLASSES[k2] = "vjs-layout-" + v2;
});
var DEFAULT_BREAKPOINTS = {
  tiny: 210,
  xsmall: 320,
  small: 425,
  medium: 768,
  large: 1440,
  xlarge: 2560,
  huge: Infinity
};
var Player = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(Player2, _Component);
  function Player2(tag, options, ready) {
    var _this;
    tag.id = tag.id || options.id || "vjs_video_" + newGUID();
    options = assign$1(Player2.getTagSettings(tag), options);
    options.initChildren = false;
    options.createEl = false;
    options.evented = false;
    options.reportTouchActivity = false;
    if (!options.language) {
      if (typeof tag.closest === "function") {
        var closest3 = tag.closest("[lang]");
        if (closest3 && closest3.getAttribute) {
          options.language = closest3.getAttribute("lang");
        }
      } else {
        var element = tag;
        while (element && element.nodeType === 1) {
          if (getAttributes(element).hasOwnProperty("lang")) {
            options.language = element.getAttribute("lang");
            break;
          }
          element = element.parentNode;
        }
      }
    }
    _this = _Component.call(this, null, options, ready) || this;
    _this.boundDocumentFullscreenChange_ = function(e2) {
      return _this.documentFullscreenChange_(e2);
    };
    _this.boundFullWindowOnEscKey_ = function(e2) {
      return _this.fullWindowOnEscKey(e2);
    };
    _this.boundUpdateStyleEl_ = function(e2) {
      return _this.updateStyleEl_(e2);
    };
    _this.boundApplyInitTime_ = function(e2) {
      return _this.applyInitTime_(e2);
    };
    _this.boundUpdateCurrentBreakpoint_ = function(e2) {
      return _this.updateCurrentBreakpoint_(e2);
    };
    _this.boundHandleTechClick_ = function(e2) {
      return _this.handleTechClick_(e2);
    };
    _this.boundHandleTechDoubleClick_ = function(e2) {
      return _this.handleTechDoubleClick_(e2);
    };
    _this.boundHandleTechTouchStart_ = function(e2) {
      return _this.handleTechTouchStart_(e2);
    };
    _this.boundHandleTechTouchMove_ = function(e2) {
      return _this.handleTechTouchMove_(e2);
    };
    _this.boundHandleTechTouchEnd_ = function(e2) {
      return _this.handleTechTouchEnd_(e2);
    };
    _this.boundHandleTechTap_ = function(e2) {
      return _this.handleTechTap_(e2);
    };
    _this.isFullscreen_ = false;
    _this.log = createLogger(_this.id_);
    _this.fsApi_ = FullscreenApi;
    _this.isPosterFromTech_ = false;
    _this.queuedCallbacks_ = [];
    _this.isReady_ = false;
    _this.hasStarted_ = false;
    _this.userActive_ = false;
    _this.debugEnabled_ = false;
    _this.audioOnlyMode_ = false;
    _this.audioPosterMode_ = false;
    _this.audioOnlyCache_ = {
      playerHeight: null,
      hiddenChildren: []
    };
    if (!_this.options_ || !_this.options_.techOrder || !_this.options_.techOrder.length) {
      throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
    }
    _this.tag = tag;
    _this.tagAttributes = tag && getAttributes(tag);
    _this.language(_this.options_.language);
    if (options.languages) {
      var languagesToLower = {};
      Object.getOwnPropertyNames(options.languages).forEach(function(name) {
        languagesToLower[name.toLowerCase()] = options.languages[name];
      });
      _this.languages_ = languagesToLower;
    } else {
      _this.languages_ = Player2.prototype.options_.languages;
    }
    _this.resetCache_();
    _this.poster_ = options.poster || "";
    _this.controls_ = !!options.controls;
    tag.controls = false;
    tag.removeAttribute("controls");
    _this.changingSrc_ = false;
    _this.playCallbacks_ = [];
    _this.playTerminatedQueue_ = [];
    if (tag.hasAttribute("autoplay")) {
      _this.autoplay(true);
    } else {
      _this.autoplay(_this.options_.autoplay);
    }
    if (options.plugins) {
      Object.keys(options.plugins).forEach(function(name) {
        if (typeof _this[name] !== "function") {
          throw new Error('plugin "' + name + '" does not exist');
        }
      });
    }
    _this.scrubbing_ = false;
    _this.el_ = _this.createEl();
    evented(_assertThisInitialized(_this), {
      eventBusKey: "el_"
    });
    if (_this.fsApi_.requestFullscreen) {
      on(document_1, _this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
      _this.on(_this.fsApi_.fullscreenchange, _this.boundDocumentFullscreenChange_);
    }
    if (_this.fluid_) {
      _this.on(["playerreset", "resize"], _this.boundUpdateStyleEl_);
    }
    var playerOptionsCopy = mergeOptions$3(_this.options_);
    if (options.plugins) {
      Object.keys(options.plugins).forEach(function(name) {
        _this[name](options.plugins[name]);
      });
    }
    if (options.debug) {
      _this.debug(true);
    }
    _this.options_.playerOptions = playerOptionsCopy;
    _this.middleware_ = [];
    _this.playbackRates(options.playbackRates);
    _this.initChildren();
    _this.isAudio(tag.nodeName.toLowerCase() === "audio");
    if (_this.controls()) {
      _this.addClass("vjs-controls-enabled");
    } else {
      _this.addClass("vjs-controls-disabled");
    }
    _this.el_.setAttribute("role", "region");
    if (_this.isAudio()) {
      _this.el_.setAttribute("aria-label", _this.localize("Audio Player"));
    } else {
      _this.el_.setAttribute("aria-label", _this.localize("Video Player"));
    }
    if (_this.isAudio()) {
      _this.addClass("vjs-audio");
    }
    if (_this.flexNotSupported_()) {
      _this.addClass("vjs-no-flex");
    }
    if (TOUCH_ENABLED) {
      _this.addClass("vjs-touch-enabled");
    }
    if (!IS_IOS) {
      _this.addClass("vjs-workinghover");
    }
    Player2.players[_this.id_] = _assertThisInitialized(_this);
    var majorVersion = version$5.split(".")[0];
    _this.addClass("vjs-v" + majorVersion);
    _this.userActive(true);
    _this.reportUserActivity();
    _this.one("play", function(e2) {
      return _this.listenForUserActivity_(e2);
    });
    _this.on("stageclick", function(e2) {
      return _this.handleStageClick_(e2);
    });
    _this.on("keydown", function(e2) {
      return _this.handleKeyDown(e2);
    });
    _this.on("languagechange", function(e2) {
      return _this.handleLanguagechange(e2);
    });
    _this.breakpoints(_this.options_.breakpoints);
    _this.responsive(_this.options_.responsive);
    _this.on("ready", function() {
      _this.audioPosterMode(_this.options_.audioPosterMode);
      _this.audioOnlyMode(_this.options_.audioOnlyMode);
    });
    return _this;
  }
  var _proto = Player2.prototype;
  _proto.dispose = function dispose() {
    var _this2 = this;
    this.trigger("dispose");
    this.off("dispose");
    off(document_1, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
    off(document_1, "keydown", this.boundFullWindowOnEscKey_);
    if (this.styleEl_ && this.styleEl_.parentNode) {
      this.styleEl_.parentNode.removeChild(this.styleEl_);
      this.styleEl_ = null;
    }
    Player2.players[this.id_] = null;
    if (this.tag && this.tag.player) {
      this.tag.player = null;
    }
    if (this.el_ && this.el_.player) {
      this.el_.player = null;
    }
    if (this.tech_) {
      this.tech_.dispose();
      this.isPosterFromTech_ = false;
      this.poster_ = "";
    }
    if (this.playerElIngest_) {
      this.playerElIngest_ = null;
    }
    if (this.tag) {
      this.tag = null;
    }
    clearCacheForPlayer(this);
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      var list = _this2[props.getterName]();
      if (list && list.off) {
        list.off();
      }
    });
    _Component.prototype.dispose.call(this, {
      restoreEl: this.options_.restoreEl
    });
  };
  _proto.createEl = function createEl2() {
    var tag = this.tag;
    var el2;
    var playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
    var divEmbed = this.tag.tagName.toLowerCase() === "video-js";
    if (playerElIngest) {
      el2 = this.el_ = tag.parentNode;
    } else if (!divEmbed) {
      el2 = this.el_ = _Component.prototype.createEl.call(this, "div");
    }
    var attrs = getAttributes(tag);
    if (divEmbed) {
      el2 = this.el_ = tag;
      tag = this.tag = document_1.createElement("video");
      while (el2.children.length) {
        tag.appendChild(el2.firstChild);
      }
      if (!hasClass(el2, "video-js")) {
        addClass(el2, "video-js");
      }
      el2.appendChild(tag);
      playerElIngest = this.playerElIngest_ = el2;
      Object.keys(el2).forEach(function(k2) {
        try {
          tag[k2] = el2[k2];
        } catch (e2) {
        }
      });
    }
    tag.setAttribute("tabindex", "-1");
    attrs.tabindex = "-1";
    if (IE_VERSION || IS_CHROME && IS_WINDOWS) {
      tag.setAttribute("role", "application");
      attrs.role = "application";
    }
    tag.removeAttribute("width");
    tag.removeAttribute("height");
    if ("width" in attrs) {
      delete attrs.width;
    }
    if ("height" in attrs) {
      delete attrs.height;
    }
    Object.getOwnPropertyNames(attrs).forEach(function(attr) {
      if (!(divEmbed && attr === "class")) {
        el2.setAttribute(attr, attrs[attr]);
      }
      if (divEmbed) {
        tag.setAttribute(attr, attrs[attr]);
      }
    });
    tag.playerId = tag.id;
    tag.id += "_html5_api";
    tag.className = "vjs-tech";
    tag.player = el2.player = this;
    this.addClass("vjs-paused");
    if (window_1.VIDEOJS_NO_DYNAMIC_STYLE !== true) {
      this.styleEl_ = createStyleElement("vjs-styles-dimensions");
      var defaultsStyleEl = $(".vjs-styles-defaults");
      var head = $("head");
      head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
    }
    this.fill_ = false;
    this.fluid_ = false;
    this.width(this.options_.width);
    this.height(this.options_.height);
    this.fill(this.options_.fill);
    this.fluid(this.options_.fluid);
    this.aspectRatio(this.options_.aspectRatio);
    this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
    var links = tag.getElementsByTagName("a");
    for (var i = 0; i < links.length; i++) {
      var linkEl = links.item(i);
      addClass(linkEl, "vjs-hidden");
      linkEl.setAttribute("hidden", "hidden");
    }
    tag.initNetworkState_ = tag.networkState;
    if (tag.parentNode && !playerElIngest) {
      tag.parentNode.insertBefore(el2, tag);
    }
    prependTo(tag, el2);
    this.children_.unshift(tag);
    this.el_.setAttribute("lang", this.language_);
    this.el_.setAttribute("translate", "no");
    this.el_ = el2;
    return el2;
  };
  _proto.crossOrigin = function crossOrigin(value) {
    if (!value) {
      return this.techGet_("crossOrigin");
    }
    if (value !== "anonymous" && value !== "use-credentials") {
      log$1.warn('crossOrigin must be "anonymous" or "use-credentials", given "' + value + '"');
      return;
    }
    this.techCall_("setCrossOrigin", value);
    return;
  };
  _proto.width = function width3(value) {
    return this.dimension("width", value);
  };
  _proto.height = function height3(value) {
    return this.dimension("height", value);
  };
  _proto.dimension = function dimension(_dimension, value) {
    var privDimension = _dimension + "_";
    if (value === void 0) {
      return this[privDimension] || 0;
    }
    if (value === "" || value === "auto") {
      this[privDimension] = void 0;
      this.updateStyleEl_();
      return;
    }
    var parsedVal = parseFloat(value);
    if (isNaN(parsedVal)) {
      log$1.error('Improper value "' + value + '" supplied for for ' + _dimension);
      return;
    }
    this[privDimension] = parsedVal;
    this.updateStyleEl_();
  };
  _proto.fluid = function fluid(bool) {
    var _this3 = this;
    if (bool === void 0) {
      return !!this.fluid_;
    }
    this.fluid_ = !!bool;
    if (isEvented(this)) {
      this.off(["playerreset", "resize"], this.boundUpdateStyleEl_);
    }
    if (bool) {
      this.addClass("vjs-fluid");
      this.fill(false);
      addEventedCallback(this, function() {
        _this3.on(["playerreset", "resize"], _this3.boundUpdateStyleEl_);
      });
    } else {
      this.removeClass("vjs-fluid");
    }
    this.updateStyleEl_();
  };
  _proto.fill = function fill(bool) {
    if (bool === void 0) {
      return !!this.fill_;
    }
    this.fill_ = !!bool;
    if (bool) {
      this.addClass("vjs-fill");
      this.fluid(false);
    } else {
      this.removeClass("vjs-fill");
    }
  };
  _proto.aspectRatio = function aspectRatio2(ratio) {
    if (ratio === void 0) {
      return this.aspectRatio_;
    }
    if (!/^\d+\:\d+$/.test(ratio)) {
      throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
    }
    this.aspectRatio_ = ratio;
    this.fluid(true);
    this.updateStyleEl_();
  };
  _proto.updateStyleEl_ = function updateStyleEl_() {
    if (window_1.VIDEOJS_NO_DYNAMIC_STYLE === true) {
      var _width = typeof this.width_ === "number" ? this.width_ : this.options_.width;
      var _height = typeof this.height_ === "number" ? this.height_ : this.options_.height;
      var techEl = this.tech_ && this.tech_.el();
      if (techEl) {
        if (_width >= 0) {
          techEl.width = _width;
        }
        if (_height >= 0) {
          techEl.height = _height;
        }
      }
      return;
    }
    var width3;
    var height3;
    var aspectRatio2;
    var idClass;
    if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") {
      aspectRatio2 = this.aspectRatio_;
    } else if (this.videoWidth() > 0) {
      aspectRatio2 = this.videoWidth() + ":" + this.videoHeight();
    } else {
      aspectRatio2 = "16:9";
    }
    var ratioParts = aspectRatio2.split(":");
    var ratioMultiplier = ratioParts[1] / ratioParts[0];
    if (this.width_ !== void 0) {
      width3 = this.width_;
    } else if (this.height_ !== void 0) {
      width3 = this.height_ / ratioMultiplier;
    } else {
      width3 = this.videoWidth() || 300;
    }
    if (this.height_ !== void 0) {
      height3 = this.height_;
    } else {
      height3 = width3 * ratioMultiplier;
    }
    if (/^[^a-zA-Z]/.test(this.id())) {
      idClass = "dimensions-" + this.id();
    } else {
      idClass = this.id() + "-dimensions";
    }
    this.addClass(idClass);
    setTextContent(this.styleEl_, "\n      ." + idClass + " {\n        width: " + width3 + "px;\n        height: " + height3 + "px;\n      }\n\n      ." + idClass + ".vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: " + ratioMultiplier * 100 + "%;\n      }\n    ");
  };
  _proto.loadTech_ = function loadTech_(techName, source) {
    var _this4 = this;
    if (this.tech_) {
      this.unloadTech_();
    }
    var titleTechName = toTitleCase$1(techName);
    var camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
    if (titleTechName !== "Html5" && this.tag) {
      Tech.getTech("Html5").disposeMediaElement(this.tag);
      this.tag.player = null;
      this.tag = null;
    }
    this.techName_ = titleTechName;
    this.isReady_ = false;
    var autoplay = this.autoplay();
    if (typeof this.autoplay() === "string" || this.autoplay() === true && this.options_.normalizeAutoplay) {
      autoplay = false;
    }
    var techOptions = {
      source,
      autoplay,
      "nativeControlsForTouch": this.options_.nativeControlsForTouch,
      "playerId": this.id(),
      "techId": this.id() + "_" + camelTechName + "_api",
      "playsinline": this.options_.playsinline,
      "preload": this.options_.preload,
      "loop": this.options_.loop,
      "disablePictureInPicture": this.options_.disablePictureInPicture,
      "muted": this.options_.muted,
      "poster": this.poster(),
      "language": this.language(),
      "playerElIngest": this.playerElIngest_ || false,
      "vtt.js": this.options_["vtt.js"],
      "canOverridePoster": !!this.options_.techCanOverridePoster,
      "enableSourceset": this.options_.enableSourceset,
      "Promise": this.options_.Promise
    };
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      techOptions[props.getterName] = _this4[props.privateName];
    });
    assign$1(techOptions, this.options_[titleTechName]);
    assign$1(techOptions, this.options_[camelTechName]);
    assign$1(techOptions, this.options_[techName.toLowerCase()]);
    if (this.tag) {
      techOptions.tag = this.tag;
    }
    if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) {
      techOptions.startTime = this.cache_.currentTime;
    }
    var TechClass = Tech.getTech(techName);
    if (!TechClass) {
      throw new Error("No Tech named '" + titleTechName + "' exists! '" + titleTechName + "' should be registered using videojs.registerTech()'");
    }
    this.tech_ = new TechClass(techOptions);
    this.tech_.ready(bind(this, this.handleTechReady_), true);
    textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
    TECH_EVENTS_RETRIGGER.forEach(function(event) {
      _this4.on(_this4.tech_, event, function(e2) {
        return _this4["handleTech" + toTitleCase$1(event) + "_"](e2);
      });
    });
    Object.keys(TECH_EVENTS_QUEUE).forEach(function(event) {
      _this4.on(_this4.tech_, event, function(eventObj) {
        if (_this4.tech_.playbackRate() === 0 && _this4.tech_.seeking()) {
          _this4.queuedCallbacks_.push({
            callback: _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"].bind(_this4),
            event: eventObj
          });
          return;
        }
        _this4["handleTech" + TECH_EVENTS_QUEUE[event] + "_"](eventObj);
      });
    });
    this.on(this.tech_, "loadstart", function(e2) {
      return _this4.handleTechLoadStart_(e2);
    });
    this.on(this.tech_, "sourceset", function(e2) {
      return _this4.handleTechSourceset_(e2);
    });
    this.on(this.tech_, "waiting", function(e2) {
      return _this4.handleTechWaiting_(e2);
    });
    this.on(this.tech_, "ended", function(e2) {
      return _this4.handleTechEnded_(e2);
    });
    this.on(this.tech_, "seeking", function(e2) {
      return _this4.handleTechSeeking_(e2);
    });
    this.on(this.tech_, "play", function(e2) {
      return _this4.handleTechPlay_(e2);
    });
    this.on(this.tech_, "firstplay", function(e2) {
      return _this4.handleTechFirstPlay_(e2);
    });
    this.on(this.tech_, "pause", function(e2) {
      return _this4.handleTechPause_(e2);
    });
    this.on(this.tech_, "durationchange", function(e2) {
      return _this4.handleTechDurationChange_(e2);
    });
    this.on(this.tech_, "fullscreenchange", function(e2, data) {
      return _this4.handleTechFullscreenChange_(e2, data);
    });
    this.on(this.tech_, "fullscreenerror", function(e2, err) {
      return _this4.handleTechFullscreenError_(e2, err);
    });
    this.on(this.tech_, "enterpictureinpicture", function(e2) {
      return _this4.handleTechEnterPictureInPicture_(e2);
    });
    this.on(this.tech_, "leavepictureinpicture", function(e2) {
      return _this4.handleTechLeavePictureInPicture_(e2);
    });
    this.on(this.tech_, "error", function(e2) {
      return _this4.handleTechError_(e2);
    });
    this.on(this.tech_, "posterchange", function(e2) {
      return _this4.handleTechPosterChange_(e2);
    });
    this.on(this.tech_, "textdata", function(e2) {
      return _this4.handleTechTextData_(e2);
    });
    this.on(this.tech_, "ratechange", function(e2) {
      return _this4.handleTechRateChange_(e2);
    });
    this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_);
    this.usingNativeControls(this.techGet_("controls"));
    if (this.controls() && !this.usingNativeControls()) {
      this.addTechControlsListeners_();
    }
    if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) {
      prependTo(this.tech_.el(), this.el());
    }
    if (this.tag) {
      this.tag.player = null;
      this.tag = null;
    }
  };
  _proto.unloadTech_ = function unloadTech_() {
    var _this5 = this;
    ALL.names.forEach(function(name) {
      var props = ALL[name];
      _this5[props.privateName] = _this5[props.getterName]();
    });
    this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
    this.isReady_ = false;
    this.tech_.dispose();
    this.tech_ = false;
    if (this.isPosterFromTech_) {
      this.poster_ = "";
      this.trigger("posterchange");
    }
    this.isPosterFromTech_ = false;
  };
  _proto.tech = function tech(safety) {
    if (safety === void 0) {
      log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\nSee https://github.com/videojs/video.js/issues/2617 for more info.\n");
    }
    return this.tech_;
  };
  _proto.addTechControlsListeners_ = function addTechControlsListeners_() {
    this.removeTechControlsListeners_();
    this.on(this.tech_, "click", this.boundHandleTechClick_);
    this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
    this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
    this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
    this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
    this.on(this.tech_, "tap", this.boundHandleTechTap_);
  };
  _proto.removeTechControlsListeners_ = function removeTechControlsListeners_() {
    this.off(this.tech_, "tap", this.boundHandleTechTap_);
    this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
    this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
    this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
    this.off(this.tech_, "click", this.boundHandleTechClick_);
    this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
  };
  _proto.handleTechReady_ = function handleTechReady_() {
    this.triggerReady();
    if (this.cache_.volume) {
      this.techCall_("setVolume", this.cache_.volume);
    }
    this.handleTechPosterChange_();
    this.handleTechDurationChange_();
  };
  _proto.handleTechLoadStart_ = function handleTechLoadStart_() {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-seeking");
    this.error(null);
    this.handleTechDurationChange_();
    if (!this.paused()) {
      this.trigger("loadstart");
      this.trigger("firstplay");
    } else {
      this.hasStarted(false);
      this.trigger("loadstart");
    }
    this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? "play" : this.autoplay());
  };
  _proto.manualAutoplay_ = function manualAutoplay_(type2) {
    var _this6 = this;
    if (!this.tech_ || typeof type2 !== "string") {
      return;
    }
    var resolveMuted = function resolveMuted2() {
      var previouslyMuted = _this6.muted();
      _this6.muted(true);
      var restoreMuted = function restoreMuted2() {
        _this6.muted(previouslyMuted);
      };
      _this6.playTerminatedQueue_.push(restoreMuted);
      var mutedPromise = _this6.play();
      if (!isPromise$1(mutedPromise)) {
        return;
      }
      return mutedPromise["catch"](function(err) {
        restoreMuted();
        throw new Error("Rejection at manualAutoplay. Restoring muted value. " + (err ? err : ""));
      });
    };
    var promise;
    if (type2 === "any" && !this.muted()) {
      promise = this.play();
      if (isPromise$1(promise)) {
        promise = promise["catch"](resolveMuted);
      }
    } else if (type2 === "muted" && !this.muted()) {
      promise = resolveMuted();
    } else {
      promise = this.play();
    }
    if (!isPromise$1(promise)) {
      return;
    }
    return promise.then(function() {
      _this6.trigger({
        type: "autoplay-success",
        autoplay: type2
      });
    })["catch"](function() {
      _this6.trigger({
        type: "autoplay-failure",
        autoplay: type2
      });
    });
  };
  _proto.updateSourceCaches_ = function updateSourceCaches_(srcObj) {
    if (srcObj === void 0) {
      srcObj = "";
    }
    var src = srcObj;
    var type2 = "";
    if (typeof src !== "string") {
      src = srcObj.src;
      type2 = srcObj.type;
    }
    this.cache_.source = this.cache_.source || {};
    this.cache_.sources = this.cache_.sources || [];
    if (src && !type2) {
      type2 = findMimetype(this, src);
    }
    this.cache_.source = mergeOptions$3({}, srcObj, {
      src,
      type: type2
    });
    var matchingSources = this.cache_.sources.filter(function(s) {
      return s.src && s.src === src;
    });
    var sourceElSources = [];
    var sourceEls = this.$$("source");
    var matchingSourceEls = [];
    for (var i = 0; i < sourceEls.length; i++) {
      var sourceObj = getAttributes(sourceEls[i]);
      sourceElSources.push(sourceObj);
      if (sourceObj.src && sourceObj.src === src) {
        matchingSourceEls.push(sourceObj.src);
      }
    }
    if (matchingSourceEls.length && !matchingSources.length) {
      this.cache_.sources = sourceElSources;
    } else if (!matchingSources.length) {
      this.cache_.sources = [this.cache_.source];
    }
    this.cache_.src = src;
  };
  _proto.handleTechSourceset_ = function handleTechSourceset_(event) {
    var _this7 = this;
    if (!this.changingSrc_) {
      var updateSourceCaches = function updateSourceCaches2(src) {
        return _this7.updateSourceCaches_(src);
      };
      var playerSrc = this.currentSource().src;
      var eventSrc = event.src;
      if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) {
        if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) {
          updateSourceCaches = function updateSourceCaches2() {
          };
        }
      }
      updateSourceCaches(eventSrc);
      if (!event.src) {
        this.tech_.any(["sourceset", "loadstart"], function(e2) {
          if (e2.type === "sourceset") {
            return;
          }
          var techSrc = _this7.techGet("currentSrc");
          _this7.lastSource_.tech = techSrc;
          _this7.updateSourceCaches_(techSrc);
        });
      }
    }
    this.lastSource_ = {
      player: this.currentSource().src,
      tech: event.src
    };
    this.trigger({
      src: event.src,
      type: "sourceset"
    });
  };
  _proto.hasStarted = function hasStarted(request2) {
    if (request2 === void 0) {
      return this.hasStarted_;
    }
    if (request2 === this.hasStarted_) {
      return;
    }
    this.hasStarted_ = request2;
    if (this.hasStarted_) {
      this.addClass("vjs-has-started");
      this.trigger("firstplay");
    } else {
      this.removeClass("vjs-has-started");
    }
  };
  _proto.handleTechPlay_ = function handleTechPlay_() {
    this.removeClass("vjs-ended");
    this.removeClass("vjs-paused");
    this.addClass("vjs-playing");
    this.hasStarted(true);
    this.trigger("play");
  };
  _proto.handleTechRateChange_ = function handleTechRateChange_() {
    if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
      this.queuedCallbacks_.forEach(function(queued) {
        return queued.callback(queued.event);
      });
      this.queuedCallbacks_ = [];
    }
    this.cache_.lastPlaybackRate = this.tech_.playbackRate();
    this.trigger("ratechange");
  };
  _proto.handleTechWaiting_ = function handleTechWaiting_() {
    var _this8 = this;
    this.addClass("vjs-waiting");
    this.trigger("waiting");
    var timeWhenWaiting = this.currentTime();
    var timeUpdateListener = function timeUpdateListener2() {
      if (timeWhenWaiting !== _this8.currentTime()) {
        _this8.removeClass("vjs-waiting");
        _this8.off("timeupdate", timeUpdateListener2);
      }
    };
    this.on("timeupdate", timeUpdateListener);
  };
  _proto.handleTechCanPlay_ = function handleTechCanPlay_() {
    this.removeClass("vjs-waiting");
    this.trigger("canplay");
  };
  _proto.handleTechCanPlayThrough_ = function handleTechCanPlayThrough_() {
    this.removeClass("vjs-waiting");
    this.trigger("canplaythrough");
  };
  _proto.handleTechPlaying_ = function handleTechPlaying_() {
    this.removeClass("vjs-waiting");
    this.trigger("playing");
  };
  _proto.handleTechSeeking_ = function handleTechSeeking_() {
    this.addClass("vjs-seeking");
    this.trigger("seeking");
  };
  _proto.handleTechSeeked_ = function handleTechSeeked_() {
    this.removeClass("vjs-seeking");
    this.removeClass("vjs-ended");
    this.trigger("seeked");
  };
  _proto.handleTechFirstPlay_ = function handleTechFirstPlay_() {
    if (this.options_.starttime) {
      log$1.warn("Passing the `starttime` option to the player will be deprecated in 6.0");
      this.currentTime(this.options_.starttime);
    }
    this.addClass("vjs-has-started");
    this.trigger("firstplay");
  };
  _proto.handleTechPause_ = function handleTechPause_() {
    this.removeClass("vjs-playing");
    this.addClass("vjs-paused");
    this.trigger("pause");
  };
  _proto.handleTechEnded_ = function handleTechEnded_() {
    this.addClass("vjs-ended");
    this.removeClass("vjs-waiting");
    if (this.options_.loop) {
      this.currentTime(0);
      this.play();
    } else if (!this.paused()) {
      this.pause();
    }
    this.trigger("ended");
  };
  _proto.handleTechDurationChange_ = function handleTechDurationChange_() {
    this.duration(this.techGet_("duration"));
  };
  _proto.handleTechClick_ = function handleTechClick_(event) {
    if (!this.controls_) {
      return;
    }
    if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== false) {
      if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click === "function") {
        this.options_.userActions.click.call(this, event);
      } else if (this.paused()) {
        silencePromise(this.play());
      } else {
        this.pause();
      }
    }
  };
  _proto.handleTechDoubleClick_ = function handleTechDoubleClick_(event) {
    if (!this.controls_) {
      return;
    }
    var inAllowedEls = Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), function(el2) {
      return el2.contains(event.target);
    });
    if (!inAllowedEls) {
      if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== false) {
        if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick === "function") {
          this.options_.userActions.doubleClick.call(this, event);
        } else if (this.isFullscreen()) {
          this.exitFullscreen();
        } else {
          this.requestFullscreen();
        }
      }
    }
  };
  _proto.handleTechTap_ = function handleTechTap_() {
    this.userActive(!this.userActive());
  };
  _proto.handleTechTouchStart_ = function handleTechTouchStart_() {
    this.userWasActive = this.userActive();
  };
  _proto.handleTechTouchMove_ = function handleTechTouchMove_() {
    if (this.userWasActive) {
      this.reportUserActivity();
    }
  };
  _proto.handleTechTouchEnd_ = function handleTechTouchEnd_(event) {
    if (event.cancelable) {
      event.preventDefault();
    }
  };
  _proto.handleStageClick_ = function handleStageClick_() {
    this.reportUserActivity();
  };
  _proto.toggleFullscreenClass_ = function toggleFullscreenClass_() {
    if (this.isFullscreen()) {
      this.addClass("vjs-fullscreen");
    } else {
      this.removeClass("vjs-fullscreen");
    }
  };
  _proto.documentFullscreenChange_ = function documentFullscreenChange_(e2) {
    var targetPlayer = e2.target.player;
    if (targetPlayer && targetPlayer !== this) {
      return;
    }
    var el2 = this.el();
    var isFs = document_1[this.fsApi_.fullscreenElement] === el2;
    if (!isFs && el2.matches) {
      isFs = el2.matches(":" + this.fsApi_.fullscreen);
    } else if (!isFs && el2.msMatchesSelector) {
      isFs = el2.msMatchesSelector(":" + this.fsApi_.fullscreen);
    }
    this.isFullscreen(isFs);
  };
  _proto.handleTechFullscreenChange_ = function handleTechFullscreenChange_(event, data) {
    var _this9 = this;
    if (data) {
      if (data.nativeIOSFullscreen) {
        this.addClass("vjs-ios-native-fs");
        this.tech_.one("webkitendfullscreen", function() {
          _this9.removeClass("vjs-ios-native-fs");
        });
      }
      this.isFullscreen(data.isFullscreen);
    }
  };
  _proto.handleTechFullscreenError_ = function handleTechFullscreenError_(event, err) {
    this.trigger("fullscreenerror", err);
  };
  _proto.togglePictureInPictureClass_ = function togglePictureInPictureClass_() {
    if (this.isInPictureInPicture()) {
      this.addClass("vjs-picture-in-picture");
    } else {
      this.removeClass("vjs-picture-in-picture");
    }
  };
  _proto.handleTechEnterPictureInPicture_ = function handleTechEnterPictureInPicture_(event) {
    this.isInPictureInPicture(true);
  };
  _proto.handleTechLeavePictureInPicture_ = function handleTechLeavePictureInPicture_(event) {
    this.isInPictureInPicture(false);
  };
  _proto.handleTechError_ = function handleTechError_() {
    var error = this.tech_.error();
    this.error(error);
  };
  _proto.handleTechTextData_ = function handleTechTextData_() {
    var data = null;
    if (arguments.length > 1) {
      data = arguments[1];
    }
    this.trigger("textdata", data);
  };
  _proto.getCache = function getCache() {
    return this.cache_;
  };
  _proto.resetCache_ = function resetCache_() {
    this.cache_ = {
      // Right now, the currentTime is not _really_ cached because it is always
      // retrieved from the tech (see: currentTime). However, for completeness,
      // we set it to zero here to ensure that if we do start actually caching
      // it, we reset it along with everything else.
      currentTime: 0,
      initTime: 0,
      inactivityTimeout: this.options_.inactivityTimeout,
      duration: NaN,
      lastVolume: 1,
      lastPlaybackRate: this.defaultPlaybackRate(),
      media: null,
      src: "",
      source: {},
      sources: [],
      playbackRates: [],
      volume: 1
    };
  };
  _proto.techCall_ = function techCall_(method, arg) {
    this.ready(function() {
      if (method in allowedSetters) {
        return set(this.middleware_, this.tech_, method, arg);
      } else if (method in allowedMediators) {
        return mediate(this.middleware_, this.tech_, method, arg);
      }
      try {
        if (this.tech_) {
          this.tech_[method](arg);
        }
      } catch (e2) {
        log$1(e2);
        throw e2;
      }
    }, true);
  };
  _proto.techGet_ = function techGet_(method) {
    if (!this.tech_ || !this.tech_.isReady_) {
      return;
    }
    if (method in allowedGetters) {
      return get(this.middleware_, this.tech_, method);
    } else if (method in allowedMediators) {
      return mediate(this.middleware_, this.tech_, method);
    }
    try {
      return this.tech_[method]();
    } catch (e2) {
      if (this.tech_[method] === void 0) {
        log$1("Video.js: " + method + " method not defined for " + this.techName_ + " playback technology.", e2);
        throw e2;
      }
      if (e2.name === "TypeError") {
        log$1("Video.js: " + method + " unavailable on " + this.techName_ + " playback technology element.", e2);
        this.tech_.isReady_ = false;
        throw e2;
      }
      log$1(e2);
      throw e2;
    }
  };
  _proto.play = function play() {
    var _this10 = this;
    var PromiseClass = this.options_.Promise || window_1.Promise;
    if (PromiseClass) {
      return new PromiseClass(function(resolve) {
        _this10.play_(resolve);
      });
    }
    return this.play_();
  };
  _proto.play_ = function play_(callback2) {
    var _this11 = this;
    if (callback2 === void 0) {
      callback2 = silencePromise;
    }
    this.playCallbacks_.push(callback2);
    var isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
    if (this.waitToPlay_) {
      this.off(["ready", "loadstart"], this.waitToPlay_);
      this.waitToPlay_ = null;
    }
    if (!this.isReady_ || !isSrcReady) {
      this.waitToPlay_ = function(e2) {
        _this11.play_();
      };
      this.one(["ready", "loadstart"], this.waitToPlay_);
      if (!isSrcReady && (IS_ANY_SAFARI || IS_IOS)) {
        this.load();
      }
      return;
    }
    var val = this.techGet_("play");
    if (val === null) {
      this.runPlayTerminatedQueue_();
    } else {
      this.runPlayCallbacks_(val);
    }
  };
  _proto.runPlayTerminatedQueue_ = function runPlayTerminatedQueue_() {
    var queue = this.playTerminatedQueue_.slice(0);
    this.playTerminatedQueue_ = [];
    queue.forEach(function(q2) {
      q2();
    });
  };
  _proto.runPlayCallbacks_ = function runPlayCallbacks_(val) {
    var callbacks = this.playCallbacks_.slice(0);
    this.playCallbacks_ = [];
    this.playTerminatedQueue_ = [];
    callbacks.forEach(function(cb2) {
      cb2(val);
    });
  };
  _proto.pause = function pause() {
    this.techCall_("pause");
  };
  _proto.paused = function paused() {
    return this.techGet_("paused") === false ? false : true;
  };
  _proto.played = function played() {
    return this.techGet_("played") || createTimeRanges(0, 0);
  };
  _proto.scrubbing = function scrubbing(isScrubbing) {
    if (typeof isScrubbing === "undefined") {
      return this.scrubbing_;
    }
    this.scrubbing_ = !!isScrubbing;
    this.techCall_("setScrubbing", this.scrubbing_);
    if (isScrubbing) {
      this.addClass("vjs-scrubbing");
    } else {
      this.removeClass("vjs-scrubbing");
    }
  };
  _proto.currentTime = function currentTime(seconds) {
    if (typeof seconds !== "undefined") {
      if (seconds < 0) {
        seconds = 0;
      }
      if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
        this.cache_.initTime = seconds;
        this.off("canplay", this.boundApplyInitTime_);
        this.one("canplay", this.boundApplyInitTime_);
        return;
      }
      this.techCall_("setCurrentTime", seconds);
      this.cache_.initTime = 0;
      return;
    }
    this.cache_.currentTime = this.techGet_("currentTime") || 0;
    return this.cache_.currentTime;
  };
  _proto.applyInitTime_ = function applyInitTime_() {
    this.currentTime(this.cache_.initTime);
  };
  _proto.duration = function duration5(seconds) {
    if (seconds === void 0) {
      return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
    }
    seconds = parseFloat(seconds);
    if (seconds < 0) {
      seconds = Infinity;
    }
    if (seconds !== this.cache_.duration) {
      this.cache_.duration = seconds;
      if (seconds === Infinity) {
        this.addClass("vjs-live");
      } else {
        this.removeClass("vjs-live");
      }
      if (!isNaN(seconds)) {
        this.trigger("durationchange");
      }
    }
  };
  _proto.remainingTime = function remainingTime() {
    return this.duration() - this.currentTime();
  };
  _proto.remainingTimeDisplay = function remainingTimeDisplay() {
    return Math.floor(this.duration()) - Math.floor(this.currentTime());
  };
  _proto.buffered = function buffered() {
    var buffered2 = this.techGet_("buffered");
    if (!buffered2 || !buffered2.length) {
      buffered2 = createTimeRanges(0, 0);
    }
    return buffered2;
  };
  _proto.bufferedPercent = function bufferedPercent$1() {
    return bufferedPercent(this.buffered(), this.duration());
  };
  _proto.bufferedEnd = function bufferedEnd() {
    var buffered = this.buffered();
    var duration5 = this.duration();
    var end2 = buffered.end(buffered.length - 1);
    if (end2 > duration5) {
      end2 = duration5;
    }
    return end2;
  };
  _proto.volume = function volume(percentAsDecimal) {
    var vol;
    if (percentAsDecimal !== void 0) {
      vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
      this.cache_.volume = vol;
      this.techCall_("setVolume", vol);
      if (vol > 0) {
        this.lastVolume_(vol);
      }
      return;
    }
    vol = parseFloat(this.techGet_("volume"));
    return isNaN(vol) ? 1 : vol;
  };
  _proto.muted = function muted(_muted) {
    if (_muted !== void 0) {
      this.techCall_("setMuted", _muted);
      return;
    }
    return this.techGet_("muted") || false;
  };
  _proto.defaultMuted = function defaultMuted(_defaultMuted) {
    if (_defaultMuted !== void 0) {
      return this.techCall_("setDefaultMuted", _defaultMuted);
    }
    return this.techGet_("defaultMuted") || false;
  };
  _proto.lastVolume_ = function lastVolume_(percentAsDecimal) {
    if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
      this.cache_.lastVolume = percentAsDecimal;
      return;
    }
    return this.cache_.lastVolume;
  };
  _proto.supportsFullScreen = function supportsFullScreen() {
    return this.techGet_("supportsFullScreen") || false;
  };
  _proto.isFullscreen = function isFullscreen(isFS) {
    if (isFS !== void 0) {
      var oldValue = this.isFullscreen_;
      this.isFullscreen_ = Boolean(isFS);
      if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) {
        this.trigger("fullscreenchange");
      }
      this.toggleFullscreenClass_();
      return;
    }
    return this.isFullscreen_;
  };
  _proto.requestFullscreen = function requestFullscreen(fullscreenOptions) {
    var PromiseClass = this.options_.Promise || window_1.Promise;
    if (PromiseClass) {
      var self2 = this;
      return new PromiseClass(function(resolve, reject) {
        function offHandler() {
          self2.off("fullscreenerror", errorHandler);
          self2.off("fullscreenchange", changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e2, err) {
          offHandler();
          reject(err);
        }
        self2.one("fullscreenchange", changeHandler);
        self2.one("fullscreenerror", errorHandler);
        var promise = self2.requestFullscreenHelper_(fullscreenOptions);
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    return this.requestFullscreenHelper_();
  };
  _proto.requestFullscreenHelper_ = function requestFullscreenHelper_(fullscreenOptions) {
    var _this12 = this;
    var fsOptions;
    if (!this.fsApi_.prefixed) {
      fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
      if (fullscreenOptions !== void 0) {
        fsOptions = fullscreenOptions;
      }
    }
    if (this.fsApi_.requestFullscreen) {
      var promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
      if (promise) {
        promise.then(function() {
          return _this12.isFullscreen(true);
        }, function() {
          return _this12.isFullscreen(false);
        });
      }
      return promise;
    } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
      this.techCall_("enterFullScreen");
    } else {
      this.enterFullWindow();
    }
  };
  _proto.exitFullscreen = function exitFullscreen() {
    var PromiseClass = this.options_.Promise || window_1.Promise;
    if (PromiseClass) {
      var self2 = this;
      return new PromiseClass(function(resolve, reject) {
        function offHandler() {
          self2.off("fullscreenerror", errorHandler);
          self2.off("fullscreenchange", changeHandler);
        }
        function changeHandler() {
          offHandler();
          resolve();
        }
        function errorHandler(e2, err) {
          offHandler();
          reject(err);
        }
        self2.one("fullscreenchange", changeHandler);
        self2.one("fullscreenerror", errorHandler);
        var promise = self2.exitFullscreenHelper_();
        if (promise) {
          promise.then(offHandler, offHandler);
          promise.then(resolve, reject);
        }
      });
    }
    return this.exitFullscreenHelper_();
  };
  _proto.exitFullscreenHelper_ = function exitFullscreenHelper_() {
    var _this13 = this;
    if (this.fsApi_.requestFullscreen) {
      var promise = document_1[this.fsApi_.exitFullscreen]();
      if (promise) {
        silencePromise(promise.then(function() {
          return _this13.isFullscreen(false);
        }));
      }
      return promise;
    } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) {
      this.techCall_("exitFullScreen");
    } else {
      this.exitFullWindow();
    }
  };
  _proto.enterFullWindow = function enterFullWindow() {
    this.isFullscreen(true);
    this.isFullWindow = true;
    this.docOrigOverflow = document_1.documentElement.style.overflow;
    on(document_1, "keydown", this.boundFullWindowOnEscKey_);
    document_1.documentElement.style.overflow = "hidden";
    addClass(document_1.body, "vjs-full-window");
    this.trigger("enterFullWindow");
  };
  _proto.fullWindowOnEscKey = function fullWindowOnEscKey(event) {
    if (keycode.isEventKey(event, "Esc")) {
      if (this.isFullscreen() === true) {
        if (!this.isFullWindow) {
          this.exitFullscreen();
        } else {
          this.exitFullWindow();
        }
      }
    }
  };
  _proto.exitFullWindow = function exitFullWindow() {
    this.isFullscreen(false);
    this.isFullWindow = false;
    off(document_1, "keydown", this.boundFullWindowOnEscKey_);
    document_1.documentElement.style.overflow = this.docOrigOverflow;
    removeClass(document_1.body, "vjs-full-window");
    this.trigger("exitFullWindow");
  };
  _proto.disablePictureInPicture = function disablePictureInPicture(value) {
    if (value === void 0) {
      return this.techGet_("disablePictureInPicture");
    }
    this.techCall_("setDisablePictureInPicture", value);
    this.options_.disablePictureInPicture = value;
    this.trigger("disablepictureinpicturechanged");
  };
  _proto.isInPictureInPicture = function isInPictureInPicture(isPiP) {
    if (isPiP !== void 0) {
      this.isInPictureInPicture_ = !!isPiP;
      this.togglePictureInPictureClass_();
      return;
    }
    return !!this.isInPictureInPicture_;
  };
  _proto.requestPictureInPicture = function requestPictureInPicture() {
    if ("pictureInPictureEnabled" in document_1 && this.disablePictureInPicture() === false) {
      return this.techGet_("requestPictureInPicture");
    }
  };
  _proto.exitPictureInPicture = function exitPictureInPicture() {
    if ("pictureInPictureEnabled" in document_1) {
      return document_1.exitPictureInPicture();
    }
  };
  _proto.handleKeyDown = function handleKeyDown2(event) {
    var userActions = this.options_.userActions;
    if (!userActions || !userActions.hotkeys) {
      return;
    }
    var excludeElement = function excludeElement2(el2) {
      var tagName = el2.tagName.toLowerCase();
      if (el2.isContentEditable) {
        return true;
      }
      var allowedInputTypes = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
      if (tagName === "input") {
        return allowedInputTypes.indexOf(el2.type) === -1;
      }
      var excludedTags = ["textarea"];
      return excludedTags.indexOf(tagName) !== -1;
    };
    if (excludeElement(this.el_.ownerDocument.activeElement)) {
      return;
    }
    if (typeof userActions.hotkeys === "function") {
      userActions.hotkeys.call(this, event);
    } else {
      this.handleHotkeys(event);
    }
  };
  _proto.handleHotkeys = function handleHotkeys(event) {
    var hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
    var _hotkeys$fullscreenKe = hotkeys.fullscreenKey, fullscreenKey = _hotkeys$fullscreenKe === void 0 ? function(keydownEvent) {
      return keycode.isEventKey(keydownEvent, "f");
    } : _hotkeys$fullscreenKe, _hotkeys$muteKey = hotkeys.muteKey, muteKey = _hotkeys$muteKey === void 0 ? function(keydownEvent) {
      return keycode.isEventKey(keydownEvent, "m");
    } : _hotkeys$muteKey, _hotkeys$playPauseKey = hotkeys.playPauseKey, playPauseKey = _hotkeys$playPauseKey === void 0 ? function(keydownEvent) {
      return keycode.isEventKey(keydownEvent, "k") || keycode.isEventKey(keydownEvent, "Space");
    } : _hotkeys$playPauseKey;
    if (fullscreenKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var FSToggle = Component$1.getComponent("FullscreenToggle");
      if (document_1[this.fsApi_.fullscreenEnabled] !== false) {
        FSToggle.prototype.handleClick.call(this, event);
      }
    } else if (muteKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var MuteToggle2 = Component$1.getComponent("MuteToggle");
      MuteToggle2.prototype.handleClick.call(this, event);
    } else if (playPauseKey.call(this, event)) {
      event.preventDefault();
      event.stopPropagation();
      var PlayToggle2 = Component$1.getComponent("PlayToggle");
      PlayToggle2.prototype.handleClick.call(this, event);
    }
  };
  _proto.canPlayType = function canPlayType3(type2) {
    var can;
    for (var i = 0, j2 = this.options_.techOrder; i < j2.length; i++) {
      var techName = j2[i];
      var tech = Tech.getTech(techName);
      if (!tech) {
        tech = Component$1.getComponent(techName);
      }
      if (!tech) {
        log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
        continue;
      }
      if (tech.isSupported()) {
        can = tech.canPlayType(type2);
        if (can) {
          return can;
        }
      }
    }
    return "";
  };
  _proto.selectSource = function selectSource(sources) {
    var _this14 = this;
    var techs = this.options_.techOrder.map(function(techName) {
      return [techName, Tech.getTech(techName)];
    }).filter(function(_ref) {
      var techName = _ref[0], tech = _ref[1];
      if (tech) {
        return tech.isSupported();
      }
      log$1.error('The "' + techName + '" tech is undefined. Skipped browser support check for that tech.');
      return false;
    });
    var findFirstPassingTechSourcePair = function findFirstPassingTechSourcePair2(outerArray, innerArray, tester) {
      var found;
      outerArray.some(function(outerChoice) {
        return innerArray.some(function(innerChoice) {
          found = tester(outerChoice, innerChoice);
          if (found) {
            return true;
          }
        });
      });
      return found;
    };
    var foundSourceAndTech;
    var flip2 = function flip3(fn2) {
      return function(a2, b2) {
        return fn2(b2, a2);
      };
    };
    var finder = function finder2(_ref2, source) {
      var techName = _ref2[0], tech = _ref2[1];
      if (tech.canPlaySource(source, _this14.options_[techName.toLowerCase()])) {
        return {
          source,
          tech: techName
        };
      }
    };
    if (this.options_.sourceOrder) {
      foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip2(finder));
    } else {
      foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
    }
    return foundSourceAndTech || false;
  };
  _proto.handleSrc_ = function handleSrc_(source, isRetry) {
    var _this15 = this;
    if (typeof source === "undefined") {
      return this.cache_.src || "";
    }
    if (this.resetRetryOnError_) {
      this.resetRetryOnError_();
    }
    var sources = filterSource(source);
    if (!sources.length) {
      this.setTimeout(function() {
        this.error({
          code: 4,
          message: this.options_.notSupportedMessage
        });
      }, 0);
      return;
    }
    this.changingSrc_ = true;
    if (!isRetry) {
      this.cache_.sources = sources;
    }
    this.updateSourceCaches_(sources[0]);
    setSource(this, sources[0], function(middlewareSource, mws) {
      _this15.middleware_ = mws;
      if (!isRetry) {
        _this15.cache_.sources = sources;
      }
      _this15.updateSourceCaches_(middlewareSource);
      var err = _this15.src_(middlewareSource);
      if (err) {
        if (sources.length > 1) {
          return _this15.handleSrc_(sources.slice(1));
        }
        _this15.changingSrc_ = false;
        _this15.setTimeout(function() {
          this.error({
            code: 4,
            message: this.options_.notSupportedMessage
          });
        }, 0);
        _this15.triggerReady();
        return;
      }
      setTech(mws, _this15.tech_);
    });
    if (this.options_.retryOnError && sources.length > 1) {
      var retry = function retry2() {
        _this15.error(null);
        _this15.handleSrc_(sources.slice(1), true);
      };
      var stopListeningForErrors = function stopListeningForErrors2() {
        _this15.off("error", retry);
      };
      this.one("error", retry);
      this.one("playing", stopListeningForErrors);
      this.resetRetryOnError_ = function() {
        _this15.off("error", retry);
        _this15.off("playing", stopListeningForErrors);
      };
    }
  };
  _proto.src = function src(source) {
    return this.handleSrc_(source, false);
  };
  _proto.src_ = function src_(source) {
    var _this16 = this;
    var sourceTech = this.selectSource([source]);
    if (!sourceTech) {
      return true;
    }
    if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
      this.changingSrc_ = true;
      this.loadTech_(sourceTech.tech, sourceTech.source);
      this.tech_.ready(function() {
        _this16.changingSrc_ = false;
      });
      return false;
    }
    this.ready(function() {
      if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) {
        this.techCall_("setSource", source);
      } else {
        this.techCall_("src", source.src);
      }
      this.changingSrc_ = false;
    }, true);
    return false;
  };
  _proto.load = function load() {
    this.techCall_("load");
  };
  _proto.reset = function reset3() {
    var _this17 = this;
    var PromiseClass = this.options_.Promise || window_1.Promise;
    if (this.paused() || !PromiseClass) {
      this.doReset_();
    } else {
      var playPromise = this.play();
      silencePromise(playPromise.then(function() {
        return _this17.doReset_();
      }));
    }
  };
  _proto.doReset_ = function doReset_() {
    if (this.tech_) {
      this.tech_.clearTracks("text");
    }
    this.resetCache_();
    this.poster("");
    this.loadTech_(this.options_.techOrder[0], null);
    this.techCall_("reset");
    this.resetControlBarUI_();
    if (isEvented(this)) {
      this.trigger("playerreset");
    }
  };
  _proto.resetControlBarUI_ = function resetControlBarUI_() {
    this.resetProgressBar_();
    this.resetPlaybackRate_();
    this.resetVolumeBar_();
  };
  _proto.resetProgressBar_ = function resetProgressBar_() {
    this.currentTime(0);
    var _ref3 = this.controlBar || {}, durationDisplay = _ref3.durationDisplay, remainingTimeDisplay = _ref3.remainingTimeDisplay;
    if (durationDisplay) {
      durationDisplay.updateContent();
    }
    if (remainingTimeDisplay) {
      remainingTimeDisplay.updateContent();
    }
  };
  _proto.resetPlaybackRate_ = function resetPlaybackRate_() {
    this.playbackRate(this.defaultPlaybackRate());
    this.handleTechRateChange_();
  };
  _proto.resetVolumeBar_ = function resetVolumeBar_() {
    this.volume(1);
    this.trigger("volumechange");
  };
  _proto.currentSources = function currentSources() {
    var source = this.currentSource();
    var sources = [];
    if (Object.keys(source).length !== 0) {
      sources.push(source);
    }
    return this.cache_.sources || sources;
  };
  _proto.currentSource = function currentSource() {
    return this.cache_.source || {};
  };
  _proto.currentSrc = function currentSrc() {
    return this.currentSource() && this.currentSource().src || "";
  };
  _proto.currentType = function currentType() {
    return this.currentSource() && this.currentSource().type || "";
  };
  _proto.preload = function preload(value) {
    if (value !== void 0) {
      this.techCall_("setPreload", value);
      this.options_.preload = value;
      return;
    }
    return this.techGet_("preload");
  };
  _proto.autoplay = function autoplay(value) {
    if (value === void 0) {
      return this.options_.autoplay || false;
    }
    var techAutoplay;
    if (typeof value === "string" && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
      this.options_.autoplay = value;
      this.manualAutoplay_(typeof value === "string" ? value : "play");
      techAutoplay = false;
    } else if (!value) {
      this.options_.autoplay = false;
    } else {
      this.options_.autoplay = true;
    }
    techAutoplay = typeof techAutoplay === "undefined" ? this.options_.autoplay : techAutoplay;
    if (this.tech_) {
      this.techCall_("setAutoplay", techAutoplay);
    }
  };
  _proto.playsinline = function playsinline(value) {
    if (value !== void 0) {
      this.techCall_("setPlaysinline", value);
      this.options_.playsinline = value;
      return this;
    }
    return this.techGet_("playsinline");
  };
  _proto.loop = function loop(value) {
    if (value !== void 0) {
      this.techCall_("setLoop", value);
      this.options_.loop = value;
      return;
    }
    return this.techGet_("loop");
  };
  _proto.poster = function poster(src) {
    if (src === void 0) {
      return this.poster_;
    }
    if (!src) {
      src = "";
    }
    if (src === this.poster_) {
      return;
    }
    this.poster_ = src;
    this.techCall_("setPoster", src);
    this.isPosterFromTech_ = false;
    this.trigger("posterchange");
  };
  _proto.handleTechPosterChange_ = function handleTechPosterChange_() {
    if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
      var newPoster = this.tech_.poster() || "";
      if (newPoster !== this.poster_) {
        this.poster_ = newPoster;
        this.isPosterFromTech_ = true;
        this.trigger("posterchange");
      }
    }
  };
  _proto.controls = function controls(bool) {
    if (bool === void 0) {
      return !!this.controls_;
    }
    bool = !!bool;
    if (this.controls_ === bool) {
      return;
    }
    this.controls_ = bool;
    if (this.usingNativeControls()) {
      this.techCall_("setControls", bool);
    }
    if (this.controls_) {
      this.removeClass("vjs-controls-disabled");
      this.addClass("vjs-controls-enabled");
      this.trigger("controlsenabled");
      if (!this.usingNativeControls()) {
        this.addTechControlsListeners_();
      }
    } else {
      this.removeClass("vjs-controls-enabled");
      this.addClass("vjs-controls-disabled");
      this.trigger("controlsdisabled");
      if (!this.usingNativeControls()) {
        this.removeTechControlsListeners_();
      }
    }
  };
  _proto.usingNativeControls = function usingNativeControls(bool) {
    if (bool === void 0) {
      return !!this.usingNativeControls_;
    }
    bool = !!bool;
    if (this.usingNativeControls_ === bool) {
      return;
    }
    this.usingNativeControls_ = bool;
    if (this.usingNativeControls_) {
      this.addClass("vjs-using-native-controls");
      this.trigger("usingnativecontrols");
    } else {
      this.removeClass("vjs-using-native-controls");
      this.trigger("usingcustomcontrols");
    }
  };
  _proto.error = function error(err) {
    var _this18 = this;
    if (err === void 0) {
      return this.error_ || null;
    }
    hooks("beforeerror").forEach(function(hookFunction) {
      var newErr = hookFunction(_this18, err);
      if (!(isObject$1(newErr) && !Array.isArray(newErr) || typeof newErr === "string" || typeof newErr === "number" || newErr === null)) {
        _this18.log.error("please return a value that MediaError expects in beforeerror hooks");
        return;
      }
      err = newErr;
    });
    if (this.options_.suppressNotSupportedError && err && err.code === 4) {
      var triggerSuppressedError = function triggerSuppressedError2() {
        this.error(err);
      };
      this.options_.suppressNotSupportedError = false;
      this.any(["click", "touchstart"], triggerSuppressedError);
      this.one("loadstart", function() {
        this.off(["click", "touchstart"], triggerSuppressedError);
      });
      return;
    }
    if (err === null) {
      this.error_ = err;
      this.removeClass("vjs-error");
      if (this.errorDisplay) {
        this.errorDisplay.close();
      }
      return;
    }
    this.error_ = new MediaError(err);
    this.addClass("vjs-error");
    log$1.error("(CODE:" + this.error_.code + " " + MediaError.errorTypes[this.error_.code] + ")", this.error_.message, this.error_);
    this.trigger("error");
    hooks("error").forEach(function(hookFunction) {
      return hookFunction(_this18, _this18.error_);
    });
    return;
  };
  _proto.reportUserActivity = function reportUserActivity(event) {
    this.userActivity_ = true;
  };
  _proto.userActive = function userActive(bool) {
    if (bool === void 0) {
      return this.userActive_;
    }
    bool = !!bool;
    if (bool === this.userActive_) {
      return;
    }
    this.userActive_ = bool;
    if (this.userActive_) {
      this.userActivity_ = true;
      this.removeClass("vjs-user-inactive");
      this.addClass("vjs-user-active");
      this.trigger("useractive");
      return;
    }
    if (this.tech_) {
      this.tech_.one("mousemove", function(e2) {
        e2.stopPropagation();
        e2.preventDefault();
      });
    }
    this.userActivity_ = false;
    this.removeClass("vjs-user-active");
    this.addClass("vjs-user-inactive");
    this.trigger("userinactive");
  };
  _proto.listenForUserActivity_ = function listenForUserActivity_() {
    var mouseInProgress;
    var lastMoveX;
    var lastMoveY;
    var handleActivity = bind(this, this.reportUserActivity);
    var handleMouseMove = function handleMouseMove2(e2) {
      if (e2.screenX !== lastMoveX || e2.screenY !== lastMoveY) {
        lastMoveX = e2.screenX;
        lastMoveY = e2.screenY;
        handleActivity();
      }
    };
    var handleMouseDown = function handleMouseDown2() {
      handleActivity();
      this.clearInterval(mouseInProgress);
      mouseInProgress = this.setInterval(handleActivity, 250);
    };
    var handleMouseUpAndMouseLeave = function handleMouseUpAndMouseLeave2(event) {
      handleActivity();
      this.clearInterval(mouseInProgress);
    };
    this.on("mousedown", handleMouseDown);
    this.on("mousemove", handleMouseMove);
    this.on("mouseup", handleMouseUpAndMouseLeave);
    this.on("mouseleave", handleMouseUpAndMouseLeave);
    var controlBar = this.getChild("controlBar");
    if (controlBar && !IS_IOS && !IS_ANDROID) {
      controlBar.on("mouseenter", function(event) {
        if (this.player().options_.inactivityTimeout !== 0) {
          this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
        }
        this.player().options_.inactivityTimeout = 0;
      });
      controlBar.on("mouseleave", function(event) {
        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
      });
    }
    this.on("keydown", handleActivity);
    this.on("keyup", handleActivity);
    var inactivityTimeout;
    this.setInterval(function() {
      if (!this.userActivity_) {
        return;
      }
      this.userActivity_ = false;
      this.userActive(true);
      this.clearTimeout(inactivityTimeout);
      var timeout = this.options_.inactivityTimeout;
      if (timeout <= 0) {
        return;
      }
      inactivityTimeout = this.setTimeout(function() {
        if (!this.userActivity_) {
          this.userActive(false);
        }
      }, timeout);
    }, 250);
  };
  _proto.playbackRate = function playbackRate(rate) {
    if (rate !== void 0) {
      this.techCall_("setPlaybackRate", rate);
      return;
    }
    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
    }
    return 1;
  };
  _proto.defaultPlaybackRate = function defaultPlaybackRate(rate) {
    if (rate !== void 0) {
      return this.techCall_("setDefaultPlaybackRate", rate);
    }
    if (this.tech_ && this.tech_.featuresPlaybackRate) {
      return this.techGet_("defaultPlaybackRate");
    }
    return 1;
  };
  _proto.isAudio = function isAudio(bool) {
    if (bool !== void 0) {
      this.isAudio_ = !!bool;
      return;
    }
    return !!this.isAudio_;
  };
  _proto.enableAudioOnlyUI_ = function enableAudioOnlyUI_() {
    var _this19 = this;
    this.addClass("vjs-audio-only-mode");
    var playerChildren = this.children();
    var controlBar = this.getChild("ControlBar");
    var controlBarHeight = controlBar && controlBar.currentHeight();
    playerChildren.forEach(function(child) {
      if (child === controlBar) {
        return;
      }
      if (child.el_ && !child.hasClass("vjs-hidden")) {
        child.hide();
        _this19.audioOnlyCache_.hiddenChildren.push(child);
      }
    });
    this.audioOnlyCache_.playerHeight = this.currentHeight();
    this.height(controlBarHeight);
    this.trigger("audioonlymodechange");
  };
  _proto.disableAudioOnlyUI_ = function disableAudioOnlyUI_() {
    this.removeClass("vjs-audio-only-mode");
    this.audioOnlyCache_.hiddenChildren.forEach(function(child) {
      return child.show();
    });
    this.height(this.audioOnlyCache_.playerHeight);
    this.trigger("audioonlymodechange");
  };
  _proto.audioOnlyMode = function audioOnlyMode(value) {
    var _this20 = this;
    if (typeof value !== "boolean" || value === this.audioOnlyMode_) {
      return this.audioOnlyMode_;
    }
    this.audioOnlyMode_ = value;
    var PromiseClass = this.options_.Promise || window_1.Promise;
    if (PromiseClass) {
      if (value) {
        var exitPromises = [];
        if (this.isInPictureInPicture()) {
          exitPromises.push(this.exitPictureInPicture());
        }
        if (this.isFullscreen()) {
          exitPromises.push(this.exitFullscreen());
        }
        if (this.audioPosterMode()) {
          exitPromises.push(this.audioPosterMode(false));
        }
        return PromiseClass.all(exitPromises).then(function() {
          return _this20.enableAudioOnlyUI_();
        });
      }
      return PromiseClass.resolve().then(function() {
        return _this20.disableAudioOnlyUI_();
      });
    }
    if (value) {
      if (this.isInPictureInPicture()) {
        this.exitPictureInPicture();
      }
      if (this.isFullscreen()) {
        this.exitFullscreen();
      }
      this.enableAudioOnlyUI_();
    } else {
      this.disableAudioOnlyUI_();
    }
  };
  _proto.enablePosterModeUI_ = function enablePosterModeUI_() {
    var tech = this.tech_ && this.tech_;
    tech.hide();
    this.addClass("vjs-audio-poster-mode");
    this.trigger("audiopostermodechange");
  };
  _proto.disablePosterModeUI_ = function disablePosterModeUI_() {
    var tech = this.tech_ && this.tech_;
    tech.show();
    this.removeClass("vjs-audio-poster-mode");
    this.trigger("audiopostermodechange");
  };
  _proto.audioPosterMode = function audioPosterMode(value) {
    var _this21 = this;
    if (typeof value !== "boolean" || value === this.audioPosterMode_) {
      return this.audioPosterMode_;
    }
    this.audioPosterMode_ = value;
    var PromiseClass = this.options_.Promise || window_1.Promise;
    if (PromiseClass) {
      if (value) {
        if (this.audioOnlyMode()) {
          var audioOnlyModePromise = this.audioOnlyMode(false);
          return audioOnlyModePromise.then(function() {
            _this21.enablePosterModeUI_();
          });
        }
        return PromiseClass.resolve().then(function() {
          _this21.enablePosterModeUI_();
        });
      }
      return PromiseClass.resolve().then(function() {
        _this21.disablePosterModeUI_();
      });
    }
    if (value) {
      if (this.audioOnlyMode()) {
        this.audioOnlyMode(false);
      }
      this.enablePosterModeUI_();
      return;
    }
    this.disablePosterModeUI_();
  };
  _proto.addTextTrack = function addTextTrack(kind, label, language) {
    if (this.tech_) {
      return this.tech_.addTextTrack(kind, label, language);
    }
  };
  _proto.addRemoteTextTrack = function addRemoteTextTrack(options, manualCleanup) {
    if (this.tech_) {
      return this.tech_.addRemoteTextTrack(options, manualCleanup);
    }
  };
  _proto.removeRemoteTextTrack = function removeRemoteTextTrack(obj) {
    if (obj === void 0) {
      obj = {};
    }
    var _obj = obj, track = _obj.track;
    if (!track) {
      track = obj;
    }
    if (this.tech_) {
      return this.tech_.removeRemoteTextTrack(track);
    }
  };
  _proto.getVideoPlaybackQuality = function getVideoPlaybackQuality() {
    return this.techGet_("getVideoPlaybackQuality");
  };
  _proto.videoWidth = function videoWidth() {
    return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
  };
  _proto.videoHeight = function videoHeight() {
    return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
  };
  _proto.language = function language(code) {
    if (code === void 0) {
      return this.language_;
    }
    if (this.language_ !== String(code).toLowerCase()) {
      this.language_ = String(code).toLowerCase();
      if (isEvented(this)) {
        this.trigger("languagechange");
      }
    }
  };
  _proto.languages = function languages() {
    return mergeOptions$3(Player2.prototype.options_.languages, this.languages_);
  };
  _proto.toJSON = function toJSON2() {
    var options = mergeOptions$3(this.options_);
    var tracks = options.tracks;
    options.tracks = [];
    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      track = mergeOptions$3(track);
      track.player = void 0;
      options.tracks[i] = track;
    }
    return options;
  };
  _proto.createModal = function createModal(content, options) {
    var _this22 = this;
    options = options || {};
    options.content = content || "";
    var modal = new ModalDialog(this, options);
    this.addChild(modal);
    modal.on("dispose", function() {
      _this22.removeChild(modal);
    });
    modal.open();
    return modal;
  };
  _proto.updateCurrentBreakpoint_ = function updateCurrentBreakpoint_() {
    if (!this.responsive()) {
      return;
    }
    var currentBreakpoint = this.currentBreakpoint();
    var currentWidth = this.currentWidth();
    for (var i = 0; i < BREAKPOINT_ORDER.length; i++) {
      var candidateBreakpoint = BREAKPOINT_ORDER[i];
      var maxWidth2 = this.breakpoints_[candidateBreakpoint];
      if (currentWidth <= maxWidth2) {
        if (currentBreakpoint === candidateBreakpoint) {
          return;
        }
        if (currentBreakpoint) {
          this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
        }
        this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
        this.breakpoint_ = candidateBreakpoint;
        break;
      }
    }
  };
  _proto.removeCurrentBreakpoint_ = function removeCurrentBreakpoint_() {
    var className = this.currentBreakpointClass();
    this.breakpoint_ = "";
    if (className) {
      this.removeClass(className);
    }
  };
  _proto.breakpoints = function breakpoints(_breakpoints) {
    if (_breakpoints === void 0) {
      return assign$1(this.breakpoints_);
    }
    this.breakpoint_ = "";
    this.breakpoints_ = assign$1({}, DEFAULT_BREAKPOINTS, _breakpoints);
    this.updateCurrentBreakpoint_();
    return assign$1(this.breakpoints_);
  };
  _proto.responsive = function responsive(value) {
    if (value === void 0) {
      return this.responsive_;
    }
    value = Boolean(value);
    var current = this.responsive_;
    if (value === current) {
      return;
    }
    this.responsive_ = value;
    if (value) {
      this.on("playerresize", this.boundUpdateCurrentBreakpoint_);
      this.updateCurrentBreakpoint_();
    } else {
      this.off("playerresize", this.boundUpdateCurrentBreakpoint_);
      this.removeCurrentBreakpoint_();
    }
    return value;
  };
  _proto.currentBreakpoint = function currentBreakpoint() {
    return this.breakpoint_;
  };
  _proto.currentBreakpointClass = function currentBreakpointClass() {
    return BREAKPOINT_CLASSES[this.breakpoint_] || "";
  };
  _proto.loadMedia = function loadMedia(media, ready) {
    var _this23 = this;
    if (!media || typeof media !== "object") {
      return;
    }
    this.reset();
    this.cache_.media = mergeOptions$3(media);
    var _this$cache_$media = this.cache_.media, artwork = _this$cache_$media.artwork, poster = _this$cache_$media.poster, src = _this$cache_$media.src, textTracks = _this$cache_$media.textTracks;
    if (!artwork && poster) {
      this.cache_.media.artwork = [{
        src: poster,
        type: getMimetype(poster)
      }];
    }
    if (src) {
      this.src(src);
    }
    if (poster) {
      this.poster(poster);
    }
    if (Array.isArray(textTracks)) {
      textTracks.forEach(function(tt) {
        return _this23.addRemoteTextTrack(tt, false);
      });
    }
    this.ready(ready);
  };
  _proto.getMedia = function getMedia() {
    if (!this.cache_.media) {
      var poster = this.poster();
      var src = this.currentSources();
      var textTracks = Array.prototype.map.call(this.remoteTextTracks(), function(tt) {
        return {
          kind: tt.kind,
          label: tt.label,
          language: tt.language,
          src: tt.src
        };
      });
      var media = {
        src,
        textTracks
      };
      if (poster) {
        media.poster = poster;
        media.artwork = [{
          src: media.poster,
          type: getMimetype(media.poster)
        }];
      }
      return media;
    }
    return mergeOptions$3(this.cache_.media);
  };
  Player2.getTagSettings = function getTagSettings(tag) {
    var baseOptions = {
      sources: [],
      tracks: []
    };
    var tagOptions = getAttributes(tag);
    var dataSetup = tagOptions["data-setup"];
    if (hasClass(tag, "vjs-fill")) {
      tagOptions.fill = true;
    }
    if (hasClass(tag, "vjs-fluid")) {
      tagOptions.fluid = true;
    }
    if (dataSetup !== null) {
      var _safeParseTuple = tuple(dataSetup || "{}"), err = _safeParseTuple[0], data = _safeParseTuple[1];
      if (err) {
        log$1.error(err);
      }
      assign$1(tagOptions, data);
    }
    assign$1(baseOptions, tagOptions);
    if (tag.hasChildNodes()) {
      var children = tag.childNodes;
      for (var i = 0, j2 = children.length; i < j2; i++) {
        var child = children[i];
        var childName = child.nodeName.toLowerCase();
        if (childName === "source") {
          baseOptions.sources.push(getAttributes(child));
        } else if (childName === "track") {
          baseOptions.tracks.push(getAttributes(child));
        }
      }
    }
    return baseOptions;
  };
  _proto.flexNotSupported_ = function flexNotSupported_() {
    var elem = document_1.createElement("i");
    return !("flexBasis" in elem.style || "webkitFlexBasis" in elem.style || "mozFlexBasis" in elem.style || "msFlexBasis" in elem.style || // IE10-specific (2012 flex spec), available for completeness
    "msFlexOrder" in elem.style);
  };
  _proto.debug = function debug(enabled) {
    if (enabled === void 0) {
      return this.debugEnabled_;
    }
    if (enabled) {
      this.trigger("debugon");
      this.previousLogLevel_ = this.log.level;
      this.log.level("debug");
      this.debugEnabled_ = true;
    } else {
      this.trigger("debugoff");
      this.log.level(this.previousLogLevel_);
      this.previousLogLevel_ = void 0;
      this.debugEnabled_ = false;
    }
  };
  _proto.playbackRates = function playbackRates(newRates) {
    if (newRates === void 0) {
      return this.cache_.playbackRates;
    }
    if (!Array.isArray(newRates)) {
      return;
    }
    if (!newRates.every(function(rate) {
      return typeof rate === "number";
    })) {
      return;
    }
    this.cache_.playbackRates = newRates;
    this.trigger("playbackrateschange");
  };
  return Player2;
}(Component$1);
ALL.names.forEach(function(name) {
  var props = ALL[name];
  Player.prototype[props.getterName] = function() {
    if (this.tech_) {
      return this.tech_[props.getterName]();
    }
    this[props.privateName] = this[props.privateName] || new props.ListClass();
    return this[props.privateName];
  };
});
Player.prototype.crossorigin = Player.prototype.crossOrigin;
Player.players = {};
var navigator$1 = window_1.navigator;
Player.prototype.options_ = {
  // Default order of fallback technology
  techOrder: Tech.defaultTechOrder_,
  html5: {},
  // default inactivity timeout
  inactivityTimeout: 2e3,
  // default playback rates
  playbackRates: [],
  // Add playback rate selection by adding rates
  // 'playbackRates': [0.5, 1, 1.5, 2],
  liveui: false,
  // Included control sets
  children: ["mediaLoader", "posterImage", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
  language: navigator$1 && (navigator$1.languages && navigator$1.languages[0] || navigator$1.userLanguage || navigator$1.language) || "en",
  // locales and their language translations
  languages: {},
  // Default message to show when a video cannot be played.
  notSupportedMessage: "No compatible source was found for this media.",
  normalizeAutoplay: false,
  fullscreen: {
    options: {
      navigationUI: "hide"
    }
  },
  breakpoints: {},
  responsive: false,
  audioOnlyMode: false,
  audioPosterMode: false
};
[
  /**
   * Returns whether or not the player is in the "ended" state.
   *
   * @return {Boolean} True if the player is in the ended state, false if not.
   * @method Player#ended
   */
  "ended",
  /**
   * Returns whether or not the player is in the "seeking" state.
   *
   * @return {Boolean} True if the player is in the seeking state, false if not.
   * @method Player#seeking
   */
  "seeking",
  /**
   * Returns the TimeRanges of the media that are currently available
   * for seeking to.
   *
   * @return {TimeRanges} the seekable intervals of the media timeline
   * @method Player#seekable
   */
  "seekable",
  /**
   * Returns the current state of network activity for the element, from
   * the codes in the list below.
   * - NETWORK_EMPTY (numeric value 0)
   *   The element has not yet been initialised. All attributes are in
   *   their initial states.
   * - NETWORK_IDLE (numeric value 1)
   *   The element's resource selection algorithm is active and has
   *   selected a resource, but it is not actually using the network at
   *   this time.
   * - NETWORK_LOADING (numeric value 2)
   *   The user agent is actively trying to download data.
   * - NETWORK_NO_SOURCE (numeric value 3)
   *   The element's resource selection algorithm is active, but it has
   *   not yet found a resource to use.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#network-states
   * @return {number} the current network activity state
   * @method Player#networkState
   */
  "networkState",
  /**
   * Returns a value that expresses the current state of the element
   * with respect to rendering the current playback position, from the
   * codes in the list below.
   * - HAVE_NOTHING (numeric value 0)
   *   No information regarding the media resource is available.
   * - HAVE_METADATA (numeric value 1)
   *   Enough of the resource has been obtained that the duration of the
   *   resource is available.
   * - HAVE_CURRENT_DATA (numeric value 2)
   *   Data for the immediate current playback position is available.
   * - HAVE_FUTURE_DATA (numeric value 3)
   *   Data for the immediate current playback position is available, as
   *   well as enough data for the user agent to advance the current
   *   playback position in the direction of playback.
   * - HAVE_ENOUGH_DATA (numeric value 4)
   *   The user agent estimates that enough data is available for
   *   playback to proceed uninterrupted.
   *
   * @see https://html.spec.whatwg.org/multipage/embedded-content.html#dom-media-readystate
   * @return {number} the current playback rendering state
   * @method Player#readyState
   */
  "readyState"
].forEach(function(fn2) {
  Player.prototype[fn2] = function() {
    return this.techGet_(fn2);
  };
});
TECH_EVENTS_RETRIGGER.forEach(function(event) {
  Player.prototype["handleTech" + toTitleCase$1(event) + "_"] = function() {
    return this.trigger(event);
  };
});
Component$1.registerComponent("Player", Player);
var BASE_PLUGIN_NAME = "plugin";
var PLUGIN_CACHE_KEY = "activePlugins_";
var pluginStorage = {};
var pluginExists = function pluginExists2(name) {
  return pluginStorage.hasOwnProperty(name);
};
var getPlugin = function getPlugin2(name) {
  return pluginExists(name) ? pluginStorage[name] : void 0;
};
var markPluginAsActive = function markPluginAsActive2(player, name) {
  player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
  player[PLUGIN_CACHE_KEY][name] = true;
};
var triggerSetupEvent = function triggerSetupEvent2(player, hash2, before) {
  var eventName = (before ? "before" : "") + "pluginsetup";
  player.trigger(eventName, hash2);
  player.trigger(eventName + ":" + hash2.name, hash2);
};
var createBasicPlugin = function createBasicPlugin2(name, plugin) {
  var basicPluginWrapper = function basicPluginWrapper2() {
    triggerSetupEvent(this, {
      name,
      plugin,
      instance: null
    }, true);
    var instance = plugin.apply(this, arguments);
    markPluginAsActive(this, name);
    triggerSetupEvent(this, {
      name,
      plugin,
      instance
    });
    return instance;
  };
  Object.keys(plugin).forEach(function(prop3) {
    basicPluginWrapper[prop3] = plugin[prop3];
  });
  return basicPluginWrapper;
};
var createPluginFactory = function createPluginFactory2(name, PluginSubClass) {
  PluginSubClass.prototype.name = name;
  return function() {
    triggerSetupEvent(this, {
      name,
      plugin: PluginSubClass,
      instance: null
    }, true);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var instance = _construct(PluginSubClass, [this].concat(args));
    this[name] = function() {
      return instance;
    };
    triggerSetupEvent(this, instance.getEventHash());
    return instance;
  };
};
var Plugin = /* @__PURE__ */ function() {
  function Plugin2(player) {
    if (this.constructor === Plugin2) {
      throw new Error("Plugin must be sub-classed; not directly instantiated.");
    }
    this.player = player;
    if (!this.log) {
      this.log = this.player.log.createLogger(this.name);
    }
    evented(this);
    delete this.trigger;
    stateful(this, this.constructor.defaultState);
    markPluginAsActive(player, this.name);
    this.dispose = this.dispose.bind(this);
    player.on("dispose", this.dispose);
  }
  var _proto = Plugin2.prototype;
  _proto.version = function version2() {
    return this.constructor.VERSION;
  };
  _proto.getEventHash = function getEventHash(hash2) {
    if (hash2 === void 0) {
      hash2 = {};
    }
    hash2.name = this.name;
    hash2.plugin = this.constructor;
    hash2.instance = this;
    return hash2;
  };
  _proto.trigger = function trigger$1$12(event, hash2) {
    if (hash2 === void 0) {
      hash2 = {};
    }
    return trigger$1(this.eventBusEl_, event, this.getEventHash(hash2));
  };
  _proto.handleStateChanged = function handleStateChanged(e2) {
  };
  _proto.dispose = function dispose() {
    var name = this.name, player = this.player;
    this.trigger("dispose");
    this.off();
    player.off("dispose", this.dispose);
    player[PLUGIN_CACHE_KEY][name] = false;
    this.player = this.state = null;
    player[name] = createPluginFactory(name, pluginStorage[name]);
  };
  Plugin2.isBasic = function isBasic(plugin) {
    var p2 = typeof plugin === "string" ? getPlugin(plugin) : plugin;
    return typeof p2 === "function" && !Plugin2.prototype.isPrototypeOf(p2.prototype);
  };
  Plugin2.registerPlugin = function registerPlugin(name, plugin) {
    if (typeof name !== "string") {
      throw new Error('Illegal plugin name, "' + name + '", must be a string, was ' + typeof name + ".");
    }
    if (pluginExists(name)) {
      log$1.warn('A plugin named "' + name + '" already exists. You may want to avoid re-registering plugins!');
    } else if (Player.prototype.hasOwnProperty(name)) {
      throw new Error('Illegal plugin name, "' + name + '", cannot share a name with an existing player method!');
    }
    if (typeof plugin !== "function") {
      throw new Error('Illegal plugin for "' + name + '", must be a function, was ' + typeof plugin + ".");
    }
    pluginStorage[name] = plugin;
    if (name !== BASE_PLUGIN_NAME) {
      if (Plugin2.isBasic(plugin)) {
        Player.prototype[name] = createBasicPlugin(name, plugin);
      } else {
        Player.prototype[name] = createPluginFactory(name, plugin);
      }
    }
    return plugin;
  };
  Plugin2.deregisterPlugin = function deregisterPlugin(name) {
    if (name === BASE_PLUGIN_NAME) {
      throw new Error("Cannot de-register base plugin.");
    }
    if (pluginExists(name)) {
      delete pluginStorage[name];
      delete Player.prototype[name];
    }
  };
  Plugin2.getPlugins = function getPlugins(names2) {
    if (names2 === void 0) {
      names2 = Object.keys(pluginStorage);
    }
    var result;
    names2.forEach(function(name) {
      var plugin = getPlugin(name);
      if (plugin) {
        result = result || {};
        result[name] = plugin;
      }
    });
    return result;
  };
  Plugin2.getPluginVersion = function getPluginVersion(name) {
    var plugin = getPlugin(name);
    return plugin && plugin.VERSION || "";
  };
  return Plugin2;
}();
Plugin.getPlugin = getPlugin;
Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
Player.prototype.usingPlugin = function(name) {
  return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
};
Player.prototype.hasPlugin = function(name) {
  return !!pluginExists(name);
};
var extend = function extend2(superClass, subClassMethods) {
  if (subClassMethods === void 0) {
    subClassMethods = {};
  }
  var subClass = function subClass2() {
    superClass.apply(this, arguments);
  };
  var methods = {};
  if (typeof subClassMethods === "object") {
    if (subClassMethods.constructor !== Object.prototype.constructor) {
      subClass = subClassMethods.constructor;
    }
    methods = subClassMethods;
  } else if (typeof subClassMethods === "function") {
    subClass = subClassMethods;
  }
  _inherits(subClass, superClass);
  if (superClass) {
    subClass.super_ = superClass;
  }
  for (var name in methods) {
    if (methods.hasOwnProperty(name)) {
      subClass.prototype[name] = methods[name];
    }
  }
  return subClass;
};
var normalizeId = function normalizeId2(id2) {
  return id2.indexOf("#") === 0 ? id2.slice(1) : id2;
};
function videojs(id2, options, ready) {
  var player = videojs.getPlayer(id2);
  if (player) {
    if (options) {
      log$1.warn('Player "' + id2 + '" is already initialised. Options will not be applied.');
    }
    if (ready) {
      player.ready(ready);
    }
    return player;
  }
  var el2 = typeof id2 === "string" ? $("#" + normalizeId(id2)) : id2;
  if (!isEl(el2)) {
    throw new TypeError("The element or ID supplied is not valid. (videojs)");
  }
  if (!el2.ownerDocument.defaultView || !el2.ownerDocument.body.contains(el2)) {
    log$1.warn("The element supplied is not included in the DOM");
  }
  options = options || {};
  if (options.restoreEl === true) {
    options.restoreEl = (el2.parentNode && el2.parentNode.hasAttribute("data-vjs-player") ? el2.parentNode : el2).cloneNode(true);
  }
  hooks("beforesetup").forEach(function(hookFunction) {
    var opts = hookFunction(el2, mergeOptions$3(options));
    if (!isObject$1(opts) || Array.isArray(opts)) {
      log$1.error("please return an object in beforesetup hooks");
      return;
    }
    options = mergeOptions$3(options, opts);
  });
  var PlayerComponent = Component$1.getComponent("Player");
  player = new PlayerComponent(el2, options, ready);
  hooks("setup").forEach(function(hookFunction) {
    return hookFunction(player);
  });
  return player;
}
videojs.hooks_ = hooks_;
videojs.hooks = hooks;
videojs.hook = hook;
videojs.hookOnce = hookOnce;
videojs.removeHook = removeHook;
if (window_1.VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
  var style$2 = $(".vjs-styles-defaults");
  if (!style$2) {
    style$2 = createStyleElement("vjs-styles-defaults");
    var head = $("head");
    if (head) {
      head.insertBefore(style$2, head.firstChild);
    }
    setTextContent(style$2, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    ");
  }
}
autoSetupTimeout(1, videojs);
videojs.VERSION = version$5;
videojs.options = Player.prototype.options_;
videojs.getPlayers = function() {
  return Player.players;
};
videojs.getPlayer = function(id2) {
  var players = Player.players;
  var tag;
  if (typeof id2 === "string") {
    var nId = normalizeId(id2);
    var player = players[nId];
    if (player) {
      return player;
    }
    tag = $("#" + nId);
  } else {
    tag = id2;
  }
  if (isEl(tag)) {
    var _tag = tag, _player = _tag.player, playerId = _tag.playerId;
    if (_player || players[playerId]) {
      return _player || players[playerId];
    }
  }
};
videojs.getAllPlayers = function() {
  return (
    // Disposed players leave a key with a `null` value, so we need to make sure
    // we filter those out.
    Object.keys(Player.players).map(function(k2) {
      return Player.players[k2];
    }).filter(Boolean)
  );
};
videojs.players = Player.players;
videojs.getComponent = Component$1.getComponent;
videojs.registerComponent = function(name, comp) {
  if (Tech.isTech(comp)) {
    log$1.warn("The " + name + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)");
  }
  Component$1.registerComponent.call(Component$1, name, comp);
};
videojs.getTech = Tech.getTech;
videojs.registerTech = Tech.registerTech;
videojs.use = use;
Object.defineProperty(videojs, "middleware", {
  value: {},
  writeable: false,
  enumerable: true
});
Object.defineProperty(videojs.middleware, "TERMINATOR", {
  value: TERMINATOR,
  writeable: false,
  enumerable: true
});
videojs.browser = browser$1;
videojs.TOUCH_ENABLED = TOUCH_ENABLED;
videojs.extend = extend;
videojs.mergeOptions = mergeOptions$3;
videojs.bind = bind;
videojs.registerPlugin = Plugin.registerPlugin;
videojs.deregisterPlugin = Plugin.deregisterPlugin;
videojs.plugin = function(name, plugin) {
  log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
  return Plugin.registerPlugin(name, plugin);
};
videojs.getPlugins = Plugin.getPlugins;
videojs.getPlugin = Plugin.getPlugin;
videojs.getPluginVersion = Plugin.getPluginVersion;
videojs.addLanguage = function(code, data) {
  var _mergeOptions;
  code = ("" + code).toLowerCase();
  videojs.options.languages = mergeOptions$3(videojs.options.languages, (_mergeOptions = {}, _mergeOptions[code] = data, _mergeOptions));
  return videojs.options.languages[code];
};
videojs.log = log$1;
videojs.createLogger = createLogger;
videojs.createTimeRange = videojs.createTimeRanges = createTimeRanges;
videojs.formatTime = formatTime;
videojs.setFormatTime = setFormatTime;
videojs.resetFormatTime = resetFormatTime;
videojs.parseUrl = parseUrl;
videojs.isCrossOrigin = isCrossOrigin;
videojs.EventTarget = EventTarget$2;
videojs.on = on;
videojs.one = one;
videojs.off = off;
videojs.trigger = trigger$1;
videojs.xhr = libExports;
videojs.TextTrack = TextTrack;
videojs.AudioTrack = AudioTrack;
videojs.VideoTrack = VideoTrack;
["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach(function(k2) {
  videojs[k2] = function() {
    log$1.warn("videojs." + k2 + "() is deprecated; use videojs.dom." + k2 + "() instead");
    return Dom[k2].apply(null, arguments);
  };
});
videojs.computedStyle = computedStyle;
videojs.dom = Dom;
videojs.url = Url;
videojs.defineLazyProperty = defineLazyProperty;
videojs.addLanguage("en", {
  "Non-Fullscreen": "Exit Fullscreen"
});
/*! @name @videojs/http-streaming @version 2.14.3 @license Apache-2.0 */
var resolveUrl2 = resolveUrl$1;
var resolveManifestRedirect = function resolveManifestRedirect2(handleManifestRedirect, url, req) {
  if (handleManifestRedirect && req && req.responseURL && url !== req.responseURL) {
    return req.responseURL;
  }
  return url;
};
var logger = function logger2(source) {
  if (videojs.log.debug) {
    return videojs.log.debug.bind(videojs, "VHS:", source + " >");
  }
  return function() {
  };
};
var TIME_FUDGE_FACTOR = 1 / 30;
var SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;
var filterRanges = function filterRanges2(timeRanges, predicate) {
  var results = [];
  var i;
  if (timeRanges && timeRanges.length) {
    for (i = 0; i < timeRanges.length; i++) {
      if (predicate(timeRanges.start(i), timeRanges.end(i))) {
        results.push([timeRanges.start(i), timeRanges.end(i)]);
      }
    }
  }
  return videojs.createTimeRanges(results);
};
var findRange = function findRange2(buffered, time2) {
  return filterRanges(buffered, function(start3, end2) {
    return start3 - SAFE_TIME_DELTA <= time2 && end2 + SAFE_TIME_DELTA >= time2;
  });
};
var findNextRange = function findNextRange2(timeRanges, time2) {
  return filterRanges(timeRanges, function(start3) {
    return start3 - TIME_FUDGE_FACTOR >= time2;
  });
};
var findGaps = function findGaps2(buffered) {
  if (buffered.length < 2) {
    return videojs.createTimeRanges();
  }
  var ranges = [];
  for (var i = 1; i < buffered.length; i++) {
    var start3 = buffered.end(i - 1);
    var end2 = buffered.start(i);
    ranges.push([start3, end2]);
  }
  return videojs.createTimeRanges(ranges);
};
var bufferIntersection = function bufferIntersection2(bufferA, bufferB) {
  var start3 = null;
  var end2 = null;
  var arity = 0;
  var extents = [];
  var ranges = [];
  if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) {
    return videojs.createTimeRange();
  }
  var count2 = bufferA.length;
  while (count2--) {
    extents.push({
      time: bufferA.start(count2),
      type: "start"
    });
    extents.push({
      time: bufferA.end(count2),
      type: "end"
    });
  }
  count2 = bufferB.length;
  while (count2--) {
    extents.push({
      time: bufferB.start(count2),
      type: "start"
    });
    extents.push({
      time: bufferB.end(count2),
      type: "end"
    });
  }
  extents.sort(function(a2, b2) {
    return a2.time - b2.time;
  });
  for (count2 = 0; count2 < extents.length; count2++) {
    if (extents[count2].type === "start") {
      arity++;
      if (arity === 2) {
        start3 = extents[count2].time;
      }
    } else if (extents[count2].type === "end") {
      arity--;
      if (arity === 1) {
        end2 = extents[count2].time;
      }
    }
    if (start3 !== null && end2 !== null) {
      ranges.push([start3, end2]);
      start3 = null;
      end2 = null;
    }
  }
  return videojs.createTimeRanges(ranges);
};
var printableRange = function printableRange2(range3) {
  var strArr = [];
  if (!range3 || !range3.length) {
    return "";
  }
  for (var i = 0; i < range3.length; i++) {
    strArr.push(range3.start(i) + " => " + range3.end(i));
  }
  return strArr.join(", ");
};
var timeUntilRebuffer = function timeUntilRebuffer2(buffered, currentTime, playbackRate) {
  if (playbackRate === void 0) {
    playbackRate = 1;
  }
  var bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
  return (bufferedEnd - currentTime) / playbackRate;
};
var timeRangesToArray = function timeRangesToArray2(timeRanges) {
  var timeRangesList = [];
  for (var i = 0; i < timeRanges.length; i++) {
    timeRangesList.push({
      start: timeRanges.start(i),
      end: timeRanges.end(i)
    });
  }
  return timeRangesList;
};
var isRangeDifferent = function isRangeDifferent2(a2, b2) {
  if (a2 === b2) {
    return false;
  }
  if (!a2 && b2 || !b2 && a2) {
    return true;
  }
  if (a2.length !== b2.length) {
    return true;
  }
  for (var i = 0; i < a2.length; i++) {
    if (a2.start(i) !== b2.start(i) || a2.end(i) !== b2.end(i)) {
      return true;
    }
  }
  return false;
};
var lastBufferedEnd = function lastBufferedEnd2(a2) {
  if (!a2 || !a2.length || !a2.end) {
    return;
  }
  return a2.end(a2.length - 1);
};
var timeAheadOf = function timeAheadOf2(range3, startTime) {
  var time2 = 0;
  if (!range3 || !range3.length) {
    return time2;
  }
  for (var i = 0; i < range3.length; i++) {
    var start3 = range3.start(i);
    var end2 = range3.end(i);
    if (startTime > end2) {
      continue;
    }
    if (startTime > start3 && startTime <= end2) {
      time2 += end2 - startTime;
      continue;
    }
    time2 += end2 - start3;
  }
  return time2;
};
var createTimeRange = videojs.createTimeRange;
var segmentDurationWithParts = function segmentDurationWithParts2(playlist, segment) {
  if (!segment.preload) {
    return segment.duration;
  }
  var result = 0;
  (segment.parts || []).forEach(function(p2) {
    result += p2.duration;
  });
  (segment.preloadHints || []).forEach(function(p2) {
    if (p2.type === "PART") {
      result += playlist.partTargetDuration;
    }
  });
  return result;
};
var getPartsAndSegments = function getPartsAndSegments2(playlist) {
  return (playlist.segments || []).reduce(function(acc, segment, si2) {
    if (segment.parts) {
      segment.parts.forEach(function(part, pi2) {
        acc.push({
          duration: part.duration,
          segmentIndex: si2,
          partIndex: pi2,
          part,
          segment
        });
      });
    } else {
      acc.push({
        duration: segment.duration,
        segmentIndex: si2,
        partIndex: null,
        segment,
        part: null
      });
    }
    return acc;
  }, []);
};
var getLastParts = function getLastParts2(media) {
  var lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
  return lastSegment && lastSegment.parts || [];
};
var getKnownPartCount = function getKnownPartCount2(_ref) {
  var preloadSegment = _ref.preloadSegment;
  if (!preloadSegment) {
    return;
  }
  var parts = preloadSegment.parts, preloadHints = preloadSegment.preloadHints;
  var partCount = (preloadHints || []).reduce(function(count2, hint) {
    return count2 + (hint.type === "PART" ? 1 : 0);
  }, 0);
  partCount += parts && parts.length ? parts.length : 0;
  return partCount;
};
var liveEdgeDelay = function liveEdgeDelay2(master, media) {
  if (media.endList) {
    return 0;
  }
  if (master && master.suggestedPresentationDelay) {
    return master.suggestedPresentationDelay;
  }
  var hasParts = getLastParts(media).length > 0;
  if (hasParts && media.serverControl && media.serverControl.partHoldBack) {
    return media.serverControl.partHoldBack;
  } else if (hasParts && media.partTargetDuration) {
    return media.partTargetDuration * 3;
  } else if (media.serverControl && media.serverControl.holdBack) {
    return media.serverControl.holdBack;
  } else if (media.targetDuration) {
    return media.targetDuration * 3;
  }
  return 0;
};
var backwardDuration = function backwardDuration2(playlist, endSequence) {
  var result = 0;
  var i = endSequence - playlist.mediaSequence;
  var segment = playlist.segments[i];
  if (segment) {
    if (typeof segment.start !== "undefined") {
      return {
        result: segment.start,
        precise: true
      };
    }
    if (typeof segment.end !== "undefined") {
      return {
        result: segment.end - segment.duration,
        precise: true
      };
    }
  }
  while (i--) {
    segment = playlist.segments[i];
    if (typeof segment.end !== "undefined") {
      return {
        result: result + segment.end,
        precise: true
      };
    }
    result += segmentDurationWithParts(playlist, segment);
    if (typeof segment.start !== "undefined") {
      return {
        result: result + segment.start,
        precise: true
      };
    }
  }
  return {
    result,
    precise: false
  };
};
var forwardDuration = function forwardDuration2(playlist, endSequence) {
  var result = 0;
  var segment;
  var i = endSequence - playlist.mediaSequence;
  for (; i < playlist.segments.length; i++) {
    segment = playlist.segments[i];
    if (typeof segment.start !== "undefined") {
      return {
        result: segment.start - result,
        precise: true
      };
    }
    result += segmentDurationWithParts(playlist, segment);
    if (typeof segment.end !== "undefined") {
      return {
        result: segment.end - result,
        precise: true
      };
    }
  }
  return {
    result: -1,
    precise: false
  };
};
var intervalDuration = function intervalDuration2(playlist, endSequence, expired) {
  if (typeof endSequence === "undefined") {
    endSequence = playlist.mediaSequence + playlist.segments.length;
  }
  if (endSequence < playlist.mediaSequence) {
    return 0;
  }
  var backward = backwardDuration(playlist, endSequence);
  if (backward.precise) {
    return backward.result;
  }
  var forward = forwardDuration(playlist, endSequence);
  if (forward.precise) {
    return forward.result;
  }
  return backward.result + expired;
};
var duration$1 = function duration2(playlist, endSequence, expired) {
  if (!playlist) {
    return 0;
  }
  if (typeof expired !== "number") {
    expired = 0;
  }
  if (typeof endSequence === "undefined") {
    if (playlist.totalDuration) {
      return playlist.totalDuration;
    }
    if (!playlist.endList) {
      return window_1.Infinity;
    }
  }
  return intervalDuration(playlist, endSequence, expired);
};
var sumDurations = function sumDurations2(_ref2) {
  var defaultDuration = _ref2.defaultDuration, durationList = _ref2.durationList, startIndex = _ref2.startIndex, endIndex = _ref2.endIndex;
  var durations = 0;
  if (startIndex > endIndex) {
    var _ref3 = [endIndex, startIndex];
    startIndex = _ref3[0];
    endIndex = _ref3[1];
  }
  if (startIndex < 0) {
    for (var i = startIndex; i < Math.min(0, endIndex); i++) {
      durations += defaultDuration;
    }
    startIndex = 0;
  }
  for (var _i = startIndex; _i < endIndex; _i++) {
    durations += durationList[_i].duration;
  }
  return durations;
};
var playlistEnd = function playlistEnd2(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
  if (!playlist || !playlist.segments) {
    return null;
  }
  if (playlist.endList) {
    return duration$1(playlist);
  }
  if (expired === null) {
    return null;
  }
  expired = expired || 0;
  var lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
  if (useSafeLiveEnd) {
    liveEdgePadding = typeof liveEdgePadding === "number" ? liveEdgePadding : liveEdgeDelay(null, playlist);
    lastSegmentEndTime -= liveEdgePadding;
  }
  return Math.max(0, lastSegmentEndTime);
};
var seekable = function seekable2(playlist, expired, liveEdgePadding) {
  var useSafeLiveEnd = true;
  var seekableStart = expired || 0;
  var seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
  if (seekableEnd === null) {
    return createTimeRange();
  }
  return createTimeRange(seekableStart, seekableEnd);
};
var getMediaInfoForTime = function getMediaInfoForTime2(_ref4) {
  var playlist = _ref4.playlist, currentTime = _ref4.currentTime, startingSegmentIndex = _ref4.startingSegmentIndex, startingPartIndex = _ref4.startingPartIndex, startTime = _ref4.startTime, experimentalExactManifestTimings = _ref4.experimentalExactManifestTimings;
  var time2 = currentTime - startTime;
  var partsAndSegments = getPartsAndSegments(playlist);
  var startIndex = 0;
  for (var i = 0; i < partsAndSegments.length; i++) {
    var partAndSegment = partsAndSegments[i];
    if (startingSegmentIndex !== partAndSegment.segmentIndex) {
      continue;
    }
    if (typeof startingPartIndex === "number" && typeof partAndSegment.partIndex === "number" && startingPartIndex !== partAndSegment.partIndex) {
      continue;
    }
    startIndex = i;
    break;
  }
  if (time2 < 0) {
    if (startIndex > 0) {
      for (var _i2 = startIndex - 1; _i2 >= 0; _i2--) {
        var _partAndSegment = partsAndSegments[_i2];
        time2 += _partAndSegment.duration;
        if (experimentalExactManifestTimings) {
          if (time2 < 0) {
            continue;
          }
        } else if (time2 + TIME_FUDGE_FACTOR <= 0) {
          continue;
        }
        return {
          partIndex: _partAndSegment.partIndex,
          segmentIndex: _partAndSegment.segmentIndex,
          startTime: startTime - sumDurations({
            defaultDuration: playlist.targetDuration,
            durationList: partsAndSegments,
            startIndex,
            endIndex: _i2
          })
        };
      }
    }
    return {
      partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
      segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
      startTime: currentTime
    };
  }
  if (startIndex < 0) {
    for (var _i3 = startIndex; _i3 < 0; _i3++) {
      time2 -= playlist.targetDuration;
      if (time2 < 0) {
        return {
          partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
          segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
          startTime: currentTime
        };
      }
    }
    startIndex = 0;
  }
  for (var _i4 = startIndex; _i4 < partsAndSegments.length; _i4++) {
    var _partAndSegment2 = partsAndSegments[_i4];
    time2 -= _partAndSegment2.duration;
    if (experimentalExactManifestTimings) {
      if (time2 > 0) {
        continue;
      }
    } else if (time2 - TIME_FUDGE_FACTOR >= 0) {
      continue;
    }
    return {
      partIndex: _partAndSegment2.partIndex,
      segmentIndex: _partAndSegment2.segmentIndex,
      startTime: startTime + sumDurations({
        defaultDuration: playlist.targetDuration,
        durationList: partsAndSegments,
        startIndex,
        endIndex: _i4
      })
    };
  }
  return {
    segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
    partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
    startTime: currentTime
  };
};
var isBlacklisted = function isBlacklisted2(playlist) {
  return playlist.excludeUntil && playlist.excludeUntil > Date.now();
};
var isIncompatible = function isIncompatible2(playlist) {
  return playlist.excludeUntil && playlist.excludeUntil === Infinity;
};
var isEnabled = function isEnabled2(playlist) {
  var blacklisted = isBlacklisted(playlist);
  return !playlist.disabled && !blacklisted;
};
var isDisabled = function isDisabled2(playlist) {
  return playlist.disabled;
};
var isAes = function isAes2(media) {
  for (var i = 0; i < media.segments.length; i++) {
    if (media.segments[i].key) {
      return true;
    }
  }
  return false;
};
var hasAttribute = function hasAttribute2(attr, playlist) {
  return playlist.attributes && playlist.attributes[attr];
};
var estimateSegmentRequestTime = function estimateSegmentRequestTime2(segmentDuration, bandwidth2, playlist, bytesReceived) {
  if (bytesReceived === void 0) {
    bytesReceived = 0;
  }
  if (!hasAttribute("BANDWIDTH", playlist)) {
    return NaN;
  }
  var size = segmentDuration * playlist.attributes.BANDWIDTH;
  return (size - bytesReceived * 8) / bandwidth2;
};
var isLowestEnabledRendition = function isLowestEnabledRendition2(master, media) {
  if (master.playlists.length === 1) {
    return true;
  }
  var currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
  return master.playlists.filter(function(playlist) {
    if (!isEnabled(playlist)) {
      return false;
    }
    return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
  }).length === 0;
};
var playlistMatch = function playlistMatch2(a2, b2) {
  if (!a2 && !b2 || !a2 && b2 || a2 && !b2) {
    return false;
  }
  if (a2 === b2) {
    return true;
  }
  if (a2.id && b2.id && a2.id === b2.id) {
    return true;
  }
  if (a2.resolvedUri && b2.resolvedUri && a2.resolvedUri === b2.resolvedUri) {
    return true;
  }
  if (a2.uri && b2.uri && a2.uri === b2.uri) {
    return true;
  }
  return false;
};
var someAudioVariant = function someAudioVariant2(master, callback2) {
  var AUDIO5 = master && master.mediaGroups && master.mediaGroups.AUDIO || {};
  var found = false;
  for (var groupName in AUDIO5) {
    for (var label in AUDIO5[groupName]) {
      found = callback2(AUDIO5[groupName][label]);
      if (found) {
        break;
      }
    }
    if (found) {
      break;
    }
  }
  return !!found;
};
var isAudioOnly = function isAudioOnly2(master) {
  if (!master || !master.playlists || !master.playlists.length) {
    var found = someAudioVariant(master, function(variant) {
      return variant.playlists && variant.playlists.length || variant.uri;
    });
    return found;
  }
  var _loop = function _loop2(i2) {
    var playlist = master.playlists[i2];
    var CODECS = playlist.attributes && playlist.attributes.CODECS;
    if (CODECS && CODECS.split(",").every(function(c2) {
      return isAudioCodec(c2);
    })) {
      return "continue";
    }
    var found2 = someAudioVariant(master, function(variant) {
      return playlistMatch(playlist, variant);
    });
    if (found2) {
      return "continue";
    }
    return {
      v: false
    };
  };
  for (var i = 0; i < master.playlists.length; i++) {
    var _ret = _loop(i);
    if (_ret === "continue")
      continue;
    if (typeof _ret === "object")
      return _ret.v;
  }
  return true;
};
var Playlist2 = {
  liveEdgeDelay,
  duration: duration$1,
  seekable,
  getMediaInfoForTime,
  isEnabled,
  isDisabled,
  isBlacklisted,
  isIncompatible,
  playlistEnd,
  isAes,
  hasAttribute,
  estimateSegmentRequestTime,
  isLowestEnabledRendition,
  isAudioOnly,
  playlistMatch,
  segmentDurationWithParts
};
var log$2 = videojs.log;
var createPlaylistID = function createPlaylistID2(index2, uri) {
  return index2 + "-" + uri;
};
var parseManifest = function parseManifest2(_ref) {
  var onwarn = _ref.onwarn, oninfo = _ref.oninfo, manifestString = _ref.manifestString, _ref$customTagParsers = _ref.customTagParsers, customTagParsers = _ref$customTagParsers === void 0 ? [] : _ref$customTagParsers, _ref$customTagMappers = _ref.customTagMappers, customTagMappers = _ref$customTagMappers === void 0 ? [] : _ref$customTagMappers, experimentalLLHLS = _ref.experimentalLLHLS;
  var parser2 = new Parser();
  if (onwarn) {
    parser2.on("warn", onwarn);
  }
  if (oninfo) {
    parser2.on("info", oninfo);
  }
  customTagParsers.forEach(function(customParser) {
    return parser2.addParser(customParser);
  });
  customTagMappers.forEach(function(mapper) {
    return parser2.addTagMapper(mapper);
  });
  parser2.push(manifestString);
  parser2.end();
  var manifest = parser2.manifest;
  if (!experimentalLLHLS) {
    ["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function(k2) {
      if (manifest.hasOwnProperty(k2)) {
        delete manifest[k2];
      }
    });
    if (manifest.segments) {
      manifest.segments.forEach(function(segment) {
        ["parts", "preloadHints"].forEach(function(k2) {
          if (segment.hasOwnProperty(k2)) {
            delete segment[k2];
          }
        });
      });
    }
  }
  if (!manifest.targetDuration) {
    var targetDuration = 10;
    if (manifest.segments && manifest.segments.length) {
      targetDuration = manifest.segments.reduce(function(acc, s) {
        return Math.max(acc, s.duration);
      }, 0);
    }
    if (onwarn) {
      onwarn("manifest has no targetDuration defaulting to " + targetDuration);
    }
    manifest.targetDuration = targetDuration;
  }
  var parts = getLastParts(manifest);
  if (parts.length && !manifest.partTargetDuration) {
    var partTargetDuration = parts.reduce(function(acc, p2) {
      return Math.max(acc, p2.duration);
    }, 0);
    if (onwarn) {
      onwarn("manifest has no partTargetDuration defaulting to " + partTargetDuration);
      log$2.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.");
    }
    manifest.partTargetDuration = partTargetDuration;
  }
  return manifest;
};
var forEachMediaGroup2 = function forEachMediaGroup3(master, callback2) {
  if (!master.mediaGroups) {
    return;
  }
  ["AUDIO", "SUBTITLES"].forEach(function(mediaType) {
    if (!master.mediaGroups[mediaType]) {
      return;
    }
    for (var groupKey in master.mediaGroups[mediaType]) {
      for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
        var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
        callback2(mediaProperties, mediaType, groupKey, labelKey);
      }
    }
  });
};
var setupMediaPlaylist = function setupMediaPlaylist2(_ref2) {
  var playlist = _ref2.playlist, uri = _ref2.uri, id2 = _ref2.id;
  playlist.id = id2;
  playlist.playlistErrors_ = 0;
  if (uri) {
    playlist.uri = uri;
  }
  playlist.attributes = playlist.attributes || {};
};
var setupMediaPlaylists = function setupMediaPlaylists2(master) {
  var i = master.playlists.length;
  while (i--) {
    var playlist = master.playlists[i];
    setupMediaPlaylist({
      playlist,
      id: createPlaylistID(i, playlist.uri)
    });
    playlist.resolvedUri = resolveUrl2(master.uri, playlist.uri);
    master.playlists[playlist.id] = playlist;
    master.playlists[playlist.uri] = playlist;
    if (!playlist.attributes.BANDWIDTH) {
      log$2.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
    }
  }
};
var resolveMediaGroupUris = function resolveMediaGroupUris2(master) {
  forEachMediaGroup2(master, function(properties2) {
    if (properties2.uri) {
      properties2.resolvedUri = resolveUrl2(master.uri, properties2.uri);
    }
  });
};
var masterForMedia = function masterForMedia2(media, uri) {
  var id2 = createPlaylistID(0, uri);
  var master = {
    mediaGroups: {
      "AUDIO": {},
      "VIDEO": {},
      "CLOSED-CAPTIONS": {},
      "SUBTITLES": {}
    },
    uri: window_1.location.href,
    resolvedUri: window_1.location.href,
    playlists: [{
      uri,
      id: id2,
      resolvedUri: uri,
      // m3u8-parser does not attach an attributes property to media playlists so make
      // sure that the property is attached to avoid undefined reference errors
      attributes: {}
    }]
  };
  master.playlists[id2] = master.playlists[0];
  master.playlists[uri] = master.playlists[0];
  return master;
};
var addPropertiesToMaster = function addPropertiesToMaster2(master, uri) {
  master.uri = uri;
  for (var i = 0; i < master.playlists.length; i++) {
    if (!master.playlists[i].uri) {
      var phonyUri = "placeholder-uri-" + i;
      master.playlists[i].uri = phonyUri;
    }
  }
  var audioOnlyMaster = isAudioOnly(master);
  forEachMediaGroup2(master, function(properties2, mediaType, groupKey, labelKey) {
    var groupId = "placeholder-uri-" + mediaType + "-" + groupKey + "-" + labelKey;
    if (!properties2.playlists || !properties2.playlists.length) {
      if (audioOnlyMaster && mediaType === "AUDIO" && !properties2.uri) {
        for (var _i = 0; _i < master.playlists.length; _i++) {
          var p2 = master.playlists[_i];
          if (p2.attributes && p2.attributes.AUDIO && p2.attributes.AUDIO === groupKey) {
            return;
          }
        }
      }
      properties2.playlists = [_extends$8({}, properties2)];
    }
    properties2.playlists.forEach(function(p3, i2) {
      var id2 = createPlaylistID(i2, groupId);
      if (p3.uri) {
        p3.resolvedUri = p3.resolvedUri || resolveUrl2(master.uri, p3.uri);
      } else {
        p3.uri = i2 === 0 ? groupId : id2;
        p3.resolvedUri = p3.uri;
      }
      p3.id = p3.id || id2;
      p3.attributes = p3.attributes || {};
      master.playlists[p3.id] = p3;
      master.playlists[p3.uri] = p3;
    });
  });
  setupMediaPlaylists(master);
  resolveMediaGroupUris(master);
};
var mergeOptions$2 = videojs.mergeOptions, EventTarget$1 = videojs.EventTarget;
var addLLHLSQueryDirectives = function addLLHLSQueryDirectives2(uri, media) {
  if (media.endList || !media.serverControl) {
    return uri;
  }
  var parameters = {};
  if (media.serverControl.canBlockReload) {
    var preloadSegment = media.preloadSegment;
    var nextMSN = media.mediaSequence + media.segments.length;
    if (preloadSegment) {
      var parts = preloadSegment.parts || [];
      var nextPart = getKnownPartCount(media) - 1;
      if (nextPart > -1 && nextPart !== parts.length - 1) {
        parameters._HLS_part = nextPart;
      }
      if (nextPart > -1 || parts.length) {
        nextMSN--;
      }
    }
    parameters._HLS_msn = nextMSN;
  }
  if (media.serverControl && media.serverControl.canSkipUntil) {
    parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES";
  }
  if (Object.keys(parameters).length) {
    var parsedUri = new window_1.URL(uri);
    ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function(name) {
      if (!parameters.hasOwnProperty(name)) {
        return;
      }
      parsedUri.searchParams.set(name, parameters[name]);
    });
    uri = parsedUri.toString();
  }
  return uri;
};
var updateSegment = function updateSegment2(a2, b2) {
  if (!a2) {
    return b2;
  }
  var result = mergeOptions$2(a2, b2);
  if (a2.preloadHints && !b2.preloadHints) {
    delete result.preloadHints;
  }
  if (a2.parts && !b2.parts) {
    delete result.parts;
  } else if (a2.parts && b2.parts) {
    for (var i = 0; i < b2.parts.length; i++) {
      if (a2.parts && a2.parts[i]) {
        result.parts[i] = mergeOptions$2(a2.parts[i], b2.parts[i]);
      }
    }
  }
  if (!a2.skipped && b2.skipped) {
    result.skipped = false;
  }
  if (a2.preload && !b2.preload) {
    result.preload = false;
  }
  return result;
};
var updateSegments = function updateSegments2(original, update2, offset3) {
  var oldSegments = original.slice();
  var newSegments = update2.slice();
  offset3 = offset3 || 0;
  var result = [];
  var currentMap;
  for (var newIndex = 0; newIndex < newSegments.length; newIndex++) {
    var oldSegment = oldSegments[newIndex + offset3];
    var newSegment = newSegments[newIndex];
    if (oldSegment) {
      currentMap = oldSegment.map || currentMap;
      result.push(updateSegment(oldSegment, newSegment));
    } else {
      if (currentMap && !newSegment.map) {
        newSegment.map = currentMap;
      }
      result.push(newSegment);
    }
  }
  return result;
};
var resolveSegmentUris = function resolveSegmentUris2(segment, baseUri) {
  if (!segment.resolvedUri && segment.uri) {
    segment.resolvedUri = resolveUrl2(baseUri, segment.uri);
  }
  if (segment.key && !segment.key.resolvedUri) {
    segment.key.resolvedUri = resolveUrl2(baseUri, segment.key.uri);
  }
  if (segment.map && !segment.map.resolvedUri) {
    segment.map.resolvedUri = resolveUrl2(baseUri, segment.map.uri);
  }
  if (segment.map && segment.map.key && !segment.map.key.resolvedUri) {
    segment.map.key.resolvedUri = resolveUrl2(baseUri, segment.map.key.uri);
  }
  if (segment.parts && segment.parts.length) {
    segment.parts.forEach(function(p2) {
      if (p2.resolvedUri) {
        return;
      }
      p2.resolvedUri = resolveUrl2(baseUri, p2.uri);
    });
  }
  if (segment.preloadHints && segment.preloadHints.length) {
    segment.preloadHints.forEach(function(p2) {
      if (p2.resolvedUri) {
        return;
      }
      p2.resolvedUri = resolveUrl2(baseUri, p2.uri);
    });
  }
};
var getAllSegments = function getAllSegments2(media) {
  var segments = media.segments || [];
  var preloadSegment = media.preloadSegment;
  if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
    if (preloadSegment.preloadHints) {
      for (var i = 0; i < preloadSegment.preloadHints.length; i++) {
        if (preloadSegment.preloadHints[i].type === "MAP") {
          return segments;
        }
      }
    }
    preloadSegment.duration = media.targetDuration;
    preloadSegment.preload = true;
    segments.push(preloadSegment);
  }
  return segments;
};
var isPlaylistUnchanged = function isPlaylistUnchanged2(a2, b2) {
  return a2 === b2 || a2.segments && b2.segments && a2.segments.length === b2.segments.length && a2.endList === b2.endList && a2.mediaSequence === b2.mediaSequence && a2.preloadSegment === b2.preloadSegment;
};
var updateMaster$1 = function updateMaster(master, newMedia, unchangedCheck) {
  if (unchangedCheck === void 0) {
    unchangedCheck = isPlaylistUnchanged;
  }
  var result = mergeOptions$2(master, {});
  var oldMedia = result.playlists[newMedia.id];
  if (!oldMedia) {
    return null;
  }
  if (unchangedCheck(oldMedia, newMedia)) {
    return null;
  }
  newMedia.segments = getAllSegments(newMedia);
  var mergedPlaylist = mergeOptions$2(oldMedia, newMedia);
  if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) {
    delete mergedPlaylist.preloadSegment;
  }
  if (oldMedia.segments) {
    if (newMedia.skip) {
      newMedia.segments = newMedia.segments || [];
      for (var i = 0; i < newMedia.skip.skippedSegments; i++) {
        newMedia.segments.unshift({
          skipped: true
        });
      }
    }
    mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
  }
  mergedPlaylist.segments.forEach(function(segment) {
    resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
  });
  for (var _i = 0; _i < result.playlists.length; _i++) {
    if (result.playlists[_i].id === newMedia.id) {
      result.playlists[_i] = mergedPlaylist;
    }
  }
  result.playlists[newMedia.id] = mergedPlaylist;
  result.playlists[newMedia.uri] = mergedPlaylist;
  forEachMediaGroup2(master, function(properties2, mediaType, groupKey, labelKey) {
    if (!properties2.playlists) {
      return;
    }
    for (var _i2 = 0; _i2 < properties2.playlists.length; _i2++) {
      if (newMedia.id === properties2.playlists[_i2].id) {
        properties2.playlists[_i2] = mergedPlaylist;
      }
    }
  });
  return result;
};
var refreshDelay = function refreshDelay2(media, update2) {
  var segments = media.segments || [];
  var lastSegment = segments[segments.length - 1];
  var lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
  var lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
  if (update2 && lastDuration) {
    return lastDuration * 1e3;
  }
  return (media.partTargetDuration || media.targetDuration || 10) * 500;
};
var PlaylistLoader = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(PlaylistLoader2, _EventTarget);
  function PlaylistLoader2(src, vhs, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    if (!src) {
      throw new Error("A non-empty playlist URL or object is required");
    }
    _this.logger_ = logger("PlaylistLoader");
    var _options = options, _options$withCredenti = _options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti, _options$handleManife = _options.handleManifestRedirects, handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
    _this.src = src;
    _this.vhs_ = vhs;
    _this.withCredentials = withCredentials;
    _this.handleManifestRedirects = handleManifestRedirects;
    var vhsOptions = vhs.options_;
    _this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
    _this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
    _this.experimentalLLHLS = vhsOptions && vhsOptions.experimentalLLHLS || false;
    if (videojs.browser.IE_VERSION) {
      _this.experimentalLLHLS = false;
    }
    _this.state = "HAVE_NOTHING";
    _this.handleMediaupdatetimeout_ = _this.handleMediaupdatetimeout_.bind(_assertThisInitialized(_this));
    _this.on("mediaupdatetimeout", _this.handleMediaupdatetimeout_);
    return _this;
  }
  var _proto = PlaylistLoader2.prototype;
  _proto.handleMediaupdatetimeout_ = function handleMediaupdatetimeout_() {
    var _this2 = this;
    if (this.state !== "HAVE_METADATA") {
      return;
    }
    var media = this.media();
    var uri = resolveUrl2(this.master.uri, media.uri);
    if (this.experimentalLLHLS) {
      uri = addLLHLSQueryDirectives(uri, media);
    }
    this.state = "HAVE_CURRENT_METADATA";
    this.request = this.vhs_.xhr({
      uri,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this2.request) {
        return;
      }
      if (error) {
        return _this2.playlistRequestError(_this2.request, _this2.media(), "HAVE_METADATA");
      }
      _this2.haveMetadata({
        playlistString: _this2.request.responseText,
        url: _this2.media().uri,
        id: _this2.media().id
      });
    });
  };
  _proto.playlistRequestError = function playlistRequestError(xhr, playlist, startingState) {
    var uri = playlist.uri, id2 = playlist.id;
    this.request = null;
    if (startingState) {
      this.state = startingState;
    }
    this.error = {
      playlist: this.master.playlists[id2],
      status: xhr.status,
      message: "HLS playlist request error at URL: " + uri + ".",
      responseText: xhr.responseText,
      code: xhr.status >= 500 ? 4 : 2
    };
    this.trigger("error");
  };
  _proto.parseManifest_ = function parseManifest_(_ref) {
    var _this3 = this;
    var url = _ref.url, manifestString = _ref.manifestString;
    return parseManifest({
      onwarn: function onwarn(_ref2) {
        var message = _ref2.message;
        return _this3.logger_("m3u8-parser warn for " + url + ": " + message);
      },
      oninfo: function oninfo(_ref3) {
        var message = _ref3.message;
        return _this3.logger_("m3u8-parser info for " + url + ": " + message);
      },
      manifestString,
      customTagParsers: this.customTagParsers,
      customTagMappers: this.customTagMappers,
      experimentalLLHLS: this.experimentalLLHLS
    });
  };
  _proto.haveMetadata = function haveMetadata(_ref4) {
    var playlistString = _ref4.playlistString, playlistObject = _ref4.playlistObject, url = _ref4.url, id2 = _ref4.id;
    this.request = null;
    this.state = "HAVE_METADATA";
    var playlist = playlistObject || this.parseManifest_({
      url,
      manifestString: playlistString
    });
    playlist.lastRequest = Date.now();
    setupMediaPlaylist({
      playlist,
      uri: url,
      id: id2
    });
    var update2 = updateMaster$1(this.master, playlist);
    this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
    this.pendingMedia_ = null;
    if (update2) {
      this.master = update2;
      this.media_ = this.master.playlists[id2];
    } else {
      this.trigger("playlistunchanged");
    }
    this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update2));
    this.trigger("loadedplaylist");
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.stopRequest();
    window_1.clearTimeout(this.mediaUpdateTimeout);
    window_1.clearTimeout(this.finalRenditionTimeout);
    this.off();
  };
  _proto.stopRequest = function stopRequest() {
    if (this.request) {
      var oldRequest = this.request;
      this.request = null;
      oldRequest.onreadystatechange = null;
      oldRequest.abort();
    }
  };
  _proto.media = function media(playlist, shouldDelay) {
    var _this4 = this;
    if (!playlist) {
      return this.media_;
    }
    if (this.state === "HAVE_NOTHING") {
      throw new Error("Cannot switch media playlist from " + this.state);
    }
    if (typeof playlist === "string") {
      if (!this.master.playlists[playlist]) {
        throw new Error("Unknown playlist URI: " + playlist);
      }
      playlist = this.master.playlists[playlist];
    }
    window_1.clearTimeout(this.finalRenditionTimeout);
    if (shouldDelay) {
      var delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1e3 || 5 * 1e3;
      this.finalRenditionTimeout = window_1.setTimeout(this.media.bind(this, playlist, false), delay);
      return;
    }
    var startingState = this.state;
    var mediaChange = !this.media_ || playlist.id !== this.media_.id;
    var masterPlaylistRef = this.master.playlists[playlist.id];
    if (masterPlaylistRef && masterPlaylistRef.endList || // handle the case of a playlist object (e.g., if using vhs-json with a resolved
    // media playlist or, for the case of demuxed audio, a resolved audio media group)
    playlist.endList && playlist.segments.length) {
      if (this.request) {
        this.request.onreadystatechange = null;
        this.request.abort();
        this.request = null;
      }
      this.state = "HAVE_METADATA";
      this.media_ = playlist;
      if (mediaChange) {
        this.trigger("mediachanging");
        if (startingState === "HAVE_MASTER") {
          this.trigger("loadedmetadata");
        } else {
          this.trigger("mediachange");
        }
      }
      return;
    }
    this.updateMediaUpdateTimeout_(refreshDelay(playlist, true));
    if (!mediaChange) {
      return;
    }
    this.state = "SWITCHING_MEDIA";
    if (this.request) {
      if (playlist.resolvedUri === this.request.url) {
        return;
      }
      this.request.onreadystatechange = null;
      this.request.abort();
      this.request = null;
    }
    if (this.media_) {
      this.trigger("mediachanging");
    }
    this.pendingMedia_ = playlist;
    this.request = this.vhs_.xhr({
      uri: playlist.resolvedUri,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this4.request) {
        return;
      }
      playlist.lastRequest = Date.now();
      playlist.resolvedUri = resolveManifestRedirect(_this4.handleManifestRedirects, playlist.resolvedUri, req);
      if (error) {
        return _this4.playlistRequestError(_this4.request, playlist, startingState);
      }
      _this4.haveMetadata({
        playlistString: req.responseText,
        url: playlist.uri,
        id: playlist.id
      });
      if (startingState === "HAVE_MASTER") {
        _this4.trigger("loadedmetadata");
      } else {
        _this4.trigger("mediachange");
      }
    });
  };
  _proto.pause = function pause() {
    if (this.mediaUpdateTimeout) {
      window_1.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    this.stopRequest();
    if (this.state === "HAVE_NOTHING") {
      this.started = false;
    }
    if (this.state === "SWITCHING_MEDIA") {
      if (this.media_) {
        this.state = "HAVE_METADATA";
      } else {
        this.state = "HAVE_MASTER";
      }
    } else if (this.state === "HAVE_CURRENT_METADATA") {
      this.state = "HAVE_METADATA";
    }
  };
  _proto.load = function load(shouldDelay) {
    var _this5 = this;
    if (this.mediaUpdateTimeout) {
      window_1.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    var media = this.media();
    if (shouldDelay) {
      var delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1e3 : 5 * 1e3;
      this.mediaUpdateTimeout = window_1.setTimeout(function() {
        _this5.mediaUpdateTimeout = null;
        _this5.load();
      }, delay);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    if (media && !media.endList) {
      this.trigger("mediaupdatetimeout");
    } else {
      this.trigger("loadedplaylist");
    }
  };
  _proto.updateMediaUpdateTimeout_ = function updateMediaUpdateTimeout_(delay) {
    var _this6 = this;
    if (this.mediaUpdateTimeout) {
      window_1.clearTimeout(this.mediaUpdateTimeout);
      this.mediaUpdateTimeout = null;
    }
    if (!this.media() || this.media().endList) {
      return;
    }
    this.mediaUpdateTimeout = window_1.setTimeout(function() {
      _this6.mediaUpdateTimeout = null;
      _this6.trigger("mediaupdatetimeout");
      _this6.updateMediaUpdateTimeout_(delay);
    }, delay);
  };
  _proto.start = function start3() {
    var _this7 = this;
    this.started = true;
    if (typeof this.src === "object") {
      if (!this.src.uri) {
        this.src.uri = window_1.location.href;
      }
      this.src.resolvedUri = this.src.uri;
      setTimeout(function() {
        _this7.setupInitialPlaylist(_this7.src);
      }, 0);
      return;
    }
    this.request = this.vhs_.xhr({
      uri: this.src,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this7.request) {
        return;
      }
      _this7.request = null;
      if (error) {
        _this7.error = {
          status: req.status,
          message: "HLS playlist request error at URL: " + _this7.src + ".",
          responseText: req.responseText,
          // MEDIA_ERR_NETWORK
          code: 2
        };
        if (_this7.state === "HAVE_NOTHING") {
          _this7.started = false;
        }
        return _this7.trigger("error");
      }
      _this7.src = resolveManifestRedirect(_this7.handleManifestRedirects, _this7.src, req);
      var manifest = _this7.parseManifest_({
        manifestString: req.responseText,
        url: _this7.src
      });
      _this7.setupInitialPlaylist(manifest);
    });
  };
  _proto.srcUri = function srcUri() {
    return typeof this.src === "string" ? this.src : this.src.uri;
  };
  _proto.setupInitialPlaylist = function setupInitialPlaylist(manifest) {
    this.state = "HAVE_MASTER";
    if (manifest.playlists) {
      this.master = manifest;
      addPropertiesToMaster(this.master, this.srcUri());
      manifest.playlists.forEach(function(playlist) {
        playlist.segments = getAllSegments(playlist);
        playlist.segments.forEach(function(segment) {
          resolveSegmentUris(segment, playlist.resolvedUri);
        });
      });
      this.trigger("loadedplaylist");
      if (!this.request) {
        this.media(this.master.playlists[0]);
      }
      return;
    }
    var uri = this.srcUri() || window_1.location.href;
    this.master = masterForMedia(manifest, uri);
    this.haveMetadata({
      playlistObject: manifest,
      url: uri,
      id: this.master.playlists[0].id
    });
    this.trigger("loadedmetadata");
  };
  return PlaylistLoader2;
}(EventTarget$1);
var videojsXHR = videojs.xhr, mergeOptions$1 = videojs.mergeOptions;
var callbackWrapper = function callbackWrapper2(request2, error, response, callback2) {
  var reqResponse = request2.responseType === "arraybuffer" ? request2.response : request2.responseText;
  if (!error && reqResponse) {
    request2.responseTime = Date.now();
    request2.roundTripTime = request2.responseTime - request2.requestTime;
    request2.bytesReceived = reqResponse.byteLength || reqResponse.length;
    if (!request2.bandwidth) {
      request2.bandwidth = Math.floor(request2.bytesReceived / request2.roundTripTime * 8 * 1e3);
    }
  }
  if (response.headers) {
    request2.responseHeaders = response.headers;
  }
  if (error && error.code === "ETIMEDOUT") {
    request2.timedout = true;
  }
  if (!error && !request2.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) {
    error = new Error("XHR Failed with a response of: " + (request2 && (reqResponse || request2.responseText)));
  }
  callback2(error, request2);
};
var xhrFactory = function xhrFactory2() {
  var xhr = function XhrFunction(options, callback2) {
    options = mergeOptions$1({
      timeout: 45e3
    }, options);
    var beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;
    if (beforeRequest && typeof beforeRequest === "function") {
      var newOptions = beforeRequest(options);
      if (newOptions) {
        options = newOptions;
      }
    }
    var xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;
    var request2 = xhrMethod(options, function(error, response) {
      return callbackWrapper(request2, error, response, callback2);
    });
    var originalAbort = request2.abort;
    request2.abort = function() {
      request2.aborted = true;
      return originalAbort.apply(request2, arguments);
    };
    request2.uri = options.uri;
    request2.requestTime = Date.now();
    return request2;
  };
  xhr.original = true;
  return xhr;
};
var byterangeStr = function byterangeStr2(byterange) {
  var byterangeEnd;
  var byterangeStart = byterange.offset;
  if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") {
    byterangeEnd = window_1.BigInt(byterange.offset) + window_1.BigInt(byterange.length) - window_1.BigInt(1);
  } else {
    byterangeEnd = byterange.offset + byterange.length - 1;
  }
  return "bytes=" + byterangeStart + "-" + byterangeEnd;
};
var segmentXhrHeaders = function segmentXhrHeaders2(segment) {
  var headers = {};
  if (segment.byterange) {
    headers.Range = byterangeStr(segment.byterange);
  }
  return headers;
};
var textRange = function textRange2(range3, i) {
  return range3.start(i) + "-" + range3.end(i);
};
var formatHexString = function formatHexString2(e2, i) {
  var value = e2.toString(16);
  return "00".substring(0, 2 - value.length) + value + (i % 2 ? " " : "");
};
var formatAsciiString = function formatAsciiString2(e2) {
  if (e2 >= 32 && e2 < 126) {
    return String.fromCharCode(e2);
  }
  return ".";
};
var createTransferableMessage = function createTransferableMessage2(message) {
  var transferable = {};
  Object.keys(message).forEach(function(key) {
    var value = message[key];
    if (isArrayBufferView(value)) {
      transferable[key] = {
        bytes: value.buffer,
        byteOffset: value.byteOffset,
        byteLength: value.byteLength
      };
    } else {
      transferable[key] = value;
    }
  });
  return transferable;
};
var initSegmentId = function initSegmentId2(initSegment) {
  var byterange = initSegment.byterange || {
    length: Infinity,
    offset: 0
  };
  return [byterange.length, byterange.offset, initSegment.resolvedUri].join(",");
};
var segmentKeyId = function segmentKeyId2(key) {
  return key.resolvedUri;
};
var hexDump = function hexDump2(data) {
  var bytes = Array.prototype.slice.call(data);
  var step = 16;
  var result = "";
  var hex;
  var ascii;
  for (var j2 = 0; j2 < bytes.length / step; j2++) {
    hex = bytes.slice(j2 * step, j2 * step + step).map(formatHexString).join("");
    ascii = bytes.slice(j2 * step, j2 * step + step).map(formatAsciiString).join("");
    result += hex + " " + ascii + "\n";
  }
  return result;
};
var tagDump = function tagDump2(_ref) {
  var bytes = _ref.bytes;
  return hexDump(bytes);
};
var textRanges = function textRanges2(ranges) {
  var result = "";
  var i;
  for (i = 0; i < ranges.length; i++) {
    result += textRange(ranges, i) + " ";
  }
  return result;
};
var utils$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createTransferableMessage,
  initSegmentId,
  segmentKeyId,
  hexDump,
  tagDump,
  textRanges
});
var SEGMENT_END_FUDGE_PERCENT = 0.25;
var playerTimeToProgramTime = function playerTimeToProgramTime2(playerTime, segment) {
  if (!segment.dateTimeObject) {
    return null;
  }
  var transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
  var transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
  var startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
  var offsetFromSegmentStart = playerTime - startOfSegment;
  return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1e3);
};
var originalSegmentVideoDuration = function originalSegmentVideoDuration2(videoTimingInfo) {
  return videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
};
var findSegmentForProgramTime = function findSegmentForProgramTime2(programTime, playlist) {
  var dateTimeObject;
  try {
    dateTimeObject = new Date(programTime);
  } catch (e2) {
    return null;
  }
  if (!playlist || !playlist.segments || playlist.segments.length === 0) {
    return null;
  }
  var segment = playlist.segments[0];
  if (dateTimeObject < segment.dateTimeObject) {
    return null;
  }
  for (var i = 0; i < playlist.segments.length - 1; i++) {
    segment = playlist.segments[i];
    var nextSegmentStart = playlist.segments[i + 1].dateTimeObject;
    if (dateTimeObject < nextSegmentStart) {
      break;
    }
  }
  var lastSegment = playlist.segments[playlist.segments.length - 1];
  var lastSegmentStart = lastSegment.dateTimeObject;
  var lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;
  var lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1e3);
  if (dateTimeObject > lastSegmentEnd) {
    return null;
  }
  if (dateTimeObject > lastSegmentStart) {
    segment = lastSegment;
  }
  return {
    segment,
    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist2.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
    // Although, given that all segments have accurate date time objects, the segment
    // selected should be accurate, unless the video has been transmuxed at some point
    // (determined by the presence of the videoTimingInfo object), the segment's "player
    // time" (the start time in the player) can't be considered accurate.
    type: segment.videoTimingInfo ? "accurate" : "estimate"
  };
};
var findSegmentForPlayerTime = function findSegmentForPlayerTime2(time2, playlist) {
  if (!playlist || !playlist.segments || playlist.segments.length === 0) {
    return null;
  }
  var segmentEnd = 0;
  var segment;
  for (var i = 0; i < playlist.segments.length; i++) {
    segment = playlist.segments[i];
    segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
    if (time2 <= segmentEnd) {
      break;
    }
  }
  var lastSegment = playlist.segments[playlist.segments.length - 1];
  if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time2) {
    return null;
  }
  if (time2 > segmentEnd) {
    if (time2 > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) {
      return null;
    }
    segment = lastSegment;
  }
  return {
    segment,
    estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
    // Because videoTimingInfo is only set after transmux, it is the only way to get
    // accurate timing values.
    type: segment.videoTimingInfo ? "accurate" : "estimate"
  };
};
var getOffsetFromTimestamp = function getOffsetFromTimestamp2(comparisonTimeStamp, programTime) {
  var segmentDateTime;
  var programDateTime;
  try {
    segmentDateTime = new Date(comparisonTimeStamp);
    programDateTime = new Date(programTime);
  } catch (e2) {
  }
  var segmentTimeEpoch = segmentDateTime.getTime();
  var programTimeEpoch = programDateTime.getTime();
  return (programTimeEpoch - segmentTimeEpoch) / 1e3;
};
var verifyProgramDateTimeTags = function verifyProgramDateTimeTags2(playlist) {
  if (!playlist.segments || playlist.segments.length === 0) {
    return false;
  }
  for (var i = 0; i < playlist.segments.length; i++) {
    var segment = playlist.segments[i];
    if (!segment.dateTimeObject) {
      return false;
    }
  }
  return true;
};
var getProgramTime = function getProgramTime2(_ref) {
  var playlist = _ref.playlist, _ref$time = _ref.time, time2 = _ref$time === void 0 ? void 0 : _ref$time, callback2 = _ref.callback;
  if (!callback2) {
    throw new Error("getProgramTime: callback must be provided");
  }
  if (!playlist || time2 === void 0) {
    return callback2({
      message: "getProgramTime: playlist and time must be provided"
    });
  }
  var matchedSegment = findSegmentForPlayerTime(time2, playlist);
  if (!matchedSegment) {
    return callback2({
      message: "valid programTime was not found"
    });
  }
  if (matchedSegment.type === "estimate") {
    return callback2({
      message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
      seekTime: matchedSegment.estimatedStart
    });
  }
  var programTimeObject = {
    mediaSeconds: time2
  };
  var programTime = playerTimeToProgramTime(time2, matchedSegment.segment);
  if (programTime) {
    programTimeObject.programDateTime = programTime.toISOString();
  }
  return callback2(null, programTimeObject);
};
var seekToProgramTime = function seekToProgramTime2(_ref2) {
  var programTime = _ref2.programTime, playlist = _ref2.playlist, _ref2$retryCount = _ref2.retryCount, retryCount = _ref2$retryCount === void 0 ? 2 : _ref2$retryCount, seekTo = _ref2.seekTo, _ref2$pauseAfterSeek = _ref2.pauseAfterSeek, pauseAfterSeek = _ref2$pauseAfterSeek === void 0 ? true : _ref2$pauseAfterSeek, tech = _ref2.tech, callback2 = _ref2.callback;
  if (!callback2) {
    throw new Error("seekToProgramTime: callback must be provided");
  }
  if (typeof programTime === "undefined" || !playlist || !seekTo) {
    return callback2({
      message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
    });
  }
  if (!playlist.endList && !tech.hasStarted_) {
    return callback2({
      message: "player must be playing a live stream to start buffering"
    });
  }
  if (!verifyProgramDateTimeTags(playlist)) {
    return callback2({
      message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
    });
  }
  var matchedSegment = findSegmentForProgramTime(programTime, playlist);
  if (!matchedSegment) {
    return callback2({
      message: programTime + " was not found in the stream"
    });
  }
  var segment = matchedSegment.segment;
  var mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
  if (matchedSegment.type === "estimate") {
    if (retryCount === 0) {
      return callback2({
        message: programTime + " is not buffered yet. Try again"
      });
    }
    seekTo(matchedSegment.estimatedStart + mediaOffset);
    tech.one("seeked", function() {
      seekToProgramTime2({
        programTime,
        playlist,
        retryCount: retryCount - 1,
        seekTo,
        pauseAfterSeek,
        tech,
        callback: callback2
      });
    });
    return;
  }
  var seekToTime = segment.start + mediaOffset;
  var seekedCallback = function seekedCallback2() {
    return callback2(null, tech.currentTime());
  };
  tech.one("seeked", seekedCallback);
  if (pauseAfterSeek) {
    tech.pause();
  }
  seekTo(seekToTime);
};
var callbackOnCompleted = function callbackOnCompleted2(request2, cb2) {
  if (request2.readyState === 4) {
    return cb2();
  }
  return;
};
var containerRequest = function containerRequest2(uri, xhr, cb2) {
  var bytes = [];
  var id3Offset;
  var finished = false;
  var endRequestAndCallback = function endRequestAndCallback2(err, req, type2, _bytes) {
    req.abort();
    finished = true;
    return cb2(err, req, type2, _bytes);
  };
  var progressListener = function progressListener2(error, request3) {
    if (finished) {
      return;
    }
    if (error) {
      return endRequestAndCallback(error, request3, "", bytes);
    }
    var newPart = request3.responseText.substring(bytes && bytes.byteLength || 0, request3.responseText.length);
    bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));
    id3Offset = id3Offset || getId3Offset(bytes);
    if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) {
      return callbackOnCompleted(request3, function() {
        return endRequestAndCallback(error, request3, "", bytes);
      });
    }
    var type2 = detectContainerForBytes(bytes);
    if (type2 === "ts" && bytes.length < 188) {
      return callbackOnCompleted(request3, function() {
        return endRequestAndCallback(error, request3, "", bytes);
      });
    }
    if (!type2 && bytes.length < 376) {
      return callbackOnCompleted(request3, function() {
        return endRequestAndCallback(error, request3, "", bytes);
      });
    }
    return endRequestAndCallback(null, request3, type2, bytes);
  };
  var options = {
    uri,
    beforeSend: function beforeSend(request3) {
      request3.overrideMimeType("text/plain; charset=x-user-defined");
      request3.addEventListener("progress", function(_ref) {
        _ref.total;
        _ref.loaded;
        return callbackWrapper(request3, null, {
          statusCode: request3.status
        }, progressListener);
      });
    }
  };
  var request2 = xhr(options, function(error, response) {
    return callbackWrapper(request2, error, response, progressListener);
  });
  return request2;
};
var EventTarget2 = videojs.EventTarget, mergeOptions = videojs.mergeOptions;
var dashPlaylistUnchanged = function dashPlaylistUnchanged2(a2, b2) {
  if (!isPlaylistUnchanged(a2, b2)) {
    return false;
  }
  if (a2.sidx && b2.sidx && (a2.sidx.offset !== b2.sidx.offset || a2.sidx.length !== b2.sidx.length)) {
    return false;
  } else if (!a2.sidx && b2.sidx || a2.sidx && !b2.sidx) {
    return false;
  }
  if (a2.segments && !b2.segments || !a2.segments && b2.segments) {
    return false;
  }
  if (!a2.segments && !b2.segments) {
    return true;
  }
  for (var i = 0; i < a2.segments.length; i++) {
    var aSegment = a2.segments[i];
    var bSegment = b2.segments[i];
    if (aSegment.uri !== bSegment.uri) {
      return false;
    }
    if (!aSegment.byterange && !bSegment.byterange) {
      continue;
    }
    var aByterange = aSegment.byterange;
    var bByterange = bSegment.byterange;
    if (aByterange && !bByterange || !aByterange && bByterange) {
      return false;
    }
    if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) {
      return false;
    }
  }
  return true;
};
var parseMasterXml = function parseMasterXml2(_ref) {
  var masterXml = _ref.masterXml, srcUrl = _ref.srcUrl, clientOffset = _ref.clientOffset, sidxMapping = _ref.sidxMapping, previousManifest = _ref.previousManifest;
  var manifest = parse$1(masterXml, {
    manifestUri: srcUrl,
    clientOffset,
    sidxMapping,
    previousManifest
  });
  addPropertiesToMaster(manifest, srcUrl);
  return manifest;
};
var updateMaster2 = function updateMaster3(oldMaster, newMaster, sidxMapping) {
  var noChanges = true;
  var update2 = mergeOptions(oldMaster, {
    // These are top level properties that can be updated
    duration: newMaster.duration,
    minimumUpdatePeriod: newMaster.minimumUpdatePeriod,
    timelineStarts: newMaster.timelineStarts
  });
  for (var i = 0; i < newMaster.playlists.length; i++) {
    var playlist = newMaster.playlists[i];
    if (playlist.sidx) {
      var sidxKey = generateSidxKey(playlist.sidx);
      if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) {
        addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
      }
    }
    var playlistUpdate = updateMaster$1(update2, playlist, dashPlaylistUnchanged);
    if (playlistUpdate) {
      update2 = playlistUpdate;
      noChanges = false;
    }
  }
  forEachMediaGroup2(newMaster, function(properties2, type2, group, label) {
    if (properties2.playlists && properties2.playlists.length) {
      var id2 = properties2.playlists[0].id;
      var _playlistUpdate = updateMaster$1(update2, properties2.playlists[0], dashPlaylistUnchanged);
      if (_playlistUpdate) {
        update2 = _playlistUpdate;
        update2.mediaGroups[type2][group][label].playlists[0] = update2.playlists[id2];
        noChanges = false;
      }
    }
  });
  if (newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
    noChanges = false;
  }
  if (noChanges) {
    return null;
  }
  return update2;
};
var equivalentSidx = function equivalentSidx2(a2, b2) {
  var neitherMap = Boolean(!a2.map && !b2.map);
  var equivalentMap = neitherMap || Boolean(a2.map && b2.map && a2.map.byterange.offset === b2.map.byterange.offset && a2.map.byterange.length === b2.map.byterange.length);
  return equivalentMap && a2.uri === b2.uri && a2.byterange.offset === b2.byterange.offset && a2.byterange.length === b2.byterange.length;
};
var compareSidxEntry = function compareSidxEntry2(playlists, oldSidxMapping) {
  var newSidxMapping = {};
  for (var id2 in playlists) {
    var playlist = playlists[id2];
    var currentSidxInfo = playlist.sidx;
    if (currentSidxInfo) {
      var key = generateSidxKey(currentSidxInfo);
      if (!oldSidxMapping[key]) {
        break;
      }
      var savedSidxInfo = oldSidxMapping[key].sidxInfo;
      if (equivalentSidx(savedSidxInfo, currentSidxInfo)) {
        newSidxMapping[key] = oldSidxMapping[key];
      }
    }
  }
  return newSidxMapping;
};
var filterChangedSidxMappings = function filterChangedSidxMappings2(master, oldSidxMapping) {
  var videoSidx = compareSidxEntry(master.playlists, oldSidxMapping);
  var mediaGroupSidx = videoSidx;
  forEachMediaGroup2(master, function(properties2, mediaType, groupKey, labelKey) {
    if (properties2.playlists && properties2.playlists.length) {
      var playlists = properties2.playlists;
      mediaGroupSidx = mergeOptions(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));
    }
  });
  return mediaGroupSidx;
};
var DashPlaylistLoader = /* @__PURE__ */ function(_EventTarget) {
  _inheritsLoose(DashPlaylistLoader2, _EventTarget);
  function DashPlaylistLoader2(srcUrlOrPlaylist, vhs, options, masterPlaylistLoader) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _EventTarget.call(this) || this;
    _this.masterPlaylistLoader_ = masterPlaylistLoader || _assertThisInitialized(_this);
    if (!masterPlaylistLoader) {
      _this.isMaster_ = true;
    }
    var _options = options, _options$withCredenti = _options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti, _options$handleManife = _options.handleManifestRedirects, handleManifestRedirects = _options$handleManife === void 0 ? false : _options$handleManife;
    _this.vhs_ = vhs;
    _this.withCredentials = withCredentials;
    _this.handleManifestRedirects = handleManifestRedirects;
    if (!srcUrlOrPlaylist) {
      throw new Error("A non-empty playlist URL or object is required");
    }
    _this.on("minimumUpdatePeriod", function() {
      _this.refreshXml_();
    });
    _this.on("mediaupdatetimeout", function() {
      _this.refreshMedia_(_this.media().id);
    });
    _this.state = "HAVE_NOTHING";
    _this.loadedPlaylists_ = {};
    _this.logger_ = logger("DashPlaylistLoader");
    if (_this.isMaster_) {
      _this.masterPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
      _this.masterPlaylistLoader_.sidxMapping_ = {};
    } else {
      _this.childPlaylist_ = srcUrlOrPlaylist;
    }
    return _this;
  }
  var _proto = DashPlaylistLoader2.prototype;
  _proto.requestErrored_ = function requestErrored_(err, request2, startingState) {
    if (!this.request) {
      return true;
    }
    this.request = null;
    if (err) {
      this.error = typeof err === "object" && !(err instanceof Error) ? err : {
        status: request2.status,
        message: "DASH request error at URL: " + request2.uri,
        response: request2.response,
        // MEDIA_ERR_NETWORK
        code: 2
      };
      if (startingState) {
        this.state = startingState;
      }
      this.trigger("error");
      return true;
    }
  };
  _proto.addSidxSegments_ = function addSidxSegments_(playlist, startingState, cb2) {
    var _this2 = this;
    var sidxKey = playlist.sidx && generateSidxKey(playlist.sidx);
    if (!playlist.sidx || !sidxKey || this.masterPlaylistLoader_.sidxMapping_[sidxKey]) {
      this.mediaRequest_ = window_1.setTimeout(function() {
        return cb2(false);
      }, 0);
      return;
    }
    var uri = resolveManifestRedirect(this.handleManifestRedirects, playlist.sidx.resolvedUri);
    var fin = function fin2(err, request2) {
      if (_this2.requestErrored_(err, request2, startingState)) {
        return;
      }
      var sidxMapping = _this2.masterPlaylistLoader_.sidxMapping_;
      var sidx;
      try {
        sidx = parseSidx_1(toUint8(request2.response).subarray(8));
      } catch (e2) {
        _this2.requestErrored_(e2, request2, startingState);
        return;
      }
      sidxMapping[sidxKey] = {
        sidxInfo: playlist.sidx,
        sidx
      };
      addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);
      return cb2(true);
    };
    this.request = containerRequest(uri, this.vhs_.xhr, function(err, request2, container2, bytes) {
      if (err) {
        return fin(err, request2);
      }
      if (!container2 || container2 !== "mp4") {
        return fin({
          status: request2.status,
          message: "Unsupported " + (container2 || "unknown") + " container type for sidx segment at URL: " + uri,
          // response is just bytes in this case
          // but we really don't want to return that.
          response: "",
          playlist,
          internal: true,
          blacklistDuration: Infinity,
          // MEDIA_ERR_NETWORK
          code: 2
        }, request2);
      }
      var _playlist$sidx$bytera = playlist.sidx.byterange, offset3 = _playlist$sidx$bytera.offset, length2 = _playlist$sidx$bytera.length;
      if (bytes.length >= length2 + offset3) {
        return fin(err, {
          response: bytes.subarray(offset3, offset3 + length2),
          status: request2.status,
          uri: request2.uri
        });
      }
      _this2.request = _this2.vhs_.xhr({
        uri,
        responseType: "arraybuffer",
        headers: segmentXhrHeaders({
          byterange: playlist.sidx.byterange
        })
      }, fin);
    });
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.stopRequest();
    this.loadedPlaylists_ = {};
    window_1.clearTimeout(this.minimumUpdatePeriodTimeout_);
    window_1.clearTimeout(this.mediaRequest_);
    window_1.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    this.mediaRequest_ = null;
    this.minimumUpdatePeriodTimeout_ = null;
    if (this.masterPlaylistLoader_.createMupOnMedia_) {
      this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_);
      this.masterPlaylistLoader_.createMupOnMedia_ = null;
    }
    this.off();
  };
  _proto.hasPendingRequest = function hasPendingRequest() {
    return this.request || this.mediaRequest_;
  };
  _proto.stopRequest = function stopRequest() {
    if (this.request) {
      var oldRequest = this.request;
      this.request = null;
      oldRequest.onreadystatechange = null;
      oldRequest.abort();
    }
  };
  _proto.media = function media(playlist) {
    var _this3 = this;
    if (!playlist) {
      return this.media_;
    }
    if (this.state === "HAVE_NOTHING") {
      throw new Error("Cannot switch media playlist from " + this.state);
    }
    var startingState = this.state;
    if (typeof playlist === "string") {
      if (!this.masterPlaylistLoader_.master.playlists[playlist]) {
        throw new Error("Unknown playlist URI: " + playlist);
      }
      playlist = this.masterPlaylistLoader_.master.playlists[playlist];
    }
    var mediaChange = !this.media_ || playlist.id !== this.media_.id;
    if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
      this.state = "HAVE_METADATA";
      this.media_ = playlist;
      if (mediaChange) {
        this.trigger("mediachanging");
        this.trigger("mediachange");
      }
      return;
    }
    if (!mediaChange) {
      return;
    }
    if (this.media_) {
      this.trigger("mediachanging");
    }
    this.addSidxSegments_(playlist, startingState, function(sidxChanged) {
      _this3.haveMetadata({
        startingState,
        playlist
      });
    });
  };
  _proto.haveMetadata = function haveMetadata(_ref2) {
    var startingState = _ref2.startingState, playlist = _ref2.playlist;
    this.state = "HAVE_METADATA";
    this.loadedPlaylists_[playlist.id] = playlist;
    this.mediaRequest_ = null;
    this.refreshMedia_(playlist.id);
    if (startingState === "HAVE_MASTER") {
      this.trigger("loadedmetadata");
    } else {
      this.trigger("mediachange");
    }
  };
  _proto.pause = function pause() {
    if (this.masterPlaylistLoader_.createMupOnMedia_) {
      this.off("loadedmetadata", this.masterPlaylistLoader_.createMupOnMedia_);
      this.masterPlaylistLoader_.createMupOnMedia_ = null;
    }
    this.stopRequest();
    window_1.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    if (this.isMaster_) {
      window_1.clearTimeout(this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_);
      this.masterPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
    }
    if (this.state === "HAVE_NOTHING") {
      this.started = false;
    }
  };
  _proto.load = function load(isFinalRendition) {
    var _this4 = this;
    window_1.clearTimeout(this.mediaUpdateTimeout);
    this.mediaUpdateTimeout = null;
    var media = this.media();
    if (isFinalRendition) {
      var delay = media ? media.targetDuration / 2 * 1e3 : 5 * 1e3;
      this.mediaUpdateTimeout = window_1.setTimeout(function() {
        return _this4.load();
      }, delay);
      return;
    }
    if (!this.started) {
      this.start();
      return;
    }
    if (media && !media.endList) {
      if (this.isMaster_ && !this.minimumUpdatePeriodTimeout_) {
        this.trigger("minimumUpdatePeriod");
        this.updateMinimumUpdatePeriodTimeout_();
      }
      this.trigger("mediaupdatetimeout");
    } else {
      this.trigger("loadedplaylist");
    }
  };
  _proto.start = function start3() {
    var _this5 = this;
    this.started = true;
    if (!this.isMaster_) {
      this.mediaRequest_ = window_1.setTimeout(function() {
        return _this5.haveMaster_();
      }, 0);
      return;
    }
    this.requestMaster_(function(req, masterChanged) {
      _this5.haveMaster_();
      if (!_this5.hasPendingRequest() && !_this5.media_) {
        _this5.media(_this5.masterPlaylistLoader_.master.playlists[0]);
      }
    });
  };
  _proto.requestMaster_ = function requestMaster_(cb2) {
    var _this6 = this;
    this.request = this.vhs_.xhr({
      uri: this.masterPlaylistLoader_.srcUrl,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (_this6.requestErrored_(error, req)) {
        if (_this6.state === "HAVE_NOTHING") {
          _this6.started = false;
        }
        return;
      }
      var masterChanged = req.responseText !== _this6.masterPlaylistLoader_.masterXml_;
      _this6.masterPlaylistLoader_.masterXml_ = req.responseText;
      if (req.responseHeaders && req.responseHeaders.date) {
        _this6.masterLoaded_ = Date.parse(req.responseHeaders.date);
      } else {
        _this6.masterLoaded_ = Date.now();
      }
      _this6.masterPlaylistLoader_.srcUrl = resolveManifestRedirect(_this6.handleManifestRedirects, _this6.masterPlaylistLoader_.srcUrl, req);
      if (masterChanged) {
        _this6.handleMaster_();
        _this6.syncClientServerClock_(function() {
          return cb2(req, masterChanged);
        });
        return;
      }
      return cb2(req, masterChanged);
    });
  };
  _proto.syncClientServerClock_ = function syncClientServerClock_(done) {
    var _this7 = this;
    var utcTiming = parseUTCTiming(this.masterPlaylistLoader_.masterXml_);
    if (utcTiming === null) {
      this.masterPlaylistLoader_.clientOffset_ = this.masterLoaded_ - Date.now();
      return done();
    }
    if (utcTiming.method === "DIRECT") {
      this.masterPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
      return done();
    }
    this.request = this.vhs_.xhr({
      uri: resolveUrl2(this.masterPlaylistLoader_.srcUrl, utcTiming.value),
      method: utcTiming.method,
      withCredentials: this.withCredentials
    }, function(error, req) {
      if (!_this7.request) {
        return;
      }
      if (error) {
        _this7.masterPlaylistLoader_.clientOffset_ = _this7.masterLoaded_ - Date.now();
        return done();
      }
      var serverTime;
      if (utcTiming.method === "HEAD") {
        if (!req.responseHeaders || !req.responseHeaders.date) {
          serverTime = _this7.masterLoaded_;
        } else {
          serverTime = Date.parse(req.responseHeaders.date);
        }
      } else {
        serverTime = Date.parse(req.responseText);
      }
      _this7.masterPlaylistLoader_.clientOffset_ = serverTime - Date.now();
      done();
    });
  };
  _proto.haveMaster_ = function haveMaster_() {
    this.state = "HAVE_MASTER";
    if (this.isMaster_) {
      this.trigger("loadedplaylist");
    } else if (!this.media_) {
      this.media(this.childPlaylist_);
    }
  };
  _proto.handleMaster_ = function handleMaster_() {
    this.mediaRequest_ = null;
    var oldMaster = this.masterPlaylistLoader_.master;
    var newMaster = parseMasterXml({
      masterXml: this.masterPlaylistLoader_.masterXml_,
      srcUrl: this.masterPlaylistLoader_.srcUrl,
      clientOffset: this.masterPlaylistLoader_.clientOffset_,
      sidxMapping: this.masterPlaylistLoader_.sidxMapping_,
      previousManifest: oldMaster
    });
    if (oldMaster) {
      newMaster = updateMaster2(oldMaster, newMaster, this.masterPlaylistLoader_.sidxMapping_);
    }
    this.masterPlaylistLoader_.master = newMaster ? newMaster : oldMaster;
    var location2 = this.masterPlaylistLoader_.master.locations && this.masterPlaylistLoader_.master.locations[0];
    if (location2 && location2 !== this.masterPlaylistLoader_.srcUrl) {
      this.masterPlaylistLoader_.srcUrl = location2;
    }
    if (!oldMaster || newMaster && newMaster.minimumUpdatePeriod !== oldMaster.minimumUpdatePeriod) {
      this.updateMinimumUpdatePeriodTimeout_();
    }
    return Boolean(newMaster);
  };
  _proto.updateMinimumUpdatePeriodTimeout_ = function updateMinimumUpdatePeriodTimeout_() {
    var mpl = this.masterPlaylistLoader_;
    if (mpl.createMupOnMedia_) {
      mpl.off("loadedmetadata", mpl.createMupOnMedia_);
      mpl.createMupOnMedia_ = null;
    }
    if (mpl.minimumUpdatePeriodTimeout_) {
      window_1.clearTimeout(mpl.minimumUpdatePeriodTimeout_);
      mpl.minimumUpdatePeriodTimeout_ = null;
    }
    var mup = mpl.master && mpl.master.minimumUpdatePeriod;
    if (mup === 0) {
      if (mpl.media()) {
        mup = mpl.media().targetDuration * 1e3;
      } else {
        mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
        mpl.one("loadedmetadata", mpl.createMupOnMedia_);
      }
    }
    if (typeof mup !== "number" || mup <= 0) {
      if (mup < 0) {
        this.logger_("found invalid minimumUpdatePeriod of " + mup + ", not setting a timeout");
      }
      return;
    }
    this.createMUPTimeout_(mup);
  };
  _proto.createMUPTimeout_ = function createMUPTimeout_(mup) {
    var mpl = this.masterPlaylistLoader_;
    mpl.minimumUpdatePeriodTimeout_ = window_1.setTimeout(function() {
      mpl.minimumUpdatePeriodTimeout_ = null;
      mpl.trigger("minimumUpdatePeriod");
      mpl.createMUPTimeout_(mup);
    }, mup);
  };
  _proto.refreshXml_ = function refreshXml_() {
    var _this8 = this;
    this.requestMaster_(function(req, masterChanged) {
      if (!masterChanged) {
        return;
      }
      if (_this8.media_) {
        _this8.media_ = _this8.masterPlaylistLoader_.master.playlists[_this8.media_.id];
      }
      _this8.masterPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(_this8.masterPlaylistLoader_.master, _this8.masterPlaylistLoader_.sidxMapping_);
      _this8.addSidxSegments_(_this8.media(), _this8.state, function(sidxChanged) {
        _this8.refreshMedia_(_this8.media().id);
      });
    });
  };
  _proto.refreshMedia_ = function refreshMedia_(mediaID) {
    var _this9 = this;
    if (!mediaID) {
      throw new Error("refreshMedia_ must take a media id");
    }
    if (this.media_ && this.isMaster_) {
      this.handleMaster_();
    }
    var playlists = this.masterPlaylistLoader_.master.playlists;
    var mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
    if (mediaChanged) {
      this.media_ = playlists[mediaID];
    } else {
      this.trigger("playlistunchanged");
    }
    if (!this.mediaUpdateTimeout) {
      var createMediaUpdateTimeout = function createMediaUpdateTimeout2() {
        if (_this9.media().endList) {
          return;
        }
        _this9.mediaUpdateTimeout = window_1.setTimeout(function() {
          _this9.trigger("mediaupdatetimeout");
          createMediaUpdateTimeout2();
        }, refreshDelay(_this9.media(), Boolean(mediaChanged)));
      };
      createMediaUpdateTimeout();
    }
    this.trigger("loadedplaylist");
  };
  return DashPlaylistLoader2;
}(EventTarget2);
var Config = {
  GOAL_BUFFER_LENGTH: 30,
  MAX_GOAL_BUFFER_LENGTH: 60,
  BACK_BUFFER_LENGTH: 30,
  GOAL_BUFFER_LENGTH_RATE: 1,
  // 0.5 MB/s
  INITIAL_BANDWIDTH: 4194304,
  // A fudge factor to apply to advertised playlist bitrates to account for
  // temporary flucations in client bandwidth
  BANDWIDTH_VARIANCE: 1.2,
  // How much of the buffer must be filled before we consider upswitching
  BUFFER_LOW_WATER_LINE: 0,
  MAX_BUFFER_LOW_WATER_LINE: 30,
  // TODO: Remove this when experimentalBufferBasedABR is removed
  EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
  BUFFER_LOW_WATER_LINE_RATE: 1,
  // If the buffer is greater than the high water line, we won't switch down
  BUFFER_HIGH_WATER_LINE: 30
};
var stringToArrayBuffer = function stringToArrayBuffer2(string) {
  var view = new Uint8Array(new ArrayBuffer(string.length));
  for (var i = 0; i < string.length; i++) {
    view[i] = string.charCodeAt(i);
  }
  return view.buffer;
};
var browserWorkerPolyFill = function browserWorkerPolyFill2(workerObj) {
  workerObj.on = workerObj.addEventListener;
  workerObj.off = workerObj.removeEventListener;
  return workerObj;
};
var createObjectURL = function createObjectURL2(str) {
  try {
    return URL.createObjectURL(new Blob([str], {
      type: "application/javascript"
    }));
  } catch (e2) {
    var blob = new BlobBuilder();
    blob.append(str);
    return URL.createObjectURL(blob.getBlob());
  }
};
var factory = function factory2(code) {
  return function() {
    var objectUrl = createObjectURL(code);
    var worker = browserWorkerPolyFill(new Worker(objectUrl));
    worker.objURL = objectUrl;
    var terminate = worker.terminate;
    worker.on = worker.addEventListener;
    worker.off = worker.removeEventListener;
    worker.terminate = function() {
      URL.revokeObjectURL(objectUrl);
      return terminate.call(this);
    };
    return worker;
  };
};
var transform = function transform2(code) {
  return "var browserWorkerPolyFill = " + browserWorkerPolyFill.toString() + ";\nbrowserWorkerPolyFill(self);\n" + code;
};
var getWorkerString = function getWorkerString2(fn2) {
  return fn2.toString().replace(/^function.+?{/, "").slice(0, -1);
};
var workerCode$1 = transform(getWorkerString(function() {
  var Stream2 = function Stream3() {
    this.init = function() {
      var listeners = {};
      this.on = function(type3, listener) {
        if (!listeners[type3]) {
          listeners[type3] = [];
        }
        listeners[type3] = listeners[type3].concat(listener);
      };
      this.off = function(type3, listener) {
        var index2;
        if (!listeners[type3]) {
          return false;
        }
        index2 = listeners[type3].indexOf(listener);
        listeners[type3] = listeners[type3].slice();
        listeners[type3].splice(index2, 1);
        return index2 > -1;
      };
      this.trigger = function(type3) {
        var callbacks, i, length2, args;
        callbacks = listeners[type3];
        if (!callbacks) {
          return;
        }
        if (arguments.length === 2) {
          length2 = callbacks.length;
          for (i = 0; i < length2; ++i) {
            callbacks[i].call(this, arguments[1]);
          }
        } else {
          args = [];
          i = arguments.length;
          for (i = 1; i < arguments.length; ++i) {
            args.push(arguments[i]);
          }
          length2 = callbacks.length;
          for (i = 0; i < length2; ++i) {
            callbacks[i].apply(this, args);
          }
        }
      };
      this.dispose = function() {
        listeners = {};
      };
    };
  };
  Stream2.prototype.pipe = function(destination) {
    this.on("data", function(data) {
      destination.push(data);
    });
    this.on("done", function(flushSource) {
      destination.flush(flushSource);
    });
    this.on("partialdone", function(flushSource) {
      destination.partialFlush(flushSource);
    });
    this.on("endedtimeline", function(flushSource) {
      destination.endTimeline(flushSource);
    });
    this.on("reset", function(flushSource) {
      destination.reset(flushSource);
    });
    return destination;
  };
  Stream2.prototype.push = function(data) {
    this.trigger("data", data);
  };
  Stream2.prototype.flush = function(flushSource) {
    this.trigger("done", flushSource);
  };
  Stream2.prototype.partialFlush = function(flushSource) {
    this.trigger("partialdone", flushSource);
  };
  Stream2.prototype.endTimeline = function(flushSource) {
    this.trigger("endedtimeline", flushSource);
  };
  Stream2.prototype.reset = function(flushSource) {
    this.trigger("reset", flushSource);
  };
  var stream = Stream2;
  var MAX_UINT32$1 = Math.pow(2, 32);
  var getUint64$2 = function getUint643(uint8) {
    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
    var value;
    if (dv.getBigUint64) {
      value = dv.getBigUint64(0);
      if (value < Number.MAX_SAFE_INTEGER) {
        return Number(value);
      }
      return value;
    }
    return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
  };
  var numbers2 = {
    getUint64: getUint64$2,
    MAX_UINT32: MAX_UINT32$1
  };
  var MAX_UINT322 = numbers2.MAX_UINT32;
  var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
  (function() {
    var i;
    types = {
      avc1: [],
      // codingname
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      // codingname
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      smhd: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      styp: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: []
    };
    if (typeof Uint8Array === "undefined") {
      return;
    }
    for (i in types) {
      if (types.hasOwnProperty(i)) {
        types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }
    MAJOR_BRAND = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]);
    AVC1_BRAND = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]);
    MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);
    VIDEO_HDLR = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      118,
      105,
      100,
      101,
      // handler_type: 'vide'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'VideoHandler'
    ]);
    AUDIO_HDLR = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // pre_defined
      115,
      111,
      117,
      110,
      // handler_type: 'soun'
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
      // name: 'SoundHandler'
    ]);
    HDLR_TYPES = {
      video: VIDEO_HDLR,
      audio: AUDIO_HDLR
    };
    DREF = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // entry_count
      0,
      0,
      0,
      12,
      // entry_size
      117,
      114,
      108,
      32,
      // 'url' type
      0,
      // version 0
      0,
      0,
      1
      // entry_flags
    ]);
    SMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      // balance, 0 means centered
      0,
      0
      // reserved
    ]);
    STCO = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0
      // entry_count
    ]);
    STSC = STCO;
    STSZ = new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      0,
      // sample_size
      0,
      0,
      0,
      0
      // sample_count
    ]);
    STTS = STCO;
    VMHD = new Uint8Array([
      0,
      // version
      0,
      0,
      1,
      // flags
      0,
      0,
      // graphicsmode
      0,
      0,
      0,
      0,
      0,
      0
      // opcolor
    ]);
  })();
  box = function box2(type3) {
    var payload = [], size = 0, i, result, view;
    for (i = 1; i < arguments.length; i++) {
      payload.push(arguments[i]);
    }
    i = payload.length;
    while (i--) {
      size += payload[i].byteLength;
    }
    result = new Uint8Array(size + 8);
    view = new DataView(result.buffer, result.byteOffset, result.byteLength);
    view.setUint32(0, result.byteLength);
    result.set(type3, 4);
    for (i = 0, size = 8; i < payload.length; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  };
  dinf = function dinf2() {
    return box(types.dinf, box(types.dref, DREF));
  };
  esds = function esds2(track) {
    return box(types.esds, new Uint8Array([
      0,
      // version
      0,
      0,
      0,
      // flags
      // ES_Descriptor
      3,
      // tag, ES_DescrTag
      25,
      // length
      0,
      0,
      // ES_ID
      0,
      // streamDependenceFlag, URL_flag, reserved, streamPriority
      // DecoderConfigDescriptor
      4,
      // tag, DecoderConfigDescrTag
      17,
      // length
      64,
      // object type
      21,
      // streamType
      0,
      6,
      0,
      // bufferSizeDB
      0,
      0,
      218,
      192,
      // maxBitrate
      0,
      0,
      218,
      192,
      // avgBitrate
      // DecoderSpecificInfo
      5,
      // tag, DecoderSpecificInfoTag
      2,
      // length
      // ISO/IEC 14496-3, AudioSpecificConfig
      // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35
      track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1,
      track.samplingfrequencyindex << 7 | track.channelcount << 3,
      6,
      1,
      2
      // GASpecificConfig
    ]));
  };
  ftyp = function ftyp2() {
    return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
  };
  hdlr = function hdlr2(type3) {
    return box(types.hdlr, HDLR_TYPES[type3]);
  };
  mdat = function mdat2(data) {
    return box(types.mdat, data);
  };
  mdhd = function mdhd2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      2,
      // creation_time
      0,
      0,
      0,
      3,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      track.duration >>> 24 & 255,
      track.duration >>> 16 & 255,
      track.duration >>> 8 & 255,
      track.duration & 255,
      // duration
      85,
      196,
      // 'und' language (undetermined)
      0,
      0
    ]);
    if (track.samplerate) {
      result[12] = track.samplerate >>> 24 & 255;
      result[13] = track.samplerate >>> 16 & 255;
      result[14] = track.samplerate >>> 8 & 255;
      result[15] = track.samplerate & 255;
    }
    return box(types.mdhd, result);
  };
  mdia = function mdia2(track) {
    return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
  };
  mfhd = function mfhd2(sequenceNumber) {
    return box(types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      // flags
      (sequenceNumber & 4278190080) >> 24,
      (sequenceNumber & 16711680) >> 16,
      (sequenceNumber & 65280) >> 8,
      sequenceNumber & 255
      // sequence_number
    ]));
  };
  minf = function minf2(track) {
    return box(types.minf, track.type === "video" ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
  };
  moof = function moof2(sequenceNumber, tracks) {
    var trackFragments = [], i = tracks.length;
    while (i--) {
      trackFragments[i] = traf(tracks[i]);
    }
    return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));
  };
  moov = function moov2(tracks) {
    var i = tracks.length, boxes = [];
    while (i--) {
      boxes[i] = trak(tracks[i]);
    }
    return box.apply(null, [types.moov, mvhd(4294967295)].concat(boxes).concat(mvex(tracks)));
  };
  mvex = function mvex2(tracks) {
    var i = tracks.length, boxes = [];
    while (i--) {
      boxes[i] = trex(tracks[i]);
    }
    return box.apply(null, [types.mvex].concat(boxes));
  };
  mvhd = function mvhd2(duration5) {
    var bytes = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      0,
      0,
      0,
      1,
      // creation_time
      0,
      0,
      0,
      2,
      // modification_time
      0,
      1,
      95,
      144,
      // timescale, 90,000 "ticks" per second
      (duration5 & 4278190080) >> 24,
      (duration5 & 16711680) >> 16,
      (duration5 & 65280) >> 8,
      duration5 & 255,
      // duration
      0,
      1,
      0,
      0,
      // 1.0 rate
      1,
      0,
      // 1.0 volume
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // pre_defined
      255,
      255,
      255,
      255
      // next_track_ID
    ]);
    return box(types.mvhd, bytes);
  };
  sdtp = function sdtp2(track) {
    var samples = track.samples || [], bytes = new Uint8Array(4 + samples.length), flags, i;
    for (i = 0; i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }
    return box(types.sdtp, bytes);
  };
  stbl = function stbl2(track) {
    return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
  };
  (function() {
    var videoSample, audioSample;
    stsd = function stsd2(track) {
      return box(types.stsd, new Uint8Array([
        0,
        // version 0
        0,
        0,
        0,
        // flags
        0,
        0,
        0,
        1
      ]), track.type === "video" ? videoSample(track) : audioSample(track));
    };
    videoSample = function videoSample2(track) {
      var sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [], i, avc1Box;
      for (i = 0; i < sps.length; i++) {
        sequenceParameterSets.push((sps[i].byteLength & 65280) >>> 8);
        sequenceParameterSets.push(sps[i].byteLength & 255);
        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
      }
      for (i = 0; i < pps.length; i++) {
        pictureParameterSets.push((pps[i].byteLength & 65280) >>> 8);
        pictureParameterSets.push(pps[i].byteLength & 255);
        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
      }
      avc1Box = [types.avc1, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // pre_defined
        (track.width & 65280) >> 8,
        track.width & 255,
        // width
        (track.height & 65280) >> 8,
        track.height & 255,
        // height
        0,
        72,
        0,
        0,
        // horizresolution
        0,
        72,
        0,
        0,
        // vertresolution
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // frame_count
        19,
        118,
        105,
        100,
        101,
        111,
        106,
        115,
        45,
        99,
        111,
        110,
        116,
        114,
        105,
        98,
        45,
        104,
        108,
        115,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // compressorname
        0,
        24,
        // depth = 24
        17,
        17
        // pre_defined = -1
      ]), box(types.avcC, new Uint8Array([
        1,
        // configurationVersion
        track.profileIdc,
        // AVCProfileIndication
        track.profileCompatibility,
        // profile_compatibility
        track.levelIdc,
        // AVCLevelIndication
        255
        // lengthSizeMinusOne, hard-coded to 4 bytes
      ].concat(
        [sps.length],
        // numOfSequenceParameterSets
        sequenceParameterSets,
        // "SPS"
        [pps.length],
        // numOfPictureParameterSets
        pictureParameterSets
        // "PPS"
      ))), box(types.btrt, new Uint8Array([
        0,
        28,
        156,
        128,
        // bufferSizeDB
        0,
        45,
        198,
        192,
        // maxBitrate
        0,
        45,
        198,
        192
        // avgBitrate
      ]))];
      if (track.sarRatio) {
        var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
        avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 4278190080) >> 24, (hSpacing & 16711680) >> 16, (hSpacing & 65280) >> 8, hSpacing & 255, (vSpacing & 4278190080) >> 24, (vSpacing & 16711680) >> 16, (vSpacing & 65280) >> 8, vSpacing & 255])));
      }
      return box.apply(null, avc1Box);
    };
    audioSample = function audioSample2(track) {
      return box(types.mp4a, new Uint8Array([
        // SampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        0,
        0,
        // reserved
        0,
        1,
        // data_reference_index
        // AudioSampleEntry, ISO/IEC 14496-12
        0,
        0,
        0,
        0,
        // reserved
        0,
        0,
        0,
        0,
        // reserved
        (track.channelcount & 65280) >> 8,
        track.channelcount & 255,
        // channelcount
        (track.samplesize & 65280) >> 8,
        track.samplesize & 255,
        // samplesize
        0,
        0,
        // pre_defined
        0,
        0,
        // reserved
        (track.samplerate & 65280) >> 8,
        track.samplerate & 255,
        0,
        0
        // samplerate, 16.16
        // MP4AudioSampleEntry, ISO/IEC 14496-14
      ]), esds(track));
    };
  })();
  tkhd = function tkhd2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      7,
      // flags
      0,
      0,
      0,
      0,
      // creation_time
      0,
      0,
      0,
      0,
      // modification_time
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      0,
      // reserved
      (track.duration & 4278190080) >> 24,
      (track.duration & 16711680) >> 16,
      (track.duration & 65280) >> 8,
      track.duration & 255,
      // duration
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // reserved
      0,
      0,
      // layer
      0,
      0,
      // alternate_group
      1,
      0,
      // non-audio track volume
      0,
      0,
      // reserved
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      // transformation: unity matrix
      (track.width & 65280) >> 8,
      track.width & 255,
      0,
      0,
      // width
      (track.height & 65280) >> 8,
      track.height & 255,
      0,
      0
      // height
    ]);
    return box(types.tkhd, result);
  };
  traf = function traf2(track) {
    var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
    trackFragmentHeader = box(types.tfhd, new Uint8Array([
      0,
      // version 0
      0,
      0,
      58,
      // flags
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      0,
      0,
      0
      // default_sample_flags
    ]));
    upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT322);
    lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT322);
    trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([
      1,
      // version 1
      0,
      0,
      0,
      // flags
      // baseMediaDecodeTime
      upperWordBaseMediaDecodeTime >>> 24 & 255,
      upperWordBaseMediaDecodeTime >>> 16 & 255,
      upperWordBaseMediaDecodeTime >>> 8 & 255,
      upperWordBaseMediaDecodeTime & 255,
      lowerWordBaseMediaDecodeTime >>> 24 & 255,
      lowerWordBaseMediaDecodeTime >>> 16 & 255,
      lowerWordBaseMediaDecodeTime >>> 8 & 255,
      lowerWordBaseMediaDecodeTime & 255
    ]));
    dataOffset = 32 + // tfhd
    20 + // tfdt
    8 + // traf header
    16 + // mfhd
    8 + // moof header
    8;
    if (track.type === "audio") {
      trackFragmentRun = trun$1(track, dataOffset);
      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
    }
    sampleDependencyTable = sdtp(track);
    trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
  };
  trak = function trak2(track) {
    track.duration = track.duration || 4294967295;
    return box(types.trak, tkhd(track), mdia(track));
  };
  trex = function trex2(track) {
    var result = new Uint8Array([
      0,
      // version 0
      0,
      0,
      0,
      // flags
      (track.id & 4278190080) >> 24,
      (track.id & 16711680) >> 16,
      (track.id & 65280) >> 8,
      track.id & 255,
      // track_ID
      0,
      0,
      0,
      1,
      // default_sample_description_index
      0,
      0,
      0,
      0,
      // default_sample_duration
      0,
      0,
      0,
      0,
      // default_sample_size
      0,
      1,
      0,
      1
      // default_sample_flags
    ]);
    if (track.type !== "video") {
      result[result.length - 1] = 0;
    }
    return box(types.trex, result);
  };
  (function() {
    var audioTrun, videoTrun, trunHeader;
    trunHeader = function trunHeader2(samples, offset3) {
      var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
      if (samples.length) {
        if (samples[0].duration !== void 0) {
          durationPresent = 1;
        }
        if (samples[0].size !== void 0) {
          sizePresent = 2;
        }
        if (samples[0].flags !== void 0) {
          flagsPresent = 4;
        }
        if (samples[0].compositionTimeOffset !== void 0) {
          compositionTimeOffset = 8;
        }
      }
      return [
        0,
        // version 0
        0,
        durationPresent | sizePresent | flagsPresent | compositionTimeOffset,
        1,
        // flags
        (samples.length & 4278190080) >>> 24,
        (samples.length & 16711680) >>> 16,
        (samples.length & 65280) >>> 8,
        samples.length & 255,
        // sample_count
        (offset3 & 4278190080) >>> 24,
        (offset3 & 16711680) >>> 16,
        (offset3 & 65280) >>> 8,
        offset3 & 255
        // data_offset
      ];
    };
    videoTrun = function videoTrun2(track, offset3) {
      var bytesOffest, bytes, header, samples, sample, i;
      samples = track.samples || [];
      offset3 += 8 + 12 + 16 * samples.length;
      header = trunHeader(samples, offset3);
      bytes = new Uint8Array(header.length + samples.length * 16);
      bytes.set(header);
      bytesOffest = header.length;
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
        bytes[bytesOffest++] = sample.duration & 255;
        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
        bytes[bytesOffest++] = sample.size & 255;
        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
        bytes[bytesOffest++] = sample.flags.degradationPriority & 240 << 8;
        bytes[bytesOffest++] = sample.flags.degradationPriority & 15;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.compositionTimeOffset & 65280) >>> 8;
        bytes[bytesOffest++] = sample.compositionTimeOffset & 255;
      }
      return box(types.trun, bytes);
    };
    audioTrun = function audioTrun2(track, offset3) {
      var bytes, bytesOffest, header, samples, sample, i;
      samples = track.samples || [];
      offset3 += 8 + 12 + 8 * samples.length;
      header = trunHeader(samples, offset3);
      bytes = new Uint8Array(header.length + samples.length * 8);
      bytes.set(header);
      bytesOffest = header.length;
      for (i = 0; i < samples.length; i++) {
        sample = samples[i];
        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
        bytes[bytesOffest++] = sample.duration & 255;
        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
        bytes[bytesOffest++] = sample.size & 255;
      }
      return box(types.trun, bytes);
    };
    trun$1 = function trun2(track, offset3) {
      if (track.type === "audio") {
        return audioTrun(track, offset3);
      }
      return videoTrun(track, offset3);
    };
  })();
  var mp4Generator = {
    ftyp,
    mdat,
    moof,
    moov,
    initSegment: function initSegment(tracks) {
      var fileType = ftyp(), movie = moov(tracks), result;
      result = new Uint8Array(fileType.byteLength + movie.byteLength);
      result.set(fileType);
      result.set(movie, fileType.byteLength);
      return result;
    }
  };
  var groupNalsIntoFrames = function groupNalsIntoFrames2(nalUnits) {
    var i, currentNal, currentFrame = [], frames = [];
    frames.byteLength = 0;
    frames.nalCount = 0;
    frames.duration = 0;
    currentFrame.byteLength = 0;
    for (i = 0; i < nalUnits.length; i++) {
      currentNal = nalUnits[i];
      if (currentNal.nalUnitType === "access_unit_delimiter_rbsp") {
        if (currentFrame.length) {
          currentFrame.duration = currentNal.dts - currentFrame.dts;
          frames.byteLength += currentFrame.byteLength;
          frames.nalCount += currentFrame.length;
          frames.duration += currentFrame.duration;
          frames.push(currentFrame);
        }
        currentFrame = [currentNal];
        currentFrame.byteLength = currentNal.data.byteLength;
        currentFrame.pts = currentNal.pts;
        currentFrame.dts = currentNal.dts;
      } else {
        if (currentNal.nalUnitType === "slice_layer_without_partitioning_rbsp_idr") {
          currentFrame.keyFrame = true;
        }
        currentFrame.duration = currentNal.dts - currentFrame.dts;
        currentFrame.byteLength += currentNal.data.byteLength;
        currentFrame.push(currentNal);
      }
    }
    if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {
      currentFrame.duration = frames[frames.length - 1].duration;
    }
    frames.byteLength += currentFrame.byteLength;
    frames.nalCount += currentFrame.length;
    frames.duration += currentFrame.duration;
    frames.push(currentFrame);
    return frames;
  };
  var groupFramesIntoGops = function groupFramesIntoGops2(frames) {
    var i, currentFrame, currentGop = [], gops = [];
    currentGop.byteLength = 0;
    currentGop.nalCount = 0;
    currentGop.duration = 0;
    currentGop.pts = frames[0].pts;
    currentGop.dts = frames[0].dts;
    gops.byteLength = 0;
    gops.nalCount = 0;
    gops.duration = 0;
    gops.pts = frames[0].pts;
    gops.dts = frames[0].dts;
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      if (currentFrame.keyFrame) {
        if (currentGop.length) {
          gops.push(currentGop);
          gops.byteLength += currentGop.byteLength;
          gops.nalCount += currentGop.nalCount;
          gops.duration += currentGop.duration;
        }
        currentGop = [currentFrame];
        currentGop.nalCount = currentFrame.length;
        currentGop.byteLength = currentFrame.byteLength;
        currentGop.pts = currentFrame.pts;
        currentGop.dts = currentFrame.dts;
        currentGop.duration = currentFrame.duration;
      } else {
        currentGop.duration += currentFrame.duration;
        currentGop.nalCount += currentFrame.length;
        currentGop.byteLength += currentFrame.byteLength;
        currentGop.push(currentFrame);
      }
    }
    if (gops.length && currentGop.duration <= 0) {
      currentGop.duration = gops[gops.length - 1].duration;
    }
    gops.byteLength += currentGop.byteLength;
    gops.nalCount += currentGop.nalCount;
    gops.duration += currentGop.duration;
    gops.push(currentGop);
    return gops;
  };
  var extendFirstKeyFrame = function extendFirstKeyFrame2(gops) {
    var currentGop;
    if (!gops[0][0].keyFrame && gops.length > 1) {
      currentGop = gops.shift();
      gops.byteLength -= currentGop.byteLength;
      gops.nalCount -= currentGop.nalCount;
      gops[0][0].dts = currentGop.dts;
      gops[0][0].pts = currentGop.pts;
      gops[0][0].duration += currentGop.duration;
    }
    return gops;
  };
  var createDefaultSample = function createDefaultSample2() {
    return {
      size: 0,
      flags: {
        isLeading: 0,
        dependsOn: 1,
        isDependedOn: 0,
        hasRedundancy: 0,
        degradationPriority: 0,
        isNonSyncSample: 1
      }
    };
  };
  var sampleForFrame = function sampleForFrame2(frame, dataOffset) {
    var sample = createDefaultSample();
    sample.dataOffset = dataOffset;
    sample.compositionTimeOffset = frame.pts - frame.dts;
    sample.duration = frame.duration;
    sample.size = 4 * frame.length;
    sample.size += frame.byteLength;
    if (frame.keyFrame) {
      sample.flags.dependsOn = 2;
      sample.flags.isNonSyncSample = 0;
    }
    return sample;
  };
  var generateSampleTable$1 = function generateSampleTable2(gops, baseDataOffset) {
    var h2, i, sample, currentGop, currentFrame, dataOffset = baseDataOffset || 0, samples = [];
    for (h2 = 0; h2 < gops.length; h2++) {
      currentGop = gops[h2];
      for (i = 0; i < currentGop.length; i++) {
        currentFrame = currentGop[i];
        sample = sampleForFrame(currentFrame, dataOffset);
        dataOffset += sample.size;
        samples.push(sample);
      }
    }
    return samples;
  };
  var concatenateNalData = function concatenateNalData2(gops) {
    var h2, i, j2, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
    for (h2 = 0; h2 < gops.length; h2++) {
      currentGop = gops[h2];
      for (i = 0; i < currentGop.length; i++) {
        currentFrame = currentGop[i];
        for (j2 = 0; j2 < currentFrame.length; j2++) {
          currentNal = currentFrame[j2];
          view.setUint32(dataOffset, currentNal.data.byteLength);
          dataOffset += 4;
          data.set(currentNal.data, dataOffset);
          dataOffset += currentNal.data.byteLength;
        }
      }
    }
    return data;
  };
  var generateSampleTableForFrame = function generateSampleTableForFrame2(frame, baseDataOffset) {
    var sample, dataOffset = baseDataOffset || 0, samples = [];
    sample = sampleForFrame(frame, dataOffset);
    samples.push(sample);
    return samples;
  };
  var concatenateNalDataForFrame = function concatenateNalDataForFrame2(frame) {
    var i, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
    for (i = 0; i < frame.length; i++) {
      currentNal = frame[i];
      view.setUint32(dataOffset, currentNal.data.byteLength);
      dataOffset += 4;
      data.set(currentNal.data, dataOffset);
      dataOffset += currentNal.data.byteLength;
    }
    return data;
  };
  var frameUtils = {
    groupNalsIntoFrames,
    groupFramesIntoGops,
    extendFirstKeyFrame,
    generateSampleTable: generateSampleTable$1,
    concatenateNalData,
    generateSampleTableForFrame,
    concatenateNalDataForFrame
  };
  var highPrefix = [33, 16, 5, 32, 164, 27];
  var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];
  var zeroFill = function zeroFill2(count2) {
    var a2 = [];
    while (count2--) {
      a2.push(0);
    }
    return a2;
  };
  var makeTable = function makeTable2(metaTable) {
    return Object.keys(metaTable).reduce(function(obj, key) {
      obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {
        return arr.concat(part);
      }, []));
      return obj;
    }, {});
  };
  var silence;
  var silence_1 = function silence_12() {
    if (!silence) {
      var coneOfSilence = {
        96e3: [highPrefix, [227, 64], zeroFill(154), [56]],
        88200: [highPrefix, [231], zeroFill(170), [56]],
        64e3: [highPrefix, [248, 192], zeroFill(240), [56]],
        48e3: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],
        44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],
        32e3: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],
        24e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],
        16e3: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],
        12e3: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],
        11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],
        8e3: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]
      };
      silence = makeTable(coneOfSilence);
    }
    return silence;
  };
  var ONE_SECOND_IN_TS$4 = 9e4, secondsToVideoTs2, secondsToAudioTs2, videoTsToSeconds2, audioTsToSeconds2, audioTsToVideoTs2, videoTsToAudioTs2, metadataTsToSeconds2;
  secondsToVideoTs2 = function secondsToVideoTs3(seconds) {
    return seconds * ONE_SECOND_IN_TS$4;
  };
  secondsToAudioTs2 = function secondsToAudioTs3(seconds, sampleRate) {
    return seconds * sampleRate;
  };
  videoTsToSeconds2 = function videoTsToSeconds3(timestamp) {
    return timestamp / ONE_SECOND_IN_TS$4;
  };
  audioTsToSeconds2 = function audioTsToSeconds3(timestamp, sampleRate) {
    return timestamp / sampleRate;
  };
  audioTsToVideoTs2 = function audioTsToVideoTs3(timestamp, sampleRate) {
    return secondsToVideoTs2(audioTsToSeconds2(timestamp, sampleRate));
  };
  videoTsToAudioTs2 = function videoTsToAudioTs3(timestamp, sampleRate) {
    return secondsToAudioTs2(videoTsToSeconds2(timestamp), sampleRate);
  };
  metadataTsToSeconds2 = function metadataTsToSeconds3(timestamp, timelineStartPts, keepOriginalTimestamps) {
    return videoTsToSeconds2(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
  };
  var clock2 = {
    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
    secondsToVideoTs: secondsToVideoTs2,
    secondsToAudioTs: secondsToAudioTs2,
    videoTsToSeconds: videoTsToSeconds2,
    audioTsToSeconds: audioTsToSeconds2,
    audioTsToVideoTs: audioTsToVideoTs2,
    videoTsToAudioTs: videoTsToAudioTs2,
    metadataTsToSeconds: metadataTsToSeconds2
  };
  var sumFrameByteLengths = function sumFrameByteLengths2(array) {
    var i, currentObj, sum = 0;
    for (i = 0; i < array.length; i++) {
      currentObj = array[i];
      sum += currentObj.data.byteLength;
    }
    return sum;
  };
  var prefixWithSilence = function prefixWithSilence2(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
    var baseMediaDecodeTimeTs, frameDuration = 0, audioGapDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0, silentFrame, i, firstFrame;
    if (!frames.length) {
      return;
    }
    baseMediaDecodeTimeTs = clock2.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
    frameDuration = Math.ceil(clock2.ONE_SECOND_IN_TS / (track.samplerate / 1024));
    if (audioAppendStartTs && videoBaseMediaDecodeTime) {
      audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
      audioFillDuration = audioFillFrameCount * frameDuration;
    }
    if (audioFillFrameCount < 1 || audioFillDuration > clock2.ONE_SECOND_IN_TS / 2) {
      return;
    }
    silentFrame = silence_1()[track.samplerate];
    if (!silentFrame) {
      silentFrame = frames[0].data;
    }
    for (i = 0; i < audioFillFrameCount; i++) {
      firstFrame = frames[0];
      frames.splice(0, 0, {
        data: silentFrame,
        dts: firstFrame.dts - frameDuration,
        pts: firstFrame.pts - frameDuration
      });
    }
    track.baseMediaDecodeTime -= Math.floor(clock2.videoTsToAudioTs(audioFillDuration, track.samplerate));
    return audioFillDuration;
  };
  var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts2(adtsFrames, track, earliestAllowedDts) {
    if (track.minSegmentDts >= earliestAllowedDts) {
      return adtsFrames;
    }
    track.minSegmentDts = Infinity;
    return adtsFrames.filter(function(currentFrame) {
      if (currentFrame.dts >= earliestAllowedDts) {
        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
        track.minSegmentPts = track.minSegmentDts;
        return true;
      }
      return false;
    });
  };
  var generateSampleTable = function generateSampleTable2(frames) {
    var i, currentFrame, samples = [];
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      samples.push({
        size: currentFrame.data.byteLength,
        duration: 1024
        // For AAC audio, all samples contain 1024 samples
      });
    }
    return samples;
  };
  var concatenateFrameData = function concatenateFrameData2(frames) {
    var i, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
    for (i = 0; i < frames.length; i++) {
      currentFrame = frames[i];
      data.set(currentFrame.data, dataOffset);
      dataOffset += currentFrame.data.byteLength;
    }
    return data;
  };
  var audioFrameUtils = {
    prefixWithSilence,
    trimAdtsFramesByEarliestDts,
    generateSampleTable,
    concatenateFrameData
  };
  var ONE_SECOND_IN_TS$3 = clock2.ONE_SECOND_IN_TS;
  var collectDtsInfo = function collectDtsInfo2(track, data) {
    if (typeof data.pts === "number") {
      if (track.timelineStartInfo.pts === void 0) {
        track.timelineStartInfo.pts = data.pts;
      }
      if (track.minSegmentPts === void 0) {
        track.minSegmentPts = data.pts;
      } else {
        track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
      }
      if (track.maxSegmentPts === void 0) {
        track.maxSegmentPts = data.pts;
      } else {
        track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
      }
    }
    if (typeof data.dts === "number") {
      if (track.timelineStartInfo.dts === void 0) {
        track.timelineStartInfo.dts = data.dts;
      }
      if (track.minSegmentDts === void 0) {
        track.minSegmentDts = data.dts;
      } else {
        track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
      }
      if (track.maxSegmentDts === void 0) {
        track.maxSegmentDts = data.dts;
      } else {
        track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
      }
    }
  };
  var clearDtsInfo = function clearDtsInfo2(track) {
    delete track.minSegmentDts;
    delete track.maxSegmentDts;
    delete track.minSegmentPts;
    delete track.maxSegmentPts;
  };
  var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime2(track, keepOriginalTimestamps) {
    var baseMediaDecodeTime, scale, minSegmentDts = track.minSegmentDts;
    if (!keepOriginalTimestamps) {
      minSegmentDts -= track.timelineStartInfo.dts;
    }
    baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
    baseMediaDecodeTime += minSegmentDts;
    baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
    if (track.type === "audio") {
      scale = track.samplerate / ONE_SECOND_IN_TS$3;
      baseMediaDecodeTime *= scale;
      baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
    }
    return baseMediaDecodeTime;
  };
  var trackDecodeInfo = {
    clearDtsInfo,
    calculateTrackBaseMediaDecodeTime,
    collectDtsInfo
  };
  var USER_DATA_REGISTERED_ITU_T_T35 = 4, RBSP_TRAILING_BITS = 128;
  var parseSei = function parseSei2(bytes) {
    var i = 0, result = {
      payloadType: -1,
      payloadSize: 0
    }, payloadType = 0, payloadSize = 0;
    while (i < bytes.byteLength) {
      if (bytes[i] === RBSP_TRAILING_BITS) {
        break;
      }
      while (bytes[i] === 255) {
        payloadType += 255;
        i++;
      }
      payloadType += bytes[i++];
      while (bytes[i] === 255) {
        payloadSize += 255;
        i++;
      }
      payloadSize += bytes[i++];
      if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);
        if (userIdentifier === "GA94") {
          result.payloadType = payloadType;
          result.payloadSize = payloadSize;
          result.payload = bytes.subarray(i, i + payloadSize);
          break;
        } else {
          result.payload = void 0;
        }
      }
      i += payloadSize;
      payloadType = 0;
      payloadSize = 0;
    }
    return result;
  };
  var parseUserData = function parseUserData2(sei) {
    if (sei.payload[0] !== 181) {
      return null;
    }
    if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {
      return null;
    }
    if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== "GA94") {
      return null;
    }
    if (sei.payload[7] !== 3) {
      return null;
    }
    return sei.payload.subarray(8, sei.payload.length - 1);
  };
  var parseCaptionPackets = function parseCaptionPackets2(pts, userData) {
    var results = [], i, count2, offset3, data;
    if (!(userData[0] & 64)) {
      return results;
    }
    count2 = userData[0] & 31;
    for (i = 0; i < count2; i++) {
      offset3 = i * 3;
      data = {
        type: userData[offset3 + 2] & 3,
        pts
      };
      if (userData[offset3 + 2] & 4) {
        data.ccData = userData[offset3 + 3] << 8 | userData[offset3 + 4];
        results.push(data);
      }
    }
    return results;
  };
  var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes4(data) {
    var length2 = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
    while (i < length2 - 2) {
      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
        emulationPreventionBytesPositions.push(i + 2);
        i += 2;
      } else {
        i++;
      }
    }
    if (emulationPreventionBytesPositions.length === 0) {
      return data;
    }
    newLength = length2 - emulationPreventionBytesPositions.length;
    newData = new Uint8Array(newLength);
    var sourceIndex = 0;
    for (i = 0; i < newLength; sourceIndex++, i++) {
      if (sourceIndex === emulationPreventionBytesPositions[0]) {
        sourceIndex++;
        emulationPreventionBytesPositions.shift();
      }
      newData[i] = data[sourceIndex];
    }
    return newData;
  };
  var captionPacketParser = {
    parseSei,
    parseUserData,
    parseCaptionPackets,
    discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
    USER_DATA_REGISTERED_ITU_T_T35
  };
  var CaptionStream$1 = function CaptionStream2(options) {
    options = options || {};
    CaptionStream2.prototype.init.call(this);
    this.parse708captions_ = typeof options.parse708captions === "boolean" ? options.parse708captions : true;
    this.captionPackets_ = [];
    this.ccStreams_ = [
      new Cea608Stream(0, 0),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(0, 1),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(1, 0),
      // eslint-disable-line no-use-before-define
      new Cea608Stream(1, 1)
      // eslint-disable-line no-use-before-define
    ];
    if (this.parse708captions_) {
      this.cc708Stream_ = new Cea708Stream({
        captionServices: options.captionServices
      });
    }
    this.reset();
    this.ccStreams_.forEach(function(cc2) {
      cc2.on("data", this.trigger.bind(this, "data"));
      cc2.on("partialdone", this.trigger.bind(this, "partialdone"));
      cc2.on("done", this.trigger.bind(this, "done"));
    }, this);
    if (this.parse708captions_) {
      this.cc708Stream_.on("data", this.trigger.bind(this, "data"));
      this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone"));
      this.cc708Stream_.on("done", this.trigger.bind(this, "done"));
    }
  };
  CaptionStream$1.prototype = new stream();
  CaptionStream$1.prototype.push = function(event) {
    var sei, userData, newCaptionPackets;
    if (event.nalUnitType !== "sei_rbsp") {
      return;
    }
    sei = captionPacketParser.parseSei(event.escapedRBSP);
    if (!sei.payload) {
      return;
    }
    if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {
      return;
    }
    userData = captionPacketParser.parseUserData(sei);
    if (!userData) {
      return;
    }
    if (event.dts < this.latestDts_) {
      this.ignoreNextEqualDts_ = true;
      return;
    } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
      this.numSameDts_--;
      if (!this.numSameDts_) {
        this.ignoreNextEqualDts_ = false;
      }
      return;
    }
    newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);
    this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
    if (this.latestDts_ !== event.dts) {
      this.numSameDts_ = 0;
    }
    this.numSameDts_++;
    this.latestDts_ = event.dts;
  };
  CaptionStream$1.prototype.flushCCStreams = function(flushType) {
    this.ccStreams_.forEach(function(cc2) {
      return flushType === "flush" ? cc2.flush() : cc2.partialFlush();
    }, this);
  };
  CaptionStream$1.prototype.flushStream = function(flushType) {
    if (!this.captionPackets_.length) {
      this.flushCCStreams(flushType);
      return;
    }
    this.captionPackets_.forEach(function(elem, idx) {
      elem.presortIndex = idx;
    });
    this.captionPackets_.sort(function(a2, b2) {
      if (a2.pts === b2.pts) {
        return a2.presortIndex - b2.presortIndex;
      }
      return a2.pts - b2.pts;
    });
    this.captionPackets_.forEach(function(packet) {
      if (packet.type < 2) {
        this.dispatchCea608Packet(packet);
      } else {
        this.dispatchCea708Packet(packet);
      }
    }, this);
    this.captionPackets_.length = 0;
    this.flushCCStreams(flushType);
  };
  CaptionStream$1.prototype.flush = function() {
    return this.flushStream("flush");
  };
  CaptionStream$1.prototype.partialFlush = function() {
    return this.flushStream("partialFlush");
  };
  CaptionStream$1.prototype.reset = function() {
    this.latestDts_ = null;
    this.ignoreNextEqualDts_ = false;
    this.numSameDts_ = 0;
    this.activeCea608Channel_ = [null, null];
    this.ccStreams_.forEach(function(ccStream) {
      ccStream.reset();
    });
  };
  CaptionStream$1.prototype.dispatchCea608Packet = function(packet) {
    if (this.setsTextOrXDSActive(packet)) {
      this.activeCea608Channel_[packet.type] = null;
    } else if (this.setsChannel1Active(packet)) {
      this.activeCea608Channel_[packet.type] = 0;
    } else if (this.setsChannel2Active(packet)) {
      this.activeCea608Channel_[packet.type] = 1;
    }
    if (this.activeCea608Channel_[packet.type] === null) {
      return;
    }
    this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
  };
  CaptionStream$1.prototype.setsChannel1Active = function(packet) {
    return (packet.ccData & 30720) === 4096;
  };
  CaptionStream$1.prototype.setsChannel2Active = function(packet) {
    return (packet.ccData & 30720) === 6144;
  };
  CaptionStream$1.prototype.setsTextOrXDSActive = function(packet) {
    return (packet.ccData & 28928) === 256 || (packet.ccData & 30974) === 4138 || (packet.ccData & 30974) === 6186;
  };
  CaptionStream$1.prototype.dispatchCea708Packet = function(packet) {
    if (this.parse708captions_) {
      this.cc708Stream_.push(packet);
    }
  };
  var CHARACTER_TRANSLATION_708 = {
    127: 9834,
    // 
    4128: 32,
    // Transparent Space
    4129: 160,
    // Nob-breaking Transparent Space
    4133: 8230,
    // 
    4138: 352,
    // 
    4140: 338,
    // 
    4144: 9608,
    // 
    4145: 8216,
    // 
    4146: 8217,
    // 
    4147: 8220,
    // 
    4148: 8221,
    // 
    4149: 8226,
    // 
    4153: 8482,
    // 
    4154: 353,
    // 
    4156: 339,
    // 
    4157: 8480,
    // 
    4159: 376,
    // 
    4214: 8539,
    // 
    4215: 8540,
    // 
    4216: 8541,
    // 
    4217: 8542,
    // 
    4218: 9168,
    // 
    4219: 9124,
    // 
    4220: 9123,
    // 
    4221: 9135,
    // 
    4222: 9126,
    // 
    4223: 9121,
    // 
    4256: 12600
    //  (CC char)
  };
  var get708CharFromCode = function get708CharFromCode2(code) {
    var newCode = CHARACTER_TRANSLATION_708[code] || code;
    if (code & 4096 && code === newCode) {
      return "";
    }
    return String.fromCharCode(newCode);
  };
  var within708TextBlock = function within708TextBlock2(b2) {
    return 32 <= b2 && b2 <= 127 || 160 <= b2 && b2 <= 255;
  };
  var Cea708Window = function Cea708Window2(windowNum) {
    this.windowNum = windowNum;
    this.reset();
  };
  Cea708Window.prototype.reset = function() {
    this.clearText();
    this.pendingNewLine = false;
    this.winAttr = {};
    this.penAttr = {};
    this.penLoc = {};
    this.penColor = {};
    this.visible = 0;
    this.rowLock = 0;
    this.columnLock = 0;
    this.priority = 0;
    this.relativePositioning = 0;
    this.anchorVertical = 0;
    this.anchorHorizontal = 0;
    this.anchorPoint = 0;
    this.rowCount = 1;
    this.virtualRowCount = this.rowCount + 1;
    this.columnCount = 41;
    this.windowStyle = 0;
    this.penStyle = 0;
  };
  Cea708Window.prototype.getText = function() {
    return this.rows.join("\n");
  };
  Cea708Window.prototype.clearText = function() {
    this.rows = [""];
    this.rowIdx = 0;
  };
  Cea708Window.prototype.newLine = function(pts) {
    if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === "function") {
      this.beforeRowOverflow(pts);
    }
    if (this.rows.length > 0) {
      this.rows.push("");
      this.rowIdx++;
    }
    while (this.rows.length > this.virtualRowCount) {
      this.rows.shift();
      this.rowIdx--;
    }
  };
  Cea708Window.prototype.isEmpty = function() {
    if (this.rows.length === 0) {
      return true;
    } else if (this.rows.length === 1) {
      return this.rows[0] === "";
    }
    return false;
  };
  Cea708Window.prototype.addText = function(text) {
    this.rows[this.rowIdx] += text;
  };
  Cea708Window.prototype.backspace = function() {
    if (!this.isEmpty()) {
      var row = this.rows[this.rowIdx];
      this.rows[this.rowIdx] = row.substr(0, row.length - 1);
    }
  };
  var Cea708Service = function Cea708Service2(serviceNum, encoding, stream2) {
    this.serviceNum = serviceNum;
    this.text = "";
    this.currentWindow = new Cea708Window(-1);
    this.windows = [];
    this.stream = stream2;
    if (typeof encoding === "string") {
      this.createTextDecoder(encoding);
    }
  };
  Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
    this.startPts = pts;
    for (var win3 = 0; win3 < 8; win3++) {
      this.windows[win3] = new Cea708Window(win3);
      if (typeof beforeRowOverflow === "function") {
        this.windows[win3].beforeRowOverflow = beforeRowOverflow;
      }
    }
  };
  Cea708Service.prototype.setCurrentWindow = function(windowNum) {
    this.currentWindow = this.windows[windowNum];
  };
  Cea708Service.prototype.createTextDecoder = function(encoding) {
    if (typeof TextDecoder === "undefined") {
      this.stream.trigger("log", {
        level: "warn",
        message: "The `encoding` option is unsupported without TextDecoder support"
      });
    } else {
      try {
        this.textDecoder_ = new TextDecoder(encoding);
      } catch (error) {
        this.stream.trigger("log", {
          level: "warn",
          message: "TextDecoder could not be created with " + encoding + " encoding. " + error
        });
      }
    }
  };
  var Cea708Stream = function Cea708Stream2(options) {
    options = options || {};
    Cea708Stream2.prototype.init.call(this);
    var self2 = this;
    var captionServices = options.captionServices || {};
    var captionServiceEncodings = {};
    var serviceProps;
    Object.keys(captionServices).forEach(function(serviceName) {
      serviceProps = captionServices[serviceName];
      if (/^SERVICE/.test(serviceName)) {
        captionServiceEncodings[serviceName] = serviceProps.encoding;
      }
    });
    this.serviceEncodings = captionServiceEncodings;
    this.current708Packet = null;
    this.services = {};
    this.push = function(packet) {
      if (packet.type === 3) {
        self2.new708Packet();
        self2.add708Bytes(packet);
      } else {
        if (self2.current708Packet === null) {
          self2.new708Packet();
        }
        self2.add708Bytes(packet);
      }
    };
  };
  Cea708Stream.prototype = new stream();
  Cea708Stream.prototype.new708Packet = function() {
    if (this.current708Packet !== null) {
      this.push708Packet();
    }
    this.current708Packet = {
      data: [],
      ptsVals: []
    };
  };
  Cea708Stream.prototype.add708Bytes = function(packet) {
    var data = packet.ccData;
    var byte0 = data >>> 8;
    var byte1 = data & 255;
    this.current708Packet.ptsVals.push(packet.pts);
    this.current708Packet.data.push(byte0);
    this.current708Packet.data.push(byte1);
  };
  Cea708Stream.prototype.push708Packet = function() {
    var packet708 = this.current708Packet;
    var packetData = packet708.data;
    var serviceNum = null;
    var blockSize = null;
    var i = 0;
    var b2 = packetData[i++];
    packet708.seq = b2 >> 6;
    packet708.sizeCode = b2 & 63;
    for (; i < packetData.length; i++) {
      b2 = packetData[i++];
      serviceNum = b2 >> 5;
      blockSize = b2 & 31;
      if (serviceNum === 7 && blockSize > 0) {
        b2 = packetData[i++];
        serviceNum = b2;
      }
      this.pushServiceBlock(serviceNum, i, blockSize);
      if (blockSize > 0) {
        i += blockSize - 1;
      }
    }
  };
  Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start3, size) {
    var b2;
    var i = start3;
    var packetData = this.current708Packet.data;
    var service = this.services[serviceNum];
    if (!service) {
      service = this.initService(serviceNum, i);
    }
    for (; i < start3 + size && i < packetData.length; i++) {
      b2 = packetData[i];
      if (within708TextBlock(b2)) {
        i = this.handleText(i, service);
      } else if (b2 === 24) {
        i = this.multiByteCharacter(i, service);
      } else if (b2 === 16) {
        i = this.extendedCommands(i, service);
      } else if (128 <= b2 && b2 <= 135) {
        i = this.setCurrentWindow(i, service);
      } else if (152 <= b2 && b2 <= 159) {
        i = this.defineWindow(i, service);
      } else if (b2 === 136) {
        i = this.clearWindows(i, service);
      } else if (b2 === 140) {
        i = this.deleteWindows(i, service);
      } else if (b2 === 137) {
        i = this.displayWindows(i, service);
      } else if (b2 === 138) {
        i = this.hideWindows(i, service);
      } else if (b2 === 139) {
        i = this.toggleWindows(i, service);
      } else if (b2 === 151) {
        i = this.setWindowAttributes(i, service);
      } else if (b2 === 144) {
        i = this.setPenAttributes(i, service);
      } else if (b2 === 145) {
        i = this.setPenColor(i, service);
      } else if (b2 === 146) {
        i = this.setPenLocation(i, service);
      } else if (b2 === 143) {
        service = this.reset(i, service);
      } else if (b2 === 8) {
        service.currentWindow.backspace();
      } else if (b2 === 12) {
        service.currentWindow.clearText();
      } else if (b2 === 13) {
        service.currentWindow.pendingNewLine = true;
      } else if (b2 === 14) {
        service.currentWindow.clearText();
      } else if (b2 === 141) {
        i++;
      } else
        ;
    }
  };
  Cea708Stream.prototype.extendedCommands = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    if (within708TextBlock(b2)) {
      i = this.handleText(i, service, {
        isExtended: true
      });
    }
    return i;
  };
  Cea708Stream.prototype.getPts = function(byteIndex) {
    return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
  };
  Cea708Stream.prototype.initService = function(serviceNum, i) {
    var serviceName = "SERVICE" + serviceNum;
    var self2 = this;
    var serviceName;
    var encoding;
    if (serviceName in this.serviceEncodings) {
      encoding = this.serviceEncodings[serviceName];
    }
    this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self2);
    this.services[serviceNum].init(this.getPts(i), function(pts) {
      self2.flushDisplayed(pts, self2.services[serviceNum]);
    });
    return this.services[serviceNum];
  };
  Cea708Stream.prototype.handleText = function(i, service, options) {
    var isExtended = options && options.isExtended;
    var isMultiByte = options && options.isMultiByte;
    var packetData = this.current708Packet.data;
    var extended = isExtended ? 4096 : 0;
    var currentByte = packetData[i];
    var nextByte = packetData[i + 1];
    var win3 = service.currentWindow;
    var _char;
    var charCodeArray;
    if (service.textDecoder_ && !isExtended) {
      if (isMultiByte) {
        charCodeArray = [currentByte, nextByte];
        i++;
      } else {
        charCodeArray = [currentByte];
      }
      _char = service.textDecoder_.decode(new Uint8Array(charCodeArray));
    } else {
      _char = get708CharFromCode(extended | currentByte);
    }
    if (win3.pendingNewLine && !win3.isEmpty()) {
      win3.newLine(this.getPts(i));
    }
    win3.pendingNewLine = false;
    win3.addText(_char);
    return i;
  };
  Cea708Stream.prototype.multiByteCharacter = function(i, service) {
    var packetData = this.current708Packet.data;
    var firstByte = packetData[i + 1];
    var secondByte = packetData[i + 2];
    if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {
      i = this.handleText(++i, service, {
        isMultiByte: true
      });
    }
    return i;
  };
  Cea708Stream.prototype.setCurrentWindow = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var windowNum = b2 & 7;
    service.setCurrentWindow(windowNum);
    return i;
  };
  Cea708Stream.prototype.defineWindow = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var windowNum = b2 & 7;
    service.setCurrentWindow(windowNum);
    var win3 = service.currentWindow;
    b2 = packetData[++i];
    win3.visible = (b2 & 32) >> 5;
    win3.rowLock = (b2 & 16) >> 4;
    win3.columnLock = (b2 & 8) >> 3;
    win3.priority = b2 & 7;
    b2 = packetData[++i];
    win3.relativePositioning = (b2 & 128) >> 7;
    win3.anchorVertical = b2 & 127;
    b2 = packetData[++i];
    win3.anchorHorizontal = b2;
    b2 = packetData[++i];
    win3.anchorPoint = (b2 & 240) >> 4;
    win3.rowCount = b2 & 15;
    b2 = packetData[++i];
    win3.columnCount = b2 & 63;
    b2 = packetData[++i];
    win3.windowStyle = (b2 & 56) >> 3;
    win3.penStyle = b2 & 7;
    win3.virtualRowCount = win3.rowCount + 1;
    return i;
  };
  Cea708Stream.prototype.setWindowAttributes = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var winAttr = service.currentWindow.winAttr;
    b2 = packetData[++i];
    winAttr.fillOpacity = (b2 & 192) >> 6;
    winAttr.fillRed = (b2 & 48) >> 4;
    winAttr.fillGreen = (b2 & 12) >> 2;
    winAttr.fillBlue = b2 & 3;
    b2 = packetData[++i];
    winAttr.borderType = (b2 & 192) >> 6;
    winAttr.borderRed = (b2 & 48) >> 4;
    winAttr.borderGreen = (b2 & 12) >> 2;
    winAttr.borderBlue = b2 & 3;
    b2 = packetData[++i];
    winAttr.borderType += (b2 & 128) >> 5;
    winAttr.wordWrap = (b2 & 64) >> 6;
    winAttr.printDirection = (b2 & 48) >> 4;
    winAttr.scrollDirection = (b2 & 12) >> 2;
    winAttr.justify = b2 & 3;
    b2 = packetData[++i];
    winAttr.effectSpeed = (b2 & 240) >> 4;
    winAttr.effectDirection = (b2 & 12) >> 2;
    winAttr.displayEffect = b2 & 3;
    return i;
  };
  Cea708Stream.prototype.flushDisplayed = function(pts, service) {
    var displayedText = [];
    for (var winId = 0; winId < 8; winId++) {
      if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {
        displayedText.push(service.windows[winId].getText());
      }
    }
    service.endPts = pts;
    service.text = displayedText.join("\n\n");
    this.pushCaption(service);
    service.startPts = pts;
  };
  Cea708Stream.prototype.pushCaption = function(service) {
    if (service.text !== "") {
      this.trigger("data", {
        startPts: service.startPts,
        endPts: service.endPts,
        text: service.text,
        stream: "cc708_" + service.serviceNum
      });
      service.text = "";
      service.startPts = service.endPts;
    }
  };
  Cea708Stream.prototype.displayWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].visible = 1;
      }
    }
    return i;
  };
  Cea708Stream.prototype.hideWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].visible = 0;
      }
    }
    return i;
  };
  Cea708Stream.prototype.toggleWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].visible ^= 1;
      }
    }
    return i;
  };
  Cea708Stream.prototype.clearWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].clearText();
      }
    }
    return i;
  };
  Cea708Stream.prototype.deleteWindows = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[++i];
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    for (var winId = 0; winId < 8; winId++) {
      if (b2 & 1 << winId) {
        service.windows[winId].reset();
      }
    }
    return i;
  };
  Cea708Stream.prototype.setPenAttributes = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var penAttr = service.currentWindow.penAttr;
    b2 = packetData[++i];
    penAttr.textTag = (b2 & 240) >> 4;
    penAttr.offset = (b2 & 12) >> 2;
    penAttr.penSize = b2 & 3;
    b2 = packetData[++i];
    penAttr.italics = (b2 & 128) >> 7;
    penAttr.underline = (b2 & 64) >> 6;
    penAttr.edgeType = (b2 & 56) >> 3;
    penAttr.fontStyle = b2 & 7;
    return i;
  };
  Cea708Stream.prototype.setPenColor = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var penColor = service.currentWindow.penColor;
    b2 = packetData[++i];
    penColor.fgOpacity = (b2 & 192) >> 6;
    penColor.fgRed = (b2 & 48) >> 4;
    penColor.fgGreen = (b2 & 12) >> 2;
    penColor.fgBlue = b2 & 3;
    b2 = packetData[++i];
    penColor.bgOpacity = (b2 & 192) >> 6;
    penColor.bgRed = (b2 & 48) >> 4;
    penColor.bgGreen = (b2 & 12) >> 2;
    penColor.bgBlue = b2 & 3;
    b2 = packetData[++i];
    penColor.edgeRed = (b2 & 48) >> 4;
    penColor.edgeGreen = (b2 & 12) >> 2;
    penColor.edgeBlue = b2 & 3;
    return i;
  };
  Cea708Stream.prototype.setPenLocation = function(i, service) {
    var packetData = this.current708Packet.data;
    var b2 = packetData[i];
    var penLoc = service.currentWindow.penLoc;
    service.currentWindow.pendingNewLine = true;
    b2 = packetData[++i];
    penLoc.row = b2 & 15;
    b2 = packetData[++i];
    penLoc.column = b2 & 63;
    return i;
  };
  Cea708Stream.prototype.reset = function(i, service) {
    var pts = this.getPts(i);
    this.flushDisplayed(pts, service);
    return this.initService(service.serviceNum, i);
  };
  var CHARACTER_TRANSLATION = {
    42: 225,
    // 
    92: 233,
    // 
    94: 237,
    // 
    95: 243,
    // 
    96: 250,
    // 
    123: 231,
    // 
    124: 247,
    // 
    125: 209,
    // 
    126: 241,
    // 
    127: 9608,
    // 
    304: 174,
    // 
    305: 176,
    // 
    306: 189,
    // 
    307: 191,
    // 
    308: 8482,
    // 
    309: 162,
    // 
    310: 163,
    // 
    311: 9834,
    // 
    312: 224,
    // 
    313: 160,
    //
    314: 232,
    // 
    315: 226,
    // 
    316: 234,
    // 
    317: 238,
    // 
    318: 244,
    // 
    319: 251,
    // 
    544: 193,
    // 
    545: 201,
    // 
    546: 211,
    // 
    547: 218,
    // 
    548: 220,
    // 
    549: 252,
    // 
    550: 8216,
    // 
    551: 161,
    // 
    552: 42,
    // *
    553: 39,
    // '
    554: 8212,
    // 
    555: 169,
    // 
    556: 8480,
    // 
    557: 8226,
    // 
    558: 8220,
    // 
    559: 8221,
    // 
    560: 192,
    // 
    561: 194,
    // 
    562: 199,
    // 
    563: 200,
    // 
    564: 202,
    // 
    565: 203,
    // 
    566: 235,
    // 
    567: 206,
    // 
    568: 207,
    // 
    569: 239,
    // 
    570: 212,
    // 
    571: 217,
    // 
    572: 249,
    // 
    573: 219,
    // 
    574: 171,
    // 
    575: 187,
    // 
    800: 195,
    // 
    801: 227,
    // 
    802: 205,
    // 
    803: 204,
    // 
    804: 236,
    // 
    805: 210,
    // 
    806: 242,
    // 
    807: 213,
    // 
    808: 245,
    // 
    809: 123,
    // {
    810: 125,
    // }
    811: 92,
    // \
    812: 94,
    // ^
    813: 95,
    // _
    814: 124,
    // |
    815: 126,
    // ~
    816: 196,
    // 
    817: 228,
    // 
    818: 214,
    // 
    819: 246,
    // 
    820: 223,
    // 
    821: 165,
    // 
    822: 164,
    // 
    823: 9474,
    // 
    824: 197,
    // 
    825: 229,
    // 
    826: 216,
    // 
    827: 248,
    // 
    828: 9484,
    // 
    829: 9488,
    // 
    830: 9492,
    // 
    831: 9496
    // 
  };
  var getCharFromCode = function getCharFromCode2(code) {
    if (code === null) {
      return "";
    }
    code = CHARACTER_TRANSLATION[code] || code;
    return String.fromCharCode(code);
  };
  var BOTTOM_ROW = 14;
  var ROWS = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152];
  var createDisplayBuffer = function createDisplayBuffer2() {
    var result = [], i = BOTTOM_ROW + 1;
    while (i--) {
      result.push("");
    }
    return result;
  };
  var Cea608Stream = function Cea608Stream2(field, dataChannel) {
    Cea608Stream2.prototype.init.call(this);
    this.field_ = field || 0;
    this.dataChannel_ = dataChannel || 0;
    this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1);
    this.setConstants();
    this.reset();
    this.push = function(packet) {
      var data, swap, char0, char1, text;
      data = packet.ccData & 32639;
      if (data === this.lastControlCode_) {
        this.lastControlCode_ = null;
        return;
      }
      if ((data & 61440) === 4096) {
        this.lastControlCode_ = data;
      } else if (data !== this.PADDING_) {
        this.lastControlCode_ = null;
      }
      char0 = data >>> 8;
      char1 = data & 255;
      if (data === this.PADDING_) {
        return;
      } else if (data === this.RESUME_CAPTION_LOADING_) {
        this.mode_ = "popOn";
      } else if (data === this.END_OF_CAPTION_) {
        this.mode_ = "popOn";
        this.clearFormatting(packet.pts);
        this.flushDisplayed(packet.pts);
        swap = this.displayed_;
        this.displayed_ = this.nonDisplayed_;
        this.nonDisplayed_ = swap;
        this.startPts_ = packet.pts;
      } else if (data === this.ROLL_UP_2_ROWS_) {
        this.rollUpRows_ = 2;
        this.setRollUp(packet.pts);
      } else if (data === this.ROLL_UP_3_ROWS_) {
        this.rollUpRows_ = 3;
        this.setRollUp(packet.pts);
      } else if (data === this.ROLL_UP_4_ROWS_) {
        this.rollUpRows_ = 4;
        this.setRollUp(packet.pts);
      } else if (data === this.CARRIAGE_RETURN_) {
        this.clearFormatting(packet.pts);
        this.flushDisplayed(packet.pts);
        this.shiftRowsUp_();
        this.startPts_ = packet.pts;
      } else if (data === this.BACKSPACE_) {
        if (this.mode_ === "popOn") {
          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
        } else {
          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
        }
      } else if (data === this.ERASE_DISPLAYED_MEMORY_) {
        this.flushDisplayed(packet.pts);
        this.displayed_ = createDisplayBuffer();
      } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {
        this.nonDisplayed_ = createDisplayBuffer();
      } else if (data === this.RESUME_DIRECT_CAPTIONING_) {
        if (this.mode_ !== "paintOn") {
          this.flushDisplayed(packet.pts);
          this.displayed_ = createDisplayBuffer();
        }
        this.mode_ = "paintOn";
        this.startPts_ = packet.pts;
      } else if (this.isSpecialCharacter(char0, char1)) {
        char0 = (char0 & 3) << 8;
        text = getCharFromCode(char0 | char1);
        this[this.mode_](packet.pts, text);
        this.column_++;
      } else if (this.isExtCharacter(char0, char1)) {
        if (this.mode_ === "popOn") {
          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);
        } else {
          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
        }
        char0 = (char0 & 3) << 8;
        text = getCharFromCode(char0 | char1);
        this[this.mode_](packet.pts, text);
        this.column_++;
      } else if (this.isMidRowCode(char0, char1)) {
        this.clearFormatting(packet.pts);
        this[this.mode_](packet.pts, " ");
        this.column_++;
        if ((char1 & 14) === 14) {
          this.addFormatting(packet.pts, ["i"]);
        }
        if ((char1 & 1) === 1) {
          this.addFormatting(packet.pts, ["u"]);
        }
      } else if (this.isOffsetControlCode(char0, char1)) {
        this.column_ += char1 & 3;
      } else if (this.isPAC(char0, char1)) {
        var row = ROWS.indexOf(data & 7968);
        if (this.mode_ === "rollUp") {
          if (row - this.rollUpRows_ + 1 < 0) {
            row = this.rollUpRows_ - 1;
          }
          this.setRollUp(packet.pts, row);
        }
        if (row !== this.row_) {
          this.clearFormatting(packet.pts);
          this.row_ = row;
        }
        if (char1 & 1 && this.formatting_.indexOf("u") === -1) {
          this.addFormatting(packet.pts, ["u"]);
        }
        if ((data & 16) === 16) {
          this.column_ = ((data & 14) >> 1) * 4;
        }
        if (this.isColorPAC(char1)) {
          if ((char1 & 14) === 14) {
            this.addFormatting(packet.pts, ["i"]);
          }
        }
      } else if (this.isNormalChar(char0)) {
        if (char1 === 0) {
          char1 = null;
        }
        text = getCharFromCode(char0);
        text += getCharFromCode(char1);
        this[this.mode_](packet.pts, text);
        this.column_ += text.length;
      }
    };
  };
  Cea608Stream.prototype = new stream();
  Cea608Stream.prototype.flushDisplayed = function(pts) {
    var content = this.displayed_.map(function(row, index2) {
      try {
        return row.trim();
      } catch (e2) {
        this.trigger("log", {
          level: "warn",
          message: "Skipping a malformed 608 caption at index " + index2 + "."
        });
        return "";
      }
    }, this).join("\n").replace(/^\n+|\n+$/g, "");
    if (content.length) {
      this.trigger("data", {
        startPts: this.startPts_,
        endPts: pts,
        text: content,
        stream: this.name_
      });
    }
  };
  Cea608Stream.prototype.reset = function() {
    this.mode_ = "popOn";
    this.topRow_ = 0;
    this.startPts_ = 0;
    this.displayed_ = createDisplayBuffer();
    this.nonDisplayed_ = createDisplayBuffer();
    this.lastControlCode_ = null;
    this.column_ = 0;
    this.row_ = BOTTOM_ROW;
    this.rollUpRows_ = 2;
    this.formatting_ = [];
  };
  Cea608Stream.prototype.setConstants = function() {
    if (this.dataChannel_ === 0) {
      this.BASE_ = 16;
      this.EXT_ = 17;
      this.CONTROL_ = (20 | this.field_) << 8;
      this.OFFSET_ = 23;
    } else if (this.dataChannel_ === 1) {
      this.BASE_ = 24;
      this.EXT_ = 25;
      this.CONTROL_ = (28 | this.field_) << 8;
      this.OFFSET_ = 31;
    }
    this.PADDING_ = 0;
    this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32;
    this.END_OF_CAPTION_ = this.CONTROL_ | 47;
    this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37;
    this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38;
    this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39;
    this.CARRIAGE_RETURN_ = this.CONTROL_ | 45;
    this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41;
    this.BACKSPACE_ = this.CONTROL_ | 33;
    this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44;
    this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
  };
  Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
    return char0 === this.EXT_ && char1 >= 48 && char1 <= 63;
  };
  Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
    return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 32 && char1 <= 63;
  };
  Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
    return char0 === this.EXT_ && char1 >= 32 && char1 <= 47;
  };
  Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
    return char0 === this.OFFSET_ && char1 >= 33 && char1 <= 35;
  };
  Cea608Stream.prototype.isPAC = function(char0, char1) {
    return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 64 && char1 <= 127;
  };
  Cea608Stream.prototype.isColorPAC = function(char1) {
    return char1 >= 64 && char1 <= 79 || char1 >= 96 && char1 <= 127;
  };
  Cea608Stream.prototype.isNormalChar = function(_char2) {
    return _char2 >= 32 && _char2 <= 127;
  };
  Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
    if (this.mode_ !== "rollUp") {
      this.row_ = BOTTOM_ROW;
      this.mode_ = "rollUp";
      this.flushDisplayed(pts);
      this.nonDisplayed_ = createDisplayBuffer();
      this.displayed_ = createDisplayBuffer();
    }
    if (newBaseRow !== void 0 && newBaseRow !== this.row_) {
      for (var i = 0; i < this.rollUpRows_; i++) {
        this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];
        this.displayed_[this.row_ - i] = "";
      }
    }
    if (newBaseRow === void 0) {
      newBaseRow = this.row_;
    }
    this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
  };
  Cea608Stream.prototype.addFormatting = function(pts, format) {
    this.formatting_ = this.formatting_.concat(format);
    var text = format.reduce(function(text2, format2) {
      return text2 + "<" + format2 + ">";
    }, "");
    this[this.mode_](pts, text);
  };
  Cea608Stream.prototype.clearFormatting = function(pts) {
    if (!this.formatting_.length) {
      return;
    }
    var text = this.formatting_.reverse().reduce(function(text2, format) {
      return text2 + "</" + format + ">";
    }, "");
    this.formatting_ = [];
    this[this.mode_](pts, text);
  };
  Cea608Stream.prototype.popOn = function(pts, text) {
    var baseRow = this.nonDisplayed_[this.row_];
    baseRow += text;
    this.nonDisplayed_[this.row_] = baseRow;
  };
  Cea608Stream.prototype.rollUp = function(pts, text) {
    var baseRow = this.displayed_[this.row_];
    baseRow += text;
    this.displayed_[this.row_] = baseRow;
  };
  Cea608Stream.prototype.shiftRowsUp_ = function() {
    var i;
    for (i = 0; i < this.topRow_; i++) {
      this.displayed_[i] = "";
    }
    for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {
      this.displayed_[i] = "";
    }
    for (i = this.topRow_; i < this.row_; i++) {
      this.displayed_[i] = this.displayed_[i + 1];
    }
    this.displayed_[this.row_] = "";
  };
  Cea608Stream.prototype.paintOn = function(pts, text) {
    var baseRow = this.displayed_[this.row_];
    baseRow += text;
    this.displayed_[this.row_] = baseRow;
  };
  var captionStream = {
    CaptionStream: CaptionStream$1,
    Cea608Stream,
    Cea708Stream
  };
  var streamTypes = {
    H264_STREAM_TYPE: 27,
    ADTS_STREAM_TYPE: 15,
    METADATA_STREAM_TYPE: 21
  };
  var MAX_TS = 8589934592;
  var RO_THRESH = 4294967296;
  var TYPE_SHARED = "shared";
  var handleRollover$1 = function handleRollover2(value, reference2) {
    var direction = 1;
    if (value > reference2) {
      direction = -1;
    }
    while (Math.abs(reference2 - value) > RO_THRESH) {
      value += direction * MAX_TS;
    }
    return value;
  };
  var TimestampRolloverStream$1 = function TimestampRolloverStream2(type3) {
    var lastDTS, referenceDTS;
    TimestampRolloverStream2.prototype.init.call(this);
    this.type_ = type3 || TYPE_SHARED;
    this.push = function(data) {
      if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {
        return;
      }
      if (referenceDTS === void 0) {
        referenceDTS = data.dts;
      }
      data.dts = handleRollover$1(data.dts, referenceDTS);
      data.pts = handleRollover$1(data.pts, referenceDTS);
      lastDTS = data.dts;
      this.trigger("data", data);
    };
    this.flush = function() {
      referenceDTS = lastDTS;
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
    this.discontinuity = function() {
      referenceDTS = void 0;
      lastDTS = void 0;
    };
    this.reset = function() {
      this.discontinuity();
      this.trigger("reset");
    };
  };
  TimestampRolloverStream$1.prototype = new stream();
  var timestampRolloverStream = {
    TimestampRolloverStream: TimestampRolloverStream$1,
    handleRollover: handleRollover$1
  };
  var percentEncode$1 = function percentEncode2(bytes, start3, end2) {
    var i, result = "";
    for (i = start3; i < end2; i++) {
      result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
    }
    return result;
  }, parseUtf8 = function parseUtf82(bytes, start3, end2) {
    return decodeURIComponent(percentEncode$1(bytes, start3, end2));
  }, parseIso88591$1 = function parseIso885912(bytes, start3, end2) {
    return unescape(percentEncode$1(bytes, start3, end2));
  }, parseSyncSafeInteger$1 = function parseSyncSafeInteger2(data) {
    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
  }, tagParsers = {
    TXXX: function TXXX(tag) {
      var i;
      if (tag.data[0] !== 3) {
        return;
      }
      for (i = 1; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.description = parseUtf8(tag.data, 1, i);
          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\0*$/, "");
          break;
        }
      }
      tag.data = tag.value;
    },
    WXXX: function WXXX(tag) {
      var i;
      if (tag.data[0] !== 3) {
        return;
      }
      for (i = 1; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.description = parseUtf8(tag.data, 1, i);
          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);
          break;
        }
      }
    },
    PRIV: function PRIV(tag) {
      var i;
      for (i = 0; i < tag.data.length; i++) {
        if (tag.data[i] === 0) {
          tag.owner = parseIso88591$1(tag.data, 0, i);
          break;
        }
      }
      tag.privateData = tag.data.subarray(i + 1);
      tag.data = tag.privateData;
    }
  }, _MetadataStream;
  _MetadataStream = function MetadataStream(options) {
    var settings = {
      // the bytes of the program-level descriptor field in MP2T
      // see ISO/IEC 13818-1:2013 (E), section 2.6 "Program and
      // program element descriptors"
      descriptor: options && options.descriptor
    }, tagSize = 0, buffer = [], bufferSize = 0, i;
    _MetadataStream.prototype.init.call(this);
    this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);
    if (settings.descriptor) {
      for (i = 0; i < settings.descriptor.length; i++) {
        this.dispatchType += ("00" + settings.descriptor[i].toString(16)).slice(-2);
      }
    }
    this.push = function(chunk) {
      var tag, frameStart, frameSize, frame, i2, frameHeader;
      if (chunk.type !== "timed-metadata") {
        return;
      }
      if (chunk.dataAlignmentIndicator) {
        bufferSize = 0;
        buffer.length = 0;
      }
      if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== "I".charCodeAt(0) || chunk.data[1] !== "D".charCodeAt(0) || chunk.data[2] !== "3".charCodeAt(0))) {
        this.trigger("log", {
          level: "warn",
          message: "Skipping unrecognized metadata packet"
        });
        return;
      }
      buffer.push(chunk);
      bufferSize += chunk.data.byteLength;
      if (buffer.length === 1) {
        tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10));
        tagSize += 10;
      }
      if (bufferSize < tagSize) {
        return;
      }
      tag = {
        data: new Uint8Array(tagSize),
        frames: [],
        pts: buffer[0].pts,
        dts: buffer[0].dts
      };
      for (i2 = 0; i2 < tagSize; ) {
        tag.data.set(buffer[0].data.subarray(0, tagSize - i2), i2);
        i2 += buffer[0].data.byteLength;
        bufferSize -= buffer[0].data.byteLength;
        buffer.shift();
      }
      frameStart = 10;
      if (tag.data[5] & 64) {
        frameStart += 4;
        frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14));
        tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));
      }
      do {
        frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));
        if (frameSize < 1) {
          this.trigger("log", {
            level: "warn",
            message: "Malformed ID3 frame encountered. Skipping metadata parsing."
          });
          return;
        }
        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
        frame = {
          id: frameHeader,
          data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
        };
        frame.key = frame.id;
        if (tagParsers[frame.id]) {
          tagParsers[frame.id](frame);
          if (frame.owner === "com.apple.streaming.transportStreamTimestamp") {
            var d3 = frame.data, size = (d3[3] & 1) << 30 | d3[4] << 22 | d3[5] << 14 | d3[6] << 6 | d3[7] >>> 2;
            size *= 4;
            size += d3[7] & 3;
            frame.timeStamp = size;
            if (tag.pts === void 0 && tag.dts === void 0) {
              tag.pts = frame.timeStamp;
              tag.dts = frame.timeStamp;
            }
            this.trigger("timestamp", frame);
          }
        }
        tag.frames.push(frame);
        frameStart += 10;
        frameStart += frameSize;
      } while (frameStart < tagSize);
      this.trigger("data", tag);
    };
  };
  _MetadataStream.prototype = new stream();
  var metadataStream = _MetadataStream;
  var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
  var _TransportPacketStream, _TransportParseStream, _ElementaryStream;
  var MP2T_PACKET_LENGTH$1 = 188, SYNC_BYTE$1 = 71;
  _TransportPacketStream = function TransportPacketStream() {
    var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1), bytesInBuffer = 0;
    _TransportPacketStream.prototype.init.call(this);
    this.push = function(bytes) {
      var startIndex = 0, endIndex = MP2T_PACKET_LENGTH$1, everything;
      if (bytesInBuffer) {
        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
        everything.set(buffer.subarray(0, bytesInBuffer));
        everything.set(bytes, bytesInBuffer);
        bytesInBuffer = 0;
      } else {
        everything = bytes;
      }
      while (endIndex < everything.byteLength) {
        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
          this.trigger("data", everything.subarray(startIndex, endIndex));
          startIndex += MP2T_PACKET_LENGTH$1;
          endIndex += MP2T_PACKET_LENGTH$1;
          continue;
        }
        startIndex++;
        endIndex++;
      }
      if (startIndex < everything.byteLength) {
        buffer.set(everything.subarray(startIndex), 0);
        bytesInBuffer = everything.byteLength - startIndex;
      }
    };
    this.flush = function() {
      if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
        this.trigger("data", buffer);
        bytesInBuffer = 0;
      }
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
    this.reset = function() {
      bytesInBuffer = 0;
      this.trigger("reset");
    };
  };
  _TransportPacketStream.prototype = new stream();
  _TransportParseStream = function TransportParseStream() {
    var parsePsi, parsePat2, parsePmt2, self2;
    _TransportParseStream.prototype.init.call(this);
    self2 = this;
    this.packetsWaitingForPmt = [];
    this.programMapTable = void 0;
    parsePsi = function parsePsi2(payload, psi) {
      var offset3 = 0;
      if (psi.payloadUnitStartIndicator) {
        offset3 += payload[offset3] + 1;
      }
      if (psi.type === "pat") {
        parsePat2(payload.subarray(offset3), psi);
      } else {
        parsePmt2(payload.subarray(offset3), psi);
      }
    };
    parsePat2 = function parsePat3(payload, pat) {
      pat.section_number = payload[7];
      pat.last_section_number = payload[8];
      self2.pmtPid = (payload[10] & 31) << 8 | payload[11];
      pat.pmtPid = self2.pmtPid;
    };
    parsePmt2 = function parsePmt3(payload, pmt) {
      var sectionLength, tableEnd, programInfoLength, offset3;
      if (!(payload[5] & 1)) {
        return;
      }
      self2.programMapTable = {
        video: null,
        audio: null,
        "timed-metadata": {}
      };
      sectionLength = (payload[1] & 15) << 8 | payload[2];
      tableEnd = 3 + sectionLength - 4;
      programInfoLength = (payload[10] & 15) << 8 | payload[11];
      offset3 = 12 + programInfoLength;
      while (offset3 < tableEnd) {
        var streamType = payload[offset3];
        var pid = (payload[offset3 + 1] & 31) << 8 | payload[offset3 + 2];
        if (streamType === streamTypes.H264_STREAM_TYPE && self2.programMapTable.video === null) {
          self2.programMapTable.video = pid;
        } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self2.programMapTable.audio === null) {
          self2.programMapTable.audio = pid;
        } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {
          self2.programMapTable["timed-metadata"][pid] = streamType;
        }
        offset3 += ((payload[offset3 + 3] & 15) << 8 | payload[offset3 + 4]) + 5;
      }
      pmt.programMapTable = self2.programMapTable;
    };
    this.push = function(packet) {
      var result = {}, offset3 = 4;
      result.payloadUnitStartIndicator = !!(packet[1] & 64);
      result.pid = packet[1] & 31;
      result.pid <<= 8;
      result.pid |= packet[2];
      if ((packet[3] & 48) >>> 4 > 1) {
        offset3 += packet[offset3] + 1;
      }
      if (result.pid === 0) {
        result.type = "pat";
        parsePsi(packet.subarray(offset3), result);
        this.trigger("data", result);
      } else if (result.pid === this.pmtPid) {
        result.type = "pmt";
        parsePsi(packet.subarray(offset3), result);
        this.trigger("data", result);
        while (this.packetsWaitingForPmt.length) {
          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
        }
      } else if (this.programMapTable === void 0) {
        this.packetsWaitingForPmt.push([packet, offset3, result]);
      } else {
        this.processPes_(packet, offset3, result);
      }
    };
    this.processPes_ = function(packet, offset3, result) {
      if (result.pid === this.programMapTable.video) {
        result.streamType = streamTypes.H264_STREAM_TYPE;
      } else if (result.pid === this.programMapTable.audio) {
        result.streamType = streamTypes.ADTS_STREAM_TYPE;
      } else {
        result.streamType = this.programMapTable["timed-metadata"][result.pid];
      }
      result.type = "pes";
      result.data = packet.subarray(offset3);
      this.trigger("data", result);
    };
  };
  _TransportParseStream.prototype = new stream();
  _TransportParseStream.STREAM_TYPES = {
    h264: 27,
    adts: 15
  };
  _ElementaryStream = function ElementaryStream() {
    var self2 = this, segmentHadPmt = false, video2 = {
      data: [],
      size: 0
    }, audio = {
      data: [],
      size: 0
    }, timedMetadata = {
      data: [],
      size: 0
    }, programMapTable, parsePes = function parsePes2(payload, pes) {
      var ptsDtsFlags;
      var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
      pes.data = new Uint8Array();
      if (startPrefix !== 1) {
        return;
      }
      pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
      pes.dataAlignmentIndicator = (payload[6] & 4) !== 0;
      ptsDtsFlags = payload[7];
      if (ptsDtsFlags & 192) {
        pes.pts = (payload[9] & 14) << 27 | (payload[10] & 255) << 20 | (payload[11] & 254) << 12 | (payload[12] & 255) << 5 | (payload[13] & 254) >>> 3;
        pes.pts *= 4;
        pes.pts += (payload[13] & 6) >>> 1;
        pes.dts = pes.pts;
        if (ptsDtsFlags & 64) {
          pes.dts = (payload[14] & 14) << 27 | (payload[15] & 255) << 20 | (payload[16] & 254) << 12 | (payload[17] & 255) << 5 | (payload[18] & 254) >>> 3;
          pes.dts *= 4;
          pes.dts += (payload[18] & 6) >>> 1;
        }
      }
      pes.data = payload.subarray(9 + payload[8]);
    }, flushStream = function flushStream2(stream2, type3, forceFlush) {
      var packetData = new Uint8Array(stream2.size), event = {
        type: type3
      }, i = 0, offset3 = 0, packetFlushable = false, fragment;
      if (!stream2.data.length || stream2.size < 9) {
        return;
      }
      event.trackId = stream2.data[0].pid;
      for (i = 0; i < stream2.data.length; i++) {
        fragment = stream2.data[i];
        packetData.set(fragment.data, offset3);
        offset3 += fragment.data.byteLength;
      }
      parsePes(packetData, event);
      packetFlushable = type3 === "video" || event.packetLength <= stream2.size;
      if (forceFlush || packetFlushable) {
        stream2.size = 0;
        stream2.data.length = 0;
      }
      if (packetFlushable) {
        self2.trigger("data", event);
      }
    };
    _ElementaryStream.prototype.init.call(this);
    this.push = function(data) {
      ({
        pat: function pat() {
        },
        pes: function pes() {
          var stream2, streamType;
          switch (data.streamType) {
            case streamTypes.H264_STREAM_TYPE:
              stream2 = video2;
              streamType = "video";
              break;
            case streamTypes.ADTS_STREAM_TYPE:
              stream2 = audio;
              streamType = "audio";
              break;
            case streamTypes.METADATA_STREAM_TYPE:
              stream2 = timedMetadata;
              streamType = "timed-metadata";
              break;
            default:
              return;
          }
          if (data.payloadUnitStartIndicator) {
            flushStream(stream2, streamType, true);
          }
          stream2.data.push(data);
          stream2.size += data.data.byteLength;
        },
        pmt: function pmt() {
          var event = {
            type: "metadata",
            tracks: []
          };
          programMapTable = data.programMapTable;
          if (programMapTable.video !== null) {
            event.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.video,
              codec: "avc",
              type: "video"
            });
          }
          if (programMapTable.audio !== null) {
            event.tracks.push({
              timelineStartInfo: {
                baseMediaDecodeTime: 0
              },
              id: +programMapTable.audio,
              codec: "adts",
              type: "audio"
            });
          }
          segmentHadPmt = true;
          self2.trigger("data", event);
        }
      })[data.type]();
    };
    this.reset = function() {
      video2.size = 0;
      video2.data.length = 0;
      audio.size = 0;
      audio.data.length = 0;
      this.trigger("reset");
    };
    this.flushStreams_ = function() {
      flushStream(video2, "video");
      flushStream(audio, "audio");
      flushStream(timedMetadata, "timed-metadata");
    };
    this.flush = function() {
      if (!segmentHadPmt && programMapTable) {
        var pmt = {
          type: "metadata",
          tracks: []
        };
        if (programMapTable.video !== null) {
          pmt.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +programMapTable.video,
            codec: "avc",
            type: "video"
          });
        }
        if (programMapTable.audio !== null) {
          pmt.tracks.push({
            timelineStartInfo: {
              baseMediaDecodeTime: 0
            },
            id: +programMapTable.audio,
            codec: "adts",
            type: "audio"
          });
        }
        self2.trigger("data", pmt);
      }
      segmentHadPmt = false;
      this.flushStreams_();
      this.trigger("done");
    };
  };
  _ElementaryStream.prototype = new stream();
  var m2ts = {
    PAT_PID: 0,
    MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
    TransportPacketStream: _TransportPacketStream,
    TransportParseStream: _TransportParseStream,
    ElementaryStream: _ElementaryStream,
    TimestampRolloverStream,
    CaptionStream: captionStream.CaptionStream,
    Cea608Stream: captionStream.Cea608Stream,
    Cea708Stream: captionStream.Cea708Stream,
    MetadataStream: metadataStream
  };
  for (var type2 in streamTypes) {
    if (streamTypes.hasOwnProperty(type2)) {
      m2ts[type2] = streamTypes[type2];
    }
  }
  var m2ts_1 = m2ts;
  var ONE_SECOND_IN_TS$2 = clock2.ONE_SECOND_IN_TS;
  var _AdtsStream;
  var ADTS_SAMPLING_FREQUENCIES$1 = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  _AdtsStream = function AdtsStream(handlePartialSegments) {
    var buffer, frameNum = 0;
    _AdtsStream.prototype.init.call(this);
    this.skipWarn_ = function(start3, end2) {
      this.trigger("log", {
        level: "warn",
        message: "adts skiping bytes " + start3 + " to " + end2 + " in frame " + frameNum + " outside syncword"
      });
    };
    this.push = function(packet) {
      var i = 0, frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration;
      if (!handlePartialSegments) {
        frameNum = 0;
      }
      if (packet.type !== "audio") {
        return;
      }
      if (buffer && buffer.length) {
        oldBuffer = buffer;
        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
        buffer.set(oldBuffer);
        buffer.set(packet.data, oldBuffer.byteLength);
      } else {
        buffer = packet.data;
      }
      var skip;
      while (i + 7 < buffer.length) {
        if (buffer[i] !== 255 || (buffer[i + 1] & 246) !== 240) {
          if (typeof skip !== "number") {
            skip = i;
          }
          i++;
          continue;
        }
        if (typeof skip === "number") {
          this.skipWarn_(skip, i);
          skip = null;
        }
        protectionSkipBytes = (~buffer[i + 1] & 1) * 2;
        frameLength = (buffer[i + 3] & 3) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 224) >> 5;
        sampleCount = ((buffer[i + 6] & 3) + 1) * 1024;
        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2];
        if (buffer.byteLength - i < frameLength) {
          break;
        }
        this.trigger("data", {
          pts: packet.pts + frameNum * adtsFrameDuration,
          dts: packet.dts + frameNum * adtsFrameDuration,
          sampleCount,
          audioobjecttype: (buffer[i + 2] >>> 6 & 3) + 1,
          channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 192) >>> 6,
          samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2],
          samplingfrequencyindex: (buffer[i + 2] & 60) >>> 2,
          // assume ISO/IEC 14496-12 AudioSampleEntry default of 16
          samplesize: 16,
          // data is the frame without it's header
          data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
        });
        frameNum++;
        i += frameLength;
      }
      if (typeof skip === "number") {
        this.skipWarn_(skip, i);
        skip = null;
      }
      buffer = buffer.subarray(i);
    };
    this.flush = function() {
      frameNum = 0;
      this.trigger("done");
    };
    this.reset = function() {
      buffer = void 0;
      this.trigger("reset");
    };
    this.endTimeline = function() {
      buffer = void 0;
      this.trigger("endedtimeline");
    };
  };
  _AdtsStream.prototype = new stream();
  var adts = _AdtsStream;
  var ExpGolomb;
  ExpGolomb = function ExpGolomb2(workingData) {
    var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
    this.length = function() {
      return 8 * workingBytesAvailable;
    };
    this.bitsAvailable = function() {
      return 8 * workingBytesAvailable + workingBitsAvailable;
    };
    this.loadWord = function() {
      var position3 = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
      if (availableBytes === 0) {
        throw new Error("no bytes available");
      }
      workingBytes.set(workingData.subarray(position3, position3 + availableBytes));
      workingWord = new DataView(workingBytes.buffer).getUint32(0);
      workingBitsAvailable = availableBytes * 8;
      workingBytesAvailable -= availableBytes;
    };
    this.skipBits = function(count2) {
      var skipBytes;
      if (workingBitsAvailable > count2) {
        workingWord <<= count2;
        workingBitsAvailable -= count2;
      } else {
        count2 -= workingBitsAvailable;
        skipBytes = Math.floor(count2 / 8);
        count2 -= skipBytes * 8;
        workingBytesAvailable -= skipBytes;
        this.loadWord();
        workingWord <<= count2;
        workingBitsAvailable -= count2;
      }
    };
    this.readBits = function(size) {
      var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
      workingBitsAvailable -= bits;
      if (workingBitsAvailable > 0) {
        workingWord <<= bits;
      } else if (workingBytesAvailable > 0) {
        this.loadWord();
      }
      bits = size - bits;
      if (bits > 0) {
        return valu << bits | this.readBits(bits);
      }
      return valu;
    };
    this.skipLeadingZeros = function() {
      var leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {
        if ((workingWord & 2147483648 >>> leadingZeroCount) !== 0) {
          workingWord <<= leadingZeroCount;
          workingBitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this.loadWord();
      return leadingZeroCount + this.skipLeadingZeros();
    };
    this.skipUnsignedExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    };
    this.skipExpGolomb = function() {
      this.skipBits(1 + this.skipLeadingZeros());
    };
    this.readUnsignedExpGolomb = function() {
      var clz = this.skipLeadingZeros();
      return this.readBits(clz + 1) - 1;
    };
    this.readExpGolomb = function() {
      var valu = this.readUnsignedExpGolomb();
      if (1 & valu) {
        return 1 + valu >>> 1;
      }
      return -1 * (valu >>> 1);
    };
    this.readBoolean = function() {
      return this.readBits(1) === 1;
    };
    this.readUnsignedByte = function() {
      return this.readBits(8);
    };
    this.loadWord();
  };
  var expGolomb = ExpGolomb;
  var _H264Stream, _NalByteStream;
  var PROFILES_WITH_OPTIONAL_SPS_DATA;
  _NalByteStream = function NalByteStream() {
    var syncPoint = 0, i, buffer;
    _NalByteStream.prototype.init.call(this);
    this.push = function(data) {
      var swapBuffer;
      if (!buffer) {
        buffer = data.data;
      } else {
        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
        swapBuffer.set(buffer);
        swapBuffer.set(data.data, buffer.byteLength);
        buffer = swapBuffer;
      }
      var len2 = buffer.byteLength;
      for (; syncPoint < len2 - 3; syncPoint++) {
        if (buffer[syncPoint + 2] === 1) {
          i = syncPoint + 5;
          break;
        }
      }
      while (i < len2) {
        switch (buffer[i]) {
          case 0:
            if (buffer[i - 1] !== 0) {
              i += 2;
              break;
            } else if (buffer[i - 2] !== 0) {
              i++;
              break;
            }
            if (syncPoint + 3 !== i - 2) {
              this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
            }
            do {
              i++;
            } while (buffer[i] !== 1 && i < len2);
            syncPoint = i - 2;
            i += 3;
            break;
          case 1:
            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
              i += 3;
              break;
            }
            this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
            syncPoint = i - 2;
            i += 3;
            break;
          default:
            i += 3;
            break;
        }
      }
      buffer = buffer.subarray(syncPoint);
      i -= syncPoint;
      syncPoint = 0;
    };
    this.reset = function() {
      buffer = null;
      syncPoint = 0;
      this.trigger("reset");
    };
    this.flush = function() {
      if (buffer && buffer.byteLength > 3) {
        this.trigger("data", buffer.subarray(syncPoint + 3));
      }
      buffer = null;
      syncPoint = 0;
      this.trigger("done");
    };
    this.endTimeline = function() {
      this.flush();
      this.trigger("endedtimeline");
    };
  };
  _NalByteStream.prototype = new stream();
  PROFILES_WITH_OPTIONAL_SPS_DATA = {
    100: true,
    110: true,
    122: true,
    244: true,
    44: true,
    83: true,
    86: true,
    118: true,
    128: true,
    // TODO: the three profiles below don't
    // appear to have sps data in the specificiation anymore?
    138: true,
    139: true,
    134: true
  };
  _H264Stream = function H264Stream2() {
    var nalByteStream = new _NalByteStream(), self2, trackId, currentPts, currentDts, discardEmulationPreventionBytes4, readSequenceParameterSet, skipScalingList;
    _H264Stream.prototype.init.call(this);
    self2 = this;
    this.push = function(packet) {
      if (packet.type !== "video") {
        return;
      }
      trackId = packet.trackId;
      currentPts = packet.pts;
      currentDts = packet.dts;
      nalByteStream.push(packet);
    };
    nalByteStream.on("data", function(data) {
      var event = {
        trackId,
        pts: currentPts,
        dts: currentDts,
        data,
        nalUnitTypeCode: data[0] & 31
      };
      switch (event.nalUnitTypeCode) {
        case 5:
          event.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
          break;
        case 6:
          event.nalUnitType = "sei_rbsp";
          event.escapedRBSP = discardEmulationPreventionBytes4(data.subarray(1));
          break;
        case 7:
          event.nalUnitType = "seq_parameter_set_rbsp";
          event.escapedRBSP = discardEmulationPreventionBytes4(data.subarray(1));
          event.config = readSequenceParameterSet(event.escapedRBSP);
          break;
        case 8:
          event.nalUnitType = "pic_parameter_set_rbsp";
          break;
        case 9:
          event.nalUnitType = "access_unit_delimiter_rbsp";
          break;
      }
      self2.trigger("data", event);
    });
    nalByteStream.on("done", function() {
      self2.trigger("done");
    });
    nalByteStream.on("partialdone", function() {
      self2.trigger("partialdone");
    });
    nalByteStream.on("reset", function() {
      self2.trigger("reset");
    });
    nalByteStream.on("endedtimeline", function() {
      self2.trigger("endedtimeline");
    });
    this.flush = function() {
      nalByteStream.flush();
    };
    this.partialFlush = function() {
      nalByteStream.partialFlush();
    };
    this.reset = function() {
      nalByteStream.reset();
    };
    this.endTimeline = function() {
      nalByteStream.endTimeline();
    };
    skipScalingList = function skipScalingList2(count2, expGolombDecoder) {
      var lastScale = 8, nextScale = 8, j2, deltaScale;
      for (j2 = 0; j2 < count2; j2++) {
        if (nextScale !== 0) {
          deltaScale = expGolombDecoder.readExpGolomb();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    };
    discardEmulationPreventionBytes4 = function discardEmulationPreventionBytes5(data) {
      var length2 = data.byteLength, emulationPreventionBytesPositions = [], i = 1, newLength, newData;
      while (i < length2 - 2) {
        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
          emulationPreventionBytesPositions.push(i + 2);
          i += 2;
        } else {
          i++;
        }
      }
      if (emulationPreventionBytesPositions.length === 0) {
        return data;
      }
      newLength = length2 - emulationPreventionBytesPositions.length;
      newData = new Uint8Array(newLength);
      var sourceIndex = 0;
      for (i = 0; i < newLength; sourceIndex++, i++) {
        if (sourceIndex === emulationPreventionBytesPositions[0]) {
          sourceIndex++;
          emulationPreventionBytesPositions.shift();
        }
        newData[i] = data[sourceIndex];
      }
      return newData;
    };
    readSequenceParameterSet = function readSequenceParameterSet2(data) {
      var frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, sarRatio = [1, 1], aspectRatioIdc, i;
      expGolombDecoder = new expGolomb(data);
      profileIdc = expGolombDecoder.readUnsignedByte();
      profileCompatibility = expGolombDecoder.readUnsignedByte();
      levelIdc = expGolombDecoder.readUnsignedByte();
      expGolombDecoder.skipUnsignedExpGolomb();
      if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
        if (chromaFormatIdc === 3) {
          expGolombDecoder.skipBits(1);
        }
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipUnsignedExpGolomb();
        expGolombDecoder.skipBits(1);
        if (expGolombDecoder.readBoolean()) {
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i = 0; i < scalingListCount; i++) {
            if (expGolombDecoder.readBoolean()) {
              if (i < 6) {
                skipScalingList(16, expGolombDecoder);
              } else {
                skipScalingList(64, expGolombDecoder);
              }
            }
          }
        }
      }
      expGolombDecoder.skipUnsignedExpGolomb();
      picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
      if (picOrderCntType === 0) {
        expGolombDecoder.readUnsignedExpGolomb();
      } else if (picOrderCntType === 1) {
        expGolombDecoder.skipBits(1);
        expGolombDecoder.skipExpGolomb();
        expGolombDecoder.skipExpGolomb();
        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
          expGolombDecoder.skipExpGolomb();
        }
      }
      expGolombDecoder.skipUnsignedExpGolomb();
      expGolombDecoder.skipBits(1);
      picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
      picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
      frameMbsOnlyFlag = expGolombDecoder.readBits(1);
      if (frameMbsOnlyFlag === 0) {
        expGolombDecoder.skipBits(1);
      }
      expGolombDecoder.skipBits(1);
      if (expGolombDecoder.readBoolean()) {
        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
      }
      if (expGolombDecoder.readBoolean()) {
        if (expGolombDecoder.readBoolean()) {
          aspectRatioIdc = expGolombDecoder.readUnsignedByte();
          switch (aspectRatioIdc) {
            case 1:
              sarRatio = [1, 1];
              break;
            case 2:
              sarRatio = [12, 11];
              break;
            case 3:
              sarRatio = [10, 11];
              break;
            case 4:
              sarRatio = [16, 11];
              break;
            case 5:
              sarRatio = [40, 33];
              break;
            case 6:
              sarRatio = [24, 11];
              break;
            case 7:
              sarRatio = [20, 11];
              break;
            case 8:
              sarRatio = [32, 11];
              break;
            case 9:
              sarRatio = [80, 33];
              break;
            case 10:
              sarRatio = [18, 11];
              break;
            case 11:
              sarRatio = [15, 11];
              break;
            case 12:
              sarRatio = [64, 33];
              break;
            case 13:
              sarRatio = [160, 99];
              break;
            case 14:
              sarRatio = [4, 3];
              break;
            case 15:
              sarRatio = [3, 2];
              break;
            case 16:
              sarRatio = [2, 1];
              break;
            case 255: {
              sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];
              break;
            }
          }
          if (sarRatio) {
            sarRatio[0] / sarRatio[1];
          }
        }
      }
      return {
        profileIdc,
        levelIdc,
        profileCompatibility,
        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
        // sar is sample aspect ratio
        sarRatio
      };
    };
  };
  _H264Stream.prototype = new stream();
  var h2642 = {
    H264Stream: _H264Stream,
    NalByteStream: _NalByteStream
  };
  var ADTS_SAMPLING_FREQUENCIES = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
  var parseId3TagSize = function parseId3TagSize2(header, byteIndex) {
    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9], flags = header[byteIndex + 5], footerPresent = (flags & 16) >> 4;
    returnSize = returnSize >= 0 ? returnSize : 0;
    if (footerPresent) {
      return returnSize + 20;
    }
    return returnSize + 10;
  };
  var getId3Offset3 = function getId3Offset4(data, offset3) {
    if (data.length - offset3 < 10 || data[offset3] !== "I".charCodeAt(0) || data[offset3 + 1] !== "D".charCodeAt(0) || data[offset3 + 2] !== "3".charCodeAt(0)) {
      return offset3;
    }
    offset3 += parseId3TagSize(data, offset3);
    return getId3Offset4(data, offset3);
  };
  var isLikelyAacData$1 = function isLikelyAacData2(data) {
    var offset3 = getId3Offset3(data, 0);
    return data.length >= offset3 + 2 && (data[offset3] & 255) === 255 && (data[offset3 + 1] & 240) === 240 && // verify that the 2 layer bits are 0, aka this
    // is not mp3 data but aac data.
    (data[offset3 + 1] & 22) === 16;
  };
  var parseSyncSafeInteger = function parseSyncSafeInteger2(data) {
    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
  };
  var percentEncode = function percentEncode2(bytes, start3, end2) {
    var i, result = "";
    for (i = start3; i < end2; i++) {
      result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
    }
    return result;
  };
  var parseIso88591 = function parseIso885912(bytes, start3, end2) {
    return unescape(percentEncode(bytes, start3, end2));
  };
  var parseAdtsSize = function parseAdtsSize2(header, byteIndex) {
    var lowThree = (header[byteIndex + 5] & 224) >> 5, middle = header[byteIndex + 4] << 3, highTwo = header[byteIndex + 3] & 3 << 11;
    return highTwo | middle | lowThree;
  };
  var parseType$2 = function parseType2(header, byteIndex) {
    if (header[byteIndex] === "I".charCodeAt(0) && header[byteIndex + 1] === "D".charCodeAt(0) && header[byteIndex + 2] === "3".charCodeAt(0)) {
      return "timed-metadata";
    } else if (header[byteIndex] & true && (header[byteIndex + 1] & 240) === 240) {
      return "audio";
    }
    return null;
  };
  var parseSampleRate = function parseSampleRate2(packet) {
    var i = 0;
    while (i + 5 < packet.length) {
      if (packet[i] !== 255 || (packet[i + 1] & 246) !== 240) {
        i++;
        continue;
      }
      return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 60) >>> 2];
    }
    return null;
  };
  var parseAacTimestamp = function parseAacTimestamp2(packet) {
    var frameStart, frameSize, frame, frameHeader;
    frameStart = 10;
    if (packet[5] & 64) {
      frameStart += 4;
      frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
    }
    do {
      frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
      if (frameSize < 1) {
        return null;
      }
      frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
      if (frameHeader === "PRIV") {
        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
        for (var i = 0; i < frame.byteLength; i++) {
          if (frame[i] === 0) {
            var owner = parseIso88591(frame, 0, i);
            if (owner === "com.apple.streaming.transportStreamTimestamp") {
              var d3 = frame.subarray(i + 1);
              var size = (d3[3] & 1) << 30 | d3[4] << 22 | d3[5] << 14 | d3[6] << 6 | d3[7] >>> 2;
              size *= 4;
              size += d3[7] & 3;
              return size;
            }
            break;
          }
        }
      }
      frameStart += 10;
      frameStart += frameSize;
    } while (frameStart < packet.byteLength);
    return null;
  };
  var utils2 = {
    isLikelyAacData: isLikelyAacData$1,
    parseId3TagSize,
    parseAdtsSize,
    parseType: parseType$2,
    parseSampleRate,
    parseAacTimestamp
  };
  var _AacStream;
  _AacStream = function AacStream() {
    var everything = new Uint8Array(), timeStamp = 0;
    _AacStream.prototype.init.call(this);
    this.setTimestamp = function(timestamp) {
      timeStamp = timestamp;
    };
    this.push = function(bytes) {
      var frameSize = 0, byteIndex = 0, bytesLeft, chunk, packet, tempLength;
      if (everything.length) {
        tempLength = everything.length;
        everything = new Uint8Array(bytes.byteLength + tempLength);
        everything.set(everything.subarray(0, tempLength));
        everything.set(bytes, tempLength);
      } else {
        everything = bytes;
      }
      while (everything.length - byteIndex >= 3) {
        if (everything[byteIndex] === "I".charCodeAt(0) && everything[byteIndex + 1] === "D".charCodeAt(0) && everything[byteIndex + 2] === "3".charCodeAt(0)) {
          if (everything.length - byteIndex < 10) {
            break;
          }
          frameSize = utils2.parseId3TagSize(everything, byteIndex);
          if (byteIndex + frameSize > everything.length) {
            break;
          }
          chunk = {
            type: "timed-metadata",
            data: everything.subarray(byteIndex, byteIndex + frameSize)
          };
          this.trigger("data", chunk);
          byteIndex += frameSize;
          continue;
        } else if ((everything[byteIndex] & 255) === 255 && (everything[byteIndex + 1] & 240) === 240) {
          if (everything.length - byteIndex < 7) {
            break;
          }
          frameSize = utils2.parseAdtsSize(everything, byteIndex);
          if (byteIndex + frameSize > everything.length) {
            break;
          }
          packet = {
            type: "audio",
            data: everything.subarray(byteIndex, byteIndex + frameSize),
            pts: timeStamp,
            dts: timeStamp
          };
          this.trigger("data", packet);
          byteIndex += frameSize;
          continue;
        }
        byteIndex++;
      }
      bytesLeft = everything.length - byteIndex;
      if (bytesLeft > 0) {
        everything = everything.subarray(byteIndex);
      } else {
        everything = new Uint8Array();
      }
    };
    this.reset = function() {
      everything = new Uint8Array();
      this.trigger("reset");
    };
    this.endTimeline = function() {
      everything = new Uint8Array();
      this.trigger("endedtimeline");
    };
  };
  _AacStream.prototype = new stream();
  var aac2 = _AacStream;
  var AUDIO_PROPERTIES = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"];
  var audioProperties = AUDIO_PROPERTIES;
  var VIDEO_PROPERTIES = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"];
  var videoProperties = VIDEO_PROPERTIES;
  var H264Stream = h2642.H264Stream;
  var isLikelyAacData = utils2.isLikelyAacData;
  var ONE_SECOND_IN_TS$1 = clock2.ONE_SECOND_IN_TS;
  var _VideoSegmentStream, _AudioSegmentStream, _Transmuxer, _CoalesceStream;
  var retriggerForStream = function retriggerForStream2(key, event) {
    event.stream = key;
    this.trigger("log", event);
  };
  var addPipelineLogRetriggers = function addPipelineLogRetriggers2(transmuxer2, pipeline) {
    var keys3 = Object.keys(pipeline);
    for (var i = 0; i < keys3.length; i++) {
      var key = keys3[i];
      if (key === "headOfPipeline" || !pipeline[key].on) {
        continue;
      }
      pipeline[key].on("log", retriggerForStream.bind(transmuxer2, key));
    }
  };
  var arrayEquals = function arrayEquals2(a2, b2) {
    var i;
    if (a2.length !== b2.length) {
      return false;
    }
    for (i = 0; i < a2.length; i++) {
      if (a2[i] !== b2[i]) {
        return false;
      }
    }
    return true;
  };
  var generateSegmentTimingInfo = function generateSegmentTimingInfo2(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
    var ptsOffsetFromDts = startPts - startDts, decodeDuration = endDts - startDts, presentationDuration = endPts - startPts;
    return {
      start: {
        dts: baseMediaDecodeTime,
        pts: baseMediaDecodeTime + ptsOffsetFromDts
      },
      end: {
        dts: baseMediaDecodeTime + decodeDuration,
        pts: baseMediaDecodeTime + presentationDuration
      },
      prependedContentDuration,
      baseMediaDecodeTime
    };
  };
  _AudioSegmentStream = function AudioSegmentStream(track, options) {
    var adtsFrames = [], sequenceNumber, earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = Infinity;
    options = options || {};
    sequenceNumber = options.firstSequenceNumber || 0;
    _AudioSegmentStream.prototype.init.call(this);
    this.push = function(data) {
      trackDecodeInfo.collectDtsInfo(track, data);
      if (track) {
        audioProperties.forEach(function(prop3) {
          track[prop3] = data[prop3];
        });
      }
      adtsFrames.push(data);
    };
    this.setEarliestDts = function(earliestDts) {
      earliestAllowedDts = earliestDts;
    };
    this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
      videoBaseMediaDecodeTime = baseMediaDecodeTime;
    };
    this.setAudioAppendStart = function(timestamp) {
      audioAppendStartTs = timestamp;
    };
    this.flush = function() {
      var frames, moof2, mdat2, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
      if (adtsFrames.length === 0) {
        this.trigger("done", "AudioSegmentStream");
        return;
      }
      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
      videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
      track.samples = audioFrameUtils.generateSampleTable(frames);
      mdat2 = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));
      adtsFrames = [];
      moof2 = mp4Generator.moof(sequenceNumber, [track]);
      boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
      sequenceNumber++;
      boxes.set(moof2);
      boxes.set(mdat2, moof2.byteLength);
      trackDecodeInfo.clearDtsInfo(track);
      frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
      if (frames.length) {
        segmentDuration = frames.length * frameDuration;
        this.trigger("segmentTimingInfo", generateSegmentTimingInfo(
          // The audio track's baseMediaDecodeTime is in audio clock cycles, but the
          // frame info is in video clock cycles. Convert to match expectation of
          // listeners (that all timestamps will be based on video clock cycles).
          clock2.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate),
          // frame times are already in video clock, as is segment duration
          frames[0].dts,
          frames[0].pts,
          frames[0].dts + segmentDuration,
          frames[0].pts + segmentDuration,
          videoClockCyclesOfSilencePrefixed || 0
        ));
        this.trigger("timingInfo", {
          start: frames[0].pts,
          end: frames[0].pts + segmentDuration
        });
      }
      this.trigger("data", {
        track,
        boxes
      });
      this.trigger("done", "AudioSegmentStream");
    };
    this.reset = function() {
      trackDecodeInfo.clearDtsInfo(track);
      adtsFrames = [];
      this.trigger("reset");
    };
  };
  _AudioSegmentStream.prototype = new stream();
  _VideoSegmentStream = function VideoSegmentStream(track, options) {
    var sequenceNumber, nalUnits = [], gopsToAlignWith = [], config2, pps;
    options = options || {};
    sequenceNumber = options.firstSequenceNumber || 0;
    _VideoSegmentStream.prototype.init.call(this);
    delete track.minPTS;
    this.gopCache_ = [];
    this.push = function(nalUnit) {
      trackDecodeInfo.collectDtsInfo(track, nalUnit);
      if (nalUnit.nalUnitType === "seq_parameter_set_rbsp" && !config2) {
        config2 = nalUnit.config;
        track.sps = [nalUnit.data];
        videoProperties.forEach(function(prop3) {
          track[prop3] = config2[prop3];
        }, this);
      }
      if (nalUnit.nalUnitType === "pic_parameter_set_rbsp" && !pps) {
        pps = nalUnit.data;
        track.pps = [nalUnit.data];
      }
      nalUnits.push(nalUnit);
    };
    this.flush = function() {
      var frames, gopForFusion, gops, moof2, mdat2, boxes, prependedContentDuration = 0, firstGop, lastGop;
      while (nalUnits.length) {
        if (nalUnits[0].nalUnitType === "access_unit_delimiter_rbsp") {
          break;
        }
        nalUnits.shift();
      }
      if (nalUnits.length === 0) {
        this.resetStream_();
        this.trigger("done", "VideoSegmentStream");
        return;
      }
      frames = frameUtils.groupNalsIntoFrames(nalUnits);
      gops = frameUtils.groupFramesIntoGops(frames);
      if (!gops[0][0].keyFrame) {
        gopForFusion = this.getGopForFusion_(nalUnits[0], track);
        if (gopForFusion) {
          prependedContentDuration = gopForFusion.duration;
          gops.unshift(gopForFusion);
          gops.byteLength += gopForFusion.byteLength;
          gops.nalCount += gopForFusion.nalCount;
          gops.pts = gopForFusion.pts;
          gops.dts = gopForFusion.dts;
          gops.duration += gopForFusion.duration;
        } else {
          gops = frameUtils.extendFirstKeyFrame(gops);
        }
      }
      if (gopsToAlignWith.length) {
        var alignedGops;
        if (options.alignGopsAtEnd) {
          alignedGops = this.alignGopsAtEnd_(gops);
        } else {
          alignedGops = this.alignGopsAtStart_(gops);
        }
        if (!alignedGops) {
          this.gopCache_.unshift({
            gop: gops.pop(),
            pps: track.pps,
            sps: track.sps
          });
          this.gopCache_.length = Math.min(6, this.gopCache_.length);
          nalUnits = [];
          this.resetStream_();
          this.trigger("done", "VideoSegmentStream");
          return;
        }
        trackDecodeInfo.clearDtsInfo(track);
        gops = alignedGops;
      }
      trackDecodeInfo.collectDtsInfo(track, gops);
      track.samples = frameUtils.generateSampleTable(gops);
      mdat2 = mp4Generator.mdat(frameUtils.concatenateNalData(gops));
      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
      this.trigger("processedGopsInfo", gops.map(function(gop) {
        return {
          pts: gop.pts,
          dts: gop.dts,
          byteLength: gop.byteLength
        };
      }));
      firstGop = gops[0];
      lastGop = gops[gops.length - 1];
      this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
      this.trigger("timingInfo", {
        start: gops[0].pts,
        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
      });
      this.gopCache_.unshift({
        gop: gops.pop(),
        pps: track.pps,
        sps: track.sps
      });
      this.gopCache_.length = Math.min(6, this.gopCache_.length);
      nalUnits = [];
      this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime);
      this.trigger("timelineStartInfo", track.timelineStartInfo);
      moof2 = mp4Generator.moof(sequenceNumber, [track]);
      boxes = new Uint8Array(moof2.byteLength + mdat2.byteLength);
      sequenceNumber++;
      boxes.set(moof2);
      boxes.set(mdat2, moof2.byteLength);
      this.trigger("data", {
        track,
        boxes
      });
      this.resetStream_();
      this.trigger("done", "VideoSegmentStream");
    };
    this.reset = function() {
      this.resetStream_();
      nalUnits = [];
      this.gopCache_.length = 0;
      gopsToAlignWith.length = 0;
      this.trigger("reset");
    };
    this.resetStream_ = function() {
      trackDecodeInfo.clearDtsInfo(track);
      config2 = void 0;
      pps = void 0;
    };
    this.getGopForFusion_ = function(nalUnit) {
      var halfSecond = 45e3, allowableOverlap = 1e4, nearestDistance = Infinity, dtsDistance, nearestGopObj, currentGop, currentGopObj, i;
      for (i = 0; i < this.gopCache_.length; i++) {
        currentGopObj = this.gopCache_[i];
        currentGop = currentGopObj.gop;
        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {
          continue;
        }
        if (currentGop.dts < track.timelineStartInfo.dts) {
          continue;
        }
        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {
          if (!nearestGopObj || nearestDistance > dtsDistance) {
            nearestGopObj = currentGopObj;
            nearestDistance = dtsDistance;
          }
        }
      }
      if (nearestGopObj) {
        return nearestGopObj.gop;
      }
      return null;
    };
    this.alignGopsAtStart_ = function(gops) {
      var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration5, alignedGops;
      byteLength = gops.byteLength;
      nalCount = gops.nalCount;
      duration5 = gops.duration;
      alignIndex = gopIndex = 0;
      while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
        align = gopsToAlignWith[alignIndex];
        gop = gops[gopIndex];
        if (align.pts === gop.pts) {
          break;
        }
        if (gop.pts > align.pts) {
          alignIndex++;
          continue;
        }
        gopIndex++;
        byteLength -= gop.byteLength;
        nalCount -= gop.nalCount;
        duration5 -= gop.duration;
      }
      if (gopIndex === 0) {
        return gops;
      }
      if (gopIndex === gops.length) {
        return null;
      }
      alignedGops = gops.slice(gopIndex);
      alignedGops.byteLength = byteLength;
      alignedGops.duration = duration5;
      alignedGops.nalCount = nalCount;
      alignedGops.pts = alignedGops[0].pts;
      alignedGops.dts = alignedGops[0].dts;
      return alignedGops;
    };
    this.alignGopsAtEnd_ = function(gops) {
      var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
      alignIndex = gopsToAlignWith.length - 1;
      gopIndex = gops.length - 1;
      alignEndIndex = null;
      matchFound = false;
      while (alignIndex >= 0 && gopIndex >= 0) {
        align = gopsToAlignWith[alignIndex];
        gop = gops[gopIndex];
        if (align.pts === gop.pts) {
          matchFound = true;
          break;
        }
        if (align.pts > gop.pts) {
          alignIndex--;
          continue;
        }
        if (alignIndex === gopsToAlignWith.length - 1) {
          alignEndIndex = gopIndex;
        }
        gopIndex--;
      }
      if (!matchFound && alignEndIndex === null) {
        return null;
      }
      var trimIndex;
      if (matchFound) {
        trimIndex = gopIndex;
      } else {
        trimIndex = alignEndIndex;
      }
      if (trimIndex === 0) {
        return gops;
      }
      var alignedGops = gops.slice(trimIndex);
      var metadata = alignedGops.reduce(function(total, gop2) {
        total.byteLength += gop2.byteLength;
        total.duration += gop2.duration;
        total.nalCount += gop2.nalCount;
        return total;
      }, {
        byteLength: 0,
        duration: 0,
        nalCount: 0
      });
      alignedGops.byteLength = metadata.byteLength;
      alignedGops.duration = metadata.duration;
      alignedGops.nalCount = metadata.nalCount;
      alignedGops.pts = alignedGops[0].pts;
      alignedGops.dts = alignedGops[0].dts;
      return alignedGops;
    };
    this.alignGopsWith = function(newGopsToAlignWith) {
      gopsToAlignWith = newGopsToAlignWith;
    };
  };
  _VideoSegmentStream.prototype = new stream();
  _CoalesceStream = function CoalesceStream(options, metadataStream2) {
    this.numberOfTracks = 0;
    this.metadataStream = metadataStream2;
    options = options || {};
    if (typeof options.remux !== "undefined") {
      this.remuxTracks = !!options.remux;
    } else {
      this.remuxTracks = true;
    }
    if (typeof options.keepOriginalTimestamps === "boolean") {
      this.keepOriginalTimestamps = options.keepOriginalTimestamps;
    } else {
      this.keepOriginalTimestamps = false;
    }
    this.pendingTracks = [];
    this.videoTrack = null;
    this.pendingBoxes = [];
    this.pendingCaptions = [];
    this.pendingMetadata = [];
    this.pendingBytes = 0;
    this.emittedTracks = 0;
    _CoalesceStream.prototype.init.call(this);
    this.push = function(output) {
      if (output.text) {
        return this.pendingCaptions.push(output);
      }
      if (output.frames) {
        return this.pendingMetadata.push(output);
      }
      this.pendingTracks.push(output.track);
      this.pendingBytes += output.boxes.byteLength;
      if (output.track.type === "video") {
        this.videoTrack = output.track;
        this.pendingBoxes.push(output.boxes);
      }
      if (output.track.type === "audio") {
        this.audioTrack = output.track;
        this.pendingBoxes.unshift(output.boxes);
      }
    };
  };
  _CoalesceStream.prototype = new stream();
  _CoalesceStream.prototype.flush = function(flushSource) {
    var offset3 = 0, event = {
      captions: [],
      captionStreams: {},
      metadata: [],
      info: {}
    }, caption, id3, initSegment, timelineStartPts = 0, i;
    if (this.pendingTracks.length < this.numberOfTracks) {
      if (flushSource !== "VideoSegmentStream" && flushSource !== "AudioSegmentStream") {
        return;
      } else if (this.remuxTracks) {
        return;
      } else if (this.pendingTracks.length === 0) {
        this.emittedTracks++;
        if (this.emittedTracks >= this.numberOfTracks) {
          this.trigger("done");
          this.emittedTracks = 0;
        }
        return;
      }
    }
    if (this.videoTrack) {
      timelineStartPts = this.videoTrack.timelineStartInfo.pts;
      videoProperties.forEach(function(prop3) {
        event.info[prop3] = this.videoTrack[prop3];
      }, this);
    } else if (this.audioTrack) {
      timelineStartPts = this.audioTrack.timelineStartInfo.pts;
      audioProperties.forEach(function(prop3) {
        event.info[prop3] = this.audioTrack[prop3];
      }, this);
    }
    if (this.videoTrack || this.audioTrack) {
      if (this.pendingTracks.length === 1) {
        event.type = this.pendingTracks[0].type;
      } else {
        event.type = "combined";
      }
      this.emittedTracks += this.pendingTracks.length;
      initSegment = mp4Generator.initSegment(this.pendingTracks);
      event.initSegment = new Uint8Array(initSegment.byteLength);
      event.initSegment.set(initSegment);
      event.data = new Uint8Array(this.pendingBytes);
      for (i = 0; i < this.pendingBoxes.length; i++) {
        event.data.set(this.pendingBoxes[i], offset3);
        offset3 += this.pendingBoxes[i].byteLength;
      }
      for (i = 0; i < this.pendingCaptions.length; i++) {
        caption = this.pendingCaptions[i];
        caption.startTime = clock2.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
        caption.endTime = clock2.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
        event.captionStreams[caption.stream] = true;
        event.captions.push(caption);
      }
      for (i = 0; i < this.pendingMetadata.length; i++) {
        id3 = this.pendingMetadata[i];
        id3.cueTime = clock2.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);
        event.metadata.push(id3);
      }
      event.metadata.dispatchType = this.metadataStream.dispatchType;
      this.pendingTracks.length = 0;
      this.videoTrack = null;
      this.pendingBoxes.length = 0;
      this.pendingCaptions.length = 0;
      this.pendingBytes = 0;
      this.pendingMetadata.length = 0;
      this.trigger("data", event);
      for (i = 0; i < event.captions.length; i++) {
        caption = event.captions[i];
        this.trigger("caption", caption);
      }
      for (i = 0; i < event.metadata.length; i++) {
        id3 = event.metadata[i];
        this.trigger("id3Frame", id3);
      }
    }
    if (this.emittedTracks >= this.numberOfTracks) {
      this.trigger("done");
      this.emittedTracks = 0;
    }
  };
  _CoalesceStream.prototype.setRemux = function(val) {
    this.remuxTracks = val;
  };
  _Transmuxer = function Transmuxer(options) {
    var self2 = this, hasFlushed = true, videoTrack, audioTrack;
    _Transmuxer.prototype.init.call(this);
    options = options || {};
    this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
    this.transmuxPipeline_ = {};
    this.setupAacPipeline = function() {
      var pipeline = {};
      this.transmuxPipeline_ = pipeline;
      pipeline.type = "aac";
      pipeline.metadataStream = new m2ts_1.MetadataStream();
      pipeline.aacStream = new aac2();
      pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream("audio");
      pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream("timed-metadata");
      pipeline.adtsStream = new adts();
      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
      pipeline.headOfPipeline = pipeline.aacStream;
      pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
      pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
      pipeline.metadataStream.on("timestamp", function(frame) {
        pipeline.aacStream.setTimestamp(frame.timeStamp);
      });
      pipeline.aacStream.on("data", function(data) {
        if (data.type !== "timed-metadata" && data.type !== "audio" || pipeline.audioSegmentStream) {
          return;
        }
        audioTrack = audioTrack || {
          timelineStartInfo: {
            baseMediaDecodeTime: self2.baseMediaDecodeTime
          },
          codec: "adts",
          type: "audio"
        };
        pipeline.coalesceStream.numberOfTracks++;
        pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
        pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
        pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
        self2.trigger("trackinfo", {
          hasAudio: !!audioTrack,
          hasVideo: !!videoTrack
        });
      });
      pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
      pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
      addPipelineLogRetriggers(this, pipeline);
    };
    this.setupTsPipeline = function() {
      var pipeline = {};
      this.transmuxPipeline_ = pipeline;
      pipeline.type = "ts";
      pipeline.metadataStream = new m2ts_1.MetadataStream();
      pipeline.packetStream = new m2ts_1.TransportPacketStream();
      pipeline.parseStream = new m2ts_1.TransportParseStream();
      pipeline.elementaryStream = new m2ts_1.ElementaryStream();
      pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();
      pipeline.adtsStream = new adts();
      pipeline.h264Stream = new H264Stream();
      pipeline.captionStream = new m2ts_1.CaptionStream(options);
      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);
      pipeline.headOfPipeline = pipeline.packetStream;
      pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
      pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
      pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
      pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
      pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
      pipeline.elementaryStream.on("data", function(data) {
        var i;
        if (data.type === "metadata") {
          i = data.tracks.length;
          while (i--) {
            if (!videoTrack && data.tracks[i].type === "video") {
              videoTrack = data.tracks[i];
              videoTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
            } else if (!audioTrack && data.tracks[i].type === "audio") {
              audioTrack = data.tracks[i];
              audioTrack.timelineStartInfo.baseMediaDecodeTime = self2.baseMediaDecodeTime;
            }
          }
          if (videoTrack && !pipeline.videoSegmentStream) {
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.videoSegmentStream = new _VideoSegmentStream(videoTrack, options);
            pipeline.videoSegmentStream.on("log", self2.getLogTrigger_("videoSegmentStream"));
            pipeline.videoSegmentStream.on("timelineStartInfo", function(timelineStartInfo) {
              if (audioTrack && !options.keepOriginalTimestamps) {
                audioTrack.timelineStartInfo = timelineStartInfo;
                pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self2.baseMediaDecodeTime);
              }
            });
            pipeline.videoSegmentStream.on("processedGopsInfo", self2.trigger.bind(self2, "gopInfo"));
            pipeline.videoSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "videoSegmentTimingInfo"));
            pipeline.videoSegmentStream.on("baseMediaDecodeTime", function(baseMediaDecodeTime) {
              if (audioTrack) {
                pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
              }
            });
            pipeline.videoSegmentStream.on("timingInfo", self2.trigger.bind(self2, "videoTimingInfo"));
            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
          }
          if (audioTrack && !pipeline.audioSegmentStream) {
            pipeline.coalesceStream.numberOfTracks++;
            pipeline.audioSegmentStream = new _AudioSegmentStream(audioTrack, options);
            pipeline.audioSegmentStream.on("log", self2.getLogTrigger_("audioSegmentStream"));
            pipeline.audioSegmentStream.on("timingInfo", self2.trigger.bind(self2, "audioTimingInfo"));
            pipeline.audioSegmentStream.on("segmentTimingInfo", self2.trigger.bind(self2, "audioSegmentTimingInfo"));
            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
          }
          self2.trigger("trackinfo", {
            hasAudio: !!audioTrack,
            hasVideo: !!videoTrack
          });
        }
      });
      pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
      pipeline.coalesceStream.on("id3Frame", function(id3Frame) {
        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
        self2.trigger("id3Frame", id3Frame);
      });
      pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption"));
      pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
      addPipelineLogRetriggers(this, pipeline);
    };
    this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
      var pipeline = this.transmuxPipeline_;
      if (!options.keepOriginalTimestamps) {
        this.baseMediaDecodeTime = baseMediaDecodeTime;
      }
      if (audioTrack) {
        audioTrack.timelineStartInfo.dts = void 0;
        audioTrack.timelineStartInfo.pts = void 0;
        trackDecodeInfo.clearDtsInfo(audioTrack);
        if (pipeline.audioTimestampRolloverStream) {
          pipeline.audioTimestampRolloverStream.discontinuity();
        }
      }
      if (videoTrack) {
        if (pipeline.videoSegmentStream) {
          pipeline.videoSegmentStream.gopCache_ = [];
        }
        videoTrack.timelineStartInfo.dts = void 0;
        videoTrack.timelineStartInfo.pts = void 0;
        trackDecodeInfo.clearDtsInfo(videoTrack);
        pipeline.captionStream.reset();
      }
      if (pipeline.timestampRolloverStream) {
        pipeline.timestampRolloverStream.discontinuity();
      }
    };
    this.setAudioAppendStart = function(timestamp) {
      if (audioTrack) {
        this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
      }
    };
    this.setRemux = function(val) {
      var pipeline = this.transmuxPipeline_;
      options.remux = val;
      if (pipeline && pipeline.coalesceStream) {
        pipeline.coalesceStream.setRemux(val);
      }
    };
    this.alignGopsWith = function(gopsToAlignWith) {
      if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {
        this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
      }
    };
    this.getLogTrigger_ = function(key) {
      var self3 = this;
      return function(event) {
        event.stream = key;
        self3.trigger("log", event);
      };
    };
    this.push = function(data) {
      if (hasFlushed) {
        var isAac = isLikelyAacData(data);
        if (isAac && this.transmuxPipeline_.type !== "aac") {
          this.setupAacPipeline();
        } else if (!isAac && this.transmuxPipeline_.type !== "ts") {
          this.setupTsPipeline();
        }
        hasFlushed = false;
      }
      this.transmuxPipeline_.headOfPipeline.push(data);
    };
    this.flush = function() {
      hasFlushed = true;
      this.transmuxPipeline_.headOfPipeline.flush();
    };
    this.endTimeline = function() {
      this.transmuxPipeline_.headOfPipeline.endTimeline();
    };
    this.reset = function() {
      if (this.transmuxPipeline_.headOfPipeline) {
        this.transmuxPipeline_.headOfPipeline.reset();
      }
    };
    this.resetCaptions = function() {
      if (this.transmuxPipeline_.captionStream) {
        this.transmuxPipeline_.captionStream.reset();
      }
    };
  };
  _Transmuxer.prototype = new stream();
  var transmuxer = {
    Transmuxer: _Transmuxer,
    VideoSegmentStream: _VideoSegmentStream,
    AudioSegmentStream: _AudioSegmentStream,
    AUDIO_PROPERTIES: audioProperties,
    VIDEO_PROPERTIES: videoProperties,
    // exported for testing
    generateSegmentTimingInfo
  };
  var toUnsigned$3 = function toUnsigned2(value) {
    return value >>> 0;
  };
  var toHexString$1 = function toHexString2(value) {
    return ("00" + value.toString(16)).slice(-2);
  };
  var bin = {
    toUnsigned: toUnsigned$3,
    toHexString: toHexString$1
  };
  var parseType$1 = function parseType2(buffer) {
    var result = "";
    result += String.fromCharCode(buffer[0]);
    result += String.fromCharCode(buffer[1]);
    result += String.fromCharCode(buffer[2]);
    result += String.fromCharCode(buffer[3]);
    return result;
  };
  var parseType_1 = parseType$1;
  var toUnsigned$2 = bin.toUnsigned;
  var findBox3 = function findBox4(data, path) {
    var results = [], i, size, type3, end2, subresults;
    if (!path.length) {
      return null;
    }
    for (i = 0; i < data.byteLength; ) {
      size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);
      type3 = parseType_1(data.subarray(i + 4, i + 8));
      end2 = size > 1 ? i + size : data.byteLength;
      if (type3 === path[0]) {
        if (path.length === 1) {
          results.push(data.subarray(i + 8, end2));
        } else {
          subresults = findBox4(data.subarray(i + 8, end2), path.slice(1));
          if (subresults.length) {
            results = results.concat(subresults);
          }
        }
      }
      i = end2;
    }
    return results;
  };
  var findBox_1 = findBox3;
  var toUnsigned$1 = bin.toUnsigned;
  var getUint64$12 = numbers2.getUint64;
  var tfdt = function tfdt2(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4))
    };
    if (result.version === 1) {
      result.baseMediaDecodeTime = getUint64$12(data.subarray(4));
    } else {
      result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
    }
    return result;
  };
  var parseTfdt = tfdt;
  var parseSampleFlags = function parseSampleFlags2(flags) {
    return {
      isLeading: (flags[0] & 12) >>> 2,
      dependsOn: flags[0] & 3,
      isDependedOn: (flags[1] & 192) >>> 6,
      hasRedundancy: (flags[1] & 48) >>> 4,
      paddingValue: (flags[1] & 14) >>> 1,
      isNonSyncSample: flags[1] & 1,
      degradationPriority: flags[2] << 8 | flags[3]
    };
  };
  var parseSampleFlags_1 = parseSampleFlags;
  var trun = function trun2(data) {
    var result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      samples: []
    }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = result.flags[2] & 1, firstSampleFlagsPresent = result.flags[2] & 4, sampleDurationPresent = result.flags[1] & 1, sampleSizePresent = result.flags[1] & 2, sampleFlagsPresent = result.flags[1] & 4, sampleCompositionTimeOffsetPresent = result.flags[1] & 8, sampleCount = view.getUint32(4), offset3 = 8, sample;
    if (dataOffsetPresent) {
      result.dataOffset = view.getInt32(offset3);
      offset3 += 4;
    }
    if (firstSampleFlagsPresent && sampleCount) {
      sample = {
        flags: parseSampleFlags_1(data.subarray(offset3, offset3 + 4))
      };
      offset3 += 4;
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset3);
        offset3 += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset3);
        offset3 += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        if (result.version === 1) {
          sample.compositionTimeOffset = view.getInt32(offset3);
        } else {
          sample.compositionTimeOffset = view.getUint32(offset3);
        }
        offset3 += 4;
      }
      result.samples.push(sample);
      sampleCount--;
    }
    while (sampleCount--) {
      sample = {};
      if (sampleDurationPresent) {
        sample.duration = view.getUint32(offset3);
        offset3 += 4;
      }
      if (sampleSizePresent) {
        sample.size = view.getUint32(offset3);
        offset3 += 4;
      }
      if (sampleFlagsPresent) {
        sample.flags = parseSampleFlags_1(data.subarray(offset3, offset3 + 4));
        offset3 += 4;
      }
      if (sampleCompositionTimeOffsetPresent) {
        if (result.version === 1) {
          sample.compositionTimeOffset = view.getInt32(offset3);
        } else {
          sample.compositionTimeOffset = view.getUint32(offset3);
        }
        offset3 += 4;
      }
      result.samples.push(sample);
    }
    return result;
  };
  var parseTrun = trun;
  var tfhd = function tfhd2(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
      version: data[0],
      flags: new Uint8Array(data.subarray(1, 4)),
      trackId: view.getUint32(4)
    }, baseDataOffsetPresent = result.flags[2] & 1, sampleDescriptionIndexPresent = result.flags[2] & 2, defaultSampleDurationPresent = result.flags[2] & 8, defaultSampleSizePresent = result.flags[2] & 16, defaultSampleFlagsPresent = result.flags[2] & 32, durationIsEmpty = result.flags[0] & 65536, defaultBaseIsMoof = result.flags[0] & 131072, i;
    i = 8;
    if (baseDataOffsetPresent) {
      i += 4;
      result.baseDataOffset = view.getUint32(12);
      i += 4;
    }
    if (sampleDescriptionIndexPresent) {
      result.sampleDescriptionIndex = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleDurationPresent) {
      result.defaultSampleDuration = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleSizePresent) {
      result.defaultSampleSize = view.getUint32(i);
      i += 4;
    }
    if (defaultSampleFlagsPresent) {
      result.defaultSampleFlags = view.getUint32(i);
    }
    if (durationIsEmpty) {
      result.durationIsEmpty = true;
    }
    if (!baseDataOffsetPresent && defaultBaseIsMoof) {
      result.baseDataOffsetIsMoof = true;
    }
    return result;
  };
  var parseTfhd = tfhd;
  var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var win2;
  if (typeof window !== "undefined") {
    win2 = window;
  } else if (typeof commonjsGlobal2 !== "undefined") {
    win2 = commonjsGlobal2;
  } else if (typeof self !== "undefined") {
    win2 = self;
  } else {
    win2 = {};
  }
  var window_12 = win2;
  var discardEmulationPreventionBytes3 = captionPacketParser.discardEmulationPreventionBytes;
  var CaptionStream = captionStream.CaptionStream;
  var mapToSample = function mapToSample2(offset3, samples) {
    var approximateOffset = offset3;
    for (var i = 0; i < samples.length; i++) {
      var sample = samples[i];
      if (approximateOffset < sample.size) {
        return sample;
      }
      approximateOffset -= sample.size;
    }
    return null;
  };
  var findSeiNals = function findSeiNals2(avcStream, samples, trackId) {
    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
      logs: [],
      seiNals: []
    }, seiNal, i, length2, lastMatchedSample;
    for (i = 0; i + 4 < avcStream.length; i += length2) {
      length2 = avcView.getUint32(i);
      i += 4;
      if (length2 <= 0) {
        continue;
      }
      switch (avcStream[i] & 31) {
        case 6:
          var data = avcStream.subarray(i + 1, i + 1 + length2);
          var matchingSample = mapToSample(i, samples);
          seiNal = {
            nalUnitType: "sei_rbsp",
            size: length2,
            data,
            escapedRBSP: discardEmulationPreventionBytes3(data),
            trackId
          };
          if (matchingSample) {
            seiNal.pts = matchingSample.pts;
            seiNal.dts = matchingSample.dts;
            lastMatchedSample = matchingSample;
          } else if (lastMatchedSample) {
            seiNal.pts = lastMatchedSample.pts;
            seiNal.dts = lastMatchedSample.dts;
          } else {
            result.logs.push({
              level: "warn",
              message: "We've encountered a nal unit without data at " + i + " for trackId " + trackId + ". See mux.js#223."
            });
            break;
          }
          result.seiNals.push(seiNal);
          break;
      }
    }
    return result;
  };
  var parseSamples = function parseSamples2(truns, baseMediaDecodeTime, tfhd2) {
    var currentDts = baseMediaDecodeTime;
    var defaultSampleDuration = tfhd2.defaultSampleDuration || 0;
    var defaultSampleSize = tfhd2.defaultSampleSize || 0;
    var trackId = tfhd2.trackId;
    var allSamples = [];
    truns.forEach(function(trun2) {
      var trackRun = parseTrun(trun2);
      var samples = trackRun.samples;
      samples.forEach(function(sample) {
        if (sample.duration === void 0) {
          sample.duration = defaultSampleDuration;
        }
        if (sample.size === void 0) {
          sample.size = defaultSampleSize;
        }
        sample.trackId = trackId;
        sample.dts = currentDts;
        if (sample.compositionTimeOffset === void 0) {
          sample.compositionTimeOffset = 0;
        }
        if (typeof currentDts === "bigint") {
          sample.pts = currentDts + window_12.BigInt(sample.compositionTimeOffset);
          currentDts += window_12.BigInt(sample.duration);
        } else {
          sample.pts = currentDts + sample.compositionTimeOffset;
          currentDts += sample.duration;
        }
      });
      allSamples = allSamples.concat(samples);
    });
    return allSamples;
  };
  var parseCaptionNals = function parseCaptionNals2(segment, videoTrackId) {
    var trafs = findBox_1(segment, ["moof", "traf"]);
    var mdats = findBox_1(segment, ["mdat"]);
    var captionNals = {};
    var mdatTrafPairs = [];
    mdats.forEach(function(mdat2, index2) {
      var matchingTraf = trafs[index2];
      mdatTrafPairs.push({
        mdat: mdat2,
        traf: matchingTraf
      });
    });
    mdatTrafPairs.forEach(function(pair) {
      var mdat2 = pair.mdat;
      var traf2 = pair.traf;
      var tfhd2 = findBox_1(traf2, ["tfhd"]);
      var headerInfo = parseTfhd(tfhd2[0]);
      var trackId = headerInfo.trackId;
      var tfdt2 = findBox_1(traf2, ["tfdt"]);
      var baseMediaDecodeTime = tfdt2.length > 0 ? parseTfdt(tfdt2[0]).baseMediaDecodeTime : 0;
      var truns = findBox_1(traf2, ["trun"]);
      var samples;
      var result;
      if (videoTrackId === trackId && truns.length > 0) {
        samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);
        result = findSeiNals(mdat2, samples, trackId);
        if (!captionNals[trackId]) {
          captionNals[trackId] = {
            seiNals: [],
            logs: []
          };
        }
        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
      }
    });
    return captionNals;
  };
  var parseEmbeddedCaptions = function parseEmbeddedCaptions2(segment, trackId, timescale3) {
    var captionNals;
    if (trackId === null) {
      return null;
    }
    captionNals = parseCaptionNals(segment, trackId);
    var trackNals = captionNals[trackId] || {};
    return {
      seiNals: trackNals.seiNals,
      logs: trackNals.logs,
      timescale: timescale3
    };
  };
  var CaptionParser = function CaptionParser2() {
    var isInitialized = false;
    var captionStream2;
    var segmentCache;
    var trackId;
    var timescale3;
    var parsedCaptions;
    var parsingPartial;
    this.isInitialized = function() {
      return isInitialized;
    };
    this.init = function(options) {
      captionStream2 = new CaptionStream();
      isInitialized = true;
      parsingPartial = options ? options.isPartial : false;
      captionStream2.on("data", function(event) {
        event.startTime = event.startPts / timescale3;
        event.endTime = event.endPts / timescale3;
        parsedCaptions.captions.push(event);
        parsedCaptions.captionStreams[event.stream] = true;
      });
      captionStream2.on("log", function(log2) {
        parsedCaptions.logs.push(log2);
      });
    };
    this.isNewInit = function(videoTrackIds, timescales) {
      if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === "object" && Object.keys(timescales).length === 0) {
        return false;
      }
      return trackId !== videoTrackIds[0] || timescale3 !== timescales[trackId];
    };
    this.parse = function(segment, videoTrackIds, timescales) {
      var parsedData;
      if (!this.isInitialized()) {
        return null;
      } else if (!videoTrackIds || !timescales) {
        return null;
      } else if (this.isNewInit(videoTrackIds, timescales)) {
        trackId = videoTrackIds[0];
        timescale3 = timescales[trackId];
      } else if (trackId === null || !timescale3) {
        segmentCache.push(segment);
        return null;
      }
      while (segmentCache.length > 0) {
        var cachedSegment = segmentCache.shift();
        this.parse(cachedSegment, videoTrackIds, timescales);
      }
      parsedData = parseEmbeddedCaptions(segment, trackId, timescale3);
      if (parsedData && parsedData.logs) {
        parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
      }
      if (parsedData === null || !parsedData.seiNals) {
        if (parsedCaptions.logs.length) {
          return {
            logs: parsedCaptions.logs,
            captions: [],
            captionStreams: []
          };
        }
        return null;
      }
      this.pushNals(parsedData.seiNals);
      this.flushStream();
      return parsedCaptions;
    };
    this.pushNals = function(nals) {
      if (!this.isInitialized() || !nals || nals.length === 0) {
        return null;
      }
      nals.forEach(function(nal) {
        captionStream2.push(nal);
      });
    };
    this.flushStream = function() {
      if (!this.isInitialized()) {
        return null;
      }
      if (!parsingPartial) {
        captionStream2.flush();
      } else {
        captionStream2.partialFlush();
      }
    };
    this.clearParsedCaptions = function() {
      parsedCaptions.captions = [];
      parsedCaptions.captionStreams = {};
      parsedCaptions.logs = [];
    };
    this.resetCaptionStream = function() {
      if (!this.isInitialized()) {
        return null;
      }
      captionStream2.reset();
    };
    this.clearAllCaptions = function() {
      this.clearParsedCaptions();
      this.resetCaptionStream();
    };
    this.reset = function() {
      segmentCache = [];
      trackId = null;
      timescale3 = null;
      if (!parsedCaptions) {
        parsedCaptions = {
          captions: [],
          // CC1, CC2, CC3, CC4
          captionStreams: {},
          logs: []
        };
      } else {
        this.clearParsedCaptions();
      }
      this.resetCaptionStream();
    };
    this.reset();
  };
  var captionParser = CaptionParser;
  var toUnsigned = bin.toUnsigned;
  var toHexString = bin.toHexString;
  var getUint642 = numbers2.getUint64;
  var timescale2, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;
  timescale2 = function timescale3(init) {
    var result = {}, traks = findBox_1(init, ["moov", "trak"]);
    return traks.reduce(function(result2, trak2) {
      var tkhd2, version2, index2, id2, mdhd2;
      tkhd2 = findBox_1(trak2, ["tkhd"])[0];
      if (!tkhd2) {
        return null;
      }
      version2 = tkhd2[0];
      index2 = version2 === 0 ? 12 : 20;
      id2 = toUnsigned(tkhd2[index2] << 24 | tkhd2[index2 + 1] << 16 | tkhd2[index2 + 2] << 8 | tkhd2[index2 + 3]);
      mdhd2 = findBox_1(trak2, ["mdia", "mdhd"])[0];
      if (!mdhd2) {
        return null;
      }
      version2 = mdhd2[0];
      index2 = version2 === 0 ? 12 : 20;
      result2[id2] = toUnsigned(mdhd2[index2] << 24 | mdhd2[index2 + 1] << 16 | mdhd2[index2 + 2] << 8 | mdhd2[index2 + 3]);
      return result2;
    }, result);
  };
  startTime = function startTime2(timescale3, fragment) {
    var trafs;
    trafs = findBox_1(fragment, ["moof", "traf"]);
    var lowestTime = trafs.reduce(function(acc, traf2) {
      var tfhd2 = findBox_1(traf2, ["tfhd"])[0];
      var id2 = toUnsigned(tfhd2[4] << 24 | tfhd2[5] << 16 | tfhd2[6] << 8 | tfhd2[7]);
      var scale = timescale3[id2] || 9e4;
      var tfdt2 = findBox_1(traf2, ["tfdt"])[0];
      var dv = new DataView(tfdt2.buffer, tfdt2.byteOffset, tfdt2.byteLength);
      var baseTime;
      if (tfdt2[0] === 1) {
        baseTime = getUint642(tfdt2.subarray(4, 12));
      } else {
        baseTime = dv.getUint32(4);
      }
      var seconds;
      if (typeof baseTime === "bigint") {
        seconds = baseTime / window_12.BigInt(scale);
      } else if (typeof baseTime === "number" && !isNaN(baseTime)) {
        seconds = baseTime / scale;
      }
      if (seconds < Number.MAX_SAFE_INTEGER) {
        seconds = Number(seconds);
      }
      if (seconds < acc) {
        acc = seconds;
      }
      return acc;
    }, Infinity);
    return typeof lowestTime === "bigint" || isFinite(lowestTime) ? lowestTime : 0;
  };
  compositionStartTime = function compositionStartTime2(timescales, fragment) {
    var trafBoxes = findBox_1(fragment, ["moof", "traf"]);
    var baseMediaDecodeTime = 0;
    var compositionTimeOffset = 0;
    var trackId;
    if (trafBoxes && trafBoxes.length) {
      var tfhd2 = findBox_1(trafBoxes[0], ["tfhd"])[0];
      var trun2 = findBox_1(trafBoxes[0], ["trun"])[0];
      var tfdt2 = findBox_1(trafBoxes[0], ["tfdt"])[0];
      if (tfhd2) {
        var parsedTfhd = parseTfhd(tfhd2);
        trackId = parsedTfhd.trackId;
      }
      if (tfdt2) {
        var parsedTfdt = parseTfdt(tfdt2);
        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
      }
      if (trun2) {
        var parsedTrun = parseTrun(trun2);
        if (parsedTrun.samples && parsedTrun.samples.length) {
          compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
        }
      }
    }
    var timescale3 = timescales[trackId] || 9e4;
    if (typeof baseMediaDecodeTime === "bigint") {
      compositionTimeOffset = window_12.BigInt(compositionTimeOffset);
      timescale3 = window_12.BigInt(timescale3);
    }
    var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale3;
    if (typeof result === "bigint" && result < Number.MAX_SAFE_INTEGER) {
      result = Number(result);
    }
    return result;
  };
  getVideoTrackIds = function getVideoTrackIds2(init) {
    var traks = findBox_1(init, ["moov", "trak"]);
    var videoTrackIds = [];
    traks.forEach(function(trak2) {
      var hdlrs = findBox_1(trak2, ["mdia", "hdlr"]);
      var tkhds = findBox_1(trak2, ["tkhd"]);
      hdlrs.forEach(function(hdlr2, index2) {
        var handlerType = parseType_1(hdlr2.subarray(8, 12));
        var tkhd2 = tkhds[index2];
        var view;
        var version2;
        var trackId;
        if (handlerType === "vide") {
          view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
          version2 = view.getUint8(0);
          trackId = version2 === 0 ? view.getUint32(12) : view.getUint32(20);
          videoTrackIds.push(trackId);
        }
      });
    });
    return videoTrackIds;
  };
  getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader2(mdhd2) {
    var version2 = mdhd2[0];
    var index2 = version2 === 0 ? 12 : 20;
    return toUnsigned(mdhd2[index2] << 24 | mdhd2[index2 + 1] << 16 | mdhd2[index2 + 2] << 8 | mdhd2[index2 + 3]);
  };
  getTracks = function getTracks2(init) {
    var traks = findBox_1(init, ["moov", "trak"]);
    var tracks = [];
    traks.forEach(function(trak2) {
      var track = {};
      var tkhd2 = findBox_1(trak2, ["tkhd"])[0];
      var view, tkhdVersion;
      if (tkhd2) {
        view = new DataView(tkhd2.buffer, tkhd2.byteOffset, tkhd2.byteLength);
        tkhdVersion = view.getUint8(0);
        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
      }
      var hdlr2 = findBox_1(trak2, ["mdia", "hdlr"])[0];
      if (hdlr2) {
        var type3 = parseType_1(hdlr2.subarray(8, 12));
        if (type3 === "vide") {
          track.type = "video";
        } else if (type3 === "soun") {
          track.type = "audio";
        } else {
          track.type = type3;
        }
      }
      var stsd2 = findBox_1(trak2, ["mdia", "minf", "stbl", "stsd"])[0];
      if (stsd2) {
        var sampleDescriptions = stsd2.subarray(8);
        track.codec = parseType_1(sampleDescriptions.subarray(4, 8));
        var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];
        var codecConfig, codecConfigType;
        if (codecBox) {
          if (/^[asm]vc[1-9]$/i.test(track.codec)) {
            codecConfig = codecBox.subarray(78);
            codecConfigType = parseType_1(codecConfig.subarray(4, 8));
            if (codecConfigType === "avcC" && codecConfig.length > 11) {
              track.codec += ".";
              track.codec += toHexString(codecConfig[9]);
              track.codec += toHexString(codecConfig[10]);
              track.codec += toHexString(codecConfig[11]);
            } else {
              track.codec = "avc1.4d400d";
            }
          } else if (/^mp4[a,v]$/i.test(track.codec)) {
            codecConfig = codecBox.subarray(28);
            codecConfigType = parseType_1(codecConfig.subarray(4, 8));
            if (codecConfigType === "esds" && codecConfig.length > 20 && codecConfig[19] !== 0) {
              track.codec += "." + toHexString(codecConfig[19]);
              track.codec += "." + toHexString(codecConfig[20] >>> 2 & 63).replace(/^0/, "");
            } else {
              track.codec = "mp4a.40.2";
            }
          } else {
            track.codec = track.codec.toLowerCase();
          }
        }
      }
      var mdhd2 = findBox_1(trak2, ["mdia", "mdhd"])[0];
      if (mdhd2) {
        track.timescale = getTimescaleFromMediaHeader(mdhd2);
      }
      tracks.push(track);
    });
    return tracks;
  };
  var probe$2 = {
    // export mp4 inspector's findBox and parseType for backwards compatibility
    findBox: findBox_1,
    parseType: parseType_1,
    timescale: timescale2,
    startTime,
    compositionStartTime,
    videoTrackIds: getVideoTrackIds,
    tracks: getTracks,
    getTimescaleFromMediaHeader
  };
  var parsePid = function parsePid2(packet) {
    var pid = packet[1] & 31;
    pid <<= 8;
    pid |= packet[2];
    return pid;
  };
  var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator2(packet) {
    return !!(packet[1] & 64);
  };
  var parseAdaptionField = function parseAdaptionField2(packet) {
    var offset3 = 0;
    if ((packet[3] & 48) >>> 4 > 1) {
      offset3 += packet[4] + 1;
    }
    return offset3;
  };
  var parseType = function parseType2(packet, pmtPid) {
    var pid = parsePid(packet);
    if (pid === 0) {
      return "pat";
    } else if (pid === pmtPid) {
      return "pmt";
    } else if (pmtPid) {
      return "pes";
    }
    return null;
  };
  var parsePat = function parsePat2(packet) {
    var pusi = parsePayloadUnitStartIndicator(packet);
    var offset3 = 4 + parseAdaptionField(packet);
    if (pusi) {
      offset3 += packet[offset3] + 1;
    }
    return (packet[offset3 + 10] & 31) << 8 | packet[offset3 + 11];
  };
  var parsePmt = function parsePmt2(packet) {
    var programMapTable = {};
    var pusi = parsePayloadUnitStartIndicator(packet);
    var payloadOffset = 4 + parseAdaptionField(packet);
    if (pusi) {
      payloadOffset += packet[payloadOffset] + 1;
    }
    if (!(packet[payloadOffset + 5] & 1)) {
      return;
    }
    var sectionLength, tableEnd, programInfoLength;
    sectionLength = (packet[payloadOffset + 1] & 15) << 8 | packet[payloadOffset + 2];
    tableEnd = 3 + sectionLength - 4;
    programInfoLength = (packet[payloadOffset + 10] & 15) << 8 | packet[payloadOffset + 11];
    var offset3 = 12 + programInfoLength;
    while (offset3 < tableEnd) {
      var i = payloadOffset + offset3;
      programMapTable[(packet[i + 1] & 31) << 8 | packet[i + 2]] = packet[i];
      offset3 += ((packet[i + 3] & 15) << 8 | packet[i + 4]) + 5;
    }
    return programMapTable;
  };
  var parsePesType = function parsePesType2(packet, programMapTable) {
    var pid = parsePid(packet);
    var type3 = programMapTable[pid];
    switch (type3) {
      case streamTypes.H264_STREAM_TYPE:
        return "video";
      case streamTypes.ADTS_STREAM_TYPE:
        return "audio";
      case streamTypes.METADATA_STREAM_TYPE:
        return "timed-metadata";
      default:
        return null;
    }
  };
  var parsePesTime = function parsePesTime2(packet) {
    var pusi = parsePayloadUnitStartIndicator(packet);
    if (!pusi) {
      return null;
    }
    var offset3 = 4 + parseAdaptionField(packet);
    if (offset3 >= packet.byteLength) {
      return null;
    }
    var pes = null;
    var ptsDtsFlags;
    ptsDtsFlags = packet[offset3 + 7];
    if (ptsDtsFlags & 192) {
      pes = {};
      pes.pts = (packet[offset3 + 9] & 14) << 27 | (packet[offset3 + 10] & 255) << 20 | (packet[offset3 + 11] & 254) << 12 | (packet[offset3 + 12] & 255) << 5 | (packet[offset3 + 13] & 254) >>> 3;
      pes.pts *= 4;
      pes.pts += (packet[offset3 + 13] & 6) >>> 1;
      pes.dts = pes.pts;
      if (ptsDtsFlags & 64) {
        pes.dts = (packet[offset3 + 14] & 14) << 27 | (packet[offset3 + 15] & 255) << 20 | (packet[offset3 + 16] & 254) << 12 | (packet[offset3 + 17] & 255) << 5 | (packet[offset3 + 18] & 254) >>> 3;
        pes.dts *= 4;
        pes.dts += (packet[offset3 + 18] & 6) >>> 1;
      }
    }
    return pes;
  };
  var parseNalUnitType = function parseNalUnitType2(type3) {
    switch (type3) {
      case 5:
        return "slice_layer_without_partitioning_rbsp_idr";
      case 6:
        return "sei_rbsp";
      case 7:
        return "seq_parameter_set_rbsp";
      case 8:
        return "pic_parameter_set_rbsp";
      case 9:
        return "access_unit_delimiter_rbsp";
      default:
        return null;
    }
  };
  var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame2(packet) {
    var offset3 = 4 + parseAdaptionField(packet);
    var frameBuffer = packet.subarray(offset3);
    var frameI = 0;
    var frameSyncPoint = 0;
    var foundKeyFrame = false;
    var nalType;
    for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {
      if (frameBuffer[frameSyncPoint + 2] === 1) {
        frameI = frameSyncPoint + 5;
        break;
      }
    }
    while (frameI < frameBuffer.byteLength) {
      switch (frameBuffer[frameI]) {
        case 0:
          if (frameBuffer[frameI - 1] !== 0) {
            frameI += 2;
            break;
          } else if (frameBuffer[frameI - 2] !== 0) {
            frameI++;
            break;
          }
          if (frameSyncPoint + 3 !== frameI - 2) {
            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
            if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
              foundKeyFrame = true;
            }
          }
          do {
            frameI++;
          } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
          frameSyncPoint = frameI - 2;
          frameI += 3;
          break;
        case 1:
          if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
            frameI += 3;
            break;
          }
          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
          if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
            foundKeyFrame = true;
          }
          frameSyncPoint = frameI - 2;
          frameI += 3;
          break;
        default:
          frameI += 3;
          break;
      }
    }
    frameBuffer = frameBuffer.subarray(frameSyncPoint);
    frameI -= frameSyncPoint;
    frameSyncPoint = 0;
    if (frameBuffer && frameBuffer.byteLength > 3) {
      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
      if (nalType === "slice_layer_without_partitioning_rbsp_idr") {
        foundKeyFrame = true;
      }
    }
    return foundKeyFrame;
  };
  var probe$1 = {
    parseType,
    parsePat,
    parsePmt,
    parsePayloadUnitStartIndicator,
    parsePesType,
    parsePesTime,
    videoPacketContainsKeyFrame
  };
  var handleRollover = timestampRolloverStream.handleRollover;
  var probe = {};
  probe.ts = probe$1;
  probe.aac = utils2;
  var ONE_SECOND_IN_TS2 = clock2.ONE_SECOND_IN_TS;
  var MP2T_PACKET_LENGTH = 188, SYNC_BYTE = 71;
  var parsePsi_ = function parsePsi_2(bytes, pmt) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3;
    while (endIndex < bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pat":
            pmt.pid = probe.ts.parsePat(packet);
            break;
          case "pmt":
            var table = probe.ts.parsePmt(packet);
            pmt.table = pmt.table || {};
            Object.keys(table).forEach(function(key) {
              pmt.table[key] = table[key];
            });
            break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
  };
  var parseAudioPes_ = function parseAudioPes_2(bytes, pmt, result) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3, pesType, pusi, parsed;
    var endLoop = false;
    while (endIndex <= bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "audio" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "audio";
                result.audio.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
    endIndex = bytes.byteLength;
    startIndex = endIndex - MP2T_PACKET_LENGTH;
    endLoop = false;
    while (startIndex >= 0) {
      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "audio" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "audio";
                result.audio.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex -= MP2T_PACKET_LENGTH;
        endIndex -= MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex--;
      endIndex--;
    }
  };
  var parseVideoPes_ = function parseVideoPes_2(bytes, pmt, result) {
    var startIndex = 0, endIndex = MP2T_PACKET_LENGTH, packet, type3, pesType, pusi, parsed, frame, i, pes;
    var endLoop = false;
    var currentFrame = {
      data: [],
      size: 0
    };
    while (endIndex < bytes.byteLength) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "video") {
              if (pusi && !endLoop) {
                parsed = probe.ts.parsePesTime(packet);
                if (parsed) {
                  parsed.type = "video";
                  result.video.push(parsed);
                  endLoop = true;
                }
              }
              if (!result.firstKeyFrame) {
                if (pusi) {
                  if (currentFrame.size !== 0) {
                    frame = new Uint8Array(currentFrame.size);
                    i = 0;
                    while (currentFrame.data.length) {
                      pes = currentFrame.data.shift();
                      frame.set(pes, i);
                      i += pes.byteLength;
                    }
                    if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                      var firstKeyFrame = probe.ts.parsePesTime(frame);
                      if (firstKeyFrame) {
                        result.firstKeyFrame = firstKeyFrame;
                        result.firstKeyFrame.type = "video";
                      } else {
                        console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.");
                      }
                    }
                    currentFrame.size = 0;
                  }
                }
                currentFrame.data.push(packet);
                currentFrame.size += packet.byteLength;
              }
            }
            break;
        }
        if (endLoop && result.firstKeyFrame) {
          break;
        }
        startIndex += MP2T_PACKET_LENGTH;
        endIndex += MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex++;
      endIndex++;
    }
    endIndex = bytes.byteLength;
    startIndex = endIndex - MP2T_PACKET_LENGTH;
    endLoop = false;
    while (startIndex >= 0) {
      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
        packet = bytes.subarray(startIndex, endIndex);
        type3 = probe.ts.parseType(packet, pmt.pid);
        switch (type3) {
          case "pes":
            pesType = probe.ts.parsePesType(packet, pmt.table);
            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
            if (pesType === "video" && pusi) {
              parsed = probe.ts.parsePesTime(packet);
              if (parsed) {
                parsed.type = "video";
                result.video.push(parsed);
                endLoop = true;
              }
            }
            break;
        }
        if (endLoop) {
          break;
        }
        startIndex -= MP2T_PACKET_LENGTH;
        endIndex -= MP2T_PACKET_LENGTH;
        continue;
      }
      startIndex--;
      endIndex--;
    }
  };
  var adjustTimestamp_ = function adjustTimestamp_2(segmentInfo, baseTimestamp) {
    if (segmentInfo.audio && segmentInfo.audio.length) {
      var audioBaseTimestamp = baseTimestamp;
      if (typeof audioBaseTimestamp === "undefined" || isNaN(audioBaseTimestamp)) {
        audioBaseTimestamp = segmentInfo.audio[0].dts;
      }
      segmentInfo.audio.forEach(function(info) {
        info.dts = handleRollover(info.dts, audioBaseTimestamp);
        info.pts = handleRollover(info.pts, audioBaseTimestamp);
        info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
        info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
      });
    }
    if (segmentInfo.video && segmentInfo.video.length) {
      var videoBaseTimestamp = baseTimestamp;
      if (typeof videoBaseTimestamp === "undefined" || isNaN(videoBaseTimestamp)) {
        videoBaseTimestamp = segmentInfo.video[0].dts;
      }
      segmentInfo.video.forEach(function(info) {
        info.dts = handleRollover(info.dts, videoBaseTimestamp);
        info.pts = handleRollover(info.pts, videoBaseTimestamp);
        info.dtsTime = info.dts / ONE_SECOND_IN_TS2;
        info.ptsTime = info.pts / ONE_SECOND_IN_TS2;
      });
      if (segmentInfo.firstKeyFrame) {
        var frame = segmentInfo.firstKeyFrame;
        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
        frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS2;
        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS2;
      }
    }
  };
  var inspectAac_ = function inspectAac_2(bytes) {
    var endLoop = false, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0, packet;
    while (bytes.length - byteIndex >= 3) {
      var type3 = probe.aac.parseType(bytes, byteIndex);
      switch (type3) {
        case "timed-metadata":
          if (bytes.length - byteIndex < 10) {
            endLoop = true;
            break;
          }
          frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);
          if (frameSize > bytes.length) {
            endLoop = true;
            break;
          }
          if (timestamp === null) {
            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
            timestamp = probe.aac.parseAacTimestamp(packet);
          }
          byteIndex += frameSize;
          break;
        case "audio":
          if (bytes.length - byteIndex < 7) {
            endLoop = true;
            break;
          }
          frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);
          if (frameSize > bytes.length) {
            endLoop = true;
            break;
          }
          if (sampleRate === null) {
            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
            sampleRate = probe.aac.parseSampleRate(packet);
          }
          audioCount++;
          byteIndex += frameSize;
          break;
        default:
          byteIndex++;
          break;
      }
      if (endLoop) {
        return null;
      }
    }
    if (sampleRate === null || timestamp === null) {
      return null;
    }
    var audioTimescale = ONE_SECOND_IN_TS2 / sampleRate;
    var result = {
      audio: [{
        type: "audio",
        dts: timestamp,
        pts: timestamp
      }, {
        type: "audio",
        dts: timestamp + audioCount * 1024 * audioTimescale,
        pts: timestamp + audioCount * 1024 * audioTimescale
      }]
    };
    return result;
  };
  var inspectTs_ = function inspectTs_2(bytes) {
    var pmt = {
      pid: null,
      table: null
    };
    var result = {};
    parsePsi_(bytes, pmt);
    for (var pid in pmt.table) {
      if (pmt.table.hasOwnProperty(pid)) {
        var type3 = pmt.table[pid];
        switch (type3) {
          case streamTypes.H264_STREAM_TYPE:
            result.video = [];
            parseVideoPes_(bytes, pmt, result);
            if (result.video.length === 0) {
              delete result.video;
            }
            break;
          case streamTypes.ADTS_STREAM_TYPE:
            result.audio = [];
            parseAudioPes_(bytes, pmt, result);
            if (result.audio.length === 0) {
              delete result.audio;
            }
            break;
        }
      }
    }
    return result;
  };
  var inspect = function inspect2(bytes, baseTimestamp) {
    var isAacData = probe.aac.isLikelyAacData(bytes);
    var result;
    if (isAacData) {
      result = inspectAac_(bytes);
    } else {
      result = inspectTs_(bytes);
    }
    if (!result || !result.audio && !result.video) {
      return null;
    }
    adjustTimestamp_(result, baseTimestamp);
    return result;
  };
  var tsInspector = {
    inspect,
    parseAudioPes_
  };
  var wireTransmuxerEvents = function wireTransmuxerEvents2(self2, transmuxer2) {
    transmuxer2.on("data", function(segment) {
      var initArray = segment.initSegment;
      segment.initSegment = {
        data: initArray.buffer,
        byteOffset: initArray.byteOffset,
        byteLength: initArray.byteLength
      };
      var typedArray = segment.data;
      segment.data = typedArray.buffer;
      self2.postMessage({
        action: "data",
        segment,
        byteOffset: typedArray.byteOffset,
        byteLength: typedArray.byteLength
      }, [segment.data]);
    });
    transmuxer2.on("done", function(data) {
      self2.postMessage({
        action: "done"
      });
    });
    transmuxer2.on("gopInfo", function(gopInfo) {
      self2.postMessage({
        action: "gopInfo",
        gopInfo
      });
    });
    transmuxer2.on("videoSegmentTimingInfo", function(timingInfo) {
      var videoSegmentTimingInfo = {
        start: {
          decode: clock2.videoTsToSeconds(timingInfo.start.dts),
          presentation: clock2.videoTsToSeconds(timingInfo.start.pts)
        },
        end: {
          decode: clock2.videoTsToSeconds(timingInfo.end.dts),
          presentation: clock2.videoTsToSeconds(timingInfo.end.pts)
        },
        baseMediaDecodeTime: clock2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
      };
      if (timingInfo.prependedContentDuration) {
        videoSegmentTimingInfo.prependedContentDuration = clock2.videoTsToSeconds(timingInfo.prependedContentDuration);
      }
      self2.postMessage({
        action: "videoSegmentTimingInfo",
        videoSegmentTimingInfo
      });
    });
    transmuxer2.on("audioSegmentTimingInfo", function(timingInfo) {
      var audioSegmentTimingInfo = {
        start: {
          decode: clock2.videoTsToSeconds(timingInfo.start.dts),
          presentation: clock2.videoTsToSeconds(timingInfo.start.pts)
        },
        end: {
          decode: clock2.videoTsToSeconds(timingInfo.end.dts),
          presentation: clock2.videoTsToSeconds(timingInfo.end.pts)
        },
        baseMediaDecodeTime: clock2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
      };
      if (timingInfo.prependedContentDuration) {
        audioSegmentTimingInfo.prependedContentDuration = clock2.videoTsToSeconds(timingInfo.prependedContentDuration);
      }
      self2.postMessage({
        action: "audioSegmentTimingInfo",
        audioSegmentTimingInfo
      });
    });
    transmuxer2.on("id3Frame", function(id3Frame) {
      self2.postMessage({
        action: "id3Frame",
        id3Frame
      });
    });
    transmuxer2.on("caption", function(caption) {
      self2.postMessage({
        action: "caption",
        caption
      });
    });
    transmuxer2.on("trackinfo", function(trackInfo) {
      self2.postMessage({
        action: "trackinfo",
        trackInfo
      });
    });
    transmuxer2.on("audioTimingInfo", function(audioTimingInfo) {
      self2.postMessage({
        action: "audioTimingInfo",
        audioTimingInfo: {
          start: clock2.videoTsToSeconds(audioTimingInfo.start),
          end: clock2.videoTsToSeconds(audioTimingInfo.end)
        }
      });
    });
    transmuxer2.on("videoTimingInfo", function(videoTimingInfo) {
      self2.postMessage({
        action: "videoTimingInfo",
        videoTimingInfo: {
          start: clock2.videoTsToSeconds(videoTimingInfo.start),
          end: clock2.videoTsToSeconds(videoTimingInfo.end)
        }
      });
    });
    transmuxer2.on("log", function(log2) {
      self2.postMessage({
        action: "log",
        log: log2
      });
    });
  };
  var MessageHandlers = /* @__PURE__ */ function() {
    function MessageHandlers2(self2, options) {
      this.options = options || {};
      this.self = self2;
      this.init();
    }
    var _proto = MessageHandlers2.prototype;
    _proto.init = function init() {
      if (this.transmuxer) {
        this.transmuxer.dispose();
      }
      this.transmuxer = new transmuxer.Transmuxer(this.options);
      wireTransmuxerEvents(this.self, this.transmuxer);
    };
    _proto.pushMp4Captions = function pushMp4Captions(data) {
      if (!this.captionParser) {
        this.captionParser = new captionParser();
        this.captionParser.init();
      }
      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
      var parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
      this.self.postMessage({
        action: "mp4Captions",
        captions: parsed && parsed.captions || [],
        logs: parsed && parsed.logs || [],
        data: segment.buffer
      }, [segment.buffer]);
    };
    _proto.probeMp4StartTime = function probeMp4StartTime(_ref) {
      var timescales = _ref.timescales, data = _ref.data;
      var startTime2 = probe$2.startTime(timescales, data);
      this.self.postMessage({
        action: "probeMp4StartTime",
        startTime: startTime2,
        data
      }, [data.buffer]);
    };
    _proto.probeMp4Tracks = function probeMp4Tracks(_ref2) {
      var data = _ref2.data;
      var tracks = probe$2.tracks(data);
      this.self.postMessage({
        action: "probeMp4Tracks",
        tracks,
        data
      }, [data.buffer]);
    };
    _proto.probeTs = function probeTs(_ref3) {
      var data = _ref3.data, baseStartTime = _ref3.baseStartTime;
      var tsStartTime = typeof baseStartTime === "number" && !isNaN(baseStartTime) ? baseStartTime * clock2.ONE_SECOND_IN_TS : void 0;
      var timeInfo = tsInspector.inspect(data, tsStartTime);
      var result = null;
      if (timeInfo) {
        result = {
          // each type's time info comes back as an array of 2 times, start and end
          hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
          hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
        };
        if (result.hasVideo) {
          result.videoStart = timeInfo.video[0].ptsTime;
        }
        if (result.hasAudio) {
          result.audioStart = timeInfo.audio[0].ptsTime;
        }
      }
      this.self.postMessage({
        action: "probeTs",
        result,
        data
      }, [data.buffer]);
    };
    _proto.clearAllMp4Captions = function clearAllMp4Captions() {
      if (this.captionParser) {
        this.captionParser.clearAllCaptions();
      }
    };
    _proto.clearParsedMp4Captions = function clearParsedMp4Captions() {
      if (this.captionParser) {
        this.captionParser.clearParsedCaptions();
      }
    };
    _proto.push = function push(data) {
      var segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
      this.transmuxer.push(segment);
    };
    _proto.reset = function reset3() {
      this.transmuxer.reset();
    };
    _proto.setTimestampOffset = function setTimestampOffset(data) {
      var timestampOffset2 = data.timestampOffset || 0;
      this.transmuxer.setBaseMediaDecodeTime(Math.round(clock2.secondsToVideoTs(timestampOffset2)));
    };
    _proto.setAudioAppendStart = function setAudioAppendStart(data) {
      this.transmuxer.setAudioAppendStart(Math.ceil(clock2.secondsToVideoTs(data.appendStart)));
    };
    _proto.setRemux = function setRemux(data) {
      this.transmuxer.setRemux(data.remux);
    };
    _proto.flush = function flush3(data) {
      this.transmuxer.flush();
      self.postMessage({
        action: "done",
        type: "transmuxed"
      });
    };
    _proto.endTimeline = function endTimeline3() {
      this.transmuxer.endTimeline();
      self.postMessage({
        action: "endedtimeline",
        type: "transmuxed"
      });
    };
    _proto.alignGopsWith = function alignGopsWith(data) {
      this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
    };
    return MessageHandlers2;
  }();
  self.onmessage = function(event) {
    if (event.data.action === "init" && event.data.options) {
      this.messageHandlers = new MessageHandlers(self, event.data.options);
      return;
    }
    if (!this.messageHandlers) {
      this.messageHandlers = new MessageHandlers(self);
    }
    if (event.data && event.data.action && event.data.action !== "init") {
      if (this.messageHandlers[event.data.action]) {
        this.messageHandlers[event.data.action](event.data);
      }
    }
  };
}));
var TransmuxWorker = factory(workerCode$1);
var handleData_ = function handleData_2(event, transmuxedData, callback2) {
  var _event$data$segment = event.data.segment, type2 = _event$data$segment.type, initSegment = _event$data$segment.initSegment, captions = _event$data$segment.captions, captionStreams = _event$data$segment.captionStreams, metadata = _event$data$segment.metadata, videoFrameDtsTime = _event$data$segment.videoFrameDtsTime, videoFramePtsTime = _event$data$segment.videoFramePtsTime;
  transmuxedData.buffer.push({
    captions,
    captionStreams,
    metadata
  });
  var boxes = event.data.segment.boxes || {
    data: event.data.segment.data
  };
  var result = {
    type: type2,
    // cast ArrayBuffer to TypedArray
    data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
    initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
  };
  if (typeof videoFrameDtsTime !== "undefined") {
    result.videoFrameDtsTime = videoFrameDtsTime;
  }
  if (typeof videoFramePtsTime !== "undefined") {
    result.videoFramePtsTime = videoFramePtsTime;
  }
  callback2(result);
};
var handleDone_ = function handleDone_2(_ref) {
  var transmuxedData = _ref.transmuxedData, callback2 = _ref.callback;
  transmuxedData.buffer = [];
  callback2(transmuxedData);
};
var handleGopInfo_ = function handleGopInfo_2(event, transmuxedData) {
  transmuxedData.gopInfo = event.data.gopInfo;
};
var processTransmux = function processTransmux2(options) {
  var transmuxer = options.transmuxer, bytes = options.bytes, audioAppendStart = options.audioAppendStart, gopsToAlignWith = options.gopsToAlignWith, remux = options.remux, onData = options.onData, onTrackInfo = options.onTrackInfo, onAudioTimingInfo = options.onAudioTimingInfo, onVideoTimingInfo = options.onVideoTimingInfo, onVideoSegmentTimingInfo = options.onVideoSegmentTimingInfo, onAudioSegmentTimingInfo = options.onAudioSegmentTimingInfo, onId3 = options.onId3, onCaptions = options.onCaptions, onDone = options.onDone, onEndedTimeline = options.onEndedTimeline, onTransmuxerLog = options.onTransmuxerLog, isEndOfTimeline = options.isEndOfTimeline;
  var transmuxedData = {
    buffer: []
  };
  var waitForEndedTimelineEvent = isEndOfTimeline;
  var handleMessage = function handleMessage2(event) {
    if (transmuxer.currentTransmux !== options) {
      return;
    }
    if (event.data.action === "data") {
      handleData_(event, transmuxedData, onData);
    }
    if (event.data.action === "trackinfo") {
      onTrackInfo(event.data.trackInfo);
    }
    if (event.data.action === "gopInfo") {
      handleGopInfo_(event, transmuxedData);
    }
    if (event.data.action === "audioTimingInfo") {
      onAudioTimingInfo(event.data.audioTimingInfo);
    }
    if (event.data.action === "videoTimingInfo") {
      onVideoTimingInfo(event.data.videoTimingInfo);
    }
    if (event.data.action === "videoSegmentTimingInfo") {
      onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);
    }
    if (event.data.action === "audioSegmentTimingInfo") {
      onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);
    }
    if (event.data.action === "id3Frame") {
      onId3([event.data.id3Frame], event.data.id3Frame.dispatchType);
    }
    if (event.data.action === "caption") {
      onCaptions(event.data.caption);
    }
    if (event.data.action === "endedtimeline") {
      waitForEndedTimelineEvent = false;
      onEndedTimeline();
    }
    if (event.data.action === "log") {
      onTransmuxerLog(event.data.log);
    }
    if (event.data.type !== "transmuxed") {
      return;
    }
    if (waitForEndedTimelineEvent) {
      return;
    }
    transmuxer.onmessage = null;
    handleDone_({
      transmuxedData,
      callback: onDone
    });
    dequeue(transmuxer);
  };
  transmuxer.onmessage = handleMessage;
  if (audioAppendStart) {
    transmuxer.postMessage({
      action: "setAudioAppendStart",
      appendStart: audioAppendStart
    });
  }
  if (Array.isArray(gopsToAlignWith)) {
    transmuxer.postMessage({
      action: "alignGopsWith",
      gopsToAlignWith
    });
  }
  if (typeof remux !== "undefined") {
    transmuxer.postMessage({
      action: "setRemux",
      remux
    });
  }
  if (bytes.byteLength) {
    var buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
    var byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
    transmuxer.postMessage({
      action: "push",
      // Send the typed-array of data as an ArrayBuffer so that
      // it can be sent as a "Transferable" and avoid the costly
      // memory copy
      data: buffer,
      // To recreate the original typed-array, we need information
      // about what portion of the ArrayBuffer it was a view into
      byteOffset,
      byteLength: bytes.byteLength
    }, [buffer]);
  }
  if (isEndOfTimeline) {
    transmuxer.postMessage({
      action: "endTimeline"
    });
  }
  transmuxer.postMessage({
    action: "flush"
  });
};
var dequeue = function dequeue2(transmuxer) {
  transmuxer.currentTransmux = null;
  if (transmuxer.transmuxQueue.length) {
    transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
    if (typeof transmuxer.currentTransmux === "function") {
      transmuxer.currentTransmux();
    } else {
      processTransmux(transmuxer.currentTransmux);
    }
  }
};
var processAction = function processAction2(transmuxer, action) {
  transmuxer.postMessage({
    action
  });
  dequeue(transmuxer);
};
var enqueueAction = function enqueueAction2(action, transmuxer) {
  if (!transmuxer.currentTransmux) {
    transmuxer.currentTransmux = action;
    processAction(transmuxer, action);
    return;
  }
  transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
};
var reset = function reset2(transmuxer) {
  enqueueAction("reset", transmuxer);
};
var endTimeline = function endTimeline2(transmuxer) {
  enqueueAction("endTimeline", transmuxer);
};
var transmux = function transmux2(options) {
  if (!options.transmuxer.currentTransmux) {
    options.transmuxer.currentTransmux = options;
    processTransmux(options);
    return;
  }
  options.transmuxer.transmuxQueue.push(options);
};
var createTransmuxer = function createTransmuxer2(options) {
  var transmuxer = new TransmuxWorker();
  transmuxer.currentTransmux = null;
  transmuxer.transmuxQueue = [];
  var term = transmuxer.terminate;
  transmuxer.terminate = function() {
    transmuxer.currentTransmux = null;
    transmuxer.transmuxQueue.length = 0;
    return term.call(transmuxer);
  };
  transmuxer.postMessage({
    action: "init",
    options
  });
  return transmuxer;
};
var segmentTransmuxer = {
  reset,
  endTimeline,
  transmux,
  createTransmuxer
};
var workerCallback = function workerCallback2(options) {
  var transmuxer = options.transmuxer;
  var endAction = options.endAction || options.action;
  var callback2 = options.callback;
  var message = _extends$8({}, options, {
    endAction: null,
    transmuxer: null,
    callback: null
  });
  var listenForEndEvent = function listenForEndEvent2(event) {
    if (event.data.action !== endAction) {
      return;
    }
    transmuxer.removeEventListener("message", listenForEndEvent2);
    if (event.data.data) {
      event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);
      if (options.data) {
        options.data = event.data.data;
      }
    }
    callback2(event.data);
  };
  transmuxer.addEventListener("message", listenForEndEvent);
  if (options.data) {
    var isArrayBuffer2 = options.data instanceof ArrayBuffer;
    message.byteOffset = isArrayBuffer2 ? 0 : options.data.byteOffset;
    message.byteLength = options.data.byteLength;
    var transfers = [isArrayBuffer2 ? options.data : options.data.buffer];
    transmuxer.postMessage(message, transfers);
  } else {
    transmuxer.postMessage(message);
  }
};
var REQUEST_ERRORS = {
  FAILURE: 2,
  TIMEOUT: -101,
  ABORTED: -102
};
var abortAll$1 = function abortAll(activeXhrs) {
  activeXhrs.forEach(function(xhr) {
    xhr.abort();
  });
};
var getRequestStats = function getRequestStats2(request2) {
  return {
    bandwidth: request2.bandwidth,
    bytesReceived: request2.bytesReceived || 0,
    roundTripTime: request2.roundTripTime || 0
  };
};
var getProgressStats = function getProgressStats2(progressEvent) {
  var request2 = progressEvent.target;
  var roundTripTime = Date.now() - request2.requestTime;
  var stats = {
    bandwidth: Infinity,
    bytesReceived: 0,
    roundTripTime: roundTripTime || 0
  };
  stats.bytesReceived = progressEvent.loaded;
  stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1e3);
  return stats;
};
var handleErrors = function handleErrors2(error, request2) {
  if (request2.timedout) {
    return {
      status: request2.status,
      message: "HLS request timed-out at URL: " + request2.uri,
      code: REQUEST_ERRORS.TIMEOUT,
      xhr: request2
    };
  }
  if (request2.aborted) {
    return {
      status: request2.status,
      message: "HLS request aborted at URL: " + request2.uri,
      code: REQUEST_ERRORS.ABORTED,
      xhr: request2
    };
  }
  if (error) {
    return {
      status: request2.status,
      message: "HLS request errored at URL: " + request2.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request2
    };
  }
  if (request2.responseType === "arraybuffer" && request2.response.byteLength === 0) {
    return {
      status: request2.status,
      message: "Empty HLS response at URL: " + request2.uri,
      code: REQUEST_ERRORS.FAILURE,
      xhr: request2
    };
  }
  return null;
};
var handleKeyResponse = function handleKeyResponse2(segment, objects, finishProcessingFn) {
  return function(error, request2) {
    var response = request2.response;
    var errorObj = handleErrors(error, request2);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    if (response.byteLength !== 16) {
      return finishProcessingFn({
        status: request2.status,
        message: "Invalid HLS key at URL: " + request2.uri,
        code: REQUEST_ERRORS.FAILURE,
        xhr: request2
      }, segment);
    }
    var view = new DataView(response);
    var bytes = new Uint32Array([view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12)]);
    for (var i = 0; i < objects.length; i++) {
      objects[i].bytes = bytes;
    }
    return finishProcessingFn(null, segment);
  };
};
var parseInitSegment = function parseInitSegment2(segment, _callback) {
  var type2 = detectContainerForBytes(segment.map.bytes);
  if (type2 !== "mp4") {
    var uri = segment.map.resolvedUri || segment.map.uri;
    return _callback({
      internal: true,
      message: "Found unsupported " + (type2 || "unknown") + " container for initialization segment at URL: " + uri,
      code: REQUEST_ERRORS.FAILURE
    });
  }
  workerCallback({
    action: "probeMp4Tracks",
    data: segment.map.bytes,
    transmuxer: segment.transmuxer,
    callback: function callback2(_ref) {
      var tracks = _ref.tracks, data = _ref.data;
      segment.map.bytes = data;
      tracks.forEach(function(track) {
        segment.map.tracks = segment.map.tracks || {};
        if (segment.map.tracks[track.type]) {
          return;
        }
        segment.map.tracks[track.type] = track;
        if (typeof track.id === "number" && track.timescale) {
          segment.map.timescales = segment.map.timescales || {};
          segment.map.timescales[track.id] = track.timescale;
        }
      });
      return _callback(null);
    }
  });
};
var handleInitSegmentResponse = function handleInitSegmentResponse2(_ref2) {
  var segment = _ref2.segment, finishProcessingFn = _ref2.finishProcessingFn;
  return function(error, request2) {
    var errorObj = handleErrors(error, request2);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    var bytes = new Uint8Array(request2.response);
    if (segment.map.key) {
      segment.map.encryptedBytes = bytes;
      return finishProcessingFn(null, segment);
    }
    segment.map.bytes = bytes;
    parseInitSegment(segment, function(parseError) {
      if (parseError) {
        parseError.xhr = request2;
        parseError.status = request2.status;
        return finishProcessingFn(parseError, segment);
      }
      finishProcessingFn(null, segment);
    });
  };
};
var handleSegmentResponse = function handleSegmentResponse2(_ref3) {
  var segment = _ref3.segment, finishProcessingFn = _ref3.finishProcessingFn, responseType = _ref3.responseType;
  return function(error, request2) {
    var errorObj = handleErrors(error, request2);
    if (errorObj) {
      return finishProcessingFn(errorObj, segment);
    }
    var newBytes = (
      // although responseText "should" exist, this guard serves to prevent an error being
      // thrown for two primary cases:
      // 1. the mime type override stops working, or is not implemented for a specific
      //    browser
      // 2. when using mock XHR libraries like sinon that do not allow the override behavior
      responseType === "arraybuffer" || !request2.responseText ? request2.response : stringToArrayBuffer(request2.responseText.substring(segment.lastReachedChar || 0))
    );
    segment.stats = getRequestStats(request2);
    if (segment.key) {
      segment.encryptedBytes = new Uint8Array(newBytes);
    } else {
      segment.bytes = new Uint8Array(newBytes);
    }
    return finishProcessingFn(null, segment);
  };
};
var transmuxAndNotify = function transmuxAndNotify2(_ref4) {
  var segment = _ref4.segment, bytes = _ref4.bytes, trackInfoFn = _ref4.trackInfoFn, timingInfoFn = _ref4.timingInfoFn, videoSegmentTimingInfoFn = _ref4.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref4.audioSegmentTimingInfoFn, id3Fn = _ref4.id3Fn, captionsFn = _ref4.captionsFn, isEndOfTimeline = _ref4.isEndOfTimeline, endedTimelineFn = _ref4.endedTimelineFn, dataFn = _ref4.dataFn, doneFn = _ref4.doneFn, onTransmuxerLog = _ref4.onTransmuxerLog;
  var fmp4Tracks = segment.map && segment.map.tracks || {};
  var isMuxed3 = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
  var audioStartFn = timingInfoFn.bind(null, segment, "audio", "start");
  var audioEndFn = timingInfoFn.bind(null, segment, "audio", "end");
  var videoStartFn = timingInfoFn.bind(null, segment, "video", "start");
  var videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
  var finish = function finish2() {
    return transmux({
      bytes,
      transmuxer: segment.transmuxer,
      audioAppendStart: segment.audioAppendStart,
      gopsToAlignWith: segment.gopsToAlignWith,
      remux: isMuxed3,
      onData: function onData(result) {
        result.type = result.type === "combined" ? "video" : result.type;
        dataFn(segment, result);
      },
      onTrackInfo: function onTrackInfo(trackInfo) {
        if (trackInfoFn) {
          if (isMuxed3) {
            trackInfo.isMuxed = true;
          }
          trackInfoFn(segment, trackInfo);
        }
      },
      onAudioTimingInfo: function onAudioTimingInfo(audioTimingInfo) {
        if (audioStartFn && typeof audioTimingInfo.start !== "undefined") {
          audioStartFn(audioTimingInfo.start);
          audioStartFn = null;
        }
        if (audioEndFn && typeof audioTimingInfo.end !== "undefined") {
          audioEndFn(audioTimingInfo.end);
        }
      },
      onVideoTimingInfo: function onVideoTimingInfo(videoTimingInfo) {
        if (videoStartFn && typeof videoTimingInfo.start !== "undefined") {
          videoStartFn(videoTimingInfo.start);
          videoStartFn = null;
        }
        if (videoEndFn && typeof videoTimingInfo.end !== "undefined") {
          videoEndFn(videoTimingInfo.end);
        }
      },
      onVideoSegmentTimingInfo: function onVideoSegmentTimingInfo(videoSegmentTimingInfo) {
        videoSegmentTimingInfoFn(videoSegmentTimingInfo);
      },
      onAudioSegmentTimingInfo: function onAudioSegmentTimingInfo(audioSegmentTimingInfo) {
        audioSegmentTimingInfoFn(audioSegmentTimingInfo);
      },
      onId3: function onId3(id3Frames, dispatchType) {
        id3Fn(segment, id3Frames, dispatchType);
      },
      onCaptions: function onCaptions(captions) {
        captionsFn(segment, [captions]);
      },
      isEndOfTimeline,
      onEndedTimeline: function onEndedTimeline() {
        endedTimelineFn();
      },
      onTransmuxerLog,
      onDone: function onDone(result) {
        if (!doneFn) {
          return;
        }
        result.type = result.type === "combined" ? "video" : result.type;
        doneFn(null, segment, result);
      }
    });
  };
  workerCallback({
    action: "probeTs",
    transmuxer: segment.transmuxer,
    data: bytes,
    baseStartTime: segment.baseStartTime,
    callback: function callback2(data) {
      segment.bytes = bytes = data.data;
      var probeResult = data.result;
      if (probeResult) {
        trackInfoFn(segment, {
          hasAudio: probeResult.hasAudio,
          hasVideo: probeResult.hasVideo,
          isMuxed: isMuxed3
        });
        trackInfoFn = null;
        if (probeResult.hasAudio && !isMuxed3) {
          audioStartFn(probeResult.audioStart);
        }
        if (probeResult.hasVideo) {
          videoStartFn(probeResult.videoStart);
        }
        audioStartFn = null;
        videoStartFn = null;
      }
      finish();
    }
  });
};
var handleSegmentBytes = function handleSegmentBytes2(_ref5) {
  var segment = _ref5.segment, bytes = _ref5.bytes, trackInfoFn = _ref5.trackInfoFn, timingInfoFn = _ref5.timingInfoFn, videoSegmentTimingInfoFn = _ref5.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref5.audioSegmentTimingInfoFn, id3Fn = _ref5.id3Fn, captionsFn = _ref5.captionsFn, isEndOfTimeline = _ref5.isEndOfTimeline, endedTimelineFn = _ref5.endedTimelineFn, dataFn = _ref5.dataFn, doneFn = _ref5.doneFn, onTransmuxerLog = _ref5.onTransmuxerLog;
  var bytesAsUint8Array = new Uint8Array(bytes);
  if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
    segment.isFmp4 = true;
    var tracks = segment.map.tracks;
    var trackInfo = {
      isFmp4: true,
      hasVideo: !!tracks.video,
      hasAudio: !!tracks.audio
    };
    if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== "enca") {
      trackInfo.audioCodec = tracks.audio.codec;
    }
    if (tracks.video && tracks.video.codec && tracks.video.codec !== "encv") {
      trackInfo.videoCodec = tracks.video.codec;
    }
    if (tracks.video && tracks.audio) {
      trackInfo.isMuxed = true;
    }
    trackInfoFn(segment, trackInfo);
    var finishLoading = function finishLoading2(captions) {
      dataFn(segment, {
        data: bytesAsUint8Array,
        type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
      });
      if (captions && captions.length) {
        captionsFn(segment, captions);
      }
      doneFn(null, segment, {});
    };
    workerCallback({
      action: "probeMp4StartTime",
      timescales: segment.map.timescales,
      data: bytesAsUint8Array,
      transmuxer: segment.transmuxer,
      callback: function callback2(_ref6) {
        var data = _ref6.data, startTime = _ref6.startTime;
        bytes = data.buffer;
        segment.bytes = bytesAsUint8Array = data;
        if (trackInfo.hasAudio && !trackInfo.isMuxed) {
          timingInfoFn(segment, "audio", "start", startTime);
        }
        if (trackInfo.hasVideo) {
          timingInfoFn(segment, "video", "start", startTime);
        }
        if (!tracks.video || !data.byteLength || !segment.transmuxer) {
          finishLoading();
          return;
        }
        workerCallback({
          action: "pushMp4Captions",
          endAction: "mp4Captions",
          transmuxer: segment.transmuxer,
          data: bytesAsUint8Array,
          timescales: segment.map.timescales,
          trackIds: [tracks.video.id],
          callback: function callback3(message) {
            bytes = message.data.buffer;
            segment.bytes = bytesAsUint8Array = message.data;
            message.logs.forEach(function(log2) {
              onTransmuxerLog(videojs.mergeOptions(log2, {
                stream: "mp4CaptionParser"
              }));
            });
            finishLoading(message.captions);
          }
        });
      }
    });
    return;
  }
  if (!segment.transmuxer) {
    doneFn(null, segment, {});
    return;
  }
  if (typeof segment.container === "undefined") {
    segment.container = detectContainerForBytes(bytesAsUint8Array);
  }
  if (segment.container !== "ts" && segment.container !== "aac") {
    trackInfoFn(segment, {
      hasAudio: false,
      hasVideo: false
    });
    doneFn(null, segment, {});
    return;
  }
  transmuxAndNotify({
    segment,
    bytes,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  });
};
var decrypt = function decrypt2(_ref7, callback2) {
  var id2 = _ref7.id, key = _ref7.key, encryptedBytes = _ref7.encryptedBytes, decryptionWorker = _ref7.decryptionWorker;
  var decryptionHandler = function decryptionHandler2(event) {
    if (event.data.source === id2) {
      decryptionWorker.removeEventListener("message", decryptionHandler2);
      var decrypted = event.data.decrypted;
      callback2(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
    }
  };
  decryptionWorker.addEventListener("message", decryptionHandler);
  var keyBytes;
  if (key.bytes.slice) {
    keyBytes = key.bytes.slice();
  } else {
    keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
  }
  decryptionWorker.postMessage(createTransferableMessage({
    source: id2,
    encrypted: encryptedBytes,
    key: keyBytes,
    iv: key.iv
  }), [encryptedBytes.buffer, keyBytes.buffer]);
};
var decryptSegment = function decryptSegment2(_ref8) {
  var decryptionWorker = _ref8.decryptionWorker, segment = _ref8.segment, trackInfoFn = _ref8.trackInfoFn, timingInfoFn = _ref8.timingInfoFn, videoSegmentTimingInfoFn = _ref8.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref8.audioSegmentTimingInfoFn, id3Fn = _ref8.id3Fn, captionsFn = _ref8.captionsFn, isEndOfTimeline = _ref8.isEndOfTimeline, endedTimelineFn = _ref8.endedTimelineFn, dataFn = _ref8.dataFn, doneFn = _ref8.doneFn, onTransmuxerLog = _ref8.onTransmuxerLog;
  decrypt({
    id: segment.requestId,
    key: segment.key,
    encryptedBytes: segment.encryptedBytes,
    decryptionWorker
  }, function(decryptedBytes) {
    segment.bytes = decryptedBytes;
    handleSegmentBytes({
      segment,
      bytes: segment.bytes,
      trackInfoFn,
      timingInfoFn,
      videoSegmentTimingInfoFn,
      audioSegmentTimingInfoFn,
      id3Fn,
      captionsFn,
      isEndOfTimeline,
      endedTimelineFn,
      dataFn,
      doneFn,
      onTransmuxerLog
    });
  });
};
var waitForCompletion = function waitForCompletion2(_ref9) {
  var activeXhrs = _ref9.activeXhrs, decryptionWorker = _ref9.decryptionWorker, trackInfoFn = _ref9.trackInfoFn, timingInfoFn = _ref9.timingInfoFn, videoSegmentTimingInfoFn = _ref9.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref9.audioSegmentTimingInfoFn, id3Fn = _ref9.id3Fn, captionsFn = _ref9.captionsFn, isEndOfTimeline = _ref9.isEndOfTimeline, endedTimelineFn = _ref9.endedTimelineFn, dataFn = _ref9.dataFn, doneFn = _ref9.doneFn, onTransmuxerLog = _ref9.onTransmuxerLog;
  var count2 = 0;
  var didError = false;
  return function(error, segment) {
    if (didError) {
      return;
    }
    if (error) {
      didError = true;
      abortAll$1(activeXhrs);
      return doneFn(error, segment);
    }
    count2 += 1;
    if (count2 === activeXhrs.length) {
      var segmentFinish = function segmentFinish2() {
        if (segment.encryptedBytes) {
          return decryptSegment({
            decryptionWorker,
            segment,
            trackInfoFn,
            timingInfoFn,
            videoSegmentTimingInfoFn,
            audioSegmentTimingInfoFn,
            id3Fn,
            captionsFn,
            isEndOfTimeline,
            endedTimelineFn,
            dataFn,
            doneFn,
            onTransmuxerLog
          });
        }
        handleSegmentBytes({
          segment,
          bytes: segment.bytes,
          trackInfoFn,
          timingInfoFn,
          videoSegmentTimingInfoFn,
          audioSegmentTimingInfoFn,
          id3Fn,
          captionsFn,
          isEndOfTimeline,
          endedTimelineFn,
          dataFn,
          doneFn,
          onTransmuxerLog
        });
      };
      segment.endOfAllRequests = Date.now();
      if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) {
        return decrypt({
          decryptionWorker,
          // add -init to the "id" to differentiate between segment
          // and init segment decryption, just in case they happen
          // at the same time at some point in the future.
          id: segment.requestId + "-init",
          encryptedBytes: segment.map.encryptedBytes,
          key: segment.map.key
        }, function(decryptedBytes) {
          segment.map.bytes = decryptedBytes;
          parseInitSegment(segment, function(parseError) {
            if (parseError) {
              abortAll$1(activeXhrs);
              return doneFn(parseError, segment);
            }
            segmentFinish();
          });
        });
      }
      segmentFinish();
    }
  };
};
var handleLoadEnd = function handleLoadEnd2(_ref10) {
  var loadendState = _ref10.loadendState, abortFn = _ref10.abortFn;
  return function(event) {
    var request2 = event.target;
    if (request2.aborted && abortFn && !loadendState.calledAbortFn) {
      abortFn();
      loadendState.calledAbortFn = true;
    }
  };
};
var handleProgress = function handleProgress2(_ref11) {
  var segment = _ref11.segment, progressFn = _ref11.progressFn;
  _ref11.trackInfoFn;
  _ref11.timingInfoFn;
  _ref11.videoSegmentTimingInfoFn;
  _ref11.audioSegmentTimingInfoFn;
  _ref11.id3Fn;
  _ref11.captionsFn;
  _ref11.isEndOfTimeline;
  _ref11.endedTimelineFn;
  _ref11.dataFn;
  return function(event) {
    var request2 = event.target;
    if (request2.aborted) {
      return;
    }
    segment.stats = videojs.mergeOptions(segment.stats, getProgressStats(event));
    if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) {
      segment.stats.firstBytesReceivedAt = Date.now();
    }
    return progressFn(event, segment);
  };
};
var mediaSegmentRequest = function mediaSegmentRequest2(_ref12) {
  var xhr = _ref12.xhr, xhrOptions = _ref12.xhrOptions, decryptionWorker = _ref12.decryptionWorker, segment = _ref12.segment, abortFn = _ref12.abortFn, progressFn = _ref12.progressFn, trackInfoFn = _ref12.trackInfoFn, timingInfoFn = _ref12.timingInfoFn, videoSegmentTimingInfoFn = _ref12.videoSegmentTimingInfoFn, audioSegmentTimingInfoFn = _ref12.audioSegmentTimingInfoFn, id3Fn = _ref12.id3Fn, captionsFn = _ref12.captionsFn, isEndOfTimeline = _ref12.isEndOfTimeline, endedTimelineFn = _ref12.endedTimelineFn, dataFn = _ref12.dataFn, doneFn = _ref12.doneFn, onTransmuxerLog = _ref12.onTransmuxerLog;
  var activeXhrs = [];
  var finishProcessingFn = waitForCompletion({
    activeXhrs,
    decryptionWorker,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn,
    doneFn,
    onTransmuxerLog
  });
  if (segment.key && !segment.key.bytes) {
    var objects = [segment.key];
    if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) {
      objects.push(segment.map.key);
    }
    var keyRequestOptions = videojs.mergeOptions(xhrOptions, {
      uri: segment.key.resolvedUri,
      responseType: "arraybuffer"
    });
    var keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);
    var keyXhr = xhr(keyRequestOptions, keyRequestCallback);
    activeXhrs.push(keyXhr);
  }
  if (segment.map && !segment.map.bytes) {
    var differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
    if (differentMapKey) {
      var mapKeyRequestOptions = videojs.mergeOptions(xhrOptions, {
        uri: segment.map.key.resolvedUri,
        responseType: "arraybuffer"
      });
      var mapKeyRequestCallback = handleKeyResponse(segment, [segment.map.key], finishProcessingFn);
      var mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
      activeXhrs.push(mapKeyXhr);
    }
    var initSegmentOptions = videojs.mergeOptions(xhrOptions, {
      uri: segment.map.resolvedUri,
      responseType: "arraybuffer",
      headers: segmentXhrHeaders(segment.map)
    });
    var initSegmentRequestCallback = handleInitSegmentResponse({
      segment,
      finishProcessingFn
    });
    var initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
    activeXhrs.push(initSegmentXhr);
  }
  var segmentRequestOptions = videojs.mergeOptions(xhrOptions, {
    uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
    responseType: "arraybuffer",
    headers: segmentXhrHeaders(segment)
  });
  var segmentRequestCallback = handleSegmentResponse({
    segment,
    finishProcessingFn,
    responseType: segmentRequestOptions.responseType
  });
  var segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
  segmentXhr.addEventListener("progress", handleProgress({
    segment,
    progressFn,
    trackInfoFn,
    timingInfoFn,
    videoSegmentTimingInfoFn,
    audioSegmentTimingInfoFn,
    id3Fn,
    captionsFn,
    isEndOfTimeline,
    endedTimelineFn,
    dataFn
  }));
  activeXhrs.push(segmentXhr);
  var loadendState = {};
  activeXhrs.forEach(function(activeXhr) {
    activeXhr.addEventListener("loadend", handleLoadEnd({
      loadendState,
      abortFn
    }));
  });
  return function() {
    return abortAll$1(activeXhrs);
  };
};
var logFn$1 = logger("CodecUtils");
var getCodecs = function getCodecs2(media) {
  var mediaAttributes = media.attributes || {};
  if (mediaAttributes.CODECS) {
    return parseCodecs(mediaAttributes.CODECS);
  }
};
var isMaat = function isMaat2(master, media) {
  var mediaAttributes = media.attributes || {};
  return master && master.mediaGroups && master.mediaGroups.AUDIO && mediaAttributes.AUDIO && master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
};
var isMuxed = function isMuxed2(master, media) {
  if (!isMaat(master, media)) {
    return true;
  }
  var mediaAttributes = media.attributes || {};
  var audioGroup = master.mediaGroups.AUDIO[mediaAttributes.AUDIO];
  for (var groupId in audioGroup) {
    if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) {
      return true;
    }
  }
  return false;
};
var unwrapCodecList = function unwrapCodecList2(codecList) {
  var codecs = {};
  codecList.forEach(function(_ref) {
    var mediaType = _ref.mediaType, type2 = _ref.type, details = _ref.details;
    codecs[mediaType] = codecs[mediaType] || [];
    codecs[mediaType].push(translateLegacyCodec("" + type2 + details));
  });
  Object.keys(codecs).forEach(function(mediaType) {
    if (codecs[mediaType].length > 1) {
      logFn$1("multiple " + mediaType + " codecs found as attributes: " + codecs[mediaType].join(", ") + ". Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.");
      codecs[mediaType] = null;
      return;
    }
    codecs[mediaType] = codecs[mediaType][0];
  });
  return codecs;
};
var codecCount = function codecCount2(codecObj) {
  var count2 = 0;
  if (codecObj.audio) {
    count2++;
  }
  if (codecObj.video) {
    count2++;
  }
  return count2;
};
var codecsForPlaylist = function codecsForPlaylist2(master, media) {
  var mediaAttributes = media.attributes || {};
  var codecInfo = unwrapCodecList(getCodecs(media) || []);
  if (isMaat(master, media) && !codecInfo.audio) {
    if (!isMuxed(master, media)) {
      var defaultCodecs = unwrapCodecList(codecsFromDefault(master, mediaAttributes.AUDIO) || []);
      if (defaultCodecs.audio) {
        codecInfo.audio = defaultCodecs.audio;
      }
    }
  }
  return codecInfo;
};
var logFn = logger("PlaylistSelector");
var representationToString = function representationToString2(representation) {
  if (!representation || !representation.playlist) {
    return;
  }
  var playlist = representation.playlist;
  return JSON.stringify({
    id: playlist.id,
    bandwidth: representation.bandwidth,
    width: representation.width,
    height: representation.height,
    codecs: playlist.attributes && playlist.attributes.CODECS || ""
  });
};
var safeGetComputedStyle = function safeGetComputedStyle2(el2, property) {
  if (!el2) {
    return "";
  }
  var result = window_1.getComputedStyle(el2);
  if (!result) {
    return "";
  }
  return result[property];
};
var stableSort$1 = function stableSort(array, sortFn) {
  var newArray = array.slice();
  array.sort(function(left2, right2) {
    var cmp = sortFn(left2, right2);
    if (cmp === 0) {
      return newArray.indexOf(left2) - newArray.indexOf(right2);
    }
    return cmp;
  });
};
var comparePlaylistBandwidth = function comparePlaylistBandwidth2(left2, right2) {
  var leftBandwidth;
  var rightBandwidth;
  if (left2.attributes.BANDWIDTH) {
    leftBandwidth = left2.attributes.BANDWIDTH;
  }
  leftBandwidth = leftBandwidth || window_1.Number.MAX_VALUE;
  if (right2.attributes.BANDWIDTH) {
    rightBandwidth = right2.attributes.BANDWIDTH;
  }
  rightBandwidth = rightBandwidth || window_1.Number.MAX_VALUE;
  return leftBandwidth - rightBandwidth;
};
var comparePlaylistResolution = function comparePlaylistResolution2(left2, right2) {
  var leftWidth;
  var rightWidth;
  if (left2.attributes.RESOLUTION && left2.attributes.RESOLUTION.width) {
    leftWidth = left2.attributes.RESOLUTION.width;
  }
  leftWidth = leftWidth || window_1.Number.MAX_VALUE;
  if (right2.attributes.RESOLUTION && right2.attributes.RESOLUTION.width) {
    rightWidth = right2.attributes.RESOLUTION.width;
  }
  rightWidth = rightWidth || window_1.Number.MAX_VALUE;
  if (leftWidth === rightWidth && left2.attributes.BANDWIDTH && right2.attributes.BANDWIDTH) {
    return left2.attributes.BANDWIDTH - right2.attributes.BANDWIDTH;
  }
  return leftWidth - rightWidth;
};
var simpleSelector = function simpleSelector2(master, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, masterPlaylistController) {
  if (!master) {
    return;
  }
  var options = {
    bandwidth: playerBandwidth,
    width: playerWidth,
    height: playerHeight,
    limitRenditionByPlayerDimensions
  };
  var playlists = master.playlists;
  if (Playlist2.isAudioOnly(master)) {
    playlists = masterPlaylistController.getAudioTrackPlaylists_();
    options.audioOnly = true;
  }
  var sortedPlaylistReps = playlists.map(function(playlist) {
    var bandwidth2;
    var width3 = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
    var height3 = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
    bandwidth2 = playlist.attributes && playlist.attributes.BANDWIDTH;
    bandwidth2 = bandwidth2 || window_1.Number.MAX_VALUE;
    return {
      bandwidth: bandwidth2,
      width: width3,
      height: height3,
      playlist
    };
  });
  stableSort$1(sortedPlaylistReps, function(left2, right2) {
    return left2.bandwidth - right2.bandwidth;
  });
  sortedPlaylistReps = sortedPlaylistReps.filter(function(rep) {
    return !Playlist2.isIncompatible(rep.playlist);
  });
  var enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
    return Playlist2.isEnabled(rep.playlist);
  });
  if (!enabledPlaylistReps.length) {
    enabledPlaylistReps = sortedPlaylistReps.filter(function(rep) {
      return !Playlist2.isDisabled(rep.playlist);
    });
  }
  var bandwidthPlaylistReps = enabledPlaylistReps.filter(function(rep) {
    return rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth;
  });
  var highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
  var bandwidthBestRep = bandwidthPlaylistReps.filter(function(rep) {
    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
  })[0];
  if (limitRenditionByPlayerDimensions === false) {
    var _chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
    if (_chosenRep && _chosenRep.playlist) {
      var type2 = "sortedPlaylistReps";
      if (bandwidthBestRep) {
        type2 = "bandwidthBestRep";
      }
      if (enabledPlaylistReps[0]) {
        type2 = "enabledPlaylistReps";
      }
      logFn("choosing " + representationToString(_chosenRep) + " using " + type2 + " with options", options);
      return _chosenRep.playlist;
    }
    logFn("could not choose a playlist with options", options);
    return null;
  }
  var haveResolution = bandwidthPlaylistReps.filter(function(rep) {
    return rep.width && rep.height;
  });
  stableSort$1(haveResolution, function(left2, right2) {
    return left2.width - right2.width;
  });
  var resolutionBestRepList = haveResolution.filter(function(rep) {
    return rep.width === playerWidth && rep.height === playerHeight;
  });
  highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
  var resolutionBestRep = resolutionBestRepList.filter(function(rep) {
    return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
  })[0];
  var resolutionPlusOneList;
  var resolutionPlusOneSmallest;
  var resolutionPlusOneRep;
  if (!resolutionBestRep) {
    resolutionPlusOneList = haveResolution.filter(function(rep) {
      return rep.width > playerWidth || rep.height > playerHeight;
    });
    resolutionPlusOneSmallest = resolutionPlusOneList.filter(function(rep) {
      return rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height;
    });
    highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
    resolutionPlusOneRep = resolutionPlusOneSmallest.filter(function(rep) {
      return rep.bandwidth === highestRemainingBandwidthRep.bandwidth;
    })[0];
  }
  var leastPixelDiffRep;
  if (masterPlaylistController.experimentalLeastPixelDiffSelector) {
    var leastPixelDiffList = haveResolution.map(function(rep) {
      rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
      return rep;
    });
    stableSort$1(leastPixelDiffList, function(left2, right2) {
      if (left2.pixelDiff === right2.pixelDiff) {
        return right2.bandwidth - left2.bandwidth;
      }
      return left2.pixelDiff - right2.pixelDiff;
    });
    leastPixelDiffRep = leastPixelDiffList[0];
  }
  var chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
  if (chosenRep && chosenRep.playlist) {
    var _type = "sortedPlaylistReps";
    if (leastPixelDiffRep) {
      _type = "leastPixelDiffRep";
    } else if (resolutionPlusOneRep) {
      _type = "resolutionPlusOneRep";
    } else if (resolutionBestRep) {
      _type = "resolutionBestRep";
    } else if (bandwidthBestRep) {
      _type = "bandwidthBestRep";
    } else if (enabledPlaylistReps[0]) {
      _type = "enabledPlaylistReps";
    }
    logFn("choosing " + representationToString(chosenRep) + " using " + _type + " with options", options);
    return chosenRep.playlist;
  }
  logFn("could not choose a playlist with options", options);
  return null;
};
var lastBandwidthSelector = function lastBandwidthSelector2() {
  var pixelRatio = this.useDevicePixelRatio ? window_1.devicePixelRatio || 1 : 1;
  return simpleSelector(this.playlists.master, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
};
var movingAverageBandwidthSelector = function movingAverageBandwidthSelector2(decay) {
  var average = -1;
  var lastSystemBandwidth = -1;
  if (decay < 0 || decay > 1) {
    throw new Error("Moving average bandwidth decay must be between 0 and 1.");
  }
  return function() {
    var pixelRatio = this.useDevicePixelRatio ? window_1.devicePixelRatio || 1 : 1;
    if (average < 0) {
      average = this.systemBandwidth;
      lastSystemBandwidth = this.systemBandwidth;
    }
    if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
      average = decay * this.systemBandwidth + (1 - decay) * average;
      lastSystemBandwidth = this.systemBandwidth;
    }
    return simpleSelector(this.playlists.master, average, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.masterPlaylistController_);
  };
};
var minRebufferMaxBandwidthSelector = function minRebufferMaxBandwidthSelector2(settings) {
  var master = settings.master, currentTime = settings.currentTime, bandwidth2 = settings.bandwidth, duration5 = settings.duration, segmentDuration = settings.segmentDuration, timeUntilRebuffer3 = settings.timeUntilRebuffer, currentTimeline = settings.currentTimeline, syncController = settings.syncController;
  var compatiblePlaylists = master.playlists.filter(function(playlist) {
    return !Playlist2.isIncompatible(playlist);
  });
  var enabledPlaylists = compatiblePlaylists.filter(Playlist2.isEnabled);
  if (!enabledPlaylists.length) {
    enabledPlaylists = compatiblePlaylists.filter(function(playlist) {
      return !Playlist2.isDisabled(playlist);
    });
  }
  var bandwidthPlaylists = enabledPlaylists.filter(Playlist2.hasAttribute.bind(null, "BANDWIDTH"));
  var rebufferingEstimates = bandwidthPlaylists.map(function(playlist) {
    var syncPoint = syncController.getSyncPoint(playlist, duration5, currentTimeline, currentTime);
    var numRequests = syncPoint ? 1 : 2;
    var requestTimeEstimate = Playlist2.estimateSegmentRequestTime(segmentDuration, bandwidth2, playlist);
    var rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer3;
    return {
      playlist,
      rebufferingImpact
    };
  });
  var noRebufferingPlaylists = rebufferingEstimates.filter(function(estimate) {
    return estimate.rebufferingImpact <= 0;
  });
  stableSort$1(noRebufferingPlaylists, function(a2, b2) {
    return comparePlaylistBandwidth(b2.playlist, a2.playlist);
  });
  if (noRebufferingPlaylists.length) {
    return noRebufferingPlaylists[0];
  }
  stableSort$1(rebufferingEstimates, function(a2, b2) {
    return a2.rebufferingImpact - b2.rebufferingImpact;
  });
  return rebufferingEstimates[0] || null;
};
var lowestBitrateCompatibleVariantSelector = function lowestBitrateCompatibleVariantSelector2() {
  var _this = this;
  var playlists = this.playlists.master.playlists.filter(Playlist2.isEnabled);
  stableSort$1(playlists, function(a2, b2) {
    return comparePlaylistBandwidth(a2, b2);
  });
  var playlistsWithVideo = playlists.filter(function(playlist) {
    return !!codecsForPlaylist(_this.playlists.master, playlist).video;
  });
  return playlistsWithVideo[0] || null;
};
var concatSegments = function concatSegments2(segmentObj) {
  var offset3 = 0;
  var tempBuffer;
  if (segmentObj.bytes) {
    tempBuffer = new Uint8Array(segmentObj.bytes);
    segmentObj.segments.forEach(function(segment) {
      tempBuffer.set(segment, offset3);
      offset3 += segment.byteLength;
    });
  }
  return tempBuffer;
};
var createCaptionsTrackIfNotExists = function createCaptionsTrackIfNotExists2(inbandTextTracks, tech, captionStream) {
  if (!inbandTextTracks[captionStream]) {
    tech.trigger({
      type: "usage",
      name: "vhs-608"
    });
    tech.trigger({
      type: "usage",
      name: "hls-608"
    });
    var instreamId = captionStream;
    if (/^cc708_/.test(captionStream)) {
      instreamId = "SERVICE" + captionStream.split("_")[1];
    }
    var track = tech.textTracks().getTrackById(instreamId);
    if (track) {
      inbandTextTracks[captionStream] = track;
    } else {
      var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
      var label = captionStream;
      var language = captionStream;
      var def = false;
      var captionService = captionServices[instreamId];
      if (captionService) {
        label = captionService.label;
        language = captionService.language;
        def = captionService["default"];
      }
      inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
        kind: "captions",
        id: instreamId,
        // TODO: investigate why this doesn't seem to turn the caption on by default
        "default": def,
        label,
        language
      }, false).track;
    }
  }
};
var addCaptionData = function addCaptionData2(_ref) {
  var inbandTextTracks = _ref.inbandTextTracks, captionArray = _ref.captionArray, timestampOffset2 = _ref.timestampOffset;
  if (!captionArray) {
    return;
  }
  var Cue = window_1.WebKitDataCue || window_1.VTTCue;
  captionArray.forEach(function(caption) {
    var track = caption.stream;
    inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset2, caption.endTime + timestampOffset2, caption.text));
  });
};
var deprecateOldCue = function deprecateOldCue2(cue) {
  Object.defineProperties(cue.frame, {
    id: {
      get: function get8() {
        videojs.log.warn("cue.frame.id is deprecated. Use cue.value.key instead.");
        return cue.value.key;
      }
    },
    value: {
      get: function get8() {
        videojs.log.warn("cue.frame.value is deprecated. Use cue.value.data instead.");
        return cue.value.data;
      }
    },
    privateData: {
      get: function get8() {
        videojs.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead.");
        return cue.value.data;
      }
    }
  });
};
var addMetadata = function addMetadata2(_ref2) {
  var inbandTextTracks = _ref2.inbandTextTracks, metadataArray = _ref2.metadataArray, timestampOffset2 = _ref2.timestampOffset, videoDuration = _ref2.videoDuration;
  if (!metadataArray) {
    return;
  }
  var Cue = window_1.WebKitDataCue || window_1.VTTCue;
  var metadataTrack = inbandTextTracks.metadataTrack_;
  if (!metadataTrack) {
    return;
  }
  metadataArray.forEach(function(metadata) {
    var time2 = metadata.cueTime + timestampOffset2;
    if (typeof time2 !== "number" || window_1.isNaN(time2) || time2 < 0 || !(time2 < Infinity)) {
      return;
    }
    metadata.frames.forEach(function(frame) {
      var cue = new Cue(time2, time2, frame.value || frame.url || frame.data || "");
      cue.frame = frame;
      cue.value = frame;
      deprecateOldCue(cue);
      metadataTrack.addCue(cue);
    });
  });
  if (!metadataTrack.cues || !metadataTrack.cues.length) {
    return;
  }
  var cues = metadataTrack.cues;
  var cuesArray = [];
  for (var i = 0; i < cues.length; i++) {
    if (cues[i]) {
      cuesArray.push(cues[i]);
    }
  }
  var cuesGroupedByStartTime = cuesArray.reduce(function(obj, cue) {
    var timeSlot = obj[cue.startTime] || [];
    timeSlot.push(cue);
    obj[cue.startTime] = timeSlot;
    return obj;
  }, {});
  var sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(function(a2, b2) {
    return Number(a2) - Number(b2);
  });
  sortedStartTimes.forEach(function(startTime, idx) {
    var cueGroup = cuesGroupedByStartTime[startTime];
    var nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;
    cueGroup.forEach(function(cue) {
      cue.endTime = nextTime;
    });
  });
};
var createMetadataTrackIfNotExists = function createMetadataTrackIfNotExists2(inbandTextTracks, dispatchType, tech) {
  if (inbandTextTracks.metadataTrack_) {
    return;
  }
  inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
    kind: "metadata",
    label: "Timed Metadata"
  }, false).track;
  inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
};
var removeCuesFromTrack = function removeCuesFromTrack2(start3, end2, track) {
  var i;
  var cue;
  if (!track) {
    return;
  }
  if (!track.cues) {
    return;
  }
  i = track.cues.length;
  while (i--) {
    cue = track.cues[i];
    if (cue.startTime >= start3 && cue.endTime <= end2) {
      track.removeCue(cue);
    }
  }
};
var removeDuplicateCuesFromTrack = function removeDuplicateCuesFromTrack2(track) {
  var cues = track.cues;
  if (!cues) {
    return;
  }
  for (var i = 0; i < cues.length; i++) {
    var duplicates = [];
    var occurrences = 0;
    for (var j2 = 0; j2 < cues.length; j2++) {
      if (cues[i].startTime === cues[j2].startTime && cues[i].endTime === cues[j2].endTime && cues[i].text === cues[j2].text) {
        occurrences++;
        if (occurrences > 1) {
          duplicates.push(cues[j2]);
        }
      }
    }
    if (duplicates.length) {
      duplicates.forEach(function(dupe) {
        return track.removeCue(dupe);
      });
    }
  }
};
var gopsSafeToAlignWith = function gopsSafeToAlignWith2(buffer, currentTime, mapping) {
  if (typeof currentTime === "undefined" || currentTime === null || !buffer.length) {
    return [];
  }
  var currentTimePts = Math.ceil((currentTime - mapping + 3) * clock.ONE_SECOND_IN_TS);
  var i;
  for (i = 0; i < buffer.length; i++) {
    if (buffer[i].pts > currentTimePts) {
      break;
    }
  }
  return buffer.slice(i);
};
var updateGopBuffer = function updateGopBuffer2(buffer, gops, replace2) {
  if (!gops.length) {
    return buffer;
  }
  if (replace2) {
    return gops.slice();
  }
  var start3 = gops[0].pts;
  var i = 0;
  for (i; i < buffer.length; i++) {
    if (buffer[i].pts >= start3) {
      break;
    }
  }
  return buffer.slice(0, i).concat(gops);
};
var removeGopBuffer = function removeGopBuffer2(buffer, start3, end2, mapping) {
  var startPts = Math.ceil((start3 - mapping) * clock.ONE_SECOND_IN_TS);
  var endPts = Math.ceil((end2 - mapping) * clock.ONE_SECOND_IN_TS);
  var updatedBuffer = buffer.slice();
  var i = buffer.length;
  while (i--) {
    if (buffer[i].pts <= endPts) {
      break;
    }
  }
  if (i === -1) {
    return updatedBuffer;
  }
  var j2 = i + 1;
  while (j2--) {
    if (buffer[j2].pts <= startPts) {
      break;
    }
  }
  j2 = Math.max(j2, 0);
  updatedBuffer.splice(j2, i - j2 + 1);
  return updatedBuffer;
};
var shallowEqual$1 = function shallowEqual(a2, b2) {
  if (!a2 && !b2 || !a2 && b2 || a2 && !b2) {
    return false;
  }
  if (a2 === b2) {
    return true;
  }
  var akeys = Object.keys(a2).sort();
  var bkeys = Object.keys(b2).sort();
  if (akeys.length !== bkeys.length) {
    return false;
  }
  for (var i = 0; i < akeys.length; i++) {
    var key = akeys[i];
    if (key !== bkeys[i]) {
      return false;
    }
    if (a2[key] !== b2[key]) {
      return false;
    }
  }
  return true;
};
var QUOTA_EXCEEDED_ERR = 22;
var getSyncSegmentCandidate = function getSyncSegmentCandidate2(currentTimeline, segments, targetTime) {
  segments = segments || [];
  var timelineSegments = [];
  var time2 = 0;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (currentTimeline === segment.timeline) {
      timelineSegments.push(i);
      time2 += segment.duration;
      if (time2 > targetTime) {
        return i;
      }
    }
  }
  if (timelineSegments.length === 0) {
    return 0;
  }
  return timelineSegments[timelineSegments.length - 1];
};
var MIN_BACK_BUFFER = 1;
var CHECK_BUFFER_DELAY = 500;
var finite = function finite2(num) {
  return typeof num === "number" && isFinite(num);
};
var MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
var illegalMediaSwitch = function illegalMediaSwitch2(loaderType, startingMedia, trackInfo) {
  if (loaderType !== "main" || !startingMedia || !trackInfo) {
    return null;
  }
  if (!trackInfo.hasAudio && !trackInfo.hasVideo) {
    return "Neither audio nor video found in segment.";
  }
  if (startingMedia.hasVideo && !trackInfo.hasVideo) {
    return "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest.";
  }
  if (!startingMedia.hasVideo && trackInfo.hasVideo) {
    return "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest.";
  }
  return null;
};
var safeBackBufferTrimTime = function safeBackBufferTrimTime2(seekable3, currentTime, targetDuration) {
  var trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
  if (seekable3.length) {
    trimTime = Math.max(trimTime, seekable3.start(0));
  }
  var maxTrimTime = currentTime - targetDuration;
  return Math.min(maxTrimTime, trimTime);
};
var segmentInfoString = function segmentInfoString2(segmentInfo) {
  var startOfSegment = segmentInfo.startOfSegment, duration5 = segmentInfo.duration, segment = segmentInfo.segment, part = segmentInfo.part, _segmentInfo$playlist = segmentInfo.playlist, seq = _segmentInfo$playlist.mediaSequence, id2 = _segmentInfo$playlist.id, _segmentInfo$playlist2 = _segmentInfo$playlist.segments, segments = _segmentInfo$playlist2 === void 0 ? [] : _segmentInfo$playlist2, index2 = segmentInfo.mediaIndex, partIndex = segmentInfo.partIndex, timeline = segmentInfo.timeline;
  var segmentLen = segments.length - 1;
  var selection = "mediaIndex/partIndex increment";
  if (segmentInfo.getMediaInfoForTime) {
    selection = "getMediaInfoForTime (" + segmentInfo.getMediaInfoForTime + ")";
  } else if (segmentInfo.isSyncRequest) {
    selection = "getSyncSegmentCandidate (isSyncRequest)";
  }
  if (segmentInfo.independent) {
    selection += " with independent " + segmentInfo.independent;
  }
  var hasPartIndex = typeof partIndex === "number";
  var name = segmentInfo.segment.uri ? "segment" : "pre-segment";
  var zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
    preloadSegment: segment
  }) - 1 : 0;
  return name + " [" + (seq + index2) + "/" + (seq + segmentLen) + "]" + (hasPartIndex ? " part [" + partIndex + "/" + zeroBasedPartCount + "]" : "") + (" segment start/end [" + segment.start + " => " + segment.end + "]") + (hasPartIndex ? " part start/end [" + part.start + " => " + part.end + "]" : "") + (" startOfSegment [" + startOfSegment + "]") + (" duration [" + duration5 + "]") + (" timeline [" + timeline + "]") + (" selected by [" + selection + "]") + (" playlist [" + id2 + "]");
};
var timingInfoPropertyForMedia = function timingInfoPropertyForMedia2(mediaType) {
  return mediaType + "TimingInfo";
};
var timestampOffsetForSegment = function timestampOffsetForSegment2(_ref) {
  var segmentTimeline = _ref.segmentTimeline, currentTimeline = _ref.currentTimeline, startOfSegment = _ref.startOfSegment, buffered = _ref.buffered, overrideCheck = _ref.overrideCheck;
  if (!overrideCheck && segmentTimeline === currentTimeline) {
    return null;
  }
  if (segmentTimeline < currentTimeline) {
    return startOfSegment;
  }
  return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
};
var shouldWaitForTimelineChange = function shouldWaitForTimelineChange2(_ref2) {
  var timelineChangeController = _ref2.timelineChangeController, currentTimeline = _ref2.currentTimeline, segmentTimeline = _ref2.segmentTimeline, loaderType = _ref2.loaderType, audioDisabled = _ref2.audioDisabled;
  if (currentTimeline === segmentTimeline) {
    return false;
  }
  if (loaderType === "audio") {
    var lastMainTimelineChange = timelineChangeController.lastTimelineChange({
      type: "main"
    });
    return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
  }
  if (loaderType === "main" && audioDisabled) {
    var pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
      type: "audio"
    });
    if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) {
      return false;
    }
    return true;
  }
  return false;
};
var mediaDuration = function mediaDuration2(timingInfos) {
  var maxDuration = 0;
  ["video", "audio"].forEach(function(type2) {
    var typeTimingInfo = timingInfos[type2 + "TimingInfo"];
    if (!typeTimingInfo) {
      return;
    }
    var start3 = typeTimingInfo.start, end2 = typeTimingInfo.end;
    var duration5;
    if (typeof start3 === "bigint" || typeof end2 === "bigint") {
      duration5 = window_1.BigInt(end2) - window_1.BigInt(start3);
    } else if (typeof start3 === "number" && typeof end2 === "number") {
      duration5 = end2 - start3;
    }
    if (typeof duration5 !== "undefined" && duration5 > maxDuration) {
      maxDuration = duration5;
    }
  });
  if (typeof maxDuration === "bigint" && maxDuration < Number.MAX_SAFE_INTEGER) {
    maxDuration = Number(maxDuration);
  }
  return maxDuration;
};
var segmentTooLong = function segmentTooLong2(_ref3) {
  var segmentDuration = _ref3.segmentDuration, maxDuration = _ref3.maxDuration;
  if (!segmentDuration) {
    return false;
  }
  return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
};
var getTroublesomeSegmentDurationMessage = function getTroublesomeSegmentDurationMessage2(segmentInfo, sourceType) {
  if (sourceType !== "hls") {
    return null;
  }
  var segmentDuration = mediaDuration({
    audioTimingInfo: segmentInfo.audioTimingInfo,
    videoTimingInfo: segmentInfo.videoTimingInfo
  });
  if (!segmentDuration) {
    return null;
  }
  var targetDuration = segmentInfo.playlist.targetDuration;
  var isSegmentWayTooLong = segmentTooLong({
    segmentDuration,
    maxDuration: targetDuration * 2
  });
  var isSegmentSlightlyTooLong = segmentTooLong({
    segmentDuration,
    maxDuration: targetDuration
  });
  var segmentTooLongMessage = "Segment with index " + segmentInfo.mediaIndex + " " + ("from playlist " + segmentInfo.playlist.id + " ") + ("has a duration of " + segmentDuration + " ") + ("when the reported duration is " + segmentInfo.duration + " ") + ("and the target duration is " + targetDuration + ". ") + "For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
  if (isSegmentWayTooLong || isSegmentSlightlyTooLong) {
    return {
      severity: isSegmentWayTooLong ? "warn" : "info",
      message: segmentTooLongMessage
    };
  }
  return null;
};
var SegmentLoader = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(SegmentLoader2, _videojs$EventTarget);
  function SegmentLoader2(settings, options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    if (!settings) {
      throw new TypeError("Initialization settings are required");
    }
    if (typeof settings.currentTime !== "function") {
      throw new TypeError("No currentTime getter specified");
    }
    if (!settings.mediaSource) {
      throw new TypeError("No MediaSource specified");
    }
    _this.bandwidth = settings.bandwidth;
    _this.throughput = {
      rate: 0,
      count: 0
    };
    _this.roundTrip = NaN;
    _this.resetStats_();
    _this.mediaIndex = null;
    _this.partIndex = null;
    _this.hasPlayed_ = settings.hasPlayed;
    _this.currentTime_ = settings.currentTime;
    _this.seekable_ = settings.seekable;
    _this.seeking_ = settings.seeking;
    _this.duration_ = settings.duration;
    _this.mediaSource_ = settings.mediaSource;
    _this.vhs_ = settings.vhs;
    _this.loaderType_ = settings.loaderType;
    _this.currentMediaInfo_ = void 0;
    _this.startingMediaInfo_ = void 0;
    _this.segmentMetadataTrack_ = settings.segmentMetadataTrack;
    _this.goalBufferLength_ = settings.goalBufferLength;
    _this.sourceType_ = settings.sourceType;
    _this.sourceUpdater_ = settings.sourceUpdater;
    _this.inbandTextTracks_ = settings.inbandTextTracks;
    _this.state_ = "INIT";
    _this.timelineChangeController_ = settings.timelineChangeController;
    _this.shouldSaveSegmentTimingInfo_ = true;
    _this.parse708captions_ = settings.parse708captions;
    _this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;
    _this.captionServices_ = settings.captionServices;
    _this.experimentalExactManifestTimings = settings.experimentalExactManifestTimings;
    _this.checkBufferTimeout_ = null;
    _this.error_ = void 0;
    _this.currentTimeline_ = -1;
    _this.pendingSegment_ = null;
    _this.xhrOptions_ = null;
    _this.pendingSegments_ = [];
    _this.audioDisabled_ = false;
    _this.isPendingTimestampOffset_ = false;
    _this.gopBuffer_ = [];
    _this.timeMapping_ = 0;
    _this.safeAppend_ = videojs.browser.IE_VERSION >= 11;
    _this.appendInitSegment_ = {
      audio: true,
      video: true
    };
    _this.playlistOfLastInitSegment_ = {
      audio: null,
      video: null
    };
    _this.callQueue_ = [];
    _this.loadQueue_ = [];
    _this.metadataQueue_ = {
      id3: [],
      caption: []
    };
    _this.waitingOnRemove_ = false;
    _this.quotaExceededErrorRetryTimeout_ = null;
    _this.activeInitSegmentId_ = null;
    _this.initSegments_ = {};
    _this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;
    _this.keyCache_ = {};
    _this.decrypter_ = settings.decrypter;
    _this.syncController_ = settings.syncController;
    _this.syncPoint_ = {
      segmentIndex: 0,
      time: 0
    };
    _this.transmuxer_ = _this.createTransmuxer_();
    _this.triggerSyncInfoUpdate_ = function() {
      return _this.trigger("syncinfoupdate");
    };
    _this.syncController_.on("syncinfoupdate", _this.triggerSyncInfoUpdate_);
    _this.mediaSource_.addEventListener("sourceopen", function() {
      if (!_this.isEndOfStream_()) {
        _this.ended_ = false;
      }
    });
    _this.fetchAtBuffer_ = false;
    _this.logger_ = logger("SegmentLoader[" + _this.loaderType_ + "]");
    Object.defineProperty(_assertThisInitialized(_this), "state", {
      get: function get8() {
        return this.state_;
      },
      set: function set4(newState) {
        if (newState !== this.state_) {
          this.logger_(this.state_ + " -> " + newState);
          this.state_ = newState;
          this.trigger("statechange");
        }
      }
    });
    _this.sourceUpdater_.on("ready", function() {
      if (_this.hasEnoughInfoToAppend_()) {
        _this.processCallQueue_();
      }
    });
    if (_this.loaderType_ === "main") {
      _this.timelineChangeController_.on("pendingtimelinechange", function() {
        if (_this.hasEnoughInfoToAppend_()) {
          _this.processCallQueue_();
        }
      });
    }
    if (_this.loaderType_ === "audio") {
      _this.timelineChangeController_.on("timelinechange", function() {
        if (_this.hasEnoughInfoToLoad_()) {
          _this.processLoadQueue_();
        }
        if (_this.hasEnoughInfoToAppend_()) {
          _this.processCallQueue_();
        }
      });
    }
    return _this;
  }
  var _proto = SegmentLoader2.prototype;
  _proto.createTransmuxer_ = function createTransmuxer_() {
    return segmentTransmuxer.createTransmuxer({
      remux: false,
      alignGopsAtEnd: this.safeAppend_,
      keepOriginalTimestamps: true,
      parse708captions: this.parse708captions_,
      captionServices: this.captionServices_
    });
  };
  _proto.resetStats_ = function resetStats_() {
    this.mediaBytesTransferred = 0;
    this.mediaRequests = 0;
    this.mediaRequestsAborted = 0;
    this.mediaRequestsTimedout = 0;
    this.mediaRequestsErrored = 0;
    this.mediaTransferDuration = 0;
    this.mediaSecondsLoaded = 0;
    this.mediaAppends = 0;
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.state = "DISPOSED";
    this.pause();
    this.abort_();
    if (this.transmuxer_) {
      this.transmuxer_.terminate();
    }
    this.resetStats_();
    if (this.checkBufferTimeout_) {
      window_1.clearTimeout(this.checkBufferTimeout_);
    }
    if (this.syncController_ && this.triggerSyncInfoUpdate_) {
      this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_);
    }
    this.off();
  };
  _proto.setAudio = function setAudio(enable) {
    this.audioDisabled_ = !enable;
    if (enable) {
      this.appendInitSegment_.audio = true;
    } else {
      this.sourceUpdater_.removeAudio(0, this.duration_());
    }
  };
  _proto.abort = function abort2() {
    if (this.state !== "WAITING") {
      if (this.pendingSegment_) {
        this.pendingSegment_ = null;
      }
      return;
    }
    this.abort_();
    this.state = "READY";
    if (!this.paused()) {
      this.monitorBuffer_();
    }
  };
  _proto.abort_ = function abort_() {
    if (this.pendingSegment_ && this.pendingSegment_.abortRequests) {
      this.pendingSegment_.abortRequests();
    }
    this.pendingSegment_ = null;
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
    this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
    this.waitingOnRemove_ = false;
    window_1.clearTimeout(this.quotaExceededErrorRetryTimeout_);
    this.quotaExceededErrorRetryTimeout_ = null;
  };
  _proto.checkForAbort_ = function checkForAbort_(requestId) {
    if (this.state === "APPENDING" && !this.pendingSegment_) {
      this.state = "READY";
      return true;
    }
    if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) {
      return true;
    }
    return false;
  };
  _proto.error = function error(_error) {
    if (typeof _error !== "undefined") {
      this.logger_("error occurred:", _error);
      this.error_ = _error;
    }
    this.pendingSegment_ = null;
    return this.error_;
  };
  _proto.endOfStream = function endOfStream2() {
    this.ended_ = true;
    if (this.transmuxer_) {
      segmentTransmuxer.reset(this.transmuxer_);
    }
    this.gopBuffer_.length = 0;
    this.pause();
    this.trigger("ended");
  };
  _proto.buffered_ = function buffered_() {
    var trackInfo = this.getMediaInfo_();
    if (!this.sourceUpdater_ || !trackInfo) {
      return videojs.createTimeRanges();
    }
    if (this.loaderType_ === "main") {
      var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
      if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed3) {
        return this.sourceUpdater_.buffered();
      }
      if (hasVideo) {
        return this.sourceUpdater_.videoBuffered();
      }
    }
    return this.sourceUpdater_.audioBuffered();
  };
  _proto.initSegmentForMap = function initSegmentForMap(map, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!map) {
      return null;
    }
    var id2 = initSegmentId(map);
    var storedMap = this.initSegments_[id2];
    if (set4 && !storedMap && map.bytes) {
      this.initSegments_[id2] = storedMap = {
        resolvedUri: map.resolvedUri,
        byterange: map.byterange,
        bytes: map.bytes,
        tracks: map.tracks,
        timescales: map.timescales
      };
    }
    return storedMap || map;
  };
  _proto.segmentKey = function segmentKey(key, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!key) {
      return null;
    }
    var id2 = segmentKeyId(key);
    var storedKey = this.keyCache_[id2];
    if (this.cacheEncryptionKeys_ && set4 && !storedKey && key.bytes) {
      this.keyCache_[id2] = storedKey = {
        resolvedUri: key.resolvedUri,
        bytes: key.bytes
      };
    }
    var result = {
      resolvedUri: (storedKey || key).resolvedUri
    };
    if (storedKey) {
      result.bytes = storedKey.bytes;
    }
    return result;
  };
  _proto.couldBeginLoading_ = function couldBeginLoading_() {
    return this.playlist_ && !this.paused();
  };
  _proto.load = function load() {
    this.monitorBuffer_();
    if (!this.playlist_) {
      return;
    }
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      return this.init_();
    }
    if (!this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT") {
      return;
    }
    this.state = "READY";
  };
  _proto.init_ = function init_() {
    this.state = "READY";
    this.resetEverything();
    return this.monitorBuffer_();
  };
  _proto.playlist = function playlist(newPlaylist, options) {
    if (options === void 0) {
      options = {};
    }
    if (!newPlaylist) {
      return;
    }
    var oldPlaylist = this.playlist_;
    var segmentInfo = this.pendingSegment_;
    this.playlist_ = newPlaylist;
    this.xhrOptions_ = options;
    if (this.state === "INIT") {
      newPlaylist.syncInfo = {
        mediaSequence: newPlaylist.mediaSequence,
        time: 0
      };
      if (this.loaderType_ === "main") {
        this.syncController_.setDateTimeMappingForStart(newPlaylist);
      }
    }
    var oldId = null;
    if (oldPlaylist) {
      if (oldPlaylist.id) {
        oldId = oldPlaylist.id;
      } else if (oldPlaylist.uri) {
        oldId = oldPlaylist.uri;
      }
    }
    this.logger_("playlist update [" + oldId + " => " + (newPlaylist.id || newPlaylist.uri) + "]");
    this.trigger("syncinfoupdate");
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      return this.init_();
    }
    if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
      if (this.mediaIndex !== null) {
        if (!newPlaylist.endList) {
          this.resetLoader();
        } else {
          this.resyncLoader();
        }
      }
      this.currentMediaInfo_ = void 0;
      this.trigger("playlistupdate");
      return;
    }
    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
    this.logger_("live window shift [" + mediaSequenceDiff + "]");
    if (this.mediaIndex !== null) {
      this.mediaIndex -= mediaSequenceDiff;
      if (this.mediaIndex < 0) {
        this.mediaIndex = null;
        this.partIndex = null;
      } else {
        var segment = this.playlist_.segments[this.mediaIndex];
        if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
          var mediaIndex = this.mediaIndex;
          this.logger_("currently processing part (index " + this.partIndex + ") no longer exists.");
          this.resetLoader();
          this.mediaIndex = mediaIndex;
        }
      }
    }
    if (segmentInfo) {
      segmentInfo.mediaIndex -= mediaSequenceDiff;
      if (segmentInfo.mediaIndex < 0) {
        segmentInfo.mediaIndex = null;
        segmentInfo.partIndex = null;
      } else {
        if (segmentInfo.mediaIndex >= 0) {
          segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
        }
        if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) {
          segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
        }
      }
    }
    this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
  };
  _proto.pause = function pause() {
    if (this.checkBufferTimeout_) {
      window_1.clearTimeout(this.checkBufferTimeout_);
      this.checkBufferTimeout_ = null;
    }
  };
  _proto.paused = function paused() {
    return this.checkBufferTimeout_ === null;
  };
  _proto.resetEverything = function resetEverything(done) {
    this.ended_ = false;
    this.appendInitSegment_ = {
      audio: true,
      video: true
    };
    this.resetLoader();
    this.remove(0, Infinity, done);
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearAllMp4Captions"
      });
      this.transmuxer_.postMessage({
        action: "reset"
      });
    }
  };
  _proto.resetLoader = function resetLoader() {
    this.fetchAtBuffer_ = false;
    this.resyncLoader();
  };
  _proto.resyncLoader = function resyncLoader() {
    if (this.transmuxer_) {
      segmentTransmuxer.reset(this.transmuxer_);
    }
    this.mediaIndex = null;
    this.partIndex = null;
    this.syncPoint_ = null;
    this.isPendingTimestampOffset_ = false;
    this.callQueue_ = [];
    this.loadQueue_ = [];
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
    this.abort();
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  };
  _proto.remove = function remove2(start3, end2, done, force) {
    if (done === void 0) {
      done = function done2() {
      };
    }
    if (force === void 0) {
      force = false;
    }
    if (end2 === Infinity) {
      end2 = this.duration_();
    }
    if (end2 <= start3) {
      this.logger_("skipping remove because end ${end} is <= start ${start}");
      return;
    }
    if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
      this.logger_("skipping remove because no source updater or starting media info");
      return;
    }
    var removesRemaining = 1;
    var removeFinished = function removeFinished2() {
      removesRemaining--;
      if (removesRemaining === 0) {
        done();
      }
    };
    if (force || !this.audioDisabled_) {
      removesRemaining++;
      this.sourceUpdater_.removeAudio(start3, end2, removeFinished);
    }
    if (force || this.loaderType_ === "main") {
      this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start3, end2, this.timeMapping_);
      removesRemaining++;
      this.sourceUpdater_.removeVideo(start3, end2, removeFinished);
    }
    for (var track in this.inbandTextTracks_) {
      removeCuesFromTrack(start3, end2, this.inbandTextTracks_[track]);
    }
    removeCuesFromTrack(start3, end2, this.segmentMetadataTrack_);
    removeFinished();
  };
  _proto.monitorBuffer_ = function monitorBuffer_() {
    if (this.checkBufferTimeout_) {
      window_1.clearTimeout(this.checkBufferTimeout_);
    }
    this.checkBufferTimeout_ = window_1.setTimeout(this.monitorBufferTick_.bind(this), 1);
  };
  _proto.monitorBufferTick_ = function monitorBufferTick_() {
    if (this.state === "READY") {
      this.fillBuffer_();
    }
    if (this.checkBufferTimeout_) {
      window_1.clearTimeout(this.checkBufferTimeout_);
    }
    this.checkBufferTimeout_ = window_1.setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);
  };
  _proto.fillBuffer_ = function fillBuffer_() {
    if (this.sourceUpdater_.updating()) {
      return;
    }
    var segmentInfo = this.chooseNextRequest_();
    if (!segmentInfo) {
      return;
    }
    if (typeof segmentInfo.timestampOffset === "number") {
      this.isPendingTimestampOffset_ = false;
      this.timelineChangeController_.pendingTimelineChange({
        type: this.loaderType_,
        from: this.currentTimeline_,
        to: segmentInfo.timeline
      });
    }
    this.loadSegment_(segmentInfo);
  };
  _proto.isEndOfStream_ = function isEndOfStream_(mediaIndex, playlist, partIndex) {
    if (mediaIndex === void 0) {
      mediaIndex = this.mediaIndex;
    }
    if (playlist === void 0) {
      playlist = this.playlist_;
    }
    if (partIndex === void 0) {
      partIndex = this.partIndex;
    }
    if (!playlist || !this.mediaSource_) {
      return false;
    }
    var segment = typeof mediaIndex === "number" && playlist.segments[mediaIndex];
    var appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
    var appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
    return playlist.endList && this.mediaSource_.readyState === "open" && appendedLastSegment && appendedLastPart;
  };
  _proto.chooseNextRequest_ = function chooseNextRequest_() {
    var buffered = this.buffered_();
    var bufferedEnd = lastBufferedEnd(buffered) || 0;
    var bufferedTime = timeAheadOf(buffered, this.currentTime_());
    var preloaded = !this.hasPlayed_() && bufferedTime >= 1;
    var haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
    var segments = this.playlist_.segments;
    if (!segments.length || preloaded || haveEnoughBuffer) {
      return null;
    }
    this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());
    var next2 = {
      partIndex: null,
      mediaIndex: null,
      startOfSegment: null,
      playlist: this.playlist_,
      isSyncRequest: Boolean(!this.syncPoint_)
    };
    if (next2.isSyncRequest) {
      next2.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd);
    } else if (this.mediaIndex !== null) {
      var segment = segments[this.mediaIndex];
      var partIndex = typeof this.partIndex === "number" ? this.partIndex : -1;
      next2.startOfSegment = segment.end ? segment.end : bufferedEnd;
      if (segment.parts && segment.parts[partIndex + 1]) {
        next2.mediaIndex = this.mediaIndex;
        next2.partIndex = partIndex + 1;
      } else {
        next2.mediaIndex = this.mediaIndex + 1;
      }
    } else {
      var _Playlist$getMediaInf = Playlist2.getMediaInfoForTime({
        experimentalExactManifestTimings: this.experimentalExactManifestTimings,
        playlist: this.playlist_,
        currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),
        startingPartIndex: this.syncPoint_.partIndex,
        startingSegmentIndex: this.syncPoint_.segmentIndex,
        startTime: this.syncPoint_.time
      }), segmentIndex = _Playlist$getMediaInf.segmentIndex, startTime = _Playlist$getMediaInf.startTime, _partIndex = _Playlist$getMediaInf.partIndex;
      next2.getMediaInfoForTime = this.fetchAtBuffer_ ? "bufferedEnd " + bufferedEnd : "currentTime " + this.currentTime_();
      next2.mediaIndex = segmentIndex;
      next2.startOfSegment = startTime;
      next2.partIndex = _partIndex;
    }
    var nextSegment = segments[next2.mediaIndex];
    var nextPart = nextSegment && typeof next2.partIndex === "number" && nextSegment.parts && nextSegment.parts[next2.partIndex];
    if (!nextSegment || typeof next2.partIndex === "number" && !nextPart) {
      return null;
    }
    if (typeof next2.partIndex !== "number" && nextSegment.parts) {
      next2.partIndex = 0;
      nextPart = nextSegment.parts[0];
    }
    if (!bufferedTime && nextPart && !nextPart.independent) {
      if (next2.partIndex === 0) {
        var lastSegment = segments[next2.mediaIndex - 1];
        var lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
        if (lastSegmentLastPart && lastSegmentLastPart.independent) {
          next2.mediaIndex -= 1;
          next2.partIndex = lastSegment.parts.length - 1;
          next2.independent = "previous segment";
        }
      } else if (nextSegment.parts[next2.partIndex - 1].independent) {
        next2.partIndex -= 1;
        next2.independent = "previous part";
      }
    }
    var ended = this.mediaSource_ && this.mediaSource_.readyState === "ended";
    if (next2.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) {
      return null;
    }
    return this.generateSegmentInfo_(next2);
  };
  _proto.generateSegmentInfo_ = function generateSegmentInfo_(options) {
    var independent = options.independent, playlist = options.playlist, mediaIndex = options.mediaIndex, startOfSegment = options.startOfSegment, isSyncRequest = options.isSyncRequest, partIndex = options.partIndex, forceTimestampOffset = options.forceTimestampOffset, getMediaInfoForTime3 = options.getMediaInfoForTime;
    var segment = playlist.segments[mediaIndex];
    var part = typeof partIndex === "number" && segment.parts[partIndex];
    var segmentInfo = {
      requestId: "segment-loader-" + Math.random(),
      // resolve the segment URL relative to the playlist
      uri: part && part.resolvedUri || segment.resolvedUri,
      // the segment's mediaIndex at the time it was requested
      mediaIndex,
      partIndex: part ? partIndex : null,
      // whether or not to update the SegmentLoader's state with this
      // segment's mediaIndex
      isSyncRequest,
      startOfSegment,
      // the segment's playlist
      playlist,
      // unencrypted bytes of the segment
      bytes: null,
      // when a key is defined for this segment, the encrypted bytes
      encryptedBytes: null,
      // The target timestampOffset for this segment when we append it
      // to the source buffer
      timestampOffset: null,
      // The timeline that the segment is in
      timeline: segment.timeline,
      // The expected duration of the segment in seconds
      duration: part && part.duration || segment.duration,
      // retain the segment in case the playlist updates while doing an async process
      segment,
      part,
      byteLength: 0,
      transmuxer: this.transmuxer_,
      // type of getMediaInfoForTime that was used to get this segment
      getMediaInfoForTime: getMediaInfoForTime3,
      independent
    };
    var overrideCheck = typeof forceTimestampOffset !== "undefined" ? forceTimestampOffset : this.isPendingTimestampOffset_;
    segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
      segmentTimeline: segment.timeline,
      currentTimeline: this.currentTimeline_,
      startOfSegment,
      buffered: this.buffered_(),
      overrideCheck
    });
    var audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
    if (typeof audioBufferedEnd === "number") {
      segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
    }
    if (this.sourceUpdater_.videoBuffered().length) {
      segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(
        this.gopBuffer_,
        // since the transmuxer is using the actual timing values, but the time is
        // adjusted by the timestmap offset, we must adjust the value here
        this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(),
        this.timeMapping_
      );
    }
    return segmentInfo;
  };
  _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_(options) {
    return timestampOffsetForSegment(options);
  };
  _proto.earlyAbortWhenNeeded_ = function earlyAbortWhenNeeded_(stats) {
    if (this.vhs_.tech_.paused() || // Don't abort if the current playlist is on the lowestEnabledRendition
    // TODO: Replace using timeout with a boolean indicating whether this playlist is
    //       the lowestEnabledRendition.
    !this.xhrOptions_.timeout || // Don't abort if we have no bandwidth information to estimate segment sizes
    !this.playlist_.attributes.BANDWIDTH) {
      return;
    }
    if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1e3) {
      return;
    }
    var currentTime = this.currentTime_();
    var measuredBandwidth = stats.bandwidth;
    var segmentDuration = this.pendingSegment_.duration;
    var requestTimeRemaining = Playlist2.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
    var timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
    if (requestTimeRemaining <= timeUntilRebuffer$1) {
      return;
    }
    var switchCandidate = minRebufferMaxBandwidthSelector({
      master: this.vhs_.playlists.master,
      currentTime,
      bandwidth: measuredBandwidth,
      duration: this.duration_(),
      segmentDuration,
      timeUntilRebuffer: timeUntilRebuffer$1,
      currentTimeline: this.currentTimeline_,
      syncController: this.syncController_
    });
    if (!switchCandidate) {
      return;
    }
    var rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
    var timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
    var minimumTimeSaving = 0.5;
    if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) {
      minimumTimeSaving = 1;
    }
    if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) {
      return;
    }
    this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;
    this.trigger("earlyabort");
  };
  _proto.handleAbort_ = function handleAbort_(segmentInfo) {
    this.logger_("Aborting " + segmentInfoString(segmentInfo));
    this.mediaRequestsAborted += 1;
  };
  _proto.handleProgress_ = function handleProgress_(event, simpleSegment) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    this.trigger("progress");
  };
  _proto.handleTrackInfo_ = function handleTrackInfo_(simpleSegment, trackInfo) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (this.checkForIllegalMediaSwitch(trackInfo)) {
      return;
    }
    trackInfo = trackInfo || {};
    if (!shallowEqual$1(this.currentMediaInfo_, trackInfo)) {
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
      this.startingMediaInfo_ = trackInfo;
      this.currentMediaInfo_ = trackInfo;
      this.logger_("trackinfo update", trackInfo);
      this.trigger("trackinfo");
    }
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    this.pendingSegment_.trackInfo = trackInfo;
    if (this.hasEnoughInfoToAppend_()) {
      this.processCallQueue_();
    }
  };
  _proto.handleTimingInfo_ = function handleTimingInfo_(simpleSegment, mediaType, timeType, time2) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    var segmentInfo = this.pendingSegment_;
    var timingInfoProperty = timingInfoPropertyForMedia(mediaType);
    segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
    segmentInfo[timingInfoProperty][timeType] = time2;
    this.logger_("timinginfo: " + mediaType + " - " + timeType + " - " + time2);
    if (this.hasEnoughInfoToAppend_()) {
      this.processCallQueue_();
    }
  };
  _proto.handleCaptions_ = function handleCaptions_(simpleSegment, captionData) {
    var _this2 = this;
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (captionData.length === 0) {
      this.logger_("SegmentLoader received no captions from a caption event");
      return;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo.hasAppendedData_) {
      this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
      return;
    }
    var timestampOffset2 = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    var captionTracks = {};
    captionData.forEach(function(caption) {
      captionTracks[caption.stream] = captionTracks[caption.stream] || {
        // Infinity, as any other value will be less than this
        startTime: Infinity,
        captions: [],
        // 0 as an other value will be more than this
        endTime: 0
      };
      var captionTrack = captionTracks[caption.stream];
      captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset2);
      captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset2);
      captionTrack.captions.push(caption);
    });
    Object.keys(captionTracks).forEach(function(trackName) {
      var _captionTracks$trackN = captionTracks[trackName], startTime = _captionTracks$trackN.startTime, endTime = _captionTracks$trackN.endTime, captions = _captionTracks$trackN.captions;
      var inbandTextTracks = _this2.inbandTextTracks_;
      _this2.logger_("adding cues from " + startTime + " -> " + endTime + " for " + trackName);
      createCaptionsTrackIfNotExists(inbandTextTracks, _this2.vhs_.tech_, trackName);
      removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
      addCaptionData({
        captionArray: captions,
        inbandTextTracks,
        timestampOffset: timestampOffset2
      });
    });
    if (this.transmuxer_) {
      this.transmuxer_.postMessage({
        action: "clearParsedMp4Captions"
      });
    }
  };
  _proto.handleId3_ = function handleId3_(simpleSegment, id3Frames, dispatchType) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo.hasAppendedData_) {
      this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
      return;
    }
    var timestampOffset2 = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
    createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);
    addMetadata({
      inbandTextTracks: this.inbandTextTracks_,
      metadataArray: id3Frames,
      timestampOffset: timestampOffset2,
      videoDuration: this.duration_()
    });
  };
  _proto.processMetadataQueue_ = function processMetadataQueue_() {
    this.metadataQueue_.id3.forEach(function(fn2) {
      return fn2();
    });
    this.metadataQueue_.caption.forEach(function(fn2) {
      return fn2();
    });
    this.metadataQueue_.id3 = [];
    this.metadataQueue_.caption = [];
  };
  _proto.processCallQueue_ = function processCallQueue_() {
    var callQueue = this.callQueue_;
    this.callQueue_ = [];
    callQueue.forEach(function(fun) {
      return fun();
    });
  };
  _proto.processLoadQueue_ = function processLoadQueue_() {
    var loadQueue = this.loadQueue_;
    this.loadQueue_ = [];
    loadQueue.forEach(function(fun) {
      return fun();
    });
  };
  _proto.hasEnoughInfoToLoad_ = function hasEnoughInfoToLoad_() {
    if (this.loaderType_ !== "audio") {
      return true;
    }
    var segmentInfo = this.pendingSegment_;
    if (!segmentInfo) {
      return false;
    }
    if (!this.getCurrentMediaInfo_()) {
      return true;
    }
    if (
      // Technically, instead of waiting to load a segment on timeline changes, a segment
      // can be requested and downloaded and only wait before it is transmuxed or parsed.
      // But in practice, there are a few reasons why it is better to wait until a loader
      // is ready to append that segment before requesting and downloading:
      //
      // 1. Because audio and main loaders cross discontinuities together, if this loader
      //    is waiting for the other to catch up, then instead of requesting another
      //    segment and using up more bandwidth, by not yet loading, more bandwidth is
      //    allotted to the loader currently behind.
      // 2. media-segment-request doesn't have to have logic to consider whether a segment
      // is ready to be processed or not, isolating the queueing behavior to the loader.
      // 3. The audio loader bases some of its segment properties on timing information
      //    provided by the main loader, meaning that, if the logic for waiting on
      //    processing was in media-segment-request, then it would also need to know how
      //    to re-generate the segment information after the main loader caught up.
      shouldWaitForTimelineChange({
        timelineChangeController: this.timelineChangeController_,
        currentTimeline: this.currentTimeline_,
        segmentTimeline: segmentInfo.timeline,
        loaderType: this.loaderType_,
        audioDisabled: this.audioDisabled_
      })
    ) {
      return false;
    }
    return true;
  };
  _proto.getCurrentMediaInfo_ = function getCurrentMediaInfo_(segmentInfo) {
    if (segmentInfo === void 0) {
      segmentInfo = this.pendingSegment_;
    }
    return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
  };
  _proto.getMediaInfo_ = function getMediaInfo_(segmentInfo) {
    if (segmentInfo === void 0) {
      segmentInfo = this.pendingSegment_;
    }
    return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
  };
  _proto.hasEnoughInfoToAppend_ = function hasEnoughInfoToAppend_() {
    if (!this.sourceUpdater_.ready()) {
      return false;
    }
    if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) {
      return false;
    }
    var segmentInfo = this.pendingSegment_;
    var trackInfo = this.getCurrentMediaInfo_();
    if (!segmentInfo || !trackInfo) {
      return false;
    }
    var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
    if (hasVideo && !segmentInfo.videoTimingInfo) {
      return false;
    }
    if (hasAudio && !this.audioDisabled_ && !isMuxed3 && !segmentInfo.audioTimingInfo) {
      return false;
    }
    if (shouldWaitForTimelineChange({
      timelineChangeController: this.timelineChangeController_,
      currentTimeline: this.currentTimeline_,
      segmentTimeline: segmentInfo.timeline,
      loaderType: this.loaderType_,
      audioDisabled: this.audioDisabled_
    })) {
      return false;
    }
    return true;
  };
  _proto.handleData_ = function handleData_3(simpleSegment, result) {
    this.earlyAbortWhenNeeded_(simpleSegment.stats);
    if (this.checkForAbort_(simpleSegment.requestId)) {
      return;
    }
    if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
      this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.setTimeMapping_(segmentInfo.timeline);
    this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
    if (this.mediaSource_.readyState === "closed") {
      return;
    }
    if (simpleSegment.map) {
      simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
      segmentInfo.segment.map = simpleSegment.map;
    }
    if (simpleSegment.key) {
      this.segmentKey(simpleSegment.key, true);
    }
    segmentInfo.isFmp4 = simpleSegment.isFmp4;
    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
    if (segmentInfo.isFmp4) {
      this.trigger("fmp4");
      segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
    } else {
      var trackInfo = this.getCurrentMediaInfo_();
      var useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
      var firstVideoFrameTimeForData;
      if (useVideoTimingInfo) {
        firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
      }
      segmentInfo.timingInfo.start = this.trueSegmentStart_({
        currentStart: segmentInfo.timingInfo.start,
        playlist: segmentInfo.playlist,
        mediaIndex: segmentInfo.mediaIndex,
        currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
        useVideoTimingInfo,
        firstVideoFrameTimeForData,
        videoTimingInfo: segmentInfo.videoTimingInfo,
        audioTimingInfo: segmentInfo.audioTimingInfo
      });
    }
    this.updateAppendInitSegmentStatus(segmentInfo, result.type);
    this.updateSourceBufferTimestampOffset_(segmentInfo);
    if (segmentInfo.isSyncRequest) {
      this.updateTimingInfoEnd_(segmentInfo);
      this.syncController_.saveSegmentTimingInfo({
        segmentInfo,
        shouldSaveTimelineMapping: this.loaderType_ === "main"
      });
      var next2 = this.chooseNextRequest_();
      if (next2.mediaIndex !== segmentInfo.mediaIndex || next2.partIndex !== segmentInfo.partIndex) {
        this.logger_("sync segment was incorrect, not appending");
        return;
      }
      this.logger_("sync segment was correct, appending");
    }
    segmentInfo.hasAppendedData_ = true;
    this.processMetadataQueue_();
    this.appendData_(segmentInfo, result);
  };
  _proto.updateAppendInitSegmentStatus = function updateAppendInitSegmentStatus(segmentInfo, type2) {
    if (this.loaderType_ === "main" && typeof segmentInfo.timestampOffset === "number" && // in the case that we're handling partial data, we don't want to append an init
    // segment for each chunk
    !segmentInfo.changedTimestampOffset) {
      this.appendInitSegment_ = {
        audio: true,
        video: true
      };
    }
    if (this.playlistOfLastInitSegment_[type2] !== segmentInfo.playlist) {
      this.appendInitSegment_[type2] = true;
    }
  };
  _proto.getInitSegmentAndUpdateState_ = function getInitSegmentAndUpdateState_(_ref4) {
    var type2 = _ref4.type, initSegment = _ref4.initSegment, map = _ref4.map, playlist = _ref4.playlist;
    if (map) {
      var id2 = initSegmentId(map);
      if (this.activeInitSegmentId_ === id2) {
        return null;
      }
      initSegment = this.initSegmentForMap(map, true).bytes;
      this.activeInitSegmentId_ = id2;
    }
    if (initSegment && this.appendInitSegment_[type2]) {
      this.playlistOfLastInitSegment_[type2] = playlist;
      this.appendInitSegment_[type2] = false;
      this.activeInitSegmentId_ = null;
      return initSegment;
    }
    return null;
  };
  _proto.handleQuotaExceededError_ = function handleQuotaExceededError_(_ref5, error) {
    var _this3 = this;
    var segmentInfo = _ref5.segmentInfo, type2 = _ref5.type, bytes = _ref5.bytes;
    var audioBuffered = this.sourceUpdater_.audioBuffered();
    var videoBuffered = this.sourceUpdater_.videoBuffered();
    if (audioBuffered.length > 1) {
      this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + timeRangesToArray(audioBuffered).join(", "));
    }
    if (videoBuffered.length > 1) {
      this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + timeRangesToArray(videoBuffered).join(", "));
    }
    var audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
    var audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
    var videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
    var videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
    if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {
      this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. " + ("Appended byte length: " + bytes.byteLength + ", ") + ("audio buffer: " + timeRangesToArray(audioBuffered).join(", ") + ", ") + ("video buffer: " + timeRangesToArray(videoBuffered).join(", ") + ", "));
      this.error({
        message: "Quota exceeded error with append of a single segment of content",
        excludeUntil: Infinity
      });
      this.trigger("error");
      return;
    }
    this.waitingOnRemove_ = true;
    this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
      segmentInfo,
      type: type2,
      bytes
    }));
    var currentTime = this.currentTime_();
    var timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;
    this.logger_("On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to " + timeToRemoveUntil);
    this.remove(0, timeToRemoveUntil, function() {
      _this3.logger_("On QUOTA_EXCEEDED_ERR, retrying append in " + MIN_BACK_BUFFER + "s");
      _this3.waitingOnRemove_ = false;
      _this3.quotaExceededErrorRetryTimeout_ = window_1.setTimeout(function() {
        _this3.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue");
        _this3.quotaExceededErrorRetryTimeout_ = null;
        _this3.processCallQueue_();
      }, MIN_BACK_BUFFER * 1e3);
    }, true);
  };
  _proto.handleAppendError_ = function handleAppendError_(_ref6, error) {
    var segmentInfo = _ref6.segmentInfo, type2 = _ref6.type, bytes = _ref6.bytes;
    if (!error) {
      return;
    }
    if (error.code === QUOTA_EXCEEDED_ERR) {
      this.handleQuotaExceededError_({
        segmentInfo,
        type: type2,
        bytes
      });
      return;
    }
    this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error);
    this.error(type2 + " append of " + bytes.length + "b failed for segment " + ("#" + segmentInfo.mediaIndex + " in playlist " + segmentInfo.playlist.id));
    this.trigger("appenderror");
  };
  _proto.appendToSourceBuffer_ = function appendToSourceBuffer_(_ref7) {
    var segmentInfo = _ref7.segmentInfo, type2 = _ref7.type, initSegment = _ref7.initSegment, data = _ref7.data, bytes = _ref7.bytes;
    if (!bytes) {
      var segments = [data];
      var byteLength = data.byteLength;
      if (initSegment) {
        segments.unshift(initSegment);
        byteLength += initSegment.byteLength;
      }
      bytes = concatSegments({
        bytes: byteLength,
        segments
      });
    }
    this.sourceUpdater_.appendBuffer({
      segmentInfo,
      type: type2,
      bytes
    }, this.handleAppendError_.bind(this, {
      segmentInfo,
      type: type2,
      bytes
    }));
  };
  _proto.handleSegmentTimingInfo_ = function handleSegmentTimingInfo_(type2, requestId, segmentTimingInfo) {
    if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) {
      return;
    }
    var segment = this.pendingSegment_.segment;
    var timingInfoProperty = type2 + "TimingInfo";
    if (!segment[timingInfoProperty]) {
      segment[timingInfoProperty] = {};
    }
    segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
    segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
    segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
    segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
    segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
    segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
  };
  _proto.appendData_ = function appendData_(segmentInfo, result) {
    var type2 = result.type, data = result.data;
    if (!data || !data.byteLength) {
      return;
    }
    if (type2 === "audio" && this.audioDisabled_) {
      return;
    }
    var initSegment = this.getInitSegmentAndUpdateState_({
      type: type2,
      initSegment: result.initSegment,
      playlist: segmentInfo.playlist,
      map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
    });
    this.appendToSourceBuffer_({
      segmentInfo,
      type: type2,
      initSegment,
      data
    });
  };
  _proto.loadSegment_ = function loadSegment_(segmentInfo) {
    var _this4 = this;
    this.state = "WAITING";
    this.pendingSegment_ = segmentInfo;
    this.trimBackBuffer_(segmentInfo);
    if (typeof segmentInfo.timestampOffset === "number") {
      if (this.transmuxer_) {
        this.transmuxer_.postMessage({
          action: "clearAllMp4Captions"
        });
      }
    }
    if (!this.hasEnoughInfoToLoad_()) {
      this.loadQueue_.push(function() {
        var options = _extends$8({}, segmentInfo, {
          forceTimestampOffset: true
        });
        _extends$8(segmentInfo, _this4.generateSegmentInfo_(options));
        _this4.isPendingTimestampOffset_ = false;
        _this4.updateTransmuxerAndRequestSegment_(segmentInfo);
      });
      return;
    }
    this.updateTransmuxerAndRequestSegment_(segmentInfo);
  };
  _proto.updateTransmuxerAndRequestSegment_ = function updateTransmuxerAndRequestSegment_(segmentInfo) {
    var _this5 = this;
    if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
      this.gopBuffer_.length = 0;
      segmentInfo.gopsToAlignWith = [];
      this.timeMapping_ = 0;
      this.transmuxer_.postMessage({
        action: "reset"
      });
      this.transmuxer_.postMessage({
        action: "setTimestampOffset",
        timestampOffset: segmentInfo.timestampOffset
      });
    }
    var simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
    var isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
    var isWalkingForward = this.mediaIndex !== null;
    var isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && // currentTimeline starts at -1, so we shouldn't end the timeline switching to 0,
    // the first timeline
    segmentInfo.timeline > 0;
    var isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
    this.logger_("Requesting " + segmentInfoString(segmentInfo));
    if (simpleSegment.map && !simpleSegment.map.bytes) {
      this.logger_("going to request init segment.");
      this.appendInitSegment_ = {
        video: true,
        audio: true
      };
    }
    segmentInfo.abortRequests = mediaSegmentRequest({
      xhr: this.vhs_.xhr,
      xhrOptions: this.xhrOptions_,
      decryptionWorker: this.decrypter_,
      segment: simpleSegment,
      abortFn: this.handleAbort_.bind(this, segmentInfo),
      progressFn: this.handleProgress_.bind(this),
      trackInfoFn: this.handleTrackInfo_.bind(this),
      timingInfoFn: this.handleTimingInfo_.bind(this),
      videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
      audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
      captionsFn: this.handleCaptions_.bind(this),
      isEndOfTimeline,
      endedTimelineFn: function endedTimelineFn() {
        _this5.logger_("received endedtimeline callback");
      },
      id3Fn: this.handleId3_.bind(this),
      dataFn: this.handleData_.bind(this),
      doneFn: this.segmentRequestFinished_.bind(this),
      onTransmuxerLog: function onTransmuxerLog(_ref8) {
        var message = _ref8.message, level = _ref8.level, stream = _ref8.stream;
        _this5.logger_(segmentInfoString(segmentInfo) + " logged from transmuxer stream " + stream + " as a " + level + ": " + message);
      }
    });
  };
  _proto.trimBackBuffer_ = function trimBackBuffer_(segmentInfo) {
    var removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
    if (removeToTime > 0) {
      this.remove(0, removeToTime);
    }
  };
  _proto.createSimplifiedSegmentObj_ = function createSimplifiedSegmentObj_(segmentInfo) {
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var simpleSegment = {
      resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
      byterange: part ? part.byterange : segment.byterange,
      requestId: segmentInfo.requestId,
      transmuxer: segmentInfo.transmuxer,
      audioAppendStart: segmentInfo.audioAppendStart,
      gopsToAlignWith: segmentInfo.gopsToAlignWith,
      part: segmentInfo.part
    };
    var previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
    if (previousSegment && previousSegment.timeline === segment.timeline) {
      if (previousSegment.videoTimingInfo) {
        simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd;
      } else if (previousSegment.audioTimingInfo) {
        simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
      }
    }
    if (segment.key) {
      var iv = segment.key.iv || new Uint32Array([0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence]);
      simpleSegment.key = this.segmentKey(segment.key);
      simpleSegment.key.iv = iv;
    }
    if (segment.map) {
      simpleSegment.map = this.initSegmentForMap(segment.map);
    }
    return simpleSegment;
  };
  _proto.saveTransferStats_ = function saveTransferStats_(stats) {
    this.mediaRequests += 1;
    if (stats) {
      this.mediaBytesTransferred += stats.bytesReceived;
      this.mediaTransferDuration += stats.roundTripTime;
    }
  };
  _proto.saveBandwidthRelatedStats_ = function saveBandwidthRelatedStats_(duration5, stats) {
    this.pendingSegment_.byteLength = stats.bytesReceived;
    if (duration5 < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
      this.logger_("Ignoring segment's bandwidth because its duration of " + duration5 + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
      return;
    }
    this.bandwidth = stats.bandwidth;
    this.roundTrip = stats.roundTripTime;
  };
  _proto.handleTimeout_ = function handleTimeout_() {
    this.mediaRequestsTimedout += 1;
    this.bandwidth = 1;
    this.roundTrip = NaN;
    this.trigger("bandwidthupdate");
  };
  _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
    if (this.callQueue_.length) {
      this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
      return;
    }
    this.saveTransferStats_(simpleSegment.stats);
    if (!this.pendingSegment_) {
      return;
    }
    if (simpleSegment.requestId !== this.pendingSegment_.requestId) {
      return;
    }
    if (error) {
      this.pendingSegment_ = null;
      this.state = "READY";
      if (error.code === REQUEST_ERRORS.ABORTED) {
        return;
      }
      this.pause();
      if (error.code === REQUEST_ERRORS.TIMEOUT) {
        this.handleTimeout_();
        return;
      }
      this.mediaRequestsErrored += 1;
      this.error(error);
      this.trigger("error");
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
    segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
    if (result.gopInfo) {
      this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
    }
    this.state = "APPENDING";
    this.trigger("appending");
    this.waitForAppendsToComplete_(segmentInfo);
  };
  _proto.setTimeMapping_ = function setTimeMapping_(timeline) {
    var timelineMapping = this.syncController_.mappingForTimeline(timeline);
    if (timelineMapping !== null) {
      this.timeMapping_ = timelineMapping;
    }
  };
  _proto.updateMediaSecondsLoaded_ = function updateMediaSecondsLoaded_(segment) {
    if (typeof segment.start === "number" && typeof segment.end === "number") {
      this.mediaSecondsLoaded += segment.end - segment.start;
    } else {
      this.mediaSecondsLoaded += segment.duration;
    }
  };
  _proto.shouldUpdateTransmuxerTimestampOffset_ = function shouldUpdateTransmuxerTimestampOffset_(timestampOffset2) {
    if (timestampOffset2 === null) {
      return false;
    }
    if (this.loaderType_ === "main" && timestampOffset2 !== this.sourceUpdater_.videoTimestampOffset()) {
      return true;
    }
    if (!this.audioDisabled_ && timestampOffset2 !== this.sourceUpdater_.audioTimestampOffset()) {
      return true;
    }
    return false;
  };
  _proto.trueSegmentStart_ = function trueSegmentStart_(_ref9) {
    var currentStart = _ref9.currentStart, playlist = _ref9.playlist, mediaIndex = _ref9.mediaIndex, firstVideoFrameTimeForData = _ref9.firstVideoFrameTimeForData, currentVideoTimestampOffset = _ref9.currentVideoTimestampOffset, useVideoTimingInfo = _ref9.useVideoTimingInfo, videoTimingInfo = _ref9.videoTimingInfo, audioTimingInfo = _ref9.audioTimingInfo;
    if (typeof currentStart !== "undefined") {
      return currentStart;
    }
    if (!useVideoTimingInfo) {
      return audioTimingInfo.start;
    }
    var previousSegment = playlist.segments[mediaIndex - 1];
    if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === "undefined" || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) {
      return firstVideoFrameTimeForData;
    }
    return videoTimingInfo.start;
  };
  _proto.waitForAppendsToComplete_ = function waitForAppendsToComplete_(segmentInfo) {
    var trackInfo = this.getCurrentMediaInfo_(segmentInfo);
    if (!trackInfo) {
      this.error({
        message: "No starting media returned, likely due to an unsupported media format.",
        blacklistDuration: Infinity
      });
      this.trigger("error");
      return;
    }
    var hasAudio = trackInfo.hasAudio, hasVideo = trackInfo.hasVideo, isMuxed3 = trackInfo.isMuxed;
    var waitForVideo = this.loaderType_ === "main" && hasVideo;
    var waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed3;
    segmentInfo.waitingOnAppends = 0;
    if (!segmentInfo.hasAppendedData_) {
      if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === "number") {
        this.isPendingTimestampOffset_ = true;
      }
      segmentInfo.timingInfo = {
        start: 0
      };
      segmentInfo.waitingOnAppends++;
      if (!this.isPendingTimestampOffset_) {
        this.updateSourceBufferTimestampOffset_(segmentInfo);
        this.processMetadataQueue_();
      }
      this.checkAppendsDone_(segmentInfo);
      return;
    }
    if (waitForVideo) {
      segmentInfo.waitingOnAppends++;
    }
    if (waitForAudio) {
      segmentInfo.waitingOnAppends++;
    }
    if (waitForVideo) {
      this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
    }
    if (waitForAudio) {
      this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
    }
  };
  _proto.checkAppendsDone_ = function checkAppendsDone_(segmentInfo) {
    if (this.checkForAbort_(segmentInfo.requestId)) {
      return;
    }
    segmentInfo.waitingOnAppends--;
    if (segmentInfo.waitingOnAppends === 0) {
      this.handleAppendsDone_();
    }
  };
  _proto.checkForIllegalMediaSwitch = function checkForIllegalMediaSwitch(trackInfo) {
    var illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
    if (illegalMediaSwitchError) {
      this.error({
        message: illegalMediaSwitchError,
        blacklistDuration: Infinity
      });
      this.trigger("error");
      return true;
    }
    return false;
  };
  _proto.updateSourceBufferTimestampOffset_ = function updateSourceBufferTimestampOffset_(segmentInfo) {
    if (segmentInfo.timestampOffset === null || // we don't yet have the start for whatever media type (video or audio) has
    // priority, timing-wise, so we must wait
    typeof segmentInfo.timingInfo.start !== "number" || // already updated the timestamp offset for this segment
    segmentInfo.changedTimestampOffset || // the alt audio loader should not be responsible for setting the timestamp offset
    this.loaderType_ !== "main") {
      return;
    }
    var didChange = false;
    segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
      videoTimingInfo: segmentInfo.segment.videoTimingInfo,
      audioTimingInfo: segmentInfo.segment.audioTimingInfo,
      timingInfo: segmentInfo.timingInfo
    });
    segmentInfo.changedTimestampOffset = true;
    if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
      this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
      didChange = true;
    }
    if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
      this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
      didChange = true;
    }
    if (didChange) {
      this.trigger("timestampoffset");
    }
  };
  _proto.getSegmentStartTimeForTimestampOffsetCalculation_ = function getSegmentStartTimeForTimestampOffsetCalculation_(_ref10) {
    var videoTimingInfo = _ref10.videoTimingInfo, audioTimingInfo = _ref10.audioTimingInfo, timingInfo = _ref10.timingInfo;
    if (!this.useDtsForTimestampOffset_) {
      return timingInfo.start;
    }
    if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === "number") {
      return videoTimingInfo.transmuxedDecodeStart;
    }
    if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === "number") {
      return audioTimingInfo.transmuxedDecodeStart;
    }
    return timingInfo.start;
  };
  _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_(segmentInfo) {
    segmentInfo.timingInfo = segmentInfo.timingInfo || {};
    var trackInfo = this.getMediaInfo_();
    var useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
    var prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
    if (!prioritizedTimingInfo) {
      return;
    }
    segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === "number" ? (
      // End time may not exist in a case where we aren't parsing the full segment (one
      // current example is the case of fmp4), so use the rough duration to calculate an
      // end time.
      prioritizedTimingInfo.end
    ) : prioritizedTimingInfo.start + segmentInfo.duration;
  };
  _proto.handleAppendsDone_ = function handleAppendsDone_() {
    if (this.pendingSegment_) {
      this.trigger("appendsdone");
    }
    if (!this.pendingSegment_) {
      this.state = "READY";
      if (!this.paused()) {
        this.monitorBuffer_();
      }
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.updateTimingInfoEnd_(segmentInfo);
    if (this.shouldSaveSegmentTimingInfo_) {
      this.syncController_.saveSegmentTimingInfo({
        segmentInfo,
        shouldSaveTimelineMapping: this.loaderType_ === "main"
      });
    }
    var segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
    if (segmentDurationMessage) {
      if (segmentDurationMessage.severity === "warn") {
        videojs.log.warn(segmentDurationMessage.message);
      } else {
        this.logger_(segmentDurationMessage.message);
      }
    }
    this.recordThroughput_(segmentInfo);
    this.pendingSegment_ = null;
    this.state = "READY";
    if (segmentInfo.isSyncRequest) {
      this.trigger("syncinfoupdate");
      if (!segmentInfo.hasAppendedData_) {
        this.logger_("Throwing away un-appended sync request " + segmentInfoString(segmentInfo));
        return;
      }
    }
    this.logger_("Appended " + segmentInfoString(segmentInfo));
    this.addSegmentMetadataCue_(segmentInfo);
    this.fetchAtBuffer_ = true;
    if (this.currentTimeline_ !== segmentInfo.timeline) {
      this.timelineChangeController_.lastTimelineChange({
        type: this.loaderType_,
        from: this.currentTimeline_,
        to: segmentInfo.timeline
      });
      if (this.loaderType_ === "main" && !this.audioDisabled_) {
        this.timelineChangeController_.lastTimelineChange({
          type: "audio",
          from: this.currentTimeline_,
          to: segmentInfo.timeline
        });
      }
    }
    this.currentTimeline_ = segmentInfo.timeline;
    this.trigger("syncinfoupdate");
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
    var badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
    if (badSegmentGuess || badPartGuess) {
      this.logger_("bad " + (badSegmentGuess ? "segment" : "part") + " " + segmentInfoString(segmentInfo));
      this.resetEverything();
      return;
    }
    var isWalkingForward = this.mediaIndex !== null;
    if (isWalkingForward) {
      this.trigger("bandwidthupdate");
    }
    this.trigger("progress");
    this.mediaIndex = segmentInfo.mediaIndex;
    this.partIndex = segmentInfo.partIndex;
    if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) {
      this.endOfStream();
    }
    this.trigger("appended");
    if (segmentInfo.hasAppendedData_) {
      this.mediaAppends++;
    }
    if (!this.paused()) {
      this.monitorBuffer_();
    }
  };
  _proto.recordThroughput_ = function recordThroughput_(segmentInfo) {
    if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
      this.logger_("Ignoring segment's throughput because its duration of " + segmentInfo.duration + (" is less than the min to record " + MIN_SEGMENT_DURATION_TO_SAVE_STATS));
      return;
    }
    var rate = this.throughput.rate;
    var segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
    var segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1e3);
    this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
  };
  _proto.addSegmentMetadataCue_ = function addSegmentMetadataCue_(segmentInfo) {
    if (!this.segmentMetadataTrack_) {
      return;
    }
    var segment = segmentInfo.segment;
    var start3 = segment.start;
    var end2 = segment.end;
    if (!finite(start3) || !finite(end2)) {
      return;
    }
    removeCuesFromTrack(start3, end2, this.segmentMetadataTrack_);
    var Cue = window_1.WebKitDataCue || window_1.VTTCue;
    var value = {
      custom: segment.custom,
      dateTimeObject: segment.dateTimeObject,
      dateTimeString: segment.dateTimeString,
      bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
      resolution: segmentInfo.playlist.attributes.RESOLUTION,
      codecs: segmentInfo.playlist.attributes.CODECS,
      byteLength: segmentInfo.byteLength,
      uri: segmentInfo.uri,
      timeline: segmentInfo.timeline,
      playlist: segmentInfo.playlist.id,
      start: start3,
      end: end2
    };
    var data = JSON.stringify(value);
    var cue = new Cue(start3, end2, data);
    cue.value = value;
    this.segmentMetadataTrack_.addCue(cue);
  };
  return SegmentLoader2;
}(videojs.EventTarget);
function noop$3() {
}
var toTitleCase2 = function toTitleCase3(string) {
  if (typeof string !== "string") {
    return string;
  }
  return string.replace(/./, function(w2) {
    return w2.toUpperCase();
  });
};
var bufferTypes = ["video", "audio"];
var _updating = function updating(type2, sourceUpdater) {
  var sourceBuffer = sourceUpdater[type2 + "Buffer"];
  return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type2];
};
var nextQueueIndexOfType = function nextQueueIndexOfType2(type2, queue) {
  for (var i = 0; i < queue.length; i++) {
    var queueEntry = queue[i];
    if (queueEntry.type === "mediaSource") {
      return null;
    }
    if (queueEntry.type === type2) {
      return i;
    }
  }
  return null;
};
var shiftQueue = function shiftQueue2(type2, sourceUpdater) {
  if (sourceUpdater.queue.length === 0) {
    return;
  }
  var queueIndex = 0;
  var queueEntry = sourceUpdater.queue[queueIndex];
  if (queueEntry.type === "mediaSource") {
    if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== "closed") {
      sourceUpdater.queue.shift();
      queueEntry.action(sourceUpdater);
      if (queueEntry.doneFn) {
        queueEntry.doneFn();
      }
      shiftQueue2("audio", sourceUpdater);
      shiftQueue2("video", sourceUpdater);
    }
    return;
  }
  if (type2 === "mediaSource") {
    return;
  }
  if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === "closed" || _updating(type2, sourceUpdater)) {
    return;
  }
  if (queueEntry.type !== type2) {
    queueIndex = nextQueueIndexOfType(type2, sourceUpdater.queue);
    if (queueIndex === null) {
      return;
    }
    queueEntry = sourceUpdater.queue[queueIndex];
  }
  sourceUpdater.queue.splice(queueIndex, 1);
  sourceUpdater.queuePending[type2] = queueEntry;
  queueEntry.action(type2, sourceUpdater);
  if (!queueEntry.doneFn) {
    sourceUpdater.queuePending[type2] = null;
    shiftQueue2(type2, sourceUpdater);
    return;
  }
};
var cleanupBuffer = function cleanupBuffer2(type2, sourceUpdater) {
  var buffer = sourceUpdater[type2 + "Buffer"];
  var titleType = toTitleCase2(type2);
  if (!buffer) {
    return;
  }
  buffer.removeEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]);
  buffer.removeEventListener("error", sourceUpdater["on" + titleType + "Error_"]);
  sourceUpdater.codecs[type2] = null;
  sourceUpdater[type2 + "Buffer"] = null;
};
var inSourceBuffers = function inSourceBuffers2(mediaSource, sourceBuffer) {
  return mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
};
var actions = {
  appendBuffer: function appendBuffer(bytes, segmentInfo, onError2) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Appending segment " + segmentInfo.mediaIndex + "'s " + bytes.length + " bytes to " + type2 + "Buffer");
      try {
        sourceBuffer.appendBuffer(bytes);
      } catch (e2) {
        sourceUpdater.logger_("Error with code " + e2.code + " " + (e2.code === QUOTA_EXCEEDED_ERR ? "(QUOTA_EXCEEDED_ERR) " : "") + ("when appending segment " + segmentInfo.mediaIndex + " to " + type2 + "Buffer"));
        sourceUpdater.queuePending[type2] = null;
        onError2(e2);
      }
    };
  },
  remove: function remove(start3, end2) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Removing " + start3 + " to " + end2 + " from " + type2 + "Buffer");
      try {
        sourceBuffer.remove(start3, end2);
      } catch (e2) {
        sourceUpdater.logger_("Remove " + start3 + " to " + end2 + " from " + type2 + "Buffer failed");
      }
    };
  },
  timestampOffset: function timestampOffset(offset3) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Setting " + type2 + "timestampOffset to " + offset3);
      sourceBuffer.timestampOffset = offset3;
    };
  },
  callback: function callback(_callback) {
    return function(type2, sourceUpdater) {
      _callback();
    };
  },
  endOfStream: function endOfStream(error) {
    return function(sourceUpdater) {
      if (sourceUpdater.mediaSource.readyState !== "open") {
        return;
      }
      sourceUpdater.logger_("Calling mediaSource endOfStream(" + (error || "") + ")");
      try {
        sourceUpdater.mediaSource.endOfStream(error);
      } catch (e2) {
        videojs.log.warn("Failed to call media source endOfStream", e2);
      }
    };
  },
  duration: function duration3(_duration) {
    return function(sourceUpdater) {
      sourceUpdater.logger_("Setting mediaSource duration to " + _duration);
      try {
        sourceUpdater.mediaSource.duration = _duration;
      } catch (e2) {
        videojs.log.warn("Failed to set media source duration", e2);
      }
    };
  },
  abort: function abort() {
    return function(type2, sourceUpdater) {
      if (sourceUpdater.mediaSource.readyState !== "open") {
        return;
      }
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("calling abort on " + type2 + "Buffer");
      try {
        sourceBuffer.abort();
      } catch (e2) {
        videojs.log.warn("Failed to abort on " + type2 + "Buffer", e2);
      }
    };
  },
  addSourceBuffer: function addSourceBuffer(type2, codec) {
    return function(sourceUpdater) {
      var titleType = toTitleCase2(type2);
      var mime = getMimeForCodec(codec);
      sourceUpdater.logger_("Adding " + type2 + "Buffer with codec " + codec + " to mediaSource");
      var sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
      sourceBuffer.addEventListener("updateend", sourceUpdater["on" + titleType + "UpdateEnd_"]);
      sourceBuffer.addEventListener("error", sourceUpdater["on" + titleType + "Error_"]);
      sourceUpdater.codecs[type2] = codec;
      sourceUpdater[type2 + "Buffer"] = sourceBuffer;
    };
  },
  removeSourceBuffer: function removeSourceBuffer(type2) {
    return function(sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      cleanupBuffer(type2, sourceUpdater);
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      sourceUpdater.logger_("Removing " + type2 + "Buffer with codec " + sourceUpdater.codecs[type2] + " from mediaSource");
      try {
        sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
      } catch (e2) {
        videojs.log.warn("Failed to removeSourceBuffer " + type2 + "Buffer", e2);
      }
    };
  },
  changeType: function changeType(codec) {
    return function(type2, sourceUpdater) {
      var sourceBuffer = sourceUpdater[type2 + "Buffer"];
      var mime = getMimeForCodec(codec);
      if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) {
        return;
      }
      if (sourceUpdater.codecs[type2] === codec) {
        return;
      }
      sourceUpdater.logger_("changing " + type2 + "Buffer codec from " + sourceUpdater.codecs[type2] + " to " + codec);
      sourceBuffer.changeType(mime);
      sourceUpdater.codecs[type2] = codec;
    };
  }
};
var pushQueue = function pushQueue2(_ref) {
  var type2 = _ref.type, sourceUpdater = _ref.sourceUpdater, action = _ref.action, doneFn = _ref.doneFn, name = _ref.name;
  sourceUpdater.queue.push({
    type: type2,
    action,
    doneFn,
    name
  });
  shiftQueue(type2, sourceUpdater);
};
var onUpdateend = function onUpdateend2(type2, sourceUpdater) {
  return function(e2) {
    if (sourceUpdater.queuePending[type2]) {
      var doneFn = sourceUpdater.queuePending[type2].doneFn;
      sourceUpdater.queuePending[type2] = null;
      if (doneFn) {
        doneFn(sourceUpdater[type2 + "Error_"]);
      }
    }
    shiftQueue(type2, sourceUpdater);
  };
};
var SourceUpdater = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(SourceUpdater2, _videojs$EventTarget);
  function SourceUpdater2(mediaSource) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.mediaSource = mediaSource;
    _this.sourceopenListener_ = function() {
      return shiftQueue("mediaSource", _assertThisInitialized(_this));
    };
    _this.mediaSource.addEventListener("sourceopen", _this.sourceopenListener_);
    _this.logger_ = logger("SourceUpdater");
    _this.audioTimestampOffset_ = 0;
    _this.videoTimestampOffset_ = 0;
    _this.queue = [];
    _this.queuePending = {
      audio: null,
      video: null
    };
    _this.delayedAudioAppendQueue_ = [];
    _this.videoAppendQueued_ = false;
    _this.codecs = {};
    _this.onVideoUpdateEnd_ = onUpdateend("video", _assertThisInitialized(_this));
    _this.onAudioUpdateEnd_ = onUpdateend("audio", _assertThisInitialized(_this));
    _this.onVideoError_ = function(e2) {
      _this.videoError_ = e2;
    };
    _this.onAudioError_ = function(e2) {
      _this.audioError_ = e2;
    };
    _this.createdSourceBuffers_ = false;
    _this.initializedEme_ = false;
    _this.triggeredReady_ = false;
    return _this;
  }
  var _proto = SourceUpdater2.prototype;
  _proto.initializedEme = function initializedEme() {
    this.initializedEme_ = true;
    this.triggerReady();
  };
  _proto.hasCreatedSourceBuffers = function hasCreatedSourceBuffers() {
    return this.createdSourceBuffers_;
  };
  _proto.hasInitializedAnyEme = function hasInitializedAnyEme() {
    return this.initializedEme_;
  };
  _proto.ready = function ready() {
    return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
  };
  _proto.createSourceBuffers = function createSourceBuffers(codecs) {
    if (this.hasCreatedSourceBuffers()) {
      return;
    }
    this.addOrChangeSourceBuffers(codecs);
    this.createdSourceBuffers_ = true;
    this.trigger("createdsourcebuffers");
    this.triggerReady();
  };
  _proto.triggerReady = function triggerReady() {
    if (this.ready() && !this.triggeredReady_) {
      this.triggeredReady_ = true;
      this.trigger("ready");
    }
  };
  _proto.addSourceBuffer = function addSourceBuffer2(type2, codec) {
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.addSourceBuffer(type2, codec),
      name: "addSourceBuffer"
    });
  };
  _proto.abort = function abort2(type2) {
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.abort(type2),
      name: "abort"
    });
  };
  _proto.removeSourceBuffer = function removeSourceBuffer2(type2) {
    if (!this.canRemoveSourceBuffer()) {
      videojs.log.error("removeSourceBuffer is not supported!");
      return;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.removeSourceBuffer(type2),
      name: "removeSourceBuffer"
    });
  };
  _proto.canRemoveSourceBuffer = function canRemoveSourceBuffer() {
    return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && window_1.MediaSource && window_1.MediaSource.prototype && typeof window_1.MediaSource.prototype.removeSourceBuffer === "function";
  };
  SourceUpdater2.canChangeType = function canChangeType() {
    return window_1.SourceBuffer && window_1.SourceBuffer.prototype && typeof window_1.SourceBuffer.prototype.changeType === "function";
  };
  _proto.canChangeType = function canChangeType() {
    return this.constructor.canChangeType();
  };
  _proto.changeType = function changeType2(type2, codec) {
    if (!this.canChangeType()) {
      videojs.log.error("changeType is not supported!");
      return;
    }
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.changeType(codec),
      name: "changeType"
    });
  };
  _proto.addOrChangeSourceBuffers = function addOrChangeSourceBuffers(codecs) {
    var _this2 = this;
    if (!codecs || typeof codecs !== "object" || Object.keys(codecs).length === 0) {
      throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
    }
    Object.keys(codecs).forEach(function(type2) {
      var codec = codecs[type2];
      if (!_this2.hasCreatedSourceBuffers()) {
        return _this2.addSourceBuffer(type2, codec);
      }
      if (_this2.canChangeType()) {
        _this2.changeType(type2, codec);
      }
    });
  };
  _proto.appendBuffer = function appendBuffer2(options, doneFn) {
    var _this3 = this;
    var segmentInfo = options.segmentInfo, type2 = options.type, bytes = options.bytes;
    this.processedAppend_ = true;
    if (type2 === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
      this.delayedAudioAppendQueue_.push([options, doneFn]);
      this.logger_("delayed audio append of " + bytes.length + " until video append");
      return;
    }
    var onError2 = doneFn;
    pushQueue({
      type: type2,
      sourceUpdater: this,
      action: actions.appendBuffer(bytes, segmentInfo || {
        mediaIndex: -1
      }, onError2),
      doneFn,
      name: "appendBuffer"
    });
    if (type2 === "video") {
      this.videoAppendQueued_ = true;
      if (!this.delayedAudioAppendQueue_.length) {
        return;
      }
      var queue = this.delayedAudioAppendQueue_.slice();
      this.logger_("queuing delayed audio " + queue.length + " appendBuffers");
      this.delayedAudioAppendQueue_.length = 0;
      queue.forEach(function(que) {
        _this3.appendBuffer.apply(_this3, que);
      });
    }
  };
  _proto.audioBuffered = function audioBuffered() {
    if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) {
      return videojs.createTimeRange();
    }
    return this.audioBuffer.buffered ? this.audioBuffer.buffered : videojs.createTimeRange();
  };
  _proto.videoBuffered = function videoBuffered() {
    if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) {
      return videojs.createTimeRange();
    }
    return this.videoBuffer.buffered ? this.videoBuffer.buffered : videojs.createTimeRange();
  };
  _proto.buffered = function buffered() {
    var video2 = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
    var audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
    if (audio && !video2) {
      return this.audioBuffered();
    }
    if (video2 && !audio) {
      return this.videoBuffered();
    }
    return bufferIntersection(this.audioBuffered(), this.videoBuffered());
  };
  _proto.setDuration = function setDuration(duration5, doneFn) {
    if (doneFn === void 0) {
      doneFn = noop$3;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.duration(duration5),
      name: "duration",
      doneFn
    });
  };
  _proto.endOfStream = function endOfStream2(error, doneFn) {
    if (error === void 0) {
      error = null;
    }
    if (doneFn === void 0) {
      doneFn = noop$3;
    }
    if (typeof error !== "string") {
      error = void 0;
    }
    pushQueue({
      type: "mediaSource",
      sourceUpdater: this,
      action: actions.endOfStream(error),
      name: "endOfStream",
      doneFn
    });
  };
  _proto.removeAudio = function removeAudio(start3, end2, done) {
    if (done === void 0) {
      done = noop$3;
    }
    if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
      done();
      return;
    }
    pushQueue({
      type: "audio",
      sourceUpdater: this,
      action: actions.remove(start3, end2),
      doneFn: done,
      name: "remove"
    });
  };
  _proto.removeVideo = function removeVideo(start3, end2, done) {
    if (done === void 0) {
      done = noop$3;
    }
    if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
      done();
      return;
    }
    pushQueue({
      type: "video",
      sourceUpdater: this,
      action: actions.remove(start3, end2),
      doneFn: done,
      name: "remove"
    });
  };
  _proto.updating = function updating2() {
    if (_updating("audio", this) || _updating("video", this)) {
      return true;
    }
    return false;
  };
  _proto.audioTimestampOffset = function audioTimestampOffset(offset3) {
    if (typeof offset3 !== "undefined" && this.audioBuffer && // no point in updating if it's the same
    this.audioTimestampOffset_ !== offset3) {
      pushQueue({
        type: "audio",
        sourceUpdater: this,
        action: actions.timestampOffset(offset3),
        name: "timestampOffset"
      });
      this.audioTimestampOffset_ = offset3;
    }
    return this.audioTimestampOffset_;
  };
  _proto.videoTimestampOffset = function videoTimestampOffset(offset3) {
    if (typeof offset3 !== "undefined" && this.videoBuffer && // no point in updating if it's the same
    this.videoTimestampOffset !== offset3) {
      pushQueue({
        type: "video",
        sourceUpdater: this,
        action: actions.timestampOffset(offset3),
        name: "timestampOffset"
      });
      this.videoTimestampOffset_ = offset3;
    }
    return this.videoTimestampOffset_;
  };
  _proto.audioQueueCallback = function audioQueueCallback(callback2) {
    if (!this.audioBuffer) {
      return;
    }
    pushQueue({
      type: "audio",
      sourceUpdater: this,
      action: actions.callback(callback2),
      name: "callback"
    });
  };
  _proto.videoQueueCallback = function videoQueueCallback(callback2) {
    if (!this.videoBuffer) {
      return;
    }
    pushQueue({
      type: "video",
      sourceUpdater: this,
      action: actions.callback(callback2),
      name: "callback"
    });
  };
  _proto.dispose = function dispose() {
    var _this4 = this;
    this.trigger("dispose");
    bufferTypes.forEach(function(type2) {
      _this4.abort(type2);
      if (_this4.canRemoveSourceBuffer()) {
        _this4.removeSourceBuffer(type2);
      } else {
        _this4[type2 + "QueueCallback"](function() {
          return cleanupBuffer(type2, _this4);
        });
      }
    });
    this.videoAppendQueued_ = false;
    this.delayedAudioAppendQueue_.length = 0;
    if (this.sourceopenListener_) {
      this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_);
    }
    this.off();
  };
  return SourceUpdater2;
}(videojs.EventTarget);
var uint8ToUtf8 = function uint8ToUtf82(uintArray) {
  return decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
};
var VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map(function(_char3) {
  return _char3.charCodeAt(0);
}));
var VTTSegmentLoader = /* @__PURE__ */ function(_SegmentLoader) {
  _inheritsLoose(VTTSegmentLoader2, _SegmentLoader);
  function VTTSegmentLoader2(settings, options) {
    var _this;
    if (options === void 0) {
      options = {};
    }
    _this = _SegmentLoader.call(this, settings, options) || this;
    _this.mediaSource_ = null;
    _this.subtitlesTrack_ = null;
    _this.loaderType_ = "subtitle";
    _this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;
    _this.shouldSaveSegmentTimingInfo_ = false;
    return _this;
  }
  var _proto = VTTSegmentLoader2.prototype;
  _proto.createTransmuxer_ = function createTransmuxer_() {
    return null;
  };
  _proto.buffered_ = function buffered_() {
    if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) {
      return videojs.createTimeRanges();
    }
    var cues = this.subtitlesTrack_.cues;
    var start3 = cues[0].startTime;
    var end2 = cues[cues.length - 1].startTime;
    return videojs.createTimeRanges([[start3, end2]]);
  };
  _proto.initSegmentForMap = function initSegmentForMap(map, set4) {
    if (set4 === void 0) {
      set4 = false;
    }
    if (!map) {
      return null;
    }
    var id2 = initSegmentId(map);
    var storedMap = this.initSegments_[id2];
    if (set4 && !storedMap && map.bytes) {
      var combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;
      var combinedSegment = new Uint8Array(combinedByteLength);
      combinedSegment.set(map.bytes);
      combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);
      this.initSegments_[id2] = storedMap = {
        resolvedUri: map.resolvedUri,
        byterange: map.byterange,
        bytes: combinedSegment
      };
    }
    return storedMap || map;
  };
  _proto.couldBeginLoading_ = function couldBeginLoading_() {
    return this.playlist_ && this.subtitlesTrack_ && !this.paused();
  };
  _proto.init_ = function init_() {
    this.state = "READY";
    this.resetEverything();
    return this.monitorBuffer_();
  };
  _proto.track = function track(_track) {
    if (typeof _track === "undefined") {
      return this.subtitlesTrack_;
    }
    this.subtitlesTrack_ = _track;
    if (this.state === "INIT" && this.couldBeginLoading_()) {
      this.init_();
    }
    return this.subtitlesTrack_;
  };
  _proto.remove = function remove2(start3, end2) {
    removeCuesFromTrack(start3, end2, this.subtitlesTrack_);
  };
  _proto.fillBuffer_ = function fillBuffer_() {
    var _this2 = this;
    var segmentInfo = this.chooseNextRequest_();
    if (!segmentInfo) {
      return;
    }
    if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
      var checkTimestampOffset = function checkTimestampOffset2() {
        _this2.state = "READY";
        if (!_this2.paused()) {
          _this2.monitorBuffer_();
        }
      };
      this.syncController_.one("timestampoffset", checkTimestampOffset);
      this.state = "WAITING_ON_TIMELINE";
      return;
    }
    this.loadSegment_(segmentInfo);
  };
  _proto.timestampOffsetForSegment_ = function timestampOffsetForSegment_() {
    return null;
  };
  _proto.chooseNextRequest_ = function chooseNextRequest_() {
    return this.skipEmptySegments_(_SegmentLoader.prototype.chooseNextRequest_.call(this));
  };
  _proto.skipEmptySegments_ = function skipEmptySegments_(segmentInfo) {
    while (segmentInfo && segmentInfo.segment.empty) {
      if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
        segmentInfo = null;
        break;
      }
      segmentInfo = this.generateSegmentInfo_({
        playlist: segmentInfo.playlist,
        mediaIndex: segmentInfo.mediaIndex + 1,
        startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
        isSyncRequest: segmentInfo.isSyncRequest
      });
    }
    return segmentInfo;
  };
  _proto.stopForError = function stopForError(error) {
    this.error(error);
    this.state = "READY";
    this.pause();
    this.trigger("error");
  };
  _proto.segmentRequestFinished_ = function segmentRequestFinished_(error, simpleSegment, result) {
    var _this3 = this;
    if (!this.subtitlesTrack_) {
      this.state = "READY";
      return;
    }
    this.saveTransferStats_(simpleSegment.stats);
    if (!this.pendingSegment_) {
      this.state = "READY";
      this.mediaRequestsAborted += 1;
      return;
    }
    if (error) {
      if (error.code === REQUEST_ERRORS.TIMEOUT) {
        this.handleTimeout_();
      }
      if (error.code === REQUEST_ERRORS.ABORTED) {
        this.mediaRequestsAborted += 1;
      } else {
        this.mediaRequestsErrored += 1;
      }
      this.stopForError(error);
      return;
    }
    var segmentInfo = this.pendingSegment_;
    this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
    if (simpleSegment.key) {
      this.segmentKey(simpleSegment.key, true);
    }
    this.state = "APPENDING";
    this.trigger("appending");
    var segment = segmentInfo.segment;
    if (segment.map) {
      segment.map.bytes = simpleSegment.map.bytes;
    }
    segmentInfo.bytes = simpleSegment.bytes;
    if (typeof window_1.WebVTT !== "function" && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) {
      var loadHandler;
      var errorHandler = function errorHandler2() {
        _this3.subtitlesTrack_.tech_.off("vttjsloaded", loadHandler);
        _this3.stopForError({
          message: "Error loading vtt.js"
        });
        return;
      };
      loadHandler = function loadHandler2() {
        _this3.subtitlesTrack_.tech_.off("vttjserror", errorHandler);
        _this3.segmentRequestFinished_(error, simpleSegment, result);
      };
      this.state = "WAITING_ON_VTTJS";
      this.subtitlesTrack_.tech_.one("vttjsloaded", loadHandler);
      this.subtitlesTrack_.tech_.one("vttjserror", errorHandler);
      return;
    }
    segment.requested = true;
    try {
      this.parseVTTCues_(segmentInfo);
    } catch (e2) {
      this.stopForError({
        message: e2.message
      });
      return;
    }
    this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
    if (segmentInfo.cues.length) {
      segmentInfo.timingInfo = {
        start: segmentInfo.cues[0].startTime,
        end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
      };
    } else {
      segmentInfo.timingInfo = {
        start: segmentInfo.startOfSegment,
        end: segmentInfo.startOfSegment + segmentInfo.duration
      };
    }
    if (segmentInfo.isSyncRequest) {
      this.trigger("syncinfoupdate");
      this.pendingSegment_ = null;
      this.state = "READY";
      return;
    }
    segmentInfo.byteLength = segmentInfo.bytes.byteLength;
    this.mediaSecondsLoaded += segment.duration;
    segmentInfo.cues.forEach(function(cue) {
      _this3.subtitlesTrack_.addCue(_this3.featuresNativeTextTracks_ ? new window_1.VTTCue(cue.startTime, cue.endTime, cue.text) : cue);
    });
    removeDuplicateCuesFromTrack(this.subtitlesTrack_);
    this.handleAppendsDone_();
  };
  _proto.handleData_ = function handleData_3() {
  };
  _proto.updateTimingInfoEnd_ = function updateTimingInfoEnd_() {
  };
  _proto.parseVTTCues_ = function parseVTTCues_(segmentInfo) {
    var decoder;
    var decodeBytesToString = false;
    if (typeof window_1.TextDecoder === "function") {
      decoder = new window_1.TextDecoder("utf8");
    } else {
      decoder = window_1.WebVTT.StringDecoder();
      decodeBytesToString = true;
    }
    var parser2 = new window_1.WebVTT.Parser(window_1, window_1.vttjs, decoder);
    segmentInfo.cues = [];
    segmentInfo.timestampmap = {
      MPEGTS: 0,
      LOCAL: 0
    };
    parser2.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
    parser2.ontimestampmap = function(map) {
      segmentInfo.timestampmap = map;
    };
    parser2.onparsingerror = function(error) {
      videojs.log.warn("Error encountered when parsing cues: " + error.message);
    };
    if (segmentInfo.segment.map) {
      var mapData = segmentInfo.segment.map.bytes;
      if (decodeBytesToString) {
        mapData = uint8ToUtf8(mapData);
      }
      parser2.parse(mapData);
    }
    var segmentData = segmentInfo.bytes;
    if (decodeBytesToString) {
      segmentData = uint8ToUtf8(segmentData);
    }
    parser2.parse(segmentData);
    parser2.flush();
  };
  _proto.updateTimeMapping_ = function updateTimeMapping_(segmentInfo, mappingObj, playlist) {
    var segment = segmentInfo.segment;
    if (!mappingObj) {
      return;
    }
    if (!segmentInfo.cues.length) {
      segment.empty = true;
      return;
    }
    var timestampmap = segmentInfo.timestampmap;
    var diff = timestampmap.MPEGTS / clock.ONE_SECOND_IN_TS - timestampmap.LOCAL + mappingObj.mapping;
    segmentInfo.cues.forEach(function(cue) {
      cue.startTime += diff;
      cue.endTime += diff;
    });
    if (!playlist.syncInfo) {
      var firstStart = segmentInfo.cues[0].startTime;
      var lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
      playlist.syncInfo = {
        mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
        time: Math.min(firstStart, lastStart - segment.duration)
      };
    }
  };
  return VTTSegmentLoader2;
}(SegmentLoader);
var findAdCue = function findAdCue2(track, mediaTime) {
  var cues = track.cues;
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];
    if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) {
      return cue;
    }
  }
  return null;
};
var updateAdCues = function updateAdCues2(media, track, offset3) {
  if (offset3 === void 0) {
    offset3 = 0;
  }
  if (!media.segments) {
    return;
  }
  var mediaTime = offset3;
  var cue;
  for (var i = 0; i < media.segments.length; i++) {
    var segment = media.segments[i];
    if (!cue) {
      cue = findAdCue(track, mediaTime + segment.duration / 2);
    }
    if (cue) {
      if ("cueIn" in segment) {
        cue.endTime = mediaTime;
        cue.adEndTime = mediaTime;
        mediaTime += segment.duration;
        cue = null;
        continue;
      }
      if (mediaTime < cue.endTime) {
        mediaTime += segment.duration;
        continue;
      }
      cue.endTime += segment.duration;
    } else {
      if ("cueOut" in segment) {
        cue = new window_1.VTTCue(mediaTime, mediaTime + segment.duration, segment.cueOut);
        cue.adStartTime = mediaTime;
        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
        track.addCue(cue);
      }
      if ("cueOutCont" in segment) {
        var _segment$cueOutCont$s = segment.cueOutCont.split("/").map(parseFloat), adOffset = _segment$cueOutCont$s[0], adTotal = _segment$cueOutCont$s[1];
        cue = new window_1.VTTCue(mediaTime, mediaTime + segment.duration, "");
        cue.adStartTime = mediaTime - adOffset;
        cue.adEndTime = cue.adStartTime + adTotal;
        track.addCue(cue);
      }
    }
    mediaTime += segment.duration;
  }
};
var MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
var syncPointStrategies = [
  // Stategy "VOD": Handle the VOD-case where the sync-point is *always*
  //                the equivalence display-time 0 === segment-index 0
  {
    name: "VOD",
    run: function run(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (duration5 !== Infinity) {
        var syncPoint = {
          time: 0,
          segmentIndex: 0,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  },
  // Stategy "ProgramDateTime": We have a program-date-time tag in this playlist
  {
    name: "ProgramDateTime",
    run: function run2(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (!Object.keys(syncController.timelineToDatetimeMappings).length) {
        return null;
      }
      var syncPoint = null;
      var lastDistance = null;
      var partsAndSegments = getPartsAndSegments(playlist);
      currentTime = currentTime || 0;
      for (var i = 0; i < partsAndSegments.length; i++) {
        var index2 = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        var partAndSegment = partsAndSegments[index2];
        var segment = partAndSegment.segment;
        var datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
        if (!datetimeMapping || !segment.dateTimeObject) {
          continue;
        }
        var segmentTime = segment.dateTimeObject.getTime() / 1e3;
        var start3 = segmentTime + datetimeMapping;
        if (segment.parts && typeof partAndSegment.partIndex === "number") {
          for (var z2 = 0; z2 < partAndSegment.partIndex; z2++) {
            start3 += segment.parts[z2].duration;
          }
        }
        var distance3 = Math.abs(currentTime - start3);
        if (lastDistance !== null && (distance3 === 0 || lastDistance < distance3)) {
          break;
        }
        lastDistance = distance3;
        syncPoint = {
          time: start3,
          segmentIndex: partAndSegment.segmentIndex,
          partIndex: partAndSegment.partIndex
        };
      }
      return syncPoint;
    }
  },
  // Stategy "Segment": We have a known time mapping for a timeline and a
  //                    segment in the current timeline with timing data
  {
    name: "Segment",
    run: function run3(syncController, playlist, duration5, currentTimeline, currentTime) {
      var syncPoint = null;
      var lastDistance = null;
      currentTime = currentTime || 0;
      var partsAndSegments = getPartsAndSegments(playlist);
      for (var i = 0; i < partsAndSegments.length; i++) {
        var index2 = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
        var partAndSegment = partsAndSegments[index2];
        var segment = partAndSegment.segment;
        var start3 = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
        if (segment.timeline === currentTimeline && typeof start3 !== "undefined") {
          var distance3 = Math.abs(currentTime - start3);
          if (lastDistance !== null && lastDistance < distance3) {
            break;
          }
          if (!syncPoint || lastDistance === null || lastDistance >= distance3) {
            lastDistance = distance3;
            syncPoint = {
              time: start3,
              segmentIndex: partAndSegment.segmentIndex,
              partIndex: partAndSegment.partIndex
            };
          }
        }
      }
      return syncPoint;
    }
  },
  // Stategy "Discontinuity": We have a discontinuity with a known
  //                          display-time
  {
    name: "Discontinuity",
    run: function run4(syncController, playlist, duration5, currentTimeline, currentTime) {
      var syncPoint = null;
      currentTime = currentTime || 0;
      if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
        var lastDistance = null;
        for (var i = 0; i < playlist.discontinuityStarts.length; i++) {
          var segmentIndex = playlist.discontinuityStarts[i];
          var discontinuity = playlist.discontinuitySequence + i + 1;
          var discontinuitySync = syncController.discontinuities[discontinuity];
          if (discontinuitySync) {
            var distance3 = Math.abs(currentTime - discontinuitySync.time);
            if (lastDistance !== null && lastDistance < distance3) {
              break;
            }
            if (!syncPoint || lastDistance === null || lastDistance >= distance3) {
              lastDistance = distance3;
              syncPoint = {
                time: discontinuitySync.time,
                segmentIndex,
                partIndex: null
              };
            }
          }
        }
      }
      return syncPoint;
    }
  },
  // Stategy "Playlist": We have a playlist with a known mapping of
  //                     segment index to display time
  {
    name: "Playlist",
    run: function run5(syncController, playlist, duration5, currentTimeline, currentTime) {
      if (playlist.syncInfo) {
        var syncPoint = {
          time: playlist.syncInfo.time,
          segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
          partIndex: null
        };
        return syncPoint;
      }
      return null;
    }
  }
];
var SyncController = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(SyncController2, _videojs$EventTarget);
  function SyncController2(options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.timelines = [];
    _this.discontinuities = [];
    _this.timelineToDatetimeMappings = {};
    _this.logger_ = logger("SyncController");
    return _this;
  }
  var _proto = SyncController2.prototype;
  _proto.getSyncPoint = function getSyncPoint(playlist, duration5, currentTimeline, currentTime) {
    var syncPoints = this.runStrategies_(playlist, duration5, currentTimeline, currentTime);
    if (!syncPoints.length) {
      return null;
    }
    return this.selectSyncPoint_(syncPoints, {
      key: "time",
      value: currentTime
    });
  };
  _proto.getExpiredTime = function getExpiredTime(playlist, duration5) {
    if (!playlist || !playlist.segments) {
      return null;
    }
    var syncPoints = this.runStrategies_(playlist, duration5, playlist.discontinuitySequence, 0);
    if (!syncPoints.length) {
      return null;
    }
    var syncPoint = this.selectSyncPoint_(syncPoints, {
      key: "segmentIndex",
      value: 0
    });
    if (syncPoint.segmentIndex > 0) {
      syncPoint.time *= -1;
    }
    return Math.abs(syncPoint.time + sumDurations({
      defaultDuration: playlist.targetDuration,
      durationList: playlist.segments,
      startIndex: syncPoint.segmentIndex,
      endIndex: 0
    }));
  };
  _proto.runStrategies_ = function runStrategies_(playlist, duration5, currentTimeline, currentTime) {
    var syncPoints = [];
    for (var i = 0; i < syncPointStrategies.length; i++) {
      var strategy = syncPointStrategies[i];
      var syncPoint = strategy.run(this, playlist, duration5, currentTimeline, currentTime);
      if (syncPoint) {
        syncPoint.strategy = strategy.name;
        syncPoints.push({
          strategy: strategy.name,
          syncPoint
        });
      }
    }
    return syncPoints;
  };
  _proto.selectSyncPoint_ = function selectSyncPoint_(syncPoints, target) {
    var bestSyncPoint = syncPoints[0].syncPoint;
    var bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
    var bestStrategy = syncPoints[0].strategy;
    for (var i = 1; i < syncPoints.length; i++) {
      var newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
      if (newDistance < bestDistance) {
        bestDistance = newDistance;
        bestSyncPoint = syncPoints[i].syncPoint;
        bestStrategy = syncPoints[i].strategy;
      }
    }
    this.logger_("syncPoint for [" + target.key + ": " + target.value + "] chosen with strategy" + (" [" + bestStrategy + "]: [time:" + bestSyncPoint.time + ",") + (" segmentIndex:" + bestSyncPoint.segmentIndex) + (typeof bestSyncPoint.partIndex === "number" ? ",partIndex:" + bestSyncPoint.partIndex : "") + "]");
    return bestSyncPoint;
  };
  _proto.saveExpiredSegmentInfo = function saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
    var mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
    if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
      videojs.log.warn("Not saving expired segment info. Media sequence gap " + mediaSequenceDiff + " is too large.");
      return;
    }
    for (var i = mediaSequenceDiff - 1; i >= 0; i--) {
      var lastRemovedSegment = oldPlaylist.segments[i];
      if (lastRemovedSegment && typeof lastRemovedSegment.start !== "undefined") {
        newPlaylist.syncInfo = {
          mediaSequence: oldPlaylist.mediaSequence + i,
          time: lastRemovedSegment.start
        };
        this.logger_("playlist refresh sync: [time:" + newPlaylist.syncInfo.time + "," + (" mediaSequence: " + newPlaylist.syncInfo.mediaSequence + "]"));
        this.trigger("syncinfoupdate");
        break;
      }
    }
  };
  _proto.setDateTimeMappingForStart = function setDateTimeMappingForStart(playlist) {
    this.timelineToDatetimeMappings = {};
    if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
      var firstSegment = playlist.segments[0];
      var playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1e3;
      this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
    }
  };
  _proto.saveSegmentTimingInfo = function saveSegmentTimingInfo(_ref) {
    var segmentInfo = _ref.segmentInfo, shouldSaveTimelineMapping = _ref.shouldSaveTimelineMapping;
    var didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
    var segment = segmentInfo.segment;
    if (didCalculateSegmentTimeMapping) {
      this.saveDiscontinuitySyncInfo_(segmentInfo);
      if (!segmentInfo.playlist.syncInfo) {
        segmentInfo.playlist.syncInfo = {
          mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
          time: segment.start
        };
      }
    }
    var dateTime = segment.dateTimeObject;
    if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) {
      this.timelineToDatetimeMappings[segment.timeline] = -(dateTime.getTime() / 1e3);
    }
  };
  _proto.timestampOffsetForTimeline = function timestampOffsetForTimeline(timeline) {
    if (typeof this.timelines[timeline] === "undefined") {
      return null;
    }
    return this.timelines[timeline].time;
  };
  _proto.mappingForTimeline = function mappingForTimeline(timeline) {
    if (typeof this.timelines[timeline] === "undefined") {
      return null;
    }
    return this.timelines[timeline].mapping;
  };
  _proto.calculateSegmentTimeMapping_ = function calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
    var segment = segmentInfo.segment;
    var part = segmentInfo.part;
    var mappingObj = this.timelines[segmentInfo.timeline];
    var start3;
    var end2;
    if (typeof segmentInfo.timestampOffset === "number") {
      mappingObj = {
        time: segmentInfo.startOfSegment,
        mapping: segmentInfo.startOfSegment - timingInfo.start
      };
      if (shouldSaveTimelineMapping) {
        this.timelines[segmentInfo.timeline] = mappingObj;
        this.trigger("timestampoffset");
        this.logger_("time mapping for timeline " + segmentInfo.timeline + ": " + ("[time: " + mappingObj.time + "] [mapping: " + mappingObj.mapping + "]"));
      }
      start3 = segmentInfo.startOfSegment;
      end2 = timingInfo.end + mappingObj.mapping;
    } else if (mappingObj) {
      start3 = timingInfo.start + mappingObj.mapping;
      end2 = timingInfo.end + mappingObj.mapping;
    } else {
      return false;
    }
    if (part) {
      part.start = start3;
      part.end = end2;
    }
    if (!segment.start || start3 < segment.start) {
      segment.start = start3;
    }
    segment.end = end2;
    return true;
  };
  _proto.saveDiscontinuitySyncInfo_ = function saveDiscontinuitySyncInfo_(segmentInfo) {
    var playlist = segmentInfo.playlist;
    var segment = segmentInfo.segment;
    if (segment.discontinuity) {
      this.discontinuities[segment.timeline] = {
        time: segment.start,
        accuracy: 0
      };
    } else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
      for (var i = 0; i < playlist.discontinuityStarts.length; i++) {
        var segmentIndex = playlist.discontinuityStarts[i];
        var discontinuity = playlist.discontinuitySequence + i + 1;
        var mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
        var accuracy = Math.abs(mediaIndexDiff);
        if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
          var time2 = void 0;
          if (mediaIndexDiff < 0) {
            time2 = segment.start - sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: playlist.segments,
              startIndex: segmentInfo.mediaIndex,
              endIndex: segmentIndex
            });
          } else {
            time2 = segment.end + sumDurations({
              defaultDuration: playlist.targetDuration,
              durationList: playlist.segments,
              startIndex: segmentInfo.mediaIndex + 1,
              endIndex: segmentIndex
            });
          }
          this.discontinuities[discontinuity] = {
            time: time2,
            accuracy
          };
        }
      }
    }
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.off();
  };
  return SyncController2;
}(videojs.EventTarget);
var TimelineChangeController = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(TimelineChangeController2, _videojs$EventTarget);
  function TimelineChangeController2() {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    _this.pendingTimelineChanges_ = {};
    _this.lastTimelineChanges_ = {};
    return _this;
  }
  var _proto = TimelineChangeController2.prototype;
  _proto.clearPendingTimelineChange = function clearPendingTimelineChange(type2) {
    this.pendingTimelineChanges_[type2] = null;
    this.trigger("pendingtimelinechange");
  };
  _proto.pendingTimelineChange = function pendingTimelineChange(_ref) {
    var type2 = _ref.type, from3 = _ref.from, to = _ref.to;
    if (typeof from3 === "number" && typeof to === "number") {
      this.pendingTimelineChanges_[type2] = {
        type: type2,
        from: from3,
        to
      };
      this.trigger("pendingtimelinechange");
    }
    return this.pendingTimelineChanges_[type2];
  };
  _proto.lastTimelineChange = function lastTimelineChange(_ref2) {
    var type2 = _ref2.type, from3 = _ref2.from, to = _ref2.to;
    if (typeof from3 === "number" && typeof to === "number") {
      this.lastTimelineChanges_[type2] = {
        type: type2,
        from: from3,
        to
      };
      delete this.pendingTimelineChanges_[type2];
      this.trigger("timelinechange");
    }
    return this.lastTimelineChanges_[type2];
  };
  _proto.dispose = function dispose() {
    this.trigger("dispose");
    this.pendingTimelineChanges_ = {};
    this.lastTimelineChanges_ = {};
    this.off();
  };
  return TimelineChangeController2;
}(videojs.EventTarget);
var workerCode = transform(getWorkerString(function() {
  var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function createCommonjsModule(fn2, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: function require2(path, base) {
        return commonjsRequire(path, base === void 0 || base === null ? module.path : base);
      }
    }, fn2(module, module.exports), module.exports;
  }
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var createClass = createCommonjsModule(function(module) {
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    module.exports = _createClass;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var setPrototypeOf = createCommonjsModule(function(module) {
    function _setPrototypeOf2(o, p2) {
      module.exports = _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p3) {
        o2.__proto__ = p3;
        return o2;
      };
      module.exports["default"] = module.exports, module.exports.__esModule = true;
      return _setPrototypeOf2(o, p2);
    }
    module.exports = _setPrototypeOf2;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var inheritsLoose = createCommonjsModule(function(module) {
    function _inheritsLoose2(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      setPrototypeOf(subClass, superClass);
    }
    module.exports = _inheritsLoose2;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  });
  var Stream2 = /* @__PURE__ */ function() {
    function Stream3() {
      this.listeners = {};
    }
    var _proto = Stream3.prototype;
    _proto.on = function on3(type2, listener) {
      if (!this.listeners[type2]) {
        this.listeners[type2] = [];
      }
      this.listeners[type2].push(listener);
    };
    _proto.off = function off2(type2, listener) {
      if (!this.listeners[type2]) {
        return false;
      }
      var index2 = this.listeners[type2].indexOf(listener);
      this.listeners[type2] = this.listeners[type2].slice(0);
      this.listeners[type2].splice(index2, 1);
      return index2 > -1;
    };
    _proto.trigger = function trigger2(type2) {
      var callbacks = this.listeners[type2];
      if (!callbacks) {
        return;
      }
      if (arguments.length === 2) {
        var length2 = callbacks.length;
        for (var i = 0; i < length2; ++i) {
          callbacks[i].call(this, arguments[1]);
        }
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        var _length = callbacks.length;
        for (var _i = 0; _i < _length; ++_i) {
          callbacks[_i].apply(this, args);
        }
      }
    };
    _proto.dispose = function dispose() {
      this.listeners = {};
    };
    _proto.pipe = function pipe(destination) {
      this.on("data", function(data) {
        destination.push(data);
      });
    };
    return Stream3;
  }();
  /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */
  function unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
  /*! @name aes-decrypter @version 3.1.3 @license Apache-2.0 */
  var precompute = function precompute2() {
    var tables = [[[], [], [], [], []], [[], [], [], [], []]];
    var encTable = tables[0];
    var decTable = tables[1];
    var sbox = encTable[4];
    var sboxInv = decTable[4];
    var i;
    var x;
    var xInv;
    var d3 = [];
    var th2 = [];
    var x2;
    var x4;
    var x8;
    var s;
    var tEnc;
    var tDec;
    for (i = 0; i < 256; i++) {
      th2[(d3[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
    }
    for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th2[xInv] || 1) {
      s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
      s = s >> 8 ^ s & 255 ^ 99;
      sbox[x] = s;
      sboxInv[s] = x;
      x8 = d3[x4 = d3[x2 = d3[x]]];
      tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      tEnc = d3[s] * 257 ^ s * 16843008;
      for (i = 0; i < 4; i++) {
        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
      }
    }
    for (i = 0; i < 5; i++) {
      encTable[i] = encTable[i].slice(0);
      decTable[i] = decTable[i].slice(0);
    }
    return tables;
  };
  var aesTables = null;
  var AES = /* @__PURE__ */ function() {
    function AES2(key) {
      if (!aesTables) {
        aesTables = precompute();
      }
      this._tables = [[aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice()], [aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice()]];
      var i;
      var j2;
      var tmp;
      var sbox = this._tables[0][4];
      var decTable = this._tables[1];
      var keyLen = key.length;
      var rcon = 1;
      if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
        throw new Error("Invalid aes key size");
      }
      var encKey = key.slice(0);
      var decKey = [];
      this._key = [encKey, decKey];
      for (i = keyLen; i < 4 * keyLen + 28; i++) {
        tmp = encKey[i - 1];
        if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
          tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
          if (i % keyLen === 0) {
            tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
            rcon = rcon << 1 ^ (rcon >> 7) * 283;
          }
        }
        encKey[i] = encKey[i - keyLen] ^ tmp;
      }
      for (j2 = 0; i; j2++, i--) {
        tmp = encKey[j2 & 3 ? i : i - 4];
        if (i <= 4 || j2 < 4) {
          decKey[j2] = tmp;
        } else {
          decKey[j2] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
        }
      }
    }
    var _proto = AES2.prototype;
    _proto.decrypt = function decrypt4(encrypted0, encrypted1, encrypted2, encrypted3, out, offset3) {
      var key = this._key[1];
      var a2 = encrypted0 ^ key[0];
      var b2 = encrypted3 ^ key[1];
      var c2 = encrypted2 ^ key[2];
      var d3 = encrypted1 ^ key[3];
      var a22;
      var b22;
      var c22;
      var nInnerRounds = key.length / 4 - 2;
      var i;
      var kIndex = 4;
      var table = this._tables[1];
      var table0 = table[0];
      var table1 = table[1];
      var table2 = table[2];
      var table3 = table[3];
      var sbox = table[4];
      for (i = 0; i < nInnerRounds; i++) {
        a22 = table0[a2 >>> 24] ^ table1[b2 >> 16 & 255] ^ table2[c2 >> 8 & 255] ^ table3[d3 & 255] ^ key[kIndex];
        b22 = table0[b2 >>> 24] ^ table1[c2 >> 16 & 255] ^ table2[d3 >> 8 & 255] ^ table3[a2 & 255] ^ key[kIndex + 1];
        c22 = table0[c2 >>> 24] ^ table1[d3 >> 16 & 255] ^ table2[a2 >> 8 & 255] ^ table3[b2 & 255] ^ key[kIndex + 2];
        d3 = table0[d3 >>> 24] ^ table1[a2 >> 16 & 255] ^ table2[b2 >> 8 & 255] ^ table3[c2 & 255] ^ key[kIndex + 3];
        kIndex += 4;
        a2 = a22;
        b2 = b22;
        c2 = c22;
      }
      for (i = 0; i < 4; i++) {
        out[(3 & -i) + offset3] = sbox[a2 >>> 24] << 24 ^ sbox[b2 >> 16 & 255] << 16 ^ sbox[c2 >> 8 & 255] << 8 ^ sbox[d3 & 255] ^ key[kIndex++];
        a22 = a2;
        a2 = b2;
        b2 = c2;
        c2 = d3;
        d3 = a22;
      }
    };
    return AES2;
  }();
  var AsyncStream = /* @__PURE__ */ function(_Stream) {
    inheritsLoose(AsyncStream2, _Stream);
    function AsyncStream2() {
      var _this;
      _this = _Stream.call(this, Stream2) || this;
      _this.jobs = [];
      _this.delay = 1;
      _this.timeout_ = null;
      return _this;
    }
    var _proto = AsyncStream2.prototype;
    _proto.processJob_ = function processJob_() {
      this.jobs.shift()();
      if (this.jobs.length) {
        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
      } else {
        this.timeout_ = null;
      }
    };
    _proto.push = function push(job) {
      this.jobs.push(job);
      if (!this.timeout_) {
        this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
      }
    };
    return AsyncStream2;
  }(Stream2);
  var ntoh = function ntoh2(word) {
    return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
  };
  var decrypt3 = function decrypt4(encrypted, key, initVector) {
    var encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
    var decipher = new AES(Array.prototype.slice.call(key));
    var decrypted = new Uint8Array(encrypted.byteLength);
    var decrypted32 = new Int32Array(decrypted.buffer);
    var init0;
    var init1;
    var init2;
    var init3;
    var encrypted0;
    var encrypted1;
    var encrypted2;
    var encrypted3;
    var wordIx;
    init0 = initVector[0];
    init1 = initVector[1];
    init2 = initVector[2];
    init3 = initVector[3];
    for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
      encrypted0 = ntoh(encrypted32[wordIx]);
      encrypted1 = ntoh(encrypted32[wordIx + 1]);
      encrypted2 = ntoh(encrypted32[wordIx + 2]);
      encrypted3 = ntoh(encrypted32[wordIx + 3]);
      decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
      decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
      decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
      decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
      decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
      init0 = encrypted0;
      init1 = encrypted1;
      init2 = encrypted2;
      init3 = encrypted3;
    }
    return decrypted;
  };
  var Decrypter2 = /* @__PURE__ */ function() {
    function Decrypter3(encrypted, key, initVector, done) {
      var step = Decrypter3.STEP;
      var encrypted32 = new Int32Array(encrypted.buffer);
      var decrypted = new Uint8Array(encrypted.byteLength);
      var i = 0;
      this.asyncStream_ = new AsyncStream();
      this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
      for (i = step; i < encrypted32.length; i += step) {
        initVector = new Uint32Array([ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1])]);
        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
      }
      this.asyncStream_.push(function() {
        done(null, unpad(decrypted));
      });
    }
    var _proto = Decrypter3.prototype;
    _proto.decryptChunk_ = function decryptChunk_(encrypted, key, initVector, decrypted) {
      return function() {
        var bytes = decrypt3(encrypted, key, initVector);
        decrypted.set(bytes, encrypted.byteOffset);
      };
    };
    createClass(Decrypter3, null, [{
      key: "STEP",
      get: function get8() {
        return 32e3;
      }
    }]);
    return Decrypter3;
  }();
  var win2;
  if (typeof window !== "undefined") {
    win2 = window;
  } else if (typeof commonjsGlobal2 !== "undefined") {
    win2 = commonjsGlobal2;
  } else if (typeof self !== "undefined") {
    win2 = self;
  } else {
    win2 = {};
  }
  var window_12 = win2;
  var isArrayBufferView3 = function isArrayBufferView4(obj) {
    if (ArrayBuffer.isView === "function") {
      return ArrayBuffer.isView(obj);
    }
    return obj && obj.buffer instanceof ArrayBuffer;
  };
  var BigInt2 = window_12.BigInt || Number;
  [BigInt2("0x1"), BigInt2("0x100"), BigInt2("0x10000"), BigInt2("0x1000000"), BigInt2("0x100000000"), BigInt2("0x10000000000"), BigInt2("0x1000000000000"), BigInt2("0x100000000000000"), BigInt2("0x10000000000000000")];
  var createTransferableMessage3 = function createTransferableMessage4(message) {
    var transferable = {};
    Object.keys(message).forEach(function(key) {
      var value = message[key];
      if (isArrayBufferView3(value)) {
        transferable[key] = {
          bytes: value.buffer,
          byteOffset: value.byteOffset,
          byteLength: value.byteLength
        };
      } else {
        transferable[key] = value;
      }
    });
    return transferable;
  };
  self.onmessage = function(event) {
    var data = event.data;
    var encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
    var key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
    var iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
    new Decrypter2(encrypted, key, iv, function(err, bytes) {
      self.postMessage(createTransferableMessage3({
        source: data.source,
        decrypted: bytes
      }), [bytes.buffer]);
    });
  };
}));
var Decrypter = factory(workerCode);
var audioTrackKind_ = function audioTrackKind_2(properties2) {
  var kind = properties2["default"] ? "main" : "alternative";
  if (properties2.characteristics && properties2.characteristics.indexOf("public.accessibility.describes-video") >= 0) {
    kind = "main-desc";
  }
  return kind;
};
var stopLoaders = function stopLoaders2(segmentLoader, mediaType) {
  segmentLoader.abort();
  segmentLoader.pause();
  if (mediaType && mediaType.activePlaylistLoader) {
    mediaType.activePlaylistLoader.pause();
    mediaType.activePlaylistLoader = null;
  }
};
var startLoaders = function startLoaders2(playlistLoader, mediaType) {
  mediaType.activePlaylistLoader = playlistLoader;
  playlistLoader.load();
};
var onGroupChanged = function onGroupChanged2(type2, settings) {
  return function() {
    var _settings$segmentLoad = settings.segmentLoaders, segmentLoader = _settings$segmentLoad[type2], mainSegmentLoader = _settings$segmentLoad.main, mediaType = settings.mediaTypes[type2];
    var activeTrack2 = mediaType.activeTrack();
    var activeGroup3 = mediaType.getActiveGroup();
    var previousActiveLoader = mediaType.activePlaylistLoader;
    var lastGroup = mediaType.lastGroup_;
    if (activeGroup3 && lastGroup && activeGroup3.id === lastGroup.id) {
      return;
    }
    mediaType.lastGroup_ = activeGroup3;
    mediaType.lastTrack_ = activeTrack2;
    stopLoaders(segmentLoader, mediaType);
    if (!activeGroup3 || activeGroup3.isMasterPlaylist) {
      return;
    }
    if (!activeGroup3.playlistLoader) {
      if (previousActiveLoader) {
        mainSegmentLoader.resetEverything();
      }
      return;
    }
    segmentLoader.resyncLoader();
    startLoaders(activeGroup3.playlistLoader, mediaType);
  };
};
var onGroupChanging = function onGroupChanging2(type2, settings) {
  return function() {
    var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
    mediaType.lastGroup_ = null;
    segmentLoader.abort();
    segmentLoader.pause();
  };
};
var onTrackChanged = function onTrackChanged2(type2, settings) {
  return function() {
    var masterPlaylistLoader = settings.masterPlaylistLoader, _settings$segmentLoad2 = settings.segmentLoaders, segmentLoader = _settings$segmentLoad2[type2], mainSegmentLoader = _settings$segmentLoad2.main, mediaType = settings.mediaTypes[type2];
    var activeTrack2 = mediaType.activeTrack();
    var activeGroup3 = mediaType.getActiveGroup();
    var previousActiveLoader = mediaType.activePlaylistLoader;
    var lastTrack = mediaType.lastTrack_;
    if (lastTrack && activeTrack2 && lastTrack.id === activeTrack2.id) {
      return;
    }
    mediaType.lastGroup_ = activeGroup3;
    mediaType.lastTrack_ = activeTrack2;
    stopLoaders(segmentLoader, mediaType);
    if (!activeGroup3) {
      return;
    }
    if (activeGroup3.isMasterPlaylist) {
      if (!activeTrack2 || !lastTrack || activeTrack2.id === lastTrack.id) {
        return;
      }
      var mpc = settings.vhs.masterPlaylistController_;
      var newPlaylist = mpc.selectPlaylist();
      if (mpc.media() === newPlaylist) {
        return;
      }
      mediaType.logger_("track change. Switching master audio from " + lastTrack.id + " to " + activeTrack2.id);
      masterPlaylistLoader.pause();
      mainSegmentLoader.resetEverything();
      mpc.fastQualityChange_(newPlaylist);
      return;
    }
    if (type2 === "AUDIO") {
      if (!activeGroup3.playlistLoader) {
        mainSegmentLoader.setAudio(true);
        mainSegmentLoader.resetEverything();
        return;
      }
      segmentLoader.setAudio(true);
      mainSegmentLoader.setAudio(false);
    }
    if (previousActiveLoader === activeGroup3.playlistLoader) {
      startLoaders(activeGroup3.playlistLoader, mediaType);
      return;
    }
    if (segmentLoader.track) {
      segmentLoader.track(activeTrack2);
    }
    segmentLoader.resetEverything();
    startLoaders(activeGroup3.playlistLoader, mediaType);
  };
};
var onError = {
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning (or error if the playlist is blacklisted) to
   *         console and switches back to default audio track.
   * @function onError.AUDIO
   */
  AUDIO: function AUDIO(type2, settings) {
    return function() {
      var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2], blacklistCurrentPlaylist = settings.blacklistCurrentPlaylist;
      stopLoaders(segmentLoader, mediaType);
      var activeTrack2 = mediaType.activeTrack();
      var activeGroup3 = mediaType.activeGroup();
      var id2 = (activeGroup3.filter(function(group) {
        return group["default"];
      })[0] || activeGroup3[0]).id;
      var defaultTrack = mediaType.tracks[id2];
      if (activeTrack2 === defaultTrack) {
        blacklistCurrentPlaylist({
          message: "Problem encountered loading the default audio track."
        });
        return;
      }
      videojs.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
      for (var trackId in mediaType.tracks) {
        mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
      }
      mediaType.onTrackChanged();
    };
  },
  /**
   * Returns a function to be called when a SegmentLoader or PlaylistLoader encounters
   * an error.
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Error handler. Logs warning to console and disables the active subtitle track
   * @function onError.SUBTITLES
   */
  SUBTITLES: function SUBTITLES(type2, settings) {
    return function() {
      var segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
      videojs.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
      stopLoaders(segmentLoader, mediaType);
      var track = mediaType.activeTrack();
      if (track) {
        track.mode = "disabled";
      }
      mediaType.onTrackChanged();
    };
  }
};
var setupListeners = {
  /**
   * Setup event listeners for audio playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.AUDIO
   */
  AUDIO: function AUDIO2(type2, playlistLoader, settings) {
    if (!playlistLoader) {
      return;
    }
    var tech = settings.tech, requestOptions = settings.requestOptions, segmentLoader = settings.segmentLoaders[type2];
    playlistLoader.on("loadedmetadata", function() {
      var media = playlistLoader.media();
      segmentLoader.playlist(media, requestOptions);
      if (!tech.paused() || media.endList && tech.preload() !== "none") {
        segmentLoader.load();
      }
    });
    playlistLoader.on("loadedplaylist", function() {
      segmentLoader.playlist(playlistLoader.media(), requestOptions);
      if (!tech.paused()) {
        segmentLoader.load();
      }
    });
    playlistLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup event listeners for subtitle playlist loader
   *
   * @param {string} type
   *        MediaGroup type
   * @param {PlaylistLoader|null} playlistLoader
   *        PlaylistLoader to register listeners on
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function setupListeners.SUBTITLES
   */
  SUBTITLES: function SUBTITLES2(type2, playlistLoader, settings) {
    var tech = settings.tech, requestOptions = settings.requestOptions, segmentLoader = settings.segmentLoaders[type2], mediaType = settings.mediaTypes[type2];
    playlistLoader.on("loadedmetadata", function() {
      var media = playlistLoader.media();
      segmentLoader.playlist(media, requestOptions);
      segmentLoader.track(mediaType.activeTrack());
      if (!tech.paused() || media.endList && tech.preload() !== "none") {
        segmentLoader.load();
      }
    });
    playlistLoader.on("loadedplaylist", function() {
      segmentLoader.playlist(playlistLoader.media(), requestOptions);
      if (!tech.paused()) {
        segmentLoader.load();
      }
    });
    playlistLoader.on("error", onError[type2](type2, settings));
  }
};
var initialize = {
  /**
   * Setup PlaylistLoaders and AudioTracks for the audio groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.AUDIO
   */
  "AUDIO": function AUDIO3(type2, settings) {
    var vhs = settings.vhs, sourceType = settings.sourceType, segmentLoader = settings.segmentLoaders[type2], requestOptions = settings.requestOptions, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$ = settings.mediaTypes[type2], groups = _settings$mediaTypes$.groups, tracks = _settings$mediaTypes$.tracks, logger_ = _settings$mediaTypes$.logger_, masterPlaylistLoader = settings.masterPlaylistLoader;
    var audioOnlyMaster = isAudioOnly(masterPlaylistLoader.master);
    if (!mediaGroups[type2] || Object.keys(mediaGroups[type2]).length === 0) {
      mediaGroups[type2] = {
        main: {
          "default": {
            "default": true
          }
        }
      };
      if (audioOnlyMaster) {
        mediaGroups[type2].main["default"].playlists = masterPlaylistLoader.master.playlists;
      }
    }
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        var properties2 = mediaGroups[type2][groupId][variantLabel];
        var playlistLoader = void 0;
        if (audioOnlyMaster) {
          logger_("AUDIO group '" + groupId + "' label '" + variantLabel + "' is a master playlist");
          properties2.isMasterPlaylist = true;
          playlistLoader = null;
        } else if (sourceType === "vhs-json" && properties2.playlists) {
          playlistLoader = new PlaylistLoader(properties2.playlists[0], vhs, requestOptions);
        } else if (properties2.resolvedUri) {
          playlistLoader = new PlaylistLoader(properties2.resolvedUri, vhs, requestOptions);
        } else if (properties2.playlists && sourceType === "dash") {
          playlistLoader = new DashPlaylistLoader(properties2.playlists[0], vhs, requestOptions, masterPlaylistLoader);
        } else {
          playlistLoader = null;
        }
        properties2 = videojs.mergeOptions({
          id: variantLabel,
          playlistLoader
        }, properties2);
        setupListeners[type2](type2, properties2.playlistLoader, settings);
        groups[groupId].push(properties2);
        if (typeof tracks[variantLabel] === "undefined") {
          var track = new videojs.AudioTrack({
            id: variantLabel,
            kind: audioTrackKind_(properties2),
            enabled: false,
            language: properties2.language,
            "default": properties2["default"],
            label: variantLabel
          });
          tracks[variantLabel] = track;
        }
      }
    }
    segmentLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup PlaylistLoaders and TextTracks for the subtitle groups
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize.SUBTITLES
   */
  "SUBTITLES": function SUBTITLES3(type2, settings) {
    var tech = settings.tech, vhs = settings.vhs, sourceType = settings.sourceType, segmentLoader = settings.segmentLoaders[type2], requestOptions = settings.requestOptions, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$2 = settings.mediaTypes[type2], groups = _settings$mediaTypes$2.groups, tracks = _settings$mediaTypes$2.tracks, masterPlaylistLoader = settings.masterPlaylistLoader;
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        if (mediaGroups[type2][groupId][variantLabel].forced) {
          continue;
        }
        var properties2 = mediaGroups[type2][groupId][variantLabel];
        var playlistLoader = void 0;
        if (sourceType === "hls") {
          playlistLoader = new PlaylistLoader(properties2.resolvedUri, vhs, requestOptions);
        } else if (sourceType === "dash") {
          var playlists = properties2.playlists.filter(function(p2) {
            return p2.excludeUntil !== Infinity;
          });
          if (!playlists.length) {
            return;
          }
          playlistLoader = new DashPlaylistLoader(properties2.playlists[0], vhs, requestOptions, masterPlaylistLoader);
        } else if (sourceType === "vhs-json") {
          playlistLoader = new PlaylistLoader(
            // if the vhs-json object included the media playlist, use the media playlist
            // as provided, otherwise use the resolved URI to load the playlist
            properties2.playlists ? properties2.playlists[0] : properties2.resolvedUri,
            vhs,
            requestOptions
          );
        }
        properties2 = videojs.mergeOptions({
          id: variantLabel,
          playlistLoader
        }, properties2);
        setupListeners[type2](type2, properties2.playlistLoader, settings);
        groups[groupId].push(properties2);
        if (typeof tracks[variantLabel] === "undefined") {
          var track = tech.addRemoteTextTrack({
            id: variantLabel,
            kind: "subtitles",
            "default": properties2["default"] && properties2.autoselect,
            language: properties2.language,
            label: variantLabel
          }, false).track;
          tracks[variantLabel] = track;
        }
      }
    }
    segmentLoader.on("error", onError[type2](type2, settings));
  },
  /**
   * Setup TextTracks for the closed-caption groups
   *
   * @param {String} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @function initialize['CLOSED-CAPTIONS']
   */
  "CLOSED-CAPTIONS": function CLOSEDCAPTIONS(type2, settings) {
    var tech = settings.tech, mediaGroups = settings.master.mediaGroups, _settings$mediaTypes$3 = settings.mediaTypes[type2], groups = _settings$mediaTypes$3.groups, tracks = _settings$mediaTypes$3.tracks;
    for (var groupId in mediaGroups[type2]) {
      if (!groups[groupId]) {
        groups[groupId] = [];
      }
      for (var variantLabel in mediaGroups[type2][groupId]) {
        var properties2 = mediaGroups[type2][groupId][variantLabel];
        if (!/^(?:CC|SERVICE)/.test(properties2.instreamId)) {
          continue;
        }
        var captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
        var newProps = {
          label: variantLabel,
          language: properties2.language,
          instreamId: properties2.instreamId,
          "default": properties2["default"] && properties2.autoselect
        };
        if (captionServices[newProps.instreamId]) {
          newProps = videojs.mergeOptions(newProps, captionServices[newProps.instreamId]);
        }
        if (newProps["default"] === void 0) {
          delete newProps["default"];
        }
        groups[groupId].push(videojs.mergeOptions({
          id: variantLabel
        }, properties2));
        if (typeof tracks[variantLabel] === "undefined") {
          var track = tech.addRemoteTextTrack({
            id: newProps.instreamId,
            kind: "captions",
            "default": newProps["default"],
            language: newProps.language,
            label: newProps.label
          }, false).track;
          tracks[variantLabel] = track;
        }
      }
    }
  }
};
var groupMatch = function groupMatch2(list, media) {
  for (var i = 0; i < list.length; i++) {
    if (playlistMatch(media, list[i])) {
      return true;
    }
    if (list[i].playlists && groupMatch2(list[i].playlists, media)) {
      return true;
    }
  }
  return false;
};
var activeGroup = function activeGroup2(type2, settings) {
  return function(track) {
    var masterPlaylistLoader = settings.masterPlaylistLoader, groups = settings.mediaTypes[type2].groups;
    var media = masterPlaylistLoader.media();
    if (!media) {
      return null;
    }
    var variants = null;
    if (media.attributes[type2]) {
      variants = groups[media.attributes[type2]];
    }
    var groupKeys = Object.keys(groups);
    if (!variants) {
      if (type2 === "AUDIO" && groupKeys.length > 1 && isAudioOnly(settings.master)) {
        for (var i = 0; i < groupKeys.length; i++) {
          var groupPropertyList = groups[groupKeys[i]];
          if (groupMatch(groupPropertyList, media)) {
            variants = groupPropertyList;
            break;
          }
        }
      } else if (groups.main) {
        variants = groups.main;
      } else if (groupKeys.length === 1) {
        variants = groups[groupKeys[0]];
      }
    }
    if (typeof track === "undefined") {
      return variants;
    }
    if (track === null || !variants) {
      return null;
    }
    return variants.filter(function(props) {
      return props.id === track.id;
    })[0] || null;
  };
};
var activeTrack = {
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.AUDIO
   */
  AUDIO: function AUDIO4(type2, settings) {
    return function() {
      var tracks = settings.mediaTypes[type2].tracks;
      for (var id2 in tracks) {
        if (tracks[id2].enabled) {
          return tracks[id2];
        }
      }
      return null;
    };
  },
  /**
   * Returns a function used to get the active track of type provided
   *
   * @param {string} type
   *        MediaGroup type
   * @param {Object} settings
   *        Object containing required information for media groups
   * @return {Function}
   *         Function that returns the active media track for the provided type. Returns
   *         null if no track is active
   * @function activeTrack.SUBTITLES
   */
  SUBTITLES: function SUBTITLES4(type2, settings) {
    return function() {
      var tracks = settings.mediaTypes[type2].tracks;
      for (var id2 in tracks) {
        if (tracks[id2].mode === "showing" || tracks[id2].mode === "hidden") {
          return tracks[id2];
        }
      }
      return null;
    };
  }
};
var getActiveGroup = function getActiveGroup2(type2, _ref) {
  var mediaTypes2 = _ref.mediaTypes;
  return function() {
    var activeTrack_ = mediaTypes2[type2].activeTrack();
    if (!activeTrack_) {
      return null;
    }
    return mediaTypes2[type2].activeGroup(activeTrack_);
  };
};
var setupMediaGroups = function setupMediaGroups2(settings) {
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(type2) {
    initialize[type2](type2, settings);
  });
  var mediaTypes2 = settings.mediaTypes, masterPlaylistLoader = settings.masterPlaylistLoader, tech = settings.tech, vhs = settings.vhs, _settings$segmentLoad3 = settings.segmentLoaders, audioSegmentLoader = _settings$segmentLoad3["AUDIO"], mainSegmentLoader = _settings$segmentLoad3.main;
  ["AUDIO", "SUBTITLES"].forEach(function(type2) {
    mediaTypes2[type2].activeGroup = activeGroup(type2, settings);
    mediaTypes2[type2].activeTrack = activeTrack[type2](type2, settings);
    mediaTypes2[type2].onGroupChanged = onGroupChanged(type2, settings);
    mediaTypes2[type2].onGroupChanging = onGroupChanging(type2, settings);
    mediaTypes2[type2].onTrackChanged = onTrackChanged(type2, settings);
    mediaTypes2[type2].getActiveGroup = getActiveGroup(type2, settings);
  });
  var audioGroup = mediaTypes2.AUDIO.activeGroup();
  if (audioGroup) {
    var groupId = (audioGroup.filter(function(group) {
      return group["default"];
    })[0] || audioGroup[0]).id;
    mediaTypes2.AUDIO.tracks[groupId].enabled = true;
    mediaTypes2.AUDIO.onGroupChanged();
    mediaTypes2.AUDIO.onTrackChanged();
    var activeAudioGroup = mediaTypes2.AUDIO.getActiveGroup();
    if (!activeAudioGroup.playlistLoader) {
      mainSegmentLoader.setAudio(true);
    } else {
      mainSegmentLoader.setAudio(false);
      audioSegmentLoader.setAudio(true);
    }
  }
  masterPlaylistLoader.on("mediachange", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      return mediaTypes2[type2].onGroupChanged();
    });
  });
  masterPlaylistLoader.on("mediachanging", function() {
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      return mediaTypes2[type2].onGroupChanging();
    });
  });
  var onAudioTrackChanged = function onAudioTrackChanged2() {
    mediaTypes2.AUDIO.onTrackChanged();
    tech.trigger({
      type: "usage",
      name: "vhs-audio-change"
    });
    tech.trigger({
      type: "usage",
      name: "hls-audio-change"
    });
  };
  tech.audioTracks().addEventListener("change", onAudioTrackChanged);
  tech.remoteTextTracks().addEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
  vhs.on("dispose", function() {
    tech.audioTracks().removeEventListener("change", onAudioTrackChanged);
    tech.remoteTextTracks().removeEventListener("change", mediaTypes2.SUBTITLES.onTrackChanged);
  });
  tech.clearTracks("audio");
  for (var id2 in mediaTypes2.AUDIO.tracks) {
    tech.audioTracks().addTrack(mediaTypes2.AUDIO.tracks[id2]);
  }
};
var createMediaTypes = function createMediaTypes2() {
  var mediaTypes2 = {};
  ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(type2) {
    mediaTypes2[type2] = {
      groups: {},
      tracks: {},
      activePlaylistLoader: null,
      activeGroup: noop$3,
      activeTrack: noop$3,
      getActiveGroup: noop$3,
      onGroupChanged: noop$3,
      onTrackChanged: noop$3,
      lastTrack_: null,
      logger_: logger("MediaGroups[" + type2 + "]")
    };
  });
  return mediaTypes2;
};
var ABORT_EARLY_BLACKLIST_SECONDS = 60 * 2;
var Vhs$1;
var loaderStats = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"];
var sumLoaderStat = function sumLoaderStat2(stat) {
  return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
};
var shouldSwitchToMedia = function shouldSwitchToMedia2(_ref) {
  var currentPlaylist = _ref.currentPlaylist, buffered = _ref.buffered, currentTime = _ref.currentTime, nextPlaylist = _ref.nextPlaylist, bufferLowWaterLine = _ref.bufferLowWaterLine, bufferHighWaterLine = _ref.bufferHighWaterLine, duration5 = _ref.duration, experimentalBufferBasedABR = _ref.experimentalBufferBasedABR, log2 = _ref.log;
  if (!nextPlaylist) {
    videojs.log.warn("We received no playlist to switch to. Please check your stream.");
    return false;
  }
  var sharedLogLine = "allowing switch " + (currentPlaylist && currentPlaylist.id || "null") + " -> " + nextPlaylist.id;
  if (!currentPlaylist) {
    log2(sharedLogLine + " as current playlist is not set");
    return true;
  }
  if (nextPlaylist.id === currentPlaylist.id) {
    return false;
  }
  var isBuffered = Boolean(findRange(buffered, currentTime).length);
  if (!currentPlaylist.endList) {
    if (!isBuffered && typeof currentPlaylist.partTargetDuration === "number") {
      log2("not " + sharedLogLine + " as current playlist is live llhls, but currentTime isn't in buffered.");
      return false;
    }
    log2(sharedLogLine + " as current playlist is live");
    return true;
  }
  var forwardBuffer = timeAheadOf(buffered, currentTime);
  var maxBufferLowWaterLine = experimentalBufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
  if (duration5 < maxBufferLowWaterLine) {
    log2(sharedLogLine + " as duration < max low water line (" + duration5 + " < " + maxBufferLowWaterLine + ")");
    return true;
  }
  var nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
  var currBandwidth = currentPlaylist.attributes.BANDWIDTH;
  if (nextBandwidth < currBandwidth && (!experimentalBufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
    var logLine = sharedLogLine + " as next bandwidth < current bandwidth (" + nextBandwidth + " < " + currBandwidth + ")";
    if (experimentalBufferBasedABR) {
      logLine += " and forwardBuffer < bufferHighWaterLine (" + forwardBuffer + " < " + bufferHighWaterLine + ")";
    }
    log2(logLine);
    return true;
  }
  if ((!experimentalBufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
    var _logLine = sharedLogLine + " as forwardBuffer >= bufferLowWaterLine (" + forwardBuffer + " >= " + bufferLowWaterLine + ")";
    if (experimentalBufferBasedABR) {
      _logLine += " and next bandwidth > current bandwidth (" + nextBandwidth + " > " + currBandwidth + ")";
    }
    log2(_logLine);
    return true;
  }
  log2("not " + sharedLogLine + " as no switching criteria met");
  return false;
};
var MasterPlaylistController = /* @__PURE__ */ function(_videojs$EventTarget) {
  _inheritsLoose(MasterPlaylistController2, _videojs$EventTarget);
  function MasterPlaylistController2(options) {
    var _this;
    _this = _videojs$EventTarget.call(this) || this;
    var src = options.src, handleManifestRedirects = options.handleManifestRedirects, withCredentials = options.withCredentials, tech = options.tech, bandwidth2 = options.bandwidth, externVhs = options.externVhs, useCueTags = options.useCueTags, blacklistDuration = options.blacklistDuration, enableLowInitialPlaylist = options.enableLowInitialPlaylist, sourceType = options.sourceType, cacheEncryptionKeys = options.cacheEncryptionKeys, experimentalBufferBasedABR = options.experimentalBufferBasedABR, experimentalLeastPixelDiffSelector = options.experimentalLeastPixelDiffSelector, captionServices = options.captionServices;
    if (!src) {
      throw new Error("A non-empty playlist URL or JSON manifest string is required");
    }
    var maxPlaylistRetries = options.maxPlaylistRetries;
    if (maxPlaylistRetries === null || typeof maxPlaylistRetries === "undefined") {
      maxPlaylistRetries = Infinity;
    }
    Vhs$1 = externVhs;
    _this.experimentalBufferBasedABR = Boolean(experimentalBufferBasedABR);
    _this.experimentalLeastPixelDiffSelector = Boolean(experimentalLeastPixelDiffSelector);
    _this.withCredentials = withCredentials;
    _this.tech_ = tech;
    _this.vhs_ = tech.vhs;
    _this.sourceType_ = sourceType;
    _this.useCueTags_ = useCueTags;
    _this.blacklistDuration = blacklistDuration;
    _this.maxPlaylistRetries = maxPlaylistRetries;
    _this.enableLowInitialPlaylist = enableLowInitialPlaylist;
    if (_this.useCueTags_) {
      _this.cueTagsTrack_ = _this.tech_.addTextTrack("metadata", "ad-cues");
      _this.cueTagsTrack_.inBandMetadataTrackDispatchType = "";
    }
    _this.requestOptions_ = {
      withCredentials,
      handleManifestRedirects,
      maxPlaylistRetries,
      timeout: null
    };
    _this.on("error", _this.pauseLoading);
    _this.mediaTypes_ = createMediaTypes();
    _this.mediaSource = new window_1.MediaSource();
    _this.handleDurationChange_ = _this.handleDurationChange_.bind(_assertThisInitialized(_this));
    _this.handleSourceOpen_ = _this.handleSourceOpen_.bind(_assertThisInitialized(_this));
    _this.handleSourceEnded_ = _this.handleSourceEnded_.bind(_assertThisInitialized(_this));
    _this.mediaSource.addEventListener("durationchange", _this.handleDurationChange_);
    _this.mediaSource.addEventListener("sourceopen", _this.handleSourceOpen_);
    _this.mediaSource.addEventListener("sourceended", _this.handleSourceEnded_);
    _this.seekable_ = videojs.createTimeRanges();
    _this.hasPlayed_ = false;
    _this.syncController_ = new SyncController(options);
    _this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
      kind: "metadata",
      label: "segment-metadata"
    }, false).track;
    _this.decrypter_ = new Decrypter();
    _this.sourceUpdater_ = new SourceUpdater(_this.mediaSource);
    _this.inbandTextTracks_ = {};
    _this.timelineChangeController_ = new TimelineChangeController();
    var segmentLoaderSettings = {
      vhs: _this.vhs_,
      parse708captions: options.parse708captions,
      useDtsForTimestampOffset: options.useDtsForTimestampOffset,
      captionServices,
      mediaSource: _this.mediaSource,
      currentTime: _this.tech_.currentTime.bind(_this.tech_),
      seekable: function seekable3() {
        return _this.seekable();
      },
      seeking: function seeking() {
        return _this.tech_.seeking();
      },
      duration: function duration5() {
        return _this.duration();
      },
      hasPlayed: function hasPlayed() {
        return _this.hasPlayed_;
      },
      goalBufferLength: function goalBufferLength() {
        return _this.goalBufferLength();
      },
      bandwidth: bandwidth2,
      syncController: _this.syncController_,
      decrypter: _this.decrypter_,
      sourceType: _this.sourceType_,
      inbandTextTracks: _this.inbandTextTracks_,
      cacheEncryptionKeys,
      sourceUpdater: _this.sourceUpdater_,
      timelineChangeController: _this.timelineChangeController_,
      experimentalExactManifestTimings: options.experimentalExactManifestTimings
    };
    _this.masterPlaylistLoader_ = _this.sourceType_ === "dash" ? new DashPlaylistLoader(src, _this.vhs_, _this.requestOptions_) : new PlaylistLoader(src, _this.vhs_, _this.requestOptions_);
    _this.setupMasterPlaylistLoaderListeners_();
    _this.mainSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      segmentMetadataTrack: _this.segmentMetadataTrack_,
      loaderType: "main"
    }), options);
    _this.audioSegmentLoader_ = new SegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      loaderType: "audio"
    }), options);
    _this.subtitleSegmentLoader_ = new VTTSegmentLoader(videojs.mergeOptions(segmentLoaderSettings, {
      loaderType: "vtt",
      featuresNativeTextTracks: _this.tech_.featuresNativeTextTracks
    }), options);
    _this.setupSegmentLoaderListeners_();
    if (_this.experimentalBufferBasedABR) {
      _this.masterPlaylistLoader_.one("loadedplaylist", function() {
        return _this.startABRTimer_();
      });
      _this.tech_.on("pause", function() {
        return _this.stopABRTimer_();
      });
      _this.tech_.on("play", function() {
        return _this.startABRTimer_();
      });
    }
    loaderStats.forEach(function(stat) {
      _this[stat + "_"] = sumLoaderStat.bind(_assertThisInitialized(_this), stat);
    });
    _this.logger_ = logger("MPC");
    _this.triggeredFmp4Usage = false;
    if (_this.tech_.preload() === "none") {
      _this.loadOnPlay_ = function() {
        _this.loadOnPlay_ = null;
        _this.masterPlaylistLoader_.load();
      };
      _this.tech_.one("play", _this.loadOnPlay_);
    } else {
      _this.masterPlaylistLoader_.load();
    }
    _this.timeToLoadedData__ = -1;
    _this.mainAppendsToLoadedData__ = -1;
    _this.audioAppendsToLoadedData__ = -1;
    var event = _this.tech_.preload() === "none" ? "play" : "loadstart";
    _this.tech_.one(event, function() {
      var timeToLoadedDataStart = Date.now();
      _this.tech_.one("loadeddata", function() {
        _this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
        _this.mainAppendsToLoadedData__ = _this.mainSegmentLoader_.mediaAppends;
        _this.audioAppendsToLoadedData__ = _this.audioSegmentLoader_.mediaAppends;
      });
    });
    return _this;
  }
  var _proto = MasterPlaylistController2.prototype;
  _proto.mainAppendsToLoadedData_ = function mainAppendsToLoadedData_() {
    return this.mainAppendsToLoadedData__;
  };
  _proto.audioAppendsToLoadedData_ = function audioAppendsToLoadedData_() {
    return this.audioAppendsToLoadedData__;
  };
  _proto.appendsToLoadedData_ = function appendsToLoadedData_() {
    var main2 = this.mainAppendsToLoadedData_();
    var audio = this.audioAppendsToLoadedData_();
    if (main2 === -1 || audio === -1) {
      return -1;
    }
    return main2 + audio;
  };
  _proto.timeToLoadedData_ = function timeToLoadedData_() {
    return this.timeToLoadedData__;
  };
  _proto.checkABR_ = function checkABR_() {
    var nextPlaylist = this.selectPlaylist();
    if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) {
      this.switchMedia_(nextPlaylist, "abr");
    }
  };
  _proto.switchMedia_ = function switchMedia_(playlist, cause, delay) {
    var oldMedia = this.media();
    var oldId = oldMedia && (oldMedia.id || oldMedia.uri);
    var newId = playlist.id || playlist.uri;
    if (oldId && oldId !== newId) {
      this.logger_("switch media " + oldId + " -> " + newId + " from " + cause);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-change-" + cause
      });
    }
    this.masterPlaylistLoader_.media(playlist, delay);
  };
  _proto.startABRTimer_ = function startABRTimer_() {
    var _this2 = this;
    this.stopABRTimer_();
    this.abrTimer_ = window_1.setInterval(function() {
      return _this2.checkABR_();
    }, 250);
  };
  _proto.stopABRTimer_ = function stopABRTimer_() {
    if (this.tech_.scrubbing && this.tech_.scrubbing()) {
      return;
    }
    window_1.clearInterval(this.abrTimer_);
    this.abrTimer_ = null;
  };
  _proto.getAudioTrackPlaylists_ = function getAudioTrackPlaylists_() {
    var master = this.master();
    var defaultPlaylists = master && master.playlists || [];
    if (!master || !master.mediaGroups || !master.mediaGroups.AUDIO) {
      return defaultPlaylists;
    }
    var AUDIO5 = master.mediaGroups.AUDIO;
    var groupKeys = Object.keys(AUDIO5);
    var track;
    if (Object.keys(this.mediaTypes_.AUDIO.groups).length) {
      track = this.mediaTypes_.AUDIO.activeTrack();
    } else {
      var defaultGroup = AUDIO5.main || groupKeys.length && AUDIO5[groupKeys[0]];
      for (var label in defaultGroup) {
        if (defaultGroup[label]["default"]) {
          track = {
            label
          };
          break;
        }
      }
    }
    if (!track) {
      return defaultPlaylists;
    }
    var playlists = [];
    for (var group in AUDIO5) {
      if (AUDIO5[group][track.label]) {
        var properties2 = AUDIO5[group][track.label];
        if (properties2.playlists && properties2.playlists.length) {
          playlists.push.apply(playlists, properties2.playlists);
        } else if (properties2.uri) {
          playlists.push(properties2);
        } else if (master.playlists.length) {
          for (var i = 0; i < master.playlists.length; i++) {
            var playlist = master.playlists[i];
            if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) {
              playlists.push(playlist);
            }
          }
        }
      }
    }
    if (!playlists.length) {
      return defaultPlaylists;
    }
    return playlists;
  };
  _proto.setupMasterPlaylistLoaderListeners_ = function setupMasterPlaylistLoaderListeners_() {
    var _this3 = this;
    this.masterPlaylistLoader_.on("loadedmetadata", function() {
      var media = _this3.masterPlaylistLoader_.media();
      var requestTimeout = media.targetDuration * 1.5 * 1e3;
      if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
        _this3.requestOptions_.timeout = 0;
      } else {
        _this3.requestOptions_.timeout = requestTimeout;
      }
      if (media.endList && _this3.tech_.preload() !== "none") {
        _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
        _this3.mainSegmentLoader_.load();
      }
      setupMediaGroups({
        sourceType: _this3.sourceType_,
        segmentLoaders: {
          AUDIO: _this3.audioSegmentLoader_,
          SUBTITLES: _this3.subtitleSegmentLoader_,
          main: _this3.mainSegmentLoader_
        },
        tech: _this3.tech_,
        requestOptions: _this3.requestOptions_,
        masterPlaylistLoader: _this3.masterPlaylistLoader_,
        vhs: _this3.vhs_,
        master: _this3.master(),
        mediaTypes: _this3.mediaTypes_,
        blacklistCurrentPlaylist: _this3.blacklistCurrentPlaylist.bind(_this3)
      });
      _this3.triggerPresenceUsage_(_this3.master(), media);
      _this3.setupFirstPlay();
      if (!_this3.mediaTypes_.AUDIO.activePlaylistLoader || _this3.mediaTypes_.AUDIO.activePlaylistLoader.media()) {
        _this3.trigger("selectedinitialmedia");
      } else {
        _this3.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", function() {
          _this3.trigger("selectedinitialmedia");
        });
      }
    });
    this.masterPlaylistLoader_.on("loadedplaylist", function() {
      if (_this3.loadOnPlay_) {
        _this3.tech_.off("play", _this3.loadOnPlay_);
      }
      var updatedPlaylist = _this3.masterPlaylistLoader_.media();
      if (!updatedPlaylist) {
        _this3.excludeUnsupportedVariants_();
        var selectedMedia;
        if (_this3.enableLowInitialPlaylist) {
          selectedMedia = _this3.selectInitialPlaylist();
        }
        if (!selectedMedia) {
          selectedMedia = _this3.selectPlaylist();
        }
        if (!selectedMedia || !_this3.shouldSwitchToMedia_(selectedMedia)) {
          return;
        }
        _this3.initialMedia_ = selectedMedia;
        _this3.switchMedia_(_this3.initialMedia_, "initial");
        var haveJsonSource = _this3.sourceType_ === "vhs-json" && _this3.initialMedia_.segments;
        if (!haveJsonSource) {
          return;
        }
        updatedPlaylist = _this3.initialMedia_;
      }
      _this3.handleUpdatedMediaPlaylist(updatedPlaylist);
    });
    this.masterPlaylistLoader_.on("error", function() {
      _this3.blacklistCurrentPlaylist(_this3.masterPlaylistLoader_.error);
    });
    this.masterPlaylistLoader_.on("mediachanging", function() {
      _this3.mainSegmentLoader_.abort();
      _this3.mainSegmentLoader_.pause();
    });
    this.masterPlaylistLoader_.on("mediachange", function() {
      var media = _this3.masterPlaylistLoader_.media();
      var requestTimeout = media.targetDuration * 1.5 * 1e3;
      if (isLowestEnabledRendition(_this3.masterPlaylistLoader_.master, _this3.masterPlaylistLoader_.media())) {
        _this3.requestOptions_.timeout = 0;
      } else {
        _this3.requestOptions_.timeout = requestTimeout;
      }
      _this3.mainSegmentLoader_.playlist(media, _this3.requestOptions_);
      _this3.mainSegmentLoader_.load();
      _this3.tech_.trigger({
        type: "mediachange",
        bubbles: true
      });
    });
    this.masterPlaylistLoader_.on("playlistunchanged", function() {
      var updatedPlaylist = _this3.masterPlaylistLoader_.media();
      if (updatedPlaylist.lastExcludeReason_ === "playlist-unchanged") {
        return;
      }
      var playlistOutdated = _this3.stuckAtPlaylistEnd_(updatedPlaylist);
      if (playlistOutdated) {
        _this3.blacklistCurrentPlaylist({
          message: "Playlist no longer updating.",
          reason: "playlist-unchanged"
        });
        _this3.tech_.trigger("playliststuck");
      }
    });
    this.masterPlaylistLoader_.on("renditiondisabled", function() {
      _this3.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-disabled"
      });
      _this3.tech_.trigger({
        type: "usage",
        name: "hls-rendition-disabled"
      });
    });
    this.masterPlaylistLoader_.on("renditionenabled", function() {
      _this3.tech_.trigger({
        type: "usage",
        name: "vhs-rendition-enabled"
      });
      _this3.tech_.trigger({
        type: "usage",
        name: "hls-rendition-enabled"
      });
    });
  };
  _proto.handleUpdatedMediaPlaylist = function handleUpdatedMediaPlaylist(updatedPlaylist) {
    if (this.useCueTags_) {
      this.updateAdCues_(updatedPlaylist);
    }
    this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
    this.updateDuration(!updatedPlaylist.endList);
    if (!this.tech_.paused()) {
      this.mainSegmentLoader_.load();
      if (this.audioSegmentLoader_) {
        this.audioSegmentLoader_.load();
      }
    }
  };
  _proto.triggerPresenceUsage_ = function triggerPresenceUsage_(master, media) {
    var mediaGroups = master.mediaGroups || {};
    var defaultDemuxed = true;
    var audioGroupKeys = Object.keys(mediaGroups.AUDIO);
    for (var mediaGroup in mediaGroups.AUDIO) {
      for (var label in mediaGroups.AUDIO[mediaGroup]) {
        var properties2 = mediaGroups.AUDIO[mediaGroup][label];
        if (!properties2.uri) {
          defaultDemuxed = false;
        }
      }
    }
    if (defaultDemuxed) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-demuxed"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-demuxed"
      });
    }
    if (Object.keys(mediaGroups.SUBTITLES).length) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-webvtt"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-webvtt"
      });
    }
    if (Vhs$1.Playlist.isAes(media)) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-aes"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-aes"
      });
    }
    if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-alternate-audio"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-alternate-audio"
      });
    }
    if (this.useCueTags_) {
      this.tech_.trigger({
        type: "usage",
        name: "vhs-playlist-cue-tags"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-playlist-cue-tags"
      });
    }
  };
  _proto.shouldSwitchToMedia_ = function shouldSwitchToMedia_(nextPlaylist) {
    var currentPlaylist = this.masterPlaylistLoader_.media() || this.masterPlaylistLoader_.pendingMedia_;
    var currentTime = this.tech_.currentTime();
    var bufferLowWaterLine = this.bufferLowWaterLine();
    var bufferHighWaterLine = this.bufferHighWaterLine();
    var buffered = this.tech_.buffered();
    return shouldSwitchToMedia({
      buffered,
      currentTime,
      currentPlaylist,
      nextPlaylist,
      bufferLowWaterLine,
      bufferHighWaterLine,
      duration: this.duration(),
      experimentalBufferBasedABR: this.experimentalBufferBasedABR,
      log: this.logger_
    });
  };
  _proto.setupSegmentLoaderListeners_ = function setupSegmentLoaderListeners_() {
    var _this4 = this;
    if (!this.experimentalBufferBasedABR) {
      this.mainSegmentLoader_.on("bandwidthupdate", function() {
        var nextPlaylist = _this4.selectPlaylist();
        if (_this4.shouldSwitchToMedia_(nextPlaylist)) {
          _this4.switchMedia_(nextPlaylist, "bandwidthupdate");
        }
        _this4.tech_.trigger("bandwidthupdate");
      });
      this.mainSegmentLoader_.on("progress", function() {
        _this4.trigger("progress");
      });
    }
    this.mainSegmentLoader_.on("error", function() {
      _this4.blacklistCurrentPlaylist(_this4.mainSegmentLoader_.error());
    });
    this.mainSegmentLoader_.on("appenderror", function() {
      _this4.error = _this4.mainSegmentLoader_.error_;
      _this4.trigger("error");
    });
    this.mainSegmentLoader_.on("syncinfoupdate", function() {
      _this4.onSyncInfoUpdate_();
    });
    this.mainSegmentLoader_.on("timestampoffset", function() {
      _this4.tech_.trigger({
        type: "usage",
        name: "vhs-timestamp-offset"
      });
      _this4.tech_.trigger({
        type: "usage",
        name: "hls-timestamp-offset"
      });
    });
    this.audioSegmentLoader_.on("syncinfoupdate", function() {
      _this4.onSyncInfoUpdate_();
    });
    this.audioSegmentLoader_.on("appenderror", function() {
      _this4.error = _this4.audioSegmentLoader_.error_;
      _this4.trigger("error");
    });
    this.mainSegmentLoader_.on("ended", function() {
      _this4.logger_("main segment loader ended");
      _this4.onEndOfStream();
    });
    this.mainSegmentLoader_.on("earlyabort", function(event) {
      if (_this4.experimentalBufferBasedABR) {
        return;
      }
      _this4.delegateLoaders_("all", ["abort"]);
      _this4.blacklistCurrentPlaylist({
        message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
      }, ABORT_EARLY_BLACKLIST_SECONDS);
    });
    var updateCodecs = function updateCodecs2() {
      if (!_this4.sourceUpdater_.hasCreatedSourceBuffers()) {
        return _this4.tryToCreateSourceBuffers_();
      }
      var codecs = _this4.getCodecsOrExclude_();
      if (!codecs) {
        return;
      }
      _this4.sourceUpdater_.addOrChangeSourceBuffers(codecs);
    };
    this.mainSegmentLoader_.on("trackinfo", updateCodecs);
    this.audioSegmentLoader_.on("trackinfo", updateCodecs);
    this.mainSegmentLoader_.on("fmp4", function() {
      if (!_this4.triggeredFmp4Usage) {
        _this4.tech_.trigger({
          type: "usage",
          name: "vhs-fmp4"
        });
        _this4.tech_.trigger({
          type: "usage",
          name: "hls-fmp4"
        });
        _this4.triggeredFmp4Usage = true;
      }
    });
    this.audioSegmentLoader_.on("fmp4", function() {
      if (!_this4.triggeredFmp4Usage) {
        _this4.tech_.trigger({
          type: "usage",
          name: "vhs-fmp4"
        });
        _this4.tech_.trigger({
          type: "usage",
          name: "hls-fmp4"
        });
        _this4.triggeredFmp4Usage = true;
      }
    });
    this.audioSegmentLoader_.on("ended", function() {
      _this4.logger_("audioSegmentLoader ended");
      _this4.onEndOfStream();
    });
  };
  _proto.mediaSecondsLoaded_ = function mediaSecondsLoaded_() {
    return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
  };
  _proto.load = function load() {
    this.mainSegmentLoader_.load();
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      this.audioSegmentLoader_.load();
    }
    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
      this.subtitleSegmentLoader_.load();
    }
  };
  _proto.smoothQualityChange_ = function smoothQualityChange_(media) {
    if (media === void 0) {
      media = this.selectPlaylist();
    }
    this.fastQualityChange_(media);
  };
  _proto.fastQualityChange_ = function fastQualityChange_(media) {
    var _this5 = this;
    if (media === void 0) {
      media = this.selectPlaylist();
    }
    if (media === this.masterPlaylistLoader_.media()) {
      this.logger_("skipping fastQualityChange because new media is same as old");
      return;
    }
    this.switchMedia_(media, "fast-quality");
    this.mainSegmentLoader_.resetEverything(function() {
      if (videojs.browser.IE_VERSION || videojs.browser.IS_EDGE) {
        _this5.tech_.setCurrentTime(_this5.tech_.currentTime() + 0.04);
      } else {
        _this5.tech_.setCurrentTime(_this5.tech_.currentTime());
      }
    });
  };
  _proto.play = function play() {
    if (this.setupFirstPlay()) {
      return;
    }
    if (this.tech_.ended()) {
      this.tech_.setCurrentTime(0);
    }
    if (this.hasPlayed_) {
      this.load();
    }
    var seekable3 = this.tech_.seekable();
    if (this.tech_.duration() === Infinity) {
      if (this.tech_.currentTime() < seekable3.start(0)) {
        return this.tech_.setCurrentTime(seekable3.end(seekable3.length - 1));
      }
    }
  };
  _proto.setupFirstPlay = function setupFirstPlay() {
    var _this6 = this;
    var media = this.masterPlaylistLoader_.media();
    if (!media || this.tech_.paused() || this.hasPlayed_) {
      return false;
    }
    if (!media.endList) {
      var seekable3 = this.seekable();
      if (!seekable3.length) {
        return false;
      }
      if (videojs.browser.IE_VERSION && this.tech_.readyState() === 0) {
        this.tech_.one("loadedmetadata", function() {
          _this6.trigger("firstplay");
          _this6.tech_.setCurrentTime(seekable3.end(0));
          _this6.hasPlayed_ = true;
        });
        return false;
      }
      this.trigger("firstplay");
      this.tech_.setCurrentTime(seekable3.end(0));
    }
    this.hasPlayed_ = true;
    this.load();
    return true;
  };
  _proto.handleSourceOpen_ = function handleSourceOpen_() {
    this.tryToCreateSourceBuffers_();
    if (this.tech_.autoplay()) {
      var playPromise = this.tech_.play();
      if (typeof playPromise !== "undefined" && typeof playPromise.then === "function") {
        playPromise.then(null, function(e2) {
        });
      }
    }
    this.trigger("sourceopen");
  };
  _proto.handleSourceEnded_ = function handleSourceEnded_() {
    if (!this.inbandTextTracks_.metadataTrack_) {
      return;
    }
    var cues = this.inbandTextTracks_.metadataTrack_.cues;
    if (!cues || !cues.length) {
      return;
    }
    var duration5 = this.duration();
    cues[cues.length - 1].endTime = isNaN(duration5) || Math.abs(duration5) === Infinity ? Number.MAX_VALUE : duration5;
  };
  _proto.handleDurationChange_ = function handleDurationChange_() {
    this.tech_.trigger("durationchange");
  };
  _proto.onEndOfStream = function onEndOfStream() {
    var isEndOfStream = this.mainSegmentLoader_.ended_;
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      var mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
      if (!mainMediaInfo || mainMediaInfo.hasVideo) {
        isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_;
      } else {
        isEndOfStream = this.audioSegmentLoader_.ended_;
      }
    }
    if (!isEndOfStream) {
      return;
    }
    this.stopABRTimer_();
    this.sourceUpdater_.endOfStream();
  };
  _proto.stuckAtPlaylistEnd_ = function stuckAtPlaylistEnd_(playlist) {
    var seekable3 = this.seekable();
    if (!seekable3.length) {
      return false;
    }
    var expired = this.syncController_.getExpiredTime(playlist, this.duration());
    if (expired === null) {
      return false;
    }
    var absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    if (!buffered.length) {
      return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
    }
    var bufferedEnd = buffered.end(buffered.length - 1);
    return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
  };
  _proto.blacklistCurrentPlaylist = function blacklistCurrentPlaylist(error, blacklistDuration) {
    if (error === void 0) {
      error = {};
    }
    var currentPlaylist = error.playlist || this.masterPlaylistLoader_.media();
    blacklistDuration = blacklistDuration || error.blacklistDuration || this.blacklistDuration;
    if (!currentPlaylist) {
      this.error = error;
      if (this.mediaSource.readyState !== "open") {
        this.trigger("error");
      } else {
        this.sourceUpdater_.endOfStream("network");
      }
      return;
    }
    currentPlaylist.playlistErrors_++;
    var playlists = this.masterPlaylistLoader_.master.playlists;
    var enabledPlaylists = playlists.filter(isEnabled);
    var isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === currentPlaylist;
    if (playlists.length === 1 && blacklistDuration !== Infinity) {
      videojs.log.warn("Problem encountered with playlist " + currentPlaylist.id + ". Trying again since it is the only playlist.");
      this.tech_.trigger("retryplaylist");
      return this.masterPlaylistLoader_.load(isFinalRendition);
    }
    if (isFinalRendition) {
      var reincluded = false;
      playlists.forEach(function(playlist) {
        if (playlist === currentPlaylist) {
          return;
        }
        var excludeUntil2 = playlist.excludeUntil;
        if (typeof excludeUntil2 !== "undefined" && excludeUntil2 !== Infinity) {
          reincluded = true;
          delete playlist.excludeUntil;
        }
      });
      if (reincluded) {
        videojs.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded.");
        this.tech_.trigger("retryplaylist");
      }
    }
    var excludeUntil;
    if (currentPlaylist.playlistErrors_ > this.maxPlaylistRetries) {
      excludeUntil = Infinity;
    } else {
      excludeUntil = Date.now() + blacklistDuration * 1e3;
    }
    currentPlaylist.excludeUntil = excludeUntil;
    if (error.reason) {
      currentPlaylist.lastExcludeReason_ = error.reason;
    }
    this.tech_.trigger("blacklistplaylist");
    this.tech_.trigger({
      type: "usage",
      name: "vhs-rendition-blacklisted"
    });
    this.tech_.trigger({
      type: "usage",
      name: "hls-rendition-blacklisted"
    });
    var nextPlaylist = this.selectPlaylist();
    if (!nextPlaylist) {
      this.error = "Playback cannot continue. No available working or supported playlists.";
      this.trigger("error");
      return;
    }
    var logFn2 = error.internal ? this.logger_ : videojs.log.warn;
    var errorMessage = error.message ? " " + error.message : "";
    logFn2((error.internal ? "Internal problem" : "Problem") + " encountered with playlist " + currentPlaylist.id + "." + (errorMessage + " Switching to playlist " + nextPlaylist.id + "."));
    if (nextPlaylist.attributes.AUDIO !== currentPlaylist.attributes.AUDIO) {
      this.delegateLoaders_("audio", ["abort", "pause"]);
    }
    if (nextPlaylist.attributes.SUBTITLES !== currentPlaylist.attributes.SUBTITLES) {
      this.delegateLoaders_("subtitle", ["abort", "pause"]);
    }
    this.delegateLoaders_("main", ["abort", "pause"]);
    var delayDuration = nextPlaylist.targetDuration / 2 * 1e3 || 5 * 1e3;
    var shouldDelay = typeof nextPlaylist.lastRequest === "number" && Date.now() - nextPlaylist.lastRequest <= delayDuration;
    return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
  };
  _proto.pauseLoading = function pauseLoading() {
    this.delegateLoaders_("all", ["abort", "pause"]);
    this.stopABRTimer_();
  };
  _proto.delegateLoaders_ = function delegateLoaders_(filter2, fnNames) {
    var _this7 = this;
    var loaders = [];
    var dontFilterPlaylist = filter2 === "all";
    if (dontFilterPlaylist || filter2 === "main") {
      loaders.push(this.masterPlaylistLoader_);
    }
    var mediaTypes2 = [];
    if (dontFilterPlaylist || filter2 === "audio") {
      mediaTypes2.push("AUDIO");
    }
    if (dontFilterPlaylist || filter2 === "subtitle") {
      mediaTypes2.push("CLOSED-CAPTIONS");
      mediaTypes2.push("SUBTITLES");
    }
    mediaTypes2.forEach(function(mediaType) {
      var loader2 = _this7.mediaTypes_[mediaType] && _this7.mediaTypes_[mediaType].activePlaylistLoader;
      if (loader2) {
        loaders.push(loader2);
      }
    });
    ["main", "audio", "subtitle"].forEach(function(name) {
      var loader2 = _this7[name + "SegmentLoader_"];
      if (loader2 && (filter2 === name || filter2 === "all")) {
        loaders.push(loader2);
      }
    });
    loaders.forEach(function(loader2) {
      return fnNames.forEach(function(fnName) {
        if (typeof loader2[fnName] === "function") {
          loader2[fnName]();
        }
      });
    });
  };
  _proto.setCurrentTime = function setCurrentTime(currentTime) {
    var buffered = findRange(this.tech_.buffered(), currentTime);
    if (!(this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media())) {
      return 0;
    }
    if (!this.masterPlaylistLoader_.media().segments) {
      return 0;
    }
    if (buffered && buffered.length) {
      return currentTime;
    }
    this.mainSegmentLoader_.resetEverything();
    this.mainSegmentLoader_.abort();
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      this.audioSegmentLoader_.resetEverything();
      this.audioSegmentLoader_.abort();
    }
    if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
      this.subtitleSegmentLoader_.resetEverything();
      this.subtitleSegmentLoader_.abort();
    }
    this.load();
  };
  _proto.duration = function duration5() {
    if (!this.masterPlaylistLoader_) {
      return 0;
    }
    var media = this.masterPlaylistLoader_.media();
    if (!media) {
      return 0;
    }
    if (!media.endList) {
      return Infinity;
    }
    if (this.mediaSource) {
      return this.mediaSource.duration;
    }
    return Vhs$1.Playlist.duration(media);
  };
  _proto.seekable = function seekable3() {
    return this.seekable_;
  };
  _proto.onSyncInfoUpdate_ = function onSyncInfoUpdate_() {
    var audioSeekable;
    if (!this.masterPlaylistLoader_) {
      return;
    }
    var media = this.masterPlaylistLoader_.media();
    if (!media) {
      return;
    }
    var expired = this.syncController_.getExpiredTime(media, this.duration());
    if (expired === null) {
      return;
    }
    var master = this.masterPlaylistLoader_.master;
    var mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
    if (mainSeekable.length === 0) {
      return;
    }
    if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
      media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();
      expired = this.syncController_.getExpiredTime(media, this.duration());
      if (expired === null) {
        return;
      }
      audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(master, media));
      if (audioSeekable.length === 0) {
        return;
      }
    }
    var oldEnd;
    var oldStart;
    if (this.seekable_ && this.seekable_.length) {
      oldEnd = this.seekable_.end(0);
      oldStart = this.seekable_.start(0);
    }
    if (!audioSeekable) {
      this.seekable_ = mainSeekable;
    } else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) {
      this.seekable_ = mainSeekable;
    } else {
      this.seekable_ = videojs.createTimeRanges([[audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0)]]);
    }
    if (this.seekable_ && this.seekable_.length) {
      if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) {
        return;
      }
    }
    this.logger_("seekable updated [" + printableRange(this.seekable_) + "]");
    this.tech_.trigger("seekablechanged");
  };
  _proto.updateDuration = function updateDuration(isLive) {
    if (this.updateDuration_) {
      this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
      this.updateDuration_ = null;
    }
    if (this.mediaSource.readyState !== "open") {
      this.updateDuration_ = this.updateDuration.bind(this, isLive);
      this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
      return;
    }
    if (isLive) {
      var seekable3 = this.seekable();
      if (!seekable3.length) {
        return;
      }
      if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable3.end(seekable3.length - 1)) {
        this.sourceUpdater_.setDuration(seekable3.end(seekable3.length - 1));
      }
      return;
    }
    var buffered = this.tech_.buffered();
    var duration5 = Vhs$1.Playlist.duration(this.masterPlaylistLoader_.media());
    if (buffered.length > 0) {
      duration5 = Math.max(duration5, buffered.end(buffered.length - 1));
    }
    if (this.mediaSource.duration !== duration5) {
      this.sourceUpdater_.setDuration(duration5);
    }
  };
  _proto.dispose = function dispose() {
    var _this8 = this;
    this.trigger("dispose");
    this.decrypter_.terminate();
    this.masterPlaylistLoader_.dispose();
    this.mainSegmentLoader_.dispose();
    if (this.loadOnPlay_) {
      this.tech_.off("play", this.loadOnPlay_);
    }
    ["AUDIO", "SUBTITLES"].forEach(function(type2) {
      var groups = _this8.mediaTypes_[type2].groups;
      for (var id2 in groups) {
        groups[id2].forEach(function(group) {
          if (group.playlistLoader) {
            group.playlistLoader.dispose();
          }
        });
      }
    });
    this.audioSegmentLoader_.dispose();
    this.subtitleSegmentLoader_.dispose();
    this.sourceUpdater_.dispose();
    this.timelineChangeController_.dispose();
    this.stopABRTimer_();
    if (this.updateDuration_) {
      this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
    }
    this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_);
    this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_);
    this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_);
    this.off();
  };
  _proto.master = function master() {
    return this.masterPlaylistLoader_.master;
  };
  _proto.media = function media() {
    return this.masterPlaylistLoader_.media() || this.initialMedia_;
  };
  _proto.areMediaTypesKnown_ = function areMediaTypesKnown_() {
    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    var hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
    var hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
    if (!hasMainMediaInfo || !hasAudioMediaInfo) {
      return false;
    }
    return true;
  };
  _proto.getCodecsOrExclude_ = function getCodecsOrExclude_() {
    var _this9 = this;
    var media = {
      main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
      audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
    };
    media.video = media.main;
    var playlistCodecs = codecsForPlaylist(this.master(), this.media());
    var codecs = {};
    var usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
    if (media.main.hasVideo) {
      codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;
    }
    if (media.main.isMuxed) {
      codecs.video += "," + (playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC);
    }
    if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
      codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC;
      media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
    }
    if (!codecs.audio && !codecs.video) {
      this.blacklistCurrentPlaylist({
        playlist: this.media(),
        message: "Could not determine codecs for playlist.",
        blacklistDuration: Infinity
      });
      return;
    }
    var supportFunction = function supportFunction2(isFmp4, codec) {
      return isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);
    };
    var unsupportedCodecs = {};
    var unsupportedAudio;
    ["video", "audio"].forEach(function(type2) {
      if (codecs.hasOwnProperty(type2) && !supportFunction(media[type2].isFmp4, codecs[type2])) {
        var supporter = media[type2].isFmp4 ? "browser" : "muxer";
        unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
        unsupportedCodecs[supporter].push(codecs[type2]);
        if (type2 === "audio") {
          unsupportedAudio = supporter;
        }
      }
    });
    if (usingAudioLoader && unsupportedAudio && this.media().attributes.AUDIO) {
      var audioGroup = this.media().attributes.AUDIO;
      this.master().playlists.forEach(function(variant) {
        var variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
        if (variantAudioGroup === audioGroup && variant !== _this9.media()) {
          variant.excludeUntil = Infinity;
        }
      });
      this.logger_("excluding audio group " + audioGroup + " as " + unsupportedAudio + ' does not support codec(s): "' + codecs.audio + '"');
    }
    if (Object.keys(unsupportedCodecs).length) {
      var message = Object.keys(unsupportedCodecs).reduce(function(acc, supporter) {
        if (acc) {
          acc += ", ";
        }
        acc += supporter + ' does not support codec(s): "' + unsupportedCodecs[supporter].join(",") + '"';
        return acc;
      }, "") + ".";
      this.blacklistCurrentPlaylist({
        playlist: this.media(),
        internal: true,
        message,
        blacklistDuration: Infinity
      });
      return;
    }
    if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
      var switchMessages = [];
      ["video", "audio"].forEach(function(type2) {
        var newCodec = (parseCodecs(_this9.sourceUpdater_.codecs[type2] || "")[0] || {}).type;
        var oldCodec = (parseCodecs(codecs[type2] || "")[0] || {}).type;
        if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) {
          switchMessages.push('"' + _this9.sourceUpdater_.codecs[type2] + '" -> "' + codecs[type2] + '"');
        }
      });
      if (switchMessages.length) {
        this.blacklistCurrentPlaylist({
          playlist: this.media(),
          message: "Codec switching not supported: " + switchMessages.join(", ") + ".",
          blacklistDuration: Infinity,
          internal: true
        });
        return;
      }
    }
    return codecs;
  };
  _proto.tryToCreateSourceBuffers_ = function tryToCreateSourceBuffers_() {
    if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) {
      return;
    }
    if (!this.areMediaTypesKnown_()) {
      return;
    }
    var codecs = this.getCodecsOrExclude_();
    if (!codecs) {
      return;
    }
    this.sourceUpdater_.createSourceBuffers(codecs);
    var codecString = [codecs.video, codecs.audio].filter(Boolean).join(",");
    this.excludeIncompatibleVariants_(codecString);
  };
  _proto.excludeUnsupportedVariants_ = function excludeUnsupportedVariants_() {
    var _this10 = this;
    var playlists = this.master().playlists;
    var ids = [];
    Object.keys(playlists).forEach(function(key) {
      var variant = playlists[key];
      if (ids.indexOf(variant.id) !== -1) {
        return;
      }
      ids.push(variant.id);
      var codecs = codecsForPlaylist(_this10.master, variant);
      var unsupported = [];
      if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) {
        unsupported.push("audio codec " + codecs.audio);
      }
      if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) {
        unsupported.push("video codec " + codecs.video);
      }
      if (codecs.text && codecs.text === "stpp.ttml.im1t") {
        unsupported.push("text codec " + codecs.text);
      }
      if (unsupported.length) {
        variant.excludeUntil = Infinity;
        _this10.logger_("excluding " + variant.id + " for unsupported: " + unsupported.join(", "));
      }
    });
  };
  _proto.excludeIncompatibleVariants_ = function excludeIncompatibleVariants_(codecString) {
    var _this11 = this;
    var ids = [];
    var playlists = this.master().playlists;
    var codecs = unwrapCodecList(parseCodecs(codecString));
    var codecCount_ = codecCount(codecs);
    var videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;
    var audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;
    Object.keys(playlists).forEach(function(key) {
      var variant = playlists[key];
      if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === Infinity) {
        return;
      }
      ids.push(variant.id);
      var blacklistReasons = [];
      var variantCodecs = codecsForPlaylist(_this11.masterPlaylistLoader_.master, variant);
      var variantCodecCount = codecCount(variantCodecs);
      if (!variantCodecs.audio && !variantCodecs.video) {
        return;
      }
      if (variantCodecCount !== codecCount_) {
        blacklistReasons.push('codec count "' + variantCodecCount + '" !== "' + codecCount_ + '"');
      }
      if (!_this11.sourceUpdater_.canChangeType()) {
        var variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;
        var variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null;
        if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) {
          blacklistReasons.push('video codec "' + variantVideoDetails.type + '" !== "' + videoDetails.type + '"');
        }
        if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) {
          blacklistReasons.push('audio codec "' + variantAudioDetails.type + '" !== "' + audioDetails.type + '"');
        }
      }
      if (blacklistReasons.length) {
        variant.excludeUntil = Infinity;
        _this11.logger_("blacklisting " + variant.id + ": " + blacklistReasons.join(" && "));
      }
    });
  };
  _proto.updateAdCues_ = function updateAdCues_(media) {
    var offset3 = 0;
    var seekable3 = this.seekable();
    if (seekable3.length) {
      offset3 = seekable3.start(0);
    }
    updateAdCues(media, this.cueTagsTrack_, offset3);
  };
  _proto.goalBufferLength = function goalBufferLength() {
    var currentTime = this.tech_.currentTime();
    var initial = Config.GOAL_BUFFER_LENGTH;
    var rate = Config.GOAL_BUFFER_LENGTH_RATE;
    var max2 = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
    return Math.min(initial + currentTime * rate, max2);
  };
  _proto.bufferLowWaterLine = function bufferLowWaterLine() {
    var currentTime = this.tech_.currentTime();
    var initial = Config.BUFFER_LOW_WATER_LINE;
    var rate = Config.BUFFER_LOW_WATER_LINE_RATE;
    var max2 = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);
    var newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
    return Math.min(initial + currentTime * rate, this.experimentalBufferBasedABR ? newMax : max2);
  };
  _proto.bufferHighWaterLine = function bufferHighWaterLine() {
    return Config.BUFFER_HIGH_WATER_LINE;
  };
  return MasterPlaylistController2;
}(videojs.EventTarget);
var enableFunction = function enableFunction2(loader2, playlistID, changePlaylistFn) {
  return function(enable) {
    var playlist = loader2.master.playlists[playlistID];
    var incompatible = isIncompatible(playlist);
    var currentlyEnabled = isEnabled(playlist);
    if (typeof enable === "undefined") {
      return currentlyEnabled;
    }
    if (enable) {
      delete playlist.disabled;
    } else {
      playlist.disabled = true;
    }
    if (enable !== currentlyEnabled && !incompatible) {
      changePlaylistFn();
      if (enable) {
        loader2.trigger("renditionenabled");
      } else {
        loader2.trigger("renditiondisabled");
      }
    }
    return enable;
  };
};
var Representation = function Representation2(vhsHandler, playlist, id2) {
  var mpc = vhsHandler.masterPlaylistController_, smoothQualityChange = vhsHandler.options_.smoothQualityChange;
  var changeType2 = smoothQualityChange ? "smooth" : "fast";
  var qualityChangeFunction = mpc[changeType2 + "QualityChange_"].bind(mpc);
  if (playlist.attributes) {
    var resolution = playlist.attributes.RESOLUTION;
    this.width = resolution && resolution.width;
    this.height = resolution && resolution.height;
    this.bandwidth = playlist.attributes.BANDWIDTH;
  }
  this.codecs = codecsForPlaylist(mpc.master(), playlist);
  this.playlist = playlist;
  this.id = id2;
  this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
};
var renditionSelectionMixin = function renditionSelectionMixin2(vhsHandler) {
  vhsHandler.representations = function() {
    var master = vhsHandler.masterPlaylistController_.master();
    var playlists = isAudioOnly(master) ? vhsHandler.masterPlaylistController_.getAudioTrackPlaylists_() : master.playlists;
    if (!playlists) {
      return [];
    }
    return playlists.filter(function(media) {
      return !isIncompatible(media);
    }).map(function(e2, i) {
      return new Representation(vhsHandler, e2, e2.id);
    });
  };
};
var timerCancelEvents = ["seeking", "seeked", "pause", "playing", "error"];
var PlaybackWatcher = /* @__PURE__ */ function() {
  function PlaybackWatcher2(options) {
    var _this = this;
    this.masterPlaylistController_ = options.masterPlaylistController;
    this.tech_ = options.tech;
    this.seekable = options.seekable;
    this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
    this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
    this.media = options.media;
    this.consecutiveUpdates = 0;
    this.lastRecordedTime = null;
    this.timer_ = null;
    this.checkCurrentTimeTimeout_ = null;
    this.logger_ = logger("PlaybackWatcher");
    this.logger_("initialize");
    var playHandler = function playHandler2() {
      return _this.monitorCurrentTime_();
    };
    var canPlayHandler = function canPlayHandler2() {
      return _this.monitorCurrentTime_();
    };
    var waitingHandler = function waitingHandler2() {
      return _this.techWaiting_();
    };
    var cancelTimerHandler = function cancelTimerHandler2() {
      return _this.cancelTimer_();
    };
    var mpc = this.masterPlaylistController_;
    var loaderTypes = ["main", "subtitle", "audio"];
    var loaderChecks = {};
    loaderTypes.forEach(function(type2) {
      loaderChecks[type2] = {
        reset: function reset3() {
          return _this.resetSegmentDownloads_(type2);
        },
        updateend: function updateend() {
          return _this.checkSegmentDownloads_(type2);
        }
      };
      mpc[type2 + "SegmentLoader_"].on("appendsdone", loaderChecks[type2].updateend);
      mpc[type2 + "SegmentLoader_"].on("playlistupdate", loaderChecks[type2].reset);
      _this.tech_.on(["seeked", "seeking"], loaderChecks[type2].reset);
    });
    var setSeekingHandlers = function setSeekingHandlers2(fn2) {
      ["main", "audio"].forEach(function(type2) {
        mpc[type2 + "SegmentLoader_"][fn2]("appended", _this.seekingAppendCheck_);
      });
    };
    this.seekingAppendCheck_ = function() {
      if (_this.fixesBadSeeks_()) {
        _this.consecutiveUpdates = 0;
        _this.lastRecordedTime = _this.tech_.currentTime();
        setSeekingHandlers("off");
      }
    };
    this.clearSeekingAppendCheck_ = function() {
      return setSeekingHandlers("off");
    };
    this.watchForBadSeeking_ = function() {
      _this.clearSeekingAppendCheck_();
      setSeekingHandlers("on");
    };
    this.tech_.on("seeked", this.clearSeekingAppendCheck_);
    this.tech_.on("seeking", this.watchForBadSeeking_);
    this.tech_.on("waiting", waitingHandler);
    this.tech_.on(timerCancelEvents, cancelTimerHandler);
    this.tech_.on("canplay", canPlayHandler);
    this.tech_.one("play", playHandler);
    this.dispose = function() {
      _this.clearSeekingAppendCheck_();
      _this.logger_("dispose");
      _this.tech_.off("waiting", waitingHandler);
      _this.tech_.off(timerCancelEvents, cancelTimerHandler);
      _this.tech_.off("canplay", canPlayHandler);
      _this.tech_.off("play", playHandler);
      _this.tech_.off("seeking", _this.watchForBadSeeking_);
      _this.tech_.off("seeked", _this.clearSeekingAppendCheck_);
      loaderTypes.forEach(function(type2) {
        mpc[type2 + "SegmentLoader_"].off("appendsdone", loaderChecks[type2].updateend);
        mpc[type2 + "SegmentLoader_"].off("playlistupdate", loaderChecks[type2].reset);
        _this.tech_.off(["seeked", "seeking"], loaderChecks[type2].reset);
      });
      if (_this.checkCurrentTimeTimeout_) {
        window_1.clearTimeout(_this.checkCurrentTimeTimeout_);
      }
      _this.cancelTimer_();
    };
  }
  var _proto = PlaybackWatcher2.prototype;
  _proto.monitorCurrentTime_ = function monitorCurrentTime_() {
    this.checkCurrentTime_();
    if (this.checkCurrentTimeTimeout_) {
      window_1.clearTimeout(this.checkCurrentTimeTimeout_);
    }
    this.checkCurrentTimeTimeout_ = window_1.setTimeout(this.monitorCurrentTime_.bind(this), 250);
  };
  _proto.resetSegmentDownloads_ = function resetSegmentDownloads_(type2) {
    var loader2 = this.masterPlaylistController_[type2 + "SegmentLoader_"];
    if (this[type2 + "StalledDownloads_"] > 0) {
      this.logger_("resetting possible stalled download count for " + type2 + " loader");
    }
    this[type2 + "StalledDownloads_"] = 0;
    this[type2 + "Buffered_"] = loader2.buffered_();
  };
  _proto.checkSegmentDownloads_ = function checkSegmentDownloads_(type2) {
    var mpc = this.masterPlaylistController_;
    var loader2 = mpc[type2 + "SegmentLoader_"];
    var buffered = loader2.buffered_();
    var isBufferedDifferent = isRangeDifferent(this[type2 + "Buffered_"], buffered);
    this[type2 + "Buffered_"] = buffered;
    if (isBufferedDifferent) {
      this.resetSegmentDownloads_(type2);
      return;
    }
    this[type2 + "StalledDownloads_"]++;
    this.logger_("found #" + this[type2 + "StalledDownloads_"] + " " + type2 + " appends that did not increase buffer (possible stalled download)", {
      playlistId: loader2.playlist_ && loader2.playlist_.id,
      buffered: timeRangesToArray(buffered)
    });
    if (this[type2 + "StalledDownloads_"] < 10) {
      return;
    }
    this.logger_(type2 + " loader stalled download exclusion");
    this.resetSegmentDownloads_(type2);
    this.tech_.trigger({
      type: "usage",
      name: "vhs-" + type2 + "-download-exclusion"
    });
    if (type2 === "subtitle") {
      return;
    }
    mpc.blacklistCurrentPlaylist({
      message: "Excessive " + type2 + " segment downloading detected."
    }, Infinity);
  };
  _proto.checkCurrentTime_ = function checkCurrentTime_() {
    if (this.tech_.paused() || this.tech_.seeking()) {
      return;
    }
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) {
      return this.techWaiting_();
    }
    if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
      this.consecutiveUpdates++;
      this.waiting_();
    } else if (currentTime === this.lastRecordedTime) {
      this.consecutiveUpdates++;
    } else {
      this.consecutiveUpdates = 0;
      this.lastRecordedTime = currentTime;
    }
  };
  _proto.cancelTimer_ = function cancelTimer_() {
    this.consecutiveUpdates = 0;
    if (this.timer_) {
      this.logger_("cancelTimer_");
      clearTimeout(this.timer_);
    }
    this.timer_ = null;
  };
  _proto.fixesBadSeeks_ = function fixesBadSeeks_() {
    var seeking = this.tech_.seeking();
    if (!seeking) {
      return false;
    }
    var seekable3 = this.seekable();
    var currentTime = this.tech_.currentTime();
    var isAfterSeekableRange = this.afterSeekableWindow_(seekable3, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
    var seekTo;
    if (isAfterSeekableRange) {
      var seekableEnd = seekable3.end(seekable3.length - 1);
      seekTo = seekableEnd;
    }
    if (this.beforeSeekableWindow_(seekable3, currentTime)) {
      var seekableStart = seekable3.start(0);
      seekTo = seekableStart + // if the playlist is too short and the seekable range is an exact time (can
      // happen in live with a 3 segment playlist), then don't use a time delta
      (seekableStart === seekable3.end(0) ? 0 : SAFE_TIME_DELTA);
    }
    if (typeof seekTo !== "undefined") {
      this.logger_("Trying to seek outside of seekable at time " + currentTime + " with " + ("seekable range " + printableRange(seekable3) + ". Seeking to ") + (seekTo + "."));
      this.tech_.setCurrentTime(seekTo);
      return true;
    }
    var sourceUpdater = this.masterPlaylistController_.sourceUpdater_;
    var buffered = this.tech_.buffered();
    var audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
    var videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
    var media = this.media();
    var minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2;
    var bufferedToCheck = [audioBuffered, videoBuffered];
    for (var i = 0; i < bufferedToCheck.length; i++) {
      if (!bufferedToCheck[i]) {
        continue;
      }
      var timeAhead = timeAheadOf(bufferedToCheck[i], currentTime);
      if (timeAhead < minAppendedDuration) {
        return false;
      }
    }
    var nextRange = findNextRange(buffered, currentTime);
    if (nextRange.length === 0) {
      return false;
    }
    seekTo = nextRange.start(0) + SAFE_TIME_DELTA;
    this.logger_("Buffered region starts (" + nextRange.start(0) + ") " + (" just beyond seek point (" + currentTime + "). Seeking to " + seekTo + "."));
    this.tech_.setCurrentTime(seekTo);
    return true;
  };
  _proto.waiting_ = function waiting_() {
    if (this.techWaiting_()) {
      return;
    }
    var currentTime = this.tech_.currentTime();
    var buffered = this.tech_.buffered();
    var currentRange = findRange(buffered, currentTime);
    if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
      this.cancelTimer_();
      this.tech_.setCurrentTime(currentTime);
      this.logger_("Stopped at " + currentTime + " while inside a buffered region " + ("[" + currentRange.start(0) + " -> " + currentRange.end(0) + "]. Attempting to resume ") + "playback by seeking to the current time.");
      this.tech_.trigger({
        type: "usage",
        name: "vhs-unknown-waiting"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-unknown-waiting"
      });
      return;
    }
  };
  _proto.techWaiting_ = function techWaiting_() {
    var seekable3 = this.seekable();
    var currentTime = this.tech_.currentTime();
    if (this.tech_.seeking() || this.timer_ !== null) {
      return true;
    }
    if (this.beforeSeekableWindow_(seekable3, currentTime)) {
      var livePoint = seekable3.end(seekable3.length - 1);
      this.logger_("Fell out of live window at time " + currentTime + ". Seeking to " + ("live point (seekable end) " + livePoint));
      this.cancelTimer_();
      this.tech_.setCurrentTime(livePoint);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-live-resync"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-live-resync"
      });
      return true;
    }
    var sourceUpdater = this.tech_.vhs.masterPlaylistController_.sourceUpdater_;
    var buffered = this.tech_.buffered();
    var videoUnderflow = this.videoUnderflow_({
      audioBuffered: sourceUpdater.audioBuffered(),
      videoBuffered: sourceUpdater.videoBuffered(),
      currentTime
    });
    if (videoUnderflow) {
      this.cancelTimer_();
      this.tech_.setCurrentTime(currentTime);
      this.tech_.trigger({
        type: "usage",
        name: "vhs-video-underflow"
      });
      this.tech_.trigger({
        type: "usage",
        name: "hls-video-underflow"
      });
      return true;
    }
    var nextRange = findNextRange(buffered, currentTime);
    if (nextRange.length > 0) {
      var difference = nextRange.start(0) - currentTime;
      this.logger_("Stopped at " + currentTime + ", setting timer for " + difference + ", seeking " + ("to " + nextRange.start(0)));
      this.cancelTimer_();
      this.timer_ = setTimeout(this.skipTheGap_.bind(this), difference * 1e3, currentTime);
      return true;
    }
    return false;
  };
  _proto.afterSeekableWindow_ = function afterSeekableWindow_(seekable3, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow) {
    if (allowSeeksWithinUnsafeLiveWindow === void 0) {
      allowSeeksWithinUnsafeLiveWindow = false;
    }
    if (!seekable3.length) {
      return false;
    }
    var allowedEnd = seekable3.end(seekable3.length - 1) + SAFE_TIME_DELTA;
    var isLive = !playlist.endList;
    if (isLive && allowSeeksWithinUnsafeLiveWindow) {
      allowedEnd = seekable3.end(seekable3.length - 1) + playlist.targetDuration * 3;
    }
    if (currentTime > allowedEnd) {
      return true;
    }
    return false;
  };
  _proto.beforeSeekableWindow_ = function beforeSeekableWindow_(seekable3, currentTime) {
    if (seekable3.length && // can't fall before 0 and 0 seekable start identifies VOD stream
    seekable3.start(0) > 0 && currentTime < seekable3.start(0) - this.liveRangeSafeTimeDelta) {
      return true;
    }
    return false;
  };
  _proto.videoUnderflow_ = function videoUnderflow_(_ref) {
    var videoBuffered = _ref.videoBuffered, audioBuffered = _ref.audioBuffered, currentTime = _ref.currentTime;
    if (!videoBuffered) {
      return;
    }
    var gap2;
    if (videoBuffered.length && audioBuffered.length) {
      var lastVideoRange = findRange(videoBuffered, currentTime - 3);
      var videoRange = findRange(videoBuffered, currentTime);
      var audioRange = findRange(audioBuffered, currentTime);
      if (audioRange.length && !videoRange.length && lastVideoRange.length) {
        gap2 = {
          start: lastVideoRange.end(0),
          end: audioRange.end(0)
        };
      }
    } else {
      var nextRange = findNextRange(videoBuffered, currentTime);
      if (!nextRange.length) {
        gap2 = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
      }
    }
    if (gap2) {
      this.logger_("Encountered a gap in video from " + gap2.start + " to " + gap2.end + ". " + ("Seeking to current time " + currentTime));
      return true;
    }
    return false;
  };
  _proto.skipTheGap_ = function skipTheGap_(scheduledCurrentTime) {
    var buffered = this.tech_.buffered();
    var currentTime = this.tech_.currentTime();
    var nextRange = findNextRange(buffered, currentTime);
    this.cancelTimer_();
    if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) {
      return;
    }
    this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0));
    this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);
    this.tech_.trigger({
      type: "usage",
      name: "vhs-gap-skip"
    });
    this.tech_.trigger({
      type: "usage",
      name: "hls-gap-skip"
    });
  };
  _proto.gapFromVideoUnderflow_ = function gapFromVideoUnderflow_(buffered, currentTime) {
    var gaps = findGaps(buffered);
    for (var i = 0; i < gaps.length; i++) {
      var start3 = gaps.start(i);
      var end2 = gaps.end(i);
      if (currentTime - start3 < 4 && currentTime - start3 > 2) {
        return {
          start: start3,
          end: end2
        };
      }
    }
    return null;
  };
  return PlaybackWatcher2;
}();
var defaultOptions = {
  errorInterval: 30,
  getSource: function getSource(next2) {
    var tech = this.tech({
      IWillNotUseThisInPlugins: true
    });
    var sourceObj = tech.currentSource_ || this.currentSource();
    return next2(sourceObj);
  }
};
var initPlugin = function initPlugin2(player, options) {
  var lastCalled = 0;
  var seekTo = 0;
  var localOptions = videojs.mergeOptions(defaultOptions, options);
  player.ready(function() {
    player.trigger({
      type: "usage",
      name: "vhs-error-reload-initialized"
    });
    player.trigger({
      type: "usage",
      name: "hls-error-reload-initialized"
    });
  });
  var loadedMetadataHandler = function loadedMetadataHandler2() {
    if (seekTo) {
      player.currentTime(seekTo);
    }
  };
  var setSource2 = function setSource3(sourceObj) {
    if (sourceObj === null || sourceObj === void 0) {
      return;
    }
    seekTo = player.duration() !== Infinity && player.currentTime() || 0;
    player.one("loadedmetadata", loadedMetadataHandler);
    player.src(sourceObj);
    player.trigger({
      type: "usage",
      name: "vhs-error-reload"
    });
    player.trigger({
      type: "usage",
      name: "hls-error-reload"
    });
    player.play();
  };
  var errorHandler = function errorHandler2() {
    if (Date.now() - lastCalled < localOptions.errorInterval * 1e3) {
      player.trigger({
        type: "usage",
        name: "vhs-error-reload-canceled"
      });
      player.trigger({
        type: "usage",
        name: "hls-error-reload-canceled"
      });
      return;
    }
    if (!localOptions.getSource || typeof localOptions.getSource !== "function") {
      videojs.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
      return;
    }
    lastCalled = Date.now();
    return localOptions.getSource.call(player, setSource2);
  };
  var cleanupEvents = function cleanupEvents2() {
    player.off("loadedmetadata", loadedMetadataHandler);
    player.off("error", errorHandler);
    player.off("dispose", cleanupEvents2);
  };
  var reinitPlugin = function reinitPlugin2(newOptions) {
    cleanupEvents();
    initPlugin2(player, newOptions);
  };
  player.on("error", errorHandler);
  player.on("dispose", cleanupEvents);
  player.reloadSourceOnError = reinitPlugin;
};
var reloadSourceOnError = function reloadSourceOnError2(options) {
  initPlugin(this, options);
};
var version$4 = "2.14.3";
var version$3 = "6.0.1";
var version$2 = "0.21.1";
var version$1 = "4.7.1";
var version = "3.1.3";
var Vhs = {
  PlaylistLoader,
  Playlist: Playlist2,
  utils: utils$1,
  STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
  INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,
  lastBandwidthSelector,
  movingAverageBandwidthSelector,
  comparePlaylistBandwidth,
  comparePlaylistResolution,
  xhr: xhrFactory()
};
Object.keys(Config).forEach(function(prop3) {
  Object.defineProperty(Vhs, prop3, {
    get: function get8() {
      videojs.log.warn("using Vhs." + prop3 + " is UNSAFE be sure you know what you are doing");
      return Config[prop3];
    },
    set: function set4(value) {
      videojs.log.warn("using Vhs." + prop3 + " is UNSAFE be sure you know what you are doing");
      if (typeof value !== "number" || value < 0) {
        videojs.log.warn("value of Vhs." + prop3 + " must be greater than or equal to 0");
        return;
      }
      Config[prop3] = value;
    }
  });
});
var LOCAL_STORAGE_KEY = "videojs-vhs";
var handleVhsMediaChange = function handleVhsMediaChange2(qualityLevels, playlistLoader) {
  var newPlaylist = playlistLoader.media();
  var selectedIndex = -1;
  for (var i = 0; i < qualityLevels.length; i++) {
    if (qualityLevels[i].id === newPlaylist.id) {
      selectedIndex = i;
      break;
    }
  }
  qualityLevels.selectedIndex_ = selectedIndex;
  qualityLevels.trigger({
    selectedIndex,
    type: "change"
  });
};
var handleVhsLoadedMetadata = function handleVhsLoadedMetadata2(qualityLevels, vhs) {
  vhs.representations().forEach(function(rep) {
    qualityLevels.addQualityLevel(rep);
  });
  handleVhsMediaChange(qualityLevels, vhs.playlists);
};
Vhs.canPlaySource = function() {
  return videojs.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
};
var emeKeySystems = function emeKeySystems2(keySystemOptions, mainPlaylist, audioPlaylist) {
  if (!keySystemOptions) {
    return keySystemOptions;
  }
  var codecs = {};
  if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) {
    codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));
  }
  if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) {
    codecs.audio = audioPlaylist.attributes.CODECS;
  }
  var videoContentType = getMimeForCodec(codecs.video);
  var audioContentType = getMimeForCodec(codecs.audio);
  var keySystemContentTypes = {};
  for (var keySystem in keySystemOptions) {
    keySystemContentTypes[keySystem] = {};
    if (audioContentType) {
      keySystemContentTypes[keySystem].audioContentType = audioContentType;
    }
    if (videoContentType) {
      keySystemContentTypes[keySystem].videoContentType = videoContentType;
    }
    if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) {
      keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
    }
    if (typeof keySystemOptions[keySystem] === "string") {
      keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
    }
  }
  return videojs.mergeOptions(keySystemOptions, keySystemContentTypes);
};
var getAllPsshKeySystemsOptions = function getAllPsshKeySystemsOptions2(playlists, keySystems) {
  return playlists.reduce(function(keySystemsArr, playlist) {
    if (!playlist.contentProtection) {
      return keySystemsArr;
    }
    var keySystemsOptions = keySystems.reduce(function(keySystemsObj, keySystem) {
      var keySystemOptions = playlist.contentProtection[keySystem];
      if (keySystemOptions && keySystemOptions.pssh) {
        keySystemsObj[keySystem] = {
          pssh: keySystemOptions.pssh
        };
      }
      return keySystemsObj;
    }, {});
    if (Object.keys(keySystemsOptions).length) {
      keySystemsArr.push(keySystemsOptions);
    }
    return keySystemsArr;
  }, []);
};
var waitForKeySessionCreation = function waitForKeySessionCreation2(_ref) {
  var player = _ref.player, sourceKeySystems = _ref.sourceKeySystems, audioMedia = _ref.audioMedia, mainPlaylists = _ref.mainPlaylists;
  if (!player.eme.initializeMediaKeys) {
    return Promise.resolve();
  }
  var playlists = audioMedia ? mainPlaylists.concat([audioMedia]) : mainPlaylists;
  var keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
  var initializationFinishedPromises = [];
  var keySessionCreatedPromises = [];
  keySystemsOptionsArr.forEach(function(keySystemsOptions) {
    keySessionCreatedPromises.push(new Promise(function(resolve, reject) {
      player.tech_.one("keysessioncreated", resolve);
    }));
    initializationFinishedPromises.push(new Promise(function(resolve, reject) {
      player.eme.initializeMediaKeys({
        keySystems: keySystemsOptions
      }, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    }));
  });
  return Promise.race([
    // If a session was previously created, these will all finish resolving without
    // creating a new session, otherwise it will take until the end of all license
    // requests, which is why the key session check is used (to make setup much faster).
    Promise.all(initializationFinishedPromises),
    // Once a single session is created, the browser knows DRM will be used.
    Promise.race(keySessionCreatedPromises)
  ]);
};
var setupEmeOptions = function setupEmeOptions2(_ref2) {
  var player = _ref2.player, sourceKeySystems = _ref2.sourceKeySystems, media = _ref2.media, audioMedia = _ref2.audioMedia;
  var sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);
  if (!sourceOptions) {
    return false;
  }
  player.currentSource().keySystems = sourceOptions;
  if (sourceOptions && !player.eme) {
    videojs.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin");
    return false;
  }
  return true;
};
var getVhsLocalStorage = function getVhsLocalStorage2() {
  if (!window_1.localStorage) {
    return null;
  }
  var storedObject = window_1.localStorage.getItem(LOCAL_STORAGE_KEY);
  if (!storedObject) {
    return null;
  }
  try {
    return JSON.parse(storedObject);
  } catch (e2) {
    return null;
  }
};
var updateVhsLocalStorage = function updateVhsLocalStorage2(options) {
  if (!window_1.localStorage) {
    return false;
  }
  var objectToStore = getVhsLocalStorage();
  objectToStore = objectToStore ? videojs.mergeOptions(objectToStore, options) : options;
  try {
    window_1.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
  } catch (e2) {
    return false;
  }
  return objectToStore;
};
var expandDataUri = function expandDataUri2(dataUri) {
  if (dataUri.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0) {
    return JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1));
  }
  return dataUri;
};
Vhs.supportsNativeHls = function() {
  if (!document_1 || !document_1.createElement) {
    return false;
  }
  var video2 = document_1.createElement("video");
  if (!videojs.getTech("Html5").isSupported()) {
    return false;
  }
  var canPlay = [
    // Apple santioned
    "application/vnd.apple.mpegurl",
    // Apple sanctioned for backwards compatibility
    "audio/mpegurl",
    // Very common
    "audio/x-mpegurl",
    // Very common
    "application/x-mpegurl",
    // Included for completeness
    "video/x-mpegurl",
    "video/mpegurl",
    "application/mpegurl"
  ];
  return canPlay.some(function(canItPlay) {
    return /maybe|probably/i.test(video2.canPlayType(canItPlay));
  });
}();
Vhs.supportsNativeDash = function() {
  if (!document_1 || !document_1.createElement || !videojs.getTech("Html5").isSupported()) {
    return false;
  }
  return /maybe|probably/i.test(document_1.createElement("video").canPlayType("application/dash+xml"));
}();
Vhs.supportsTypeNatively = function(type2) {
  if (type2 === "hls") {
    return Vhs.supportsNativeHls;
  }
  if (type2 === "dash") {
    return Vhs.supportsNativeDash;
  }
  return false;
};
Vhs.isSupported = function() {
  return videojs.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.");
};
var Component = videojs.getComponent("Component");
var VhsHandler = /* @__PURE__ */ function(_Component) {
  _inheritsLoose(VhsHandler2, _Component);
  function VhsHandler2(source, tech, options) {
    var _this;
    _this = _Component.call(this, tech, videojs.mergeOptions(options.hls, options.vhs)) || this;
    if (options.hls && Object.keys(options.hls).length) {
      videojs.log.warn("Using hls options is deprecated. Please rename `hls` to `vhs` in your options object.");
    }
    if (typeof options.initialBandwidth === "number") {
      _this.options_.bandwidth = options.initialBandwidth;
    }
    _this.logger_ = logger("VhsHandler");
    if (tech.options_ && tech.options_.playerId) {
      var _player = videojs(tech.options_.playerId);
      if (!_player.hasOwnProperty("hls")) {
        Object.defineProperty(_player, "hls", {
          get: function get8() {
            videojs.log.warn("player.hls is deprecated. Use player.tech().vhs instead.");
            tech.trigger({
              type: "usage",
              name: "hls-player-access"
            });
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      if (!_player.hasOwnProperty("vhs")) {
        Object.defineProperty(_player, "vhs", {
          get: function get8() {
            videojs.log.warn("player.vhs is deprecated. Use player.tech().vhs instead.");
            tech.trigger({
              type: "usage",
              name: "vhs-player-access"
            });
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      if (!_player.hasOwnProperty("dash")) {
        Object.defineProperty(_player, "dash", {
          get: function get8() {
            videojs.log.warn("player.dash is deprecated. Use player.tech().vhs instead.");
            return _assertThisInitialized(_this);
          },
          configurable: true
        });
      }
      _this.player_ = _player;
    }
    _this.tech_ = tech;
    _this.source_ = source;
    _this.stats = {};
    _this.ignoreNextSeekingEvent_ = false;
    _this.setOptions_();
    if (_this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
      tech.overrideNativeAudioTracks(true);
      tech.overrideNativeVideoTracks(true);
    } else if (_this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) {
      throw new Error("Overriding native HLS requires emulated tracks. See https://git.io/vMpjB");
    }
    _this.on(document_1, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], function(event) {
      var fullscreenElement = document_1.fullscreenElement || document_1.webkitFullscreenElement || document_1.mozFullScreenElement || document_1.msFullscreenElement;
      if (fullscreenElement && fullscreenElement.contains(_this.tech_.el())) {
        _this.masterPlaylistController_.fastQualityChange_();
      } else {
        _this.masterPlaylistController_.checkABR_();
      }
    });
    _this.on(_this.tech_, "seeking", function() {
      if (this.ignoreNextSeekingEvent_) {
        this.ignoreNextSeekingEvent_ = false;
        return;
      }
      this.setCurrentTime(this.tech_.currentTime());
    });
    _this.on(_this.tech_, "error", function() {
      if (this.tech_.error() && this.masterPlaylistController_) {
        this.masterPlaylistController_.pauseLoading();
      }
    });
    _this.on(_this.tech_, "play", _this.play);
    return _this;
  }
  var _proto = VhsHandler2.prototype;
  _proto.setOptions_ = function setOptions_() {
    var _this2 = this;
    this.options_.withCredentials = this.options_.withCredentials || false;
    this.options_.handleManifestRedirects = this.options_.handleManifestRedirects === false ? false : true;
    this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
    this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
    this.options_.smoothQualityChange = this.options_.smoothQualityChange || false;
    this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== "undefined" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
    this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
    this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;
    this.options_.customTagParsers = this.options_.customTagParsers || [];
    this.options_.customTagMappers = this.options_.customTagMappers || [];
    this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
    if (typeof this.options_.blacklistDuration !== "number") {
      this.options_.blacklistDuration = 5 * 60;
    }
    if (typeof this.options_.bandwidth !== "number") {
      if (this.options_.useBandwidthFromLocalStorage) {
        var storedObject = getVhsLocalStorage();
        if (storedObject && storedObject.bandwidth) {
          this.options_.bandwidth = storedObject.bandwidth;
          this.tech_.trigger({
            type: "usage",
            name: "vhs-bandwidth-from-local-storage"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-bandwidth-from-local-storage"
          });
        }
        if (storedObject && storedObject.throughput) {
          this.options_.throughput = storedObject.throughput;
          this.tech_.trigger({
            type: "usage",
            name: "vhs-throughput-from-local-storage"
          });
          this.tech_.trigger({
            type: "usage",
            name: "hls-throughput-from-local-storage"
          });
        }
      }
    }
    if (typeof this.options_.bandwidth !== "number") {
      this.options_.bandwidth = Config.INITIAL_BANDWIDTH;
    }
    this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH;
    ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "smoothQualityChange", "customTagParsers", "customTagMappers", "handleManifestRedirects", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "experimentalBufferBasedABR", "liveRangeSafeTimeDelta", "experimentalLLHLS", "useNetworkInformationApi", "useDtsForTimestampOffset", "experimentalExactManifestTimings", "experimentalLeastPixelDiffSelector"].forEach(function(option) {
      if (typeof _this2.source_[option] !== "undefined") {
        _this2.options_[option] = _this2.source_[option];
      }
    });
    this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
    this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
  };
  _proto.src = function src(_src, type2) {
    var _this3 = this;
    if (!_src) {
      return;
    }
    this.setOptions_();
    this.options_.src = expandDataUri(this.source_.src);
    this.options_.tech = this.tech_;
    this.options_.externVhs = Vhs;
    this.options_.sourceType = simpleTypeFromSourceType(type2);
    this.options_.seekTo = function(time2) {
      _this3.tech_.setCurrentTime(time2);
    };
    if (this.options_.smoothQualityChange) {
      videojs.log.warn("smoothQualityChange is deprecated and will be removed in the next major version");
    }
    this.masterPlaylistController_ = new MasterPlaylistController(this.options_);
    var playbackWatcherOptions = videojs.mergeOptions({
      liveRangeSafeTimeDelta: SAFE_TIME_DELTA
    }, this.options_, {
      seekable: function seekable3() {
        return _this3.seekable();
      },
      media: function media() {
        return _this3.masterPlaylistController_.media();
      },
      masterPlaylistController: this.masterPlaylistController_
    });
    this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);
    this.masterPlaylistController_.on("error", function() {
      var player = videojs.players[_this3.tech_.options_.playerId];
      var error = _this3.masterPlaylistController_.error;
      if (typeof error === "object" && !error.code) {
        error.code = 3;
      } else if (typeof error === "string") {
        error = {
          message: error,
          code: 3
        };
      }
      player.error(error);
    });
    var defaultSelector = this.options_.experimentalBufferBasedABR ? Vhs.movingAverageBandwidthSelector(0.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
    this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
    this.masterPlaylistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
    this.playlists = this.masterPlaylistController_.masterPlaylistLoader_;
    this.mediaSource = this.masterPlaylistController_.mediaSource;
    Object.defineProperties(this, {
      selectPlaylist: {
        get: function get8() {
          return this.masterPlaylistController_.selectPlaylist;
        },
        set: function set4(selectPlaylist) {
          this.masterPlaylistController_.selectPlaylist = selectPlaylist.bind(this);
        }
      },
      throughput: {
        get: function get8() {
          return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate;
        },
        set: function set4(throughput) {
          this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = throughput;
          this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1;
        }
      },
      bandwidth: {
        get: function get8() {
          var playerBandwidthEst = this.masterPlaylistController_.mainSegmentLoader_.bandwidth;
          var networkInformation = window_1.navigator.connection || window_1.navigator.mozConnection || window_1.navigator.webkitConnection;
          var tenMbpsAsBitsPerSecond = 1e7;
          if (this.options_.useNetworkInformationApi && networkInformation) {
            var networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1e3 * 1e3;
            if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) {
              playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec);
            } else {
              playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
            }
          }
          return playerBandwidthEst;
        },
        set: function set4(bandwidth2) {
          this.masterPlaylistController_.mainSegmentLoader_.bandwidth = bandwidth2;
          this.masterPlaylistController_.mainSegmentLoader_.throughput = {
            rate: 0,
            count: 0
          };
        }
      },
      /**
       * `systemBandwidth` is a combination of two serial processes bit-rates. The first
       * is the network bitrate provided by `bandwidth` and the second is the bitrate of
       * the entire process after that - decryption, transmuxing, and appending - provided
       * by `throughput`.
       *
       * Since the two process are serial, the overall system bandwidth is given by:
       *   sysBandwidth = 1 / (1 / bandwidth + 1 / throughput)
       */
      systemBandwidth: {
        get: function get8() {
          var invBandwidth = 1 / (this.bandwidth || 1);
          var invThroughput;
          if (this.throughput > 0) {
            invThroughput = 1 / this.throughput;
          } else {
            invThroughput = 0;
          }
          var systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
          return systemBitrate;
        },
        set: function set4() {
          videojs.log.error('The "systemBandwidth" property is read-only');
        }
      }
    });
    if (this.options_.bandwidth) {
      this.bandwidth = this.options_.bandwidth;
    }
    if (this.options_.throughput) {
      this.throughput = this.options_.throughput;
    }
    Object.defineProperties(this.stats, {
      bandwidth: {
        get: function get8() {
          return _this3.bandwidth || 0;
        },
        enumerable: true
      },
      mediaRequests: {
        get: function get8() {
          return _this3.masterPlaylistController_.mediaRequests_() || 0;
        },
        enumerable: true
      },
      mediaRequestsAborted: {
        get: function get8() {
          return _this3.masterPlaylistController_.mediaRequestsAborted_() || 0;
        },
        enumerable: true
      },
      mediaRequestsTimedout: {
        get: function get8() {
          return _this3.masterPlaylistController_.mediaRequestsTimedout_() || 0;
        },
        enumerable: true
      },
      mediaRequestsErrored: {
        get: function get8() {
          return _this3.masterPlaylistController_.mediaRequestsErrored_() || 0;
        },
        enumerable: true
      },
      mediaTransferDuration: {
        get: function get8() {
          return _this3.masterPlaylistController_.mediaTransferDuration_() || 0;
        },
        enumerable: true
      },
      mediaBytesTransferred: {
        get: function get8() {
          return _this3.masterPlaylistController_.mediaBytesTransferred_() || 0;
        },
        enumerable: true
      },
      mediaSecondsLoaded: {
        get: function get8() {
          return _this3.masterPlaylistController_.mediaSecondsLoaded_() || 0;
        },
        enumerable: true
      },
      mediaAppends: {
        get: function get8() {
          return _this3.masterPlaylistController_.mediaAppends_() || 0;
        },
        enumerable: true
      },
      mainAppendsToLoadedData: {
        get: function get8() {
          return _this3.masterPlaylistController_.mainAppendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      audioAppendsToLoadedData: {
        get: function get8() {
          return _this3.masterPlaylistController_.audioAppendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      appendsToLoadedData: {
        get: function get8() {
          return _this3.masterPlaylistController_.appendsToLoadedData_() || 0;
        },
        enumerable: true
      },
      timeToLoadedData: {
        get: function get8() {
          return _this3.masterPlaylistController_.timeToLoadedData_() || 0;
        },
        enumerable: true
      },
      buffered: {
        get: function get8() {
          return timeRangesToArray(_this3.tech_.buffered());
        },
        enumerable: true
      },
      currentTime: {
        get: function get8() {
          return _this3.tech_.currentTime();
        },
        enumerable: true
      },
      currentSource: {
        get: function get8() {
          return _this3.tech_.currentSource_;
        },
        enumerable: true
      },
      currentTech: {
        get: function get8() {
          return _this3.tech_.name_;
        },
        enumerable: true
      },
      duration: {
        get: function get8() {
          return _this3.tech_.duration();
        },
        enumerable: true
      },
      master: {
        get: function get8() {
          return _this3.playlists.master;
        },
        enumerable: true
      },
      playerDimensions: {
        get: function get8() {
          return _this3.tech_.currentDimensions();
        },
        enumerable: true
      },
      seekable: {
        get: function get8() {
          return timeRangesToArray(_this3.tech_.seekable());
        },
        enumerable: true
      },
      timestamp: {
        get: function get8() {
          return Date.now();
        },
        enumerable: true
      },
      videoPlaybackQuality: {
        get: function get8() {
          return _this3.tech_.getVideoPlaybackQuality();
        },
        enumerable: true
      }
    });
    this.tech_.one("canplay", this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_));
    this.tech_.on("bandwidthupdate", function() {
      if (_this3.options_.useBandwidthFromLocalStorage) {
        updateVhsLocalStorage({
          bandwidth: _this3.bandwidth,
          throughput: Math.round(_this3.throughput)
        });
      }
    });
    this.masterPlaylistController_.on("selectedinitialmedia", function() {
      renditionSelectionMixin(_this3);
    });
    this.masterPlaylistController_.sourceUpdater_.on("createdsourcebuffers", function() {
      _this3.setupEme_();
    });
    this.on(this.masterPlaylistController_, "progress", function() {
      this.tech_.trigger("progress");
    });
    this.on(this.masterPlaylistController_, "firstplay", function() {
      this.ignoreNextSeekingEvent_ = true;
    });
    this.setupQualityLevels_();
    if (!this.tech_.el()) {
      return;
    }
    this.mediaSourceUrl_ = window_1.URL.createObjectURL(this.masterPlaylistController_.mediaSource);
    this.tech_.src(this.mediaSourceUrl_);
  };
  _proto.createKeySessions_ = function createKeySessions_() {
    var _this4 = this;
    var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    this.logger_("waiting for EME key session creation");
    waitForKeySessionCreation({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
      mainPlaylists: this.playlists.master.playlists
    }).then(function() {
      _this4.logger_("created EME key session");
      _this4.masterPlaylistController_.sourceUpdater_.initializedEme();
    })["catch"](function(err) {
      _this4.logger_("error while creating EME key session", err);
      _this4.player_.error({
        message: "Failed to initialize media keys for EME",
        code: 3
      });
    });
  };
  _proto.handleWaitingForKey_ = function handleWaitingForKey_() {
    this.logger_("waitingforkey fired, attempting to create any new key sessions");
    this.createKeySessions_();
  };
  _proto.setupEme_ = function setupEme_() {
    var _this5 = this;
    var audioPlaylistLoader = this.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader;
    var didSetupEmeOptions = setupEmeOptions({
      player: this.player_,
      sourceKeySystems: this.source_.keySystems,
      media: this.playlists.media(),
      audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
    });
    this.player_.tech_.on("keystatuschange", function(e2) {
      if (e2.status !== "output-restricted") {
        return;
      }
      var masterPlaylist = _this5.masterPlaylistController_.master();
      if (!masterPlaylist || !masterPlaylist.playlists) {
        return;
      }
      var excludedHDPlaylists = [];
      masterPlaylist.playlists.forEach(function(playlist) {
        if (playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height >= 720) {
          if (!playlist.excludeUntil || playlist.excludeUntil < Infinity) {
            playlist.excludeUntil = Infinity;
            excludedHDPlaylists.push(playlist);
          }
        }
      });
      if (excludedHDPlaylists.length) {
        var _videojs$log;
        (_videojs$log = videojs.log).warn.apply(_videojs$log, ['DRM keystatus changed to "output-restricted." Removing the following HD playlists that will most likely fail to play and clearing the buffer. This may be due to HDCP restrictions on the stream and the capabilities of the current device.'].concat(excludedHDPlaylists));
        _this5.masterPlaylistController_.fastQualityChange_();
      }
    });
    this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
    this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_);
    if (videojs.browser.IE_VERSION === 11 || !didSetupEmeOptions) {
      this.masterPlaylistController_.sourceUpdater_.initializedEme();
      return;
    }
    this.createKeySessions_();
  };
  _proto.setupQualityLevels_ = function setupQualityLevels_() {
    var _this6 = this;
    var player = videojs.players[this.tech_.options_.playerId];
    if (!player || !player.qualityLevels || this.qualityLevels_) {
      return;
    }
    this.qualityLevels_ = player.qualityLevels();
    this.masterPlaylistController_.on("selectedinitialmedia", function() {
      handleVhsLoadedMetadata(_this6.qualityLevels_, _this6);
    });
    this.playlists.on("mediachange", function() {
      handleVhsMediaChange(_this6.qualityLevels_, _this6.playlists);
    });
  };
  VhsHandler2.version = function version$52() {
    return {
      "@videojs/http-streaming": version$4,
      "mux.js": version$3,
      "mpd-parser": version$2,
      "m3u8-parser": version$1,
      "aes-decrypter": version
    };
  };
  _proto.version = function version2() {
    return this.constructor.version();
  };
  _proto.canChangeType = function canChangeType() {
    return SourceUpdater.canChangeType();
  };
  _proto.play = function play() {
    this.masterPlaylistController_.play();
  };
  _proto.setCurrentTime = function setCurrentTime(currentTime) {
    this.masterPlaylistController_.setCurrentTime(currentTime);
  };
  _proto.duration = function duration5() {
    return this.masterPlaylistController_.duration();
  };
  _proto.seekable = function seekable3() {
    return this.masterPlaylistController_.seekable();
  };
  _proto.dispose = function dispose() {
    if (this.playbackWatcher_) {
      this.playbackWatcher_.dispose();
    }
    if (this.masterPlaylistController_) {
      this.masterPlaylistController_.dispose();
    }
    if (this.qualityLevels_) {
      this.qualityLevels_.dispose();
    }
    if (this.player_) {
      delete this.player_.vhs;
      delete this.player_.dash;
      delete this.player_.hls;
    }
    if (this.tech_ && this.tech_.vhs) {
      delete this.tech_.vhs;
    }
    if (this.tech_) {
      delete this.tech_.hls;
    }
    if (this.mediaSourceUrl_ && window_1.URL.revokeObjectURL) {
      window_1.URL.revokeObjectURL(this.mediaSourceUrl_);
      this.mediaSourceUrl_ = null;
    }
    if (this.tech_) {
      this.tech_.off("waitingforkey", this.handleWaitingForKey_);
    }
    _Component.prototype.dispose.call(this);
  };
  _proto.convertToProgramTime = function convertToProgramTime(time2, callback2) {
    return getProgramTime({
      playlist: this.masterPlaylistController_.media(),
      time: time2,
      callback: callback2
    });
  };
  _proto.seekToProgramTime = function seekToProgramTime$1(programTime, callback2, pauseAfterSeek, retryCount) {
    if (pauseAfterSeek === void 0) {
      pauseAfterSeek = true;
    }
    if (retryCount === void 0) {
      retryCount = 2;
    }
    return seekToProgramTime({
      programTime,
      playlist: this.masterPlaylistController_.media(),
      retryCount,
      pauseAfterSeek,
      seekTo: this.options_.seekTo,
      tech: this.options_.tech,
      callback: callback2
    });
  };
  return VhsHandler2;
}(Component);
var VhsSourceHandler = {
  name: "videojs-http-streaming",
  VERSION: version$4,
  canHandleSource: function canHandleSource(srcObj, options) {
    if (options === void 0) {
      options = {};
    }
    var localOptions = videojs.mergeOptions(videojs.options, options);
    return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
  },
  handleSource: function handleSource(source, tech, options) {
    if (options === void 0) {
      options = {};
    }
    var localOptions = videojs.mergeOptions(videojs.options, options);
    tech.vhs = new VhsHandler(source, tech, localOptions);
    if (!videojs.hasOwnProperty("hls")) {
      Object.defineProperty(tech, "hls", {
        get: function get8() {
          videojs.log.warn("player.tech().hls is deprecated. Use player.tech().vhs instead.");
          return tech.vhs;
        },
        configurable: true
      });
    }
    tech.vhs.xhr = xhrFactory();
    tech.vhs.src(source.src, source.type);
    return tech.vhs;
  },
  canPlayType: function canPlayType2(type2, options) {
    if (options === void 0) {
      options = {};
    }
    var _videojs$mergeOptions = videojs.mergeOptions(videojs.options, options), _videojs$mergeOptions2 = _videojs$mergeOptions.vhs;
    _videojs$mergeOptions2 = _videojs$mergeOptions2 === void 0 ? {} : _videojs$mergeOptions2;
    var _videojs$mergeOptions3 = _videojs$mergeOptions2.overrideNative, overrideNative = _videojs$mergeOptions3 === void 0 ? !videojs.browser.IS_ANY_SAFARI : _videojs$mergeOptions3, _videojs$mergeOptions4 = _videojs$mergeOptions.hls;
    _videojs$mergeOptions4 = _videojs$mergeOptions4 === void 0 ? {} : _videojs$mergeOptions4;
    var _videojs$mergeOptions5 = _videojs$mergeOptions4.overrideNative, legacyOverrideNative = _videojs$mergeOptions5 === void 0 ? false : _videojs$mergeOptions5;
    var supportedType = simpleTypeFromSourceType(type2);
    var canUseMsePlayback = supportedType && (!Vhs.supportsTypeNatively(supportedType) || legacyOverrideNative || overrideNative);
    return canUseMsePlayback ? "maybe" : "";
  }
};
var supportsNativeMediaSources = function supportsNativeMediaSources2() {
  return browserSupportsCodec("avc1.4d400d,mp4a.40.2");
};
if (supportsNativeMediaSources()) {
  videojs.getTech("Html5").registerSourceHandler(VhsSourceHandler, 0);
}
videojs.VhsHandler = VhsHandler;
Object.defineProperty(videojs, "HlsHandler", {
  get: function get4() {
    videojs.log.warn("videojs.HlsHandler is deprecated. Use videojs.VhsHandler instead.");
    return VhsHandler;
  },
  configurable: true
});
videojs.VhsSourceHandler = VhsSourceHandler;
Object.defineProperty(videojs, "HlsSourceHandler", {
  get: function get5() {
    videojs.log.warn("videojs.HlsSourceHandler is deprecated. Use videojs.VhsSourceHandler instead.");
    return VhsSourceHandler;
  },
  configurable: true
});
videojs.Vhs = Vhs;
Object.defineProperty(videojs, "Hls", {
  get: function get6() {
    videojs.log.warn("videojs.Hls is deprecated. Use videojs.Vhs instead.");
    return Vhs;
  },
  configurable: true
});
if (!videojs.use) {
  videojs.registerComponent("Hls", Vhs);
  videojs.registerComponent("Vhs", Vhs);
}
videojs.options.vhs = videojs.options.vhs || {};
videojs.options.hls = videojs.options.hls || {};
if (!videojs.getPlugin || !videojs.getPlugin("reloadSourceOnError")) {
  var registerPlugin = videojs.registerPlugin || videojs.plugin;
  registerPlugin("reloadSourceOnError", reloadSourceOnError);
}
const video_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: videojs
}, Symbol.toStringTag, { value: "Module" }));
const videoJs = "";
var videojs_hotkeysExports = {};
var videojs_hotkeys = {
  get exports() {
    return videojs_hotkeysExports;
  },
  set exports(v2) {
    videojs_hotkeysExports = v2;
  }
};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(video_es);
(function(module) {
  (function(root2, factory3) {
    if (typeof window !== "undefined" && window.videojs) {
      factory3(window.videojs);
    } else if (module.exports) {
      var videojs2 = require$$0;
      module.exports = factory3(videojs2.default || videojs2);
    }
  })(commonjsGlobal, function(videojs2) {
    if (typeof window !== "undefined") {
      window["videojs_hotkeys"] = { version: "0.2.28" };
    }
    var hotkeys = function(options) {
      var player = this;
      var pEl = player.el();
      var doc = document;
      var def_options = {
        volumeStep: 0.1,
        seekStep: 5,
        enableMute: true,
        enableVolumeScroll: true,
        enableHoverScroll: false,
        enableFullscreen: true,
        enableNumbers: true,
        enableJogStyle: false,
        alwaysCaptureHotkeys: false,
        captureDocumentHotkeys: false,
        documentHotkeysFocusElementFilter: function() {
          return false;
        },
        enableModifiersForNumbers: true,
        enableInactiveFocus: true,
        skipInitialFocus: false,
        playPauseKey,
        rewindKey,
        forwardKey,
        volumeUpKey,
        volumeDownKey,
        muteKey,
        fullscreenKey,
        customKeys: {}
      };
      var cPlay = 1, cRewind = 2, cForward = 3, cVolumeUp = 4, cVolumeDown = 5, cMute = 6, cFullscreen = 7;
      var mergeOptions2 = videojs2.mergeOptions || videojs2.util.mergeOptions;
      options = mergeOptions2(def_options, options || {});
      var volumeStep = options.volumeStep, seekStep = options.seekStep, enableMute = options.enableMute, enableVolumeScroll = options.enableVolumeScroll, enableHoverScroll = options.enableHoverScroll, enableFull = options.enableFullscreen, enableNumbers = options.enableNumbers, enableJogStyle = options.enableJogStyle, alwaysCaptureHotkeys = options.alwaysCaptureHotkeys, captureDocumentHotkeys = options.captureDocumentHotkeys, documentHotkeysFocusElementFilter = options.documentHotkeysFocusElementFilter, enableModifiersForNumbers = options.enableModifiersForNumbers, enableInactiveFocus = options.enableInactiveFocus, skipInitialFocus = options.skipInitialFocus;
      var videojsVer = videojs2.VERSION;
      if (!pEl.hasAttribute("tabIndex")) {
        pEl.setAttribute("tabIndex", "-1");
      }
      pEl.style.outline = "none";
      if (alwaysCaptureHotkeys || !player.autoplay()) {
        if (!skipInitialFocus) {
          player.one("play", function() {
            pEl.focus();
          });
        }
      }
      if (enableInactiveFocus) {
        player.on("userinactive", function() {
          var cancelFocusingPlayer = function() {
            clearTimeout(focusingPlayerTimeout);
          };
          var focusingPlayerTimeout = setTimeout(function() {
            player.off("useractive", cancelFocusingPlayer);
            var activeElement = doc.activeElement;
            var controlBar = pEl.querySelector(".vjs-control-bar");
            if (activeElement && activeElement.parentElement == controlBar) {
              pEl.focus();
            }
          }, 10);
          player.one("useractive", cancelFocusingPlayer);
        });
      }
      player.on("play", function() {
        var ifblocker = pEl.querySelector(".iframeblocker");
        if (ifblocker && ifblocker.style.display === "") {
          ifblocker.style.display = "block";
          ifblocker.style.bottom = "39px";
        }
      });
      var keyDown = function keyDown2(event) {
        var ewhich = event.which, wasPlaying, seekTime;
        var ePreventDefault = event.preventDefault.bind(event);
        var duration5 = player.duration();
        if (player.controls()) {
          var activeEl = doc.activeElement;
          if (alwaysCaptureHotkeys || captureDocumentHotkeys && documentHotkeysFocusElementFilter(activeEl) || activeEl == pEl || activeEl == pEl.querySelector(".vjs-tech") || activeEl == pEl.querySelector(".vjs-control-bar") || activeEl == pEl.querySelector(".iframeblocker")) {
            switch (checkKeys(event, player)) {
              case cPlay:
                ePreventDefault();
                if (alwaysCaptureHotkeys || captureDocumentHotkeys) {
                  event.stopPropagation();
                }
                if (player.paused()) {
                  silencePromise2(player.play());
                } else {
                  player.pause();
                }
                break;
              case cRewind:
                wasPlaying = !player.paused();
                ePreventDefault();
                if (wasPlaying) {
                  player.pause();
                }
                seekTime = player.currentTime() - seekStepD(event);
                if (seekTime <= 0) {
                  seekTime = 0;
                }
                player.currentTime(seekTime);
                if (wasPlaying) {
                  silencePromise2(player.play());
                }
                break;
              case cForward:
                wasPlaying = !player.paused();
                ePreventDefault();
                if (wasPlaying) {
                  player.pause();
                }
                seekTime = player.currentTime() + seekStepD(event);
                if (seekTime >= duration5) {
                  seekTime = wasPlaying ? duration5 - 1e-3 : duration5;
                }
                player.currentTime(seekTime);
                if (wasPlaying) {
                  silencePromise2(player.play());
                }
                break;
              case cVolumeDown:
                ePreventDefault();
                if (!enableJogStyle) {
                  player.volume(player.volume() - volumeStep);
                } else {
                  seekTime = player.currentTime() - 1;
                  if (player.currentTime() <= 1) {
                    seekTime = 0;
                  }
                  player.currentTime(seekTime);
                }
                break;
              case cVolumeUp:
                ePreventDefault();
                if (!enableJogStyle) {
                  player.volume(player.volume() + volumeStep);
                } else {
                  seekTime = player.currentTime() + 1;
                  if (seekTime >= duration5) {
                    seekTime = duration5;
                  }
                  player.currentTime(seekTime);
                }
                break;
              case cMute:
                if (enableMute) {
                  player.muted(!player.muted());
                }
                break;
              case cFullscreen:
                if (enableFull) {
                  if (player.isFullscreen()) {
                    player.exitFullscreen();
                  } else {
                    player.requestFullscreen();
                  }
                }
                break;
              default:
                if (ewhich > 47 && ewhich < 59 || ewhich > 95 && ewhich < 106) {
                  if (enableModifiersForNumbers || !(event.metaKey || event.ctrlKey || event.altKey)) {
                    if (enableNumbers) {
                      var sub = 48;
                      if (ewhich > 95) {
                        sub = 96;
                      }
                      var number = ewhich - sub;
                      ePreventDefault();
                      player.currentTime(player.duration() * number * 0.1);
                    }
                  }
                }
                for (var customKey in options.customKeys) {
                  var customHotkey = options.customKeys[customKey];
                  if (customHotkey && customHotkey.key && customHotkey.handler) {
                    if (customHotkey.key(event)) {
                      ePreventDefault();
                      customHotkey.handler(player, options, event);
                    }
                  }
                }
            }
          }
        }
      };
      var doubleClick = function doubleClick2(event) {
        if (videojsVer != null && videojsVer <= "7.1.0") {
          if (player.controls()) {
            var activeEl = event.relatedTarget || event.toElement || doc.activeElement;
            if (activeEl == pEl || activeEl == pEl.querySelector(".vjs-tech") || activeEl == pEl.querySelector(".iframeblocker")) {
              if (enableFull) {
                if (player.isFullscreen()) {
                  player.exitFullscreen();
                } else {
                  player.requestFullscreen();
                }
              }
            }
          }
        }
      };
      var volumeHover = false;
      var volumeSelector = pEl.querySelector(".vjs-volume-menu-button") || pEl.querySelector(".vjs-volume-panel");
      if (volumeSelector != null) {
        volumeSelector.onmouseover = function() {
          volumeHover = true;
        };
        volumeSelector.onmouseout = function() {
          volumeHover = false;
        };
      }
      var mouseScroll = function mouseScroll2(event) {
        if (enableHoverScroll) {
          var activeEl = 0;
        } else {
          var activeEl = doc.activeElement;
        }
        if (player.controls()) {
          if (alwaysCaptureHotkeys || activeEl == pEl || activeEl == pEl.querySelector(".vjs-tech") || activeEl == pEl.querySelector(".iframeblocker") || activeEl == pEl.querySelector(".vjs-control-bar") || volumeHover) {
            if (enableVolumeScroll) {
              event = window.event || event;
              var delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
              event.preventDefault();
              if (delta == 1) {
                player.volume(player.volume() + volumeStep);
              } else if (delta == -1) {
                player.volume(player.volume() - volumeStep);
              }
            }
          }
        }
      };
      var checkKeys = function checkKeys2(e2, player2) {
        if (options.playPauseKey(e2, player2)) {
          return cPlay;
        }
        if (options.rewindKey(e2, player2)) {
          return cRewind;
        }
        if (options.forwardKey(e2, player2)) {
          return cForward;
        }
        if (options.volumeUpKey(e2, player2)) {
          return cVolumeUp;
        }
        if (options.volumeDownKey(e2, player2)) {
          return cVolumeDown;
        }
        if (options.muteKey(e2, player2)) {
          return cMute;
        }
        if (options.fullscreenKey(e2, player2)) {
          return cFullscreen;
        }
      };
      function playPauseKey(e2) {
        return e2.which === 32 || e2.which === 179;
      }
      function rewindKey(e2) {
        return e2.which === 37 || e2.which === 177;
      }
      function forwardKey(e2) {
        return e2.which === 39 || e2.which === 176;
      }
      function volumeUpKey(e2) {
        return e2.which === 38;
      }
      function volumeDownKey(e2) {
        return e2.which === 40;
      }
      function muteKey(e2) {
        return e2.which === 77;
      }
      function fullscreenKey(e2) {
        return e2.which === 70;
      }
      function seekStepD(e2) {
        return typeof seekStep === "function" ? seekStep(e2) : seekStep;
      }
      function silencePromise2(value) {
        if (value != null && typeof value.then === "function") {
          value.then(null, function(e2) {
          });
        }
      }
      if (captureDocumentHotkeys) {
        var capDocHK = function(event) {
          keyDown(event);
        };
        document.addEventListener("keydown", capDocHK);
        this.dispose = function() {
          document.removeEventListener("keydown", capDocHK);
        };
      } else {
        player.on("keydown", keyDown);
      }
      player.on("dblclick", doubleClick);
      player.on("mousewheel", mouseScroll);
      player.on("DOMMouseScroll", mouseScroll);
      return this;
    };
    var registerPlugin = videojs2.registerPlugin || videojs2.plugin;
    registerPlugin("hotkeys", hotkeys);
  });
})(videojs_hotkeys);
function VideoPlayer({ videoSrc, autoplay, muted, triggerWatched, watchedTimeSec }) {
  const playerRef = reactExports.useRef(null);
  const videoRef = reactExports.useRef(null);
  const usercontext = reactExports.useContext(UserContext);
  reactExports.useEffect(() => {
    var _a;
    if (!playerRef.current) {
      const videoElement = document.createElement("video-js");
      videoElement.className = "video-js vjs-16-9 vjs-big-play-centered";
      (_a = videoRef.current) == null ? void 0 : _a.appendChild(videoElement);
      const player2 = videojs(
        videoElement,
        {
          autoplay: autoplay ?? false,
          muted: muted ?? false,
          controls: true,
          aspectRatio: "9:16",
          responsive: true,
          fluid: true,
          plugins: {
            hotkeys: {
              enableVolumeScroll: false,
              volumeStep: 0.1,
              seekStep: 5,
              enableModifiersForNumbers: false
            }
          }
        },
        () => {
          player2.src(videoSrc);
        }
      );
      playerRef.current = player2;
    }
    const player = playerRef.current;
    let lastWatchedSec = 9;
    const timeCheck = () => {
      const currentTime = Math.round(player.currentTime());
      if (currentTime % 10 === 0 && currentTime > lastWatchedSec) {
        lastWatchedSec = currentTime;
        triggerWatched == null ? void 0 : triggerWatched(currentTime);
      }
    };
    if (triggerWatched && (usercontext == null ? void 0 : usercontext.user)) {
      player.on("timeupdate", timeCheck);
    }
  }, [videoRef, usercontext]);
  reactExports.useEffect(() => {
    const player = playerRef.current;
    return () => {
      if (player && !player.isDisposed()) {
        player.dispose();
        playerRef.current = null;
      }
    };
  }, [playerRef]);
  reactExports.useEffect(() => {
    var _a;
    (_a = playerRef.current) == null ? void 0 : _a.currentTime(watchedTimeSec ?? 0);
  }, [watchedTimeSec]);
  return /* @__PURE__ */ jsx("div", { ref: videoRef, style: { height: "100vh - 64px" } });
}
var SkipNext = {};
var _interopRequireDefault$o = interopRequireDefaultExports;
Object.defineProperty(SkipNext, "__esModule", {
  value: true
});
var default_1$m = SkipNext.default = void 0;
var _createSvgIcon$m = _interopRequireDefault$o(requireCreateSvgIcon());
var _jsxRuntime$m = require$$2;
var _default$m = (0, _createSvgIcon$m.default)(/* @__PURE__ */ (0, _jsxRuntime$m.jsx)("path", {
  d: "m6 18 8.5-6L6 6v12zM16 6v12h2V6h-2z"
}), "SkipNext");
default_1$m = SkipNext.default = _default$m;
var MoreVert = {};
var _interopRequireDefault$n = interopRequireDefaultExports;
Object.defineProperty(MoreVert, "__esModule", {
  value: true
});
var default_1$l = MoreVert.default = void 0;
var _createSvgIcon$l = _interopRequireDefault$n(requireCreateSvgIcon());
var _jsxRuntime$l = require$$2;
var _default$l = (0, _createSvgIcon$l.default)(/* @__PURE__ */ (0, _jsxRuntime$l.jsx)("path", {
  d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
}), "MoreVert");
default_1$l = MoreVert.default = _default$l;
function ChipLine({ chipData }) {
  return /* @__PURE__ */ jsxs(
    Box$1,
    {
      sx: {
        display: "flex",
        gap: 1
      },
      children: [
        chipData ? chipData.map((tag) => /* @__PURE__ */ jsx(CustomChip, { text: tag.name }, tag.id)) : [...Array(6)].map(() => (
          // eslint-disable-next-line react/jsx-key
          /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 6, p: 0.5, children: /* @__PURE__ */ jsx(Skeleton$1, { variant: "rounded", animation: "wave", width: "100%", height: "32px" }) })
        )),
        /* @__PURE__ */ jsx(
          Box$1,
          {
            sx: {
              right: 0,
              width: "25px",
              height: "100%",
              position: "absolute",
              background: "linear-gradient(90deg, rgba(2,0,36,0) 0%, rgba(255,255,255,1) 75%)"
            }
          }
        )
      ]
    }
  );
}
var dayjs_minExports = {};
var dayjs_min = {
  get exports() {
    return dayjs_minExports;
  },
  set exports(v2) {
    dayjs_minExports = v2;
  }
};
(function(module, exports) {
  !function(t3, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t3 = 1e3, e2 = 6e4, n2 = 36e5, r3 = "millisecond", i = "second", s = "minute", u2 = "hour", a2 = "day", o = "week", f2 = "month", h2 = "quarter", c2 = "year", d3 = "date", l2 = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t4) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t4 % 100;
      return "[" + t4 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t4, e3, n3) {
      var r4 = String(t4);
      return !r4 || r4.length >= e3 ? t4 : "" + Array(e3 + 1 - r4.length).join(n3) + t4;
    }, v2 = { s: m2, z: function(t4) {
      var e3 = -t4.utcOffset(), n3 = Math.abs(e3), r4 = Math.floor(n3 / 60), i2 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r4, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t4(e3, n3) {
      if (e3.date() < n3.date())
        return -t4(n3, e3);
      var r4 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r4, f2), s2 = n3 - i2 < 0, u3 = e3.clone().add(r4 + (s2 ? -1 : 1), f2);
      return +(-(r4 + (n3 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t4) {
      return t4 < 0 ? Math.ceil(t4) || 0 : Math.floor(t4);
    }, p: function(t4) {
      return { M: f2, y: c2, w: o, d: a2, D: d3, h: u2, m: s, s: i, ms: r3, Q: h2 }[t4] || String(t4 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t4) {
      return void 0 === t4;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = function(t4) {
      return t4 instanceof _2;
    }, S2 = function t4(e3, n3, r4) {
      var i2;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s2 = e3.toLowerCase();
        D2[s2] && (i2 = s2), n3 && (D2[s2] = n3, i2 = s2);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1)
          return t4(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i2 = a3;
      }
      return !r4 && i2 && (g2 = i2), i2 || !r4 && g2;
    }, w2 = function(t4, e3) {
      if (p2(t4))
        return t4.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t4, n3.args = arguments, new _2(n3);
    }, O2 = v2;
    O2.l = S2, O2.i = p2, O2.w = function(t4, e3) {
      return w2(t4, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t4) {
        this.$L = S2(t4.locale, null, true), this.parse(t4);
      }
      var m3 = M3.prototype;
      return m3.parse = function(t4) {
        this.$d = function(t5) {
          var e3 = t5.date, n3 = t5.utc;
          if (null === e3)
            return new Date(NaN);
          if (O2.u(e3))
            return new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r4 = e3.match($2);
            if (r4) {
              var i2 = r4[2] - 1 || 0, s2 = (r4[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r4[1], i2, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s2)) : new Date(r4[1], i2, r4[3] || 1, r4[4] || 0, r4[5] || 0, r4[6] || 0, s2);
            }
          }
          return new Date(e3);
        }(t4), this.$x = t4.x || {}, this.init();
      }, m3.init = function() {
        var t4 = this.$d;
        this.$y = t4.getFullYear(), this.$M = t4.getMonth(), this.$D = t4.getDate(), this.$W = t4.getDay(), this.$H = t4.getHours(), this.$m = t4.getMinutes(), this.$s = t4.getSeconds(), this.$ms = t4.getMilliseconds();
      }, m3.$utils = function() {
        return O2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t4, e3) {
        var n3 = w2(t4);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t4, e3) {
        return w2(t4) < this.startOf(e3);
      }, m3.isBefore = function(t4, e3) {
        return this.endOf(e3) < w2(t4);
      }, m3.$g = function(t4, e3, n3) {
        return O2.u(t4) ? this[e3] : this.set(n3, t4);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t4, e3) {
        var n3 = this, r4 = !!O2.u(e3) || e3, h3 = O2.p(t4), l3 = function(t5, e4) {
          var i2 = O2.w(n3.$u ? Date.UTC(n3.$y, e4, t5) : new Date(n3.$y, e4, t5), n3);
          return r4 ? i2 : i2.endOf(a2);
        }, $3 = function(t5, e4) {
          return O2.w(n3.toDate()[t5].apply(n3.toDate("s"), (r4 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c2:
            return r4 ? l3(1, 0) : l3(31, 11);
          case f2:
            return r4 ? l3(1, M4) : l3(0, M4 + 1);
          case o:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r4 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d3:
            return $3(v3 + "Hours", 0);
          case u2:
            return $3(v3 + "Minutes", 1);
          case s:
            return $3(v3 + "Seconds", 2);
          case i:
            return $3(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t4) {
        return this.startOf(t4, false);
      }, m3.$set = function(t4, e3) {
        var n3, o2 = O2.p(t4), h3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = h3 + "Date", n3[d3] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s] = h3 + "Minutes", n3[i] = h3 + "Seconds", n3[r3] = h3 + "Milliseconds", n3)[o2], $3 = o2 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o2 === f2 || o2 === c2) {
          var y3 = this.clone().set(d3, 1);
          y3.$d[l3]($3), y3.init(), this.$d = y3.set(d3, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($3);
        return this.init(), this;
      }, m3.set = function(t4, e3) {
        return this.clone().$set(t4, e3);
      }, m3.get = function(t4) {
        return this[O2.p(t4)]();
      }, m3.add = function(r4, h3) {
        var d4, l3 = this;
        r4 = Number(r4);
        var $3 = O2.p(h3), y3 = function(t4) {
          var e3 = w2(l3);
          return O2.w(e3.date(e3.date() + Math.round(t4 * r4)), l3);
        };
        if ($3 === f2)
          return this.set(f2, this.$M + r4);
        if ($3 === c2)
          return this.set(c2, this.$y + r4);
        if ($3 === a2)
          return y3(1);
        if ($3 === o)
          return y3(7);
        var M4 = (d4 = {}, d4[s] = e2, d4[u2] = n2, d4[i] = t3, d4)[$3] || 1, m4 = this.$d.getTime() + r4 * M4;
        return O2.w(m4, this);
      }, m3.subtract = function(t4, e3) {
        return this.add(-1 * t4, e3);
      }, m3.format = function(t4) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r4 = t4 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O2.z(this), s2 = this.$H, u3 = this.$m, a3 = this.$M, o2 = n3.weekdays, f3 = n3.months, h3 = function(t5, n4, i3, s3) {
          return t5 && (t5[n4] || t5(e3, r4)) || i3[n4].slice(0, s3);
        }, c3 = function(t5) {
          return O2.s(s2 % 12 || 12, t5, "0");
        }, d4 = n3.meridiem || function(t5, e4, n4) {
          var r5 = t5 < 12 ? "AM" : "PM";
          return n4 ? r5.toLowerCase() : r5;
        }, $3 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n3.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o2, 2), ddd: h3(n3.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O2.s(s2, 2, "0"), h: c3(1), hh: c3(2), a: d4(s2, u3, true), A: d4(s2, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i2 };
        return r4.replace(y2, function(t5, e4) {
          return e4 || $3[t5] || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r4, d4, l3) {
        var $3, y3 = O2.p(d4), M4 = w2(r4), m4 = (M4.utcOffset() - this.utcOffset()) * e2, v3 = this - M4, g3 = O2.m(this, M4);
        return g3 = ($3 = {}, $3[c2] = g3 / 12, $3[f2] = g3, $3[h2] = g3 / 3, $3[o] = (v3 - m4) / 6048e5, $3[a2] = (v3 - m4) / 864e5, $3[u2] = v3 / n2, $3[s] = v3 / e2, $3[i] = v3 / t3, $3)[y3] || v3, l3 ? g3 : O2.a(g3);
      }, m3.daysInMonth = function() {
        return this.endOf(f2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t4, e3) {
        if (!t4)
          return this.$L;
        var n3 = this.clone(), r4 = S2(t4, e3, true);
        return r4 && (n3.$L = r4), n3;
      }, m3.clone = function() {
        return O2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), T2 = _2.prototype;
    return w2.prototype = T2, [["$ms", r3], ["$s", i], ["$m", s], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d3]].forEach(function(t4) {
      T2[t4[1]] = function(e3) {
        return this.$g(e3, t4[0], t4[1]);
      };
    }), w2.extend = function(t4, e3) {
      return t4.$i || (t4(e3, _2, w2), t4.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t4) {
      return w2(1e3 * t4);
    }, w2.en = D2[g2], w2.Ls = D2, w2.p = {}, w2;
  });
})(dayjs_min);
const dayjs = dayjs_minExports;
function NumberToWords(input) {
  if (input > 999999) {
    return `${(input / 1e6).toFixed(1)} mil.`;
  }
  if (input > 999) {
    return `${(input / 1e3).toFixed(1)} tis.`;
  }
  return `${input.toFixed(0)}`;
}
function SizeToWords(input) {
  if (input >= 1e6) {
    return `${(input / 1e6).toFixed(1)} MB`;
  }
  if (input >= 1e3) {
    return `${(input / 1e3).toFixed(1)} KB`;
  }
  return `${input.toFixed(1)} B`;
}
function TimeSpanToReadableFormat(input, includeHours = false) {
  return includeHours ? input : input.slice(3);
}
function TimestampToAgoWords(input) {
  const now = dayjs(Date.now());
  const diff = new Date(now.diff(input));
  const years = diff.getFullYear() - 1970;
  if (years > 0) {
    if (years === 1) {
      return `ped 1 rokem`;
    }
    return `ped ${years} lety`;
  }
  const months = diff.getMonth();
  if (months > 0) {
    if (months === 1) {
      return `ped 1 mscem`;
    }
    return `ped ${months} msci`;
  }
  const days = diff.getDate() - 1;
  if (days > 0) {
    if (days === 1) {
      return `ped 1 dnem`;
    }
    return `ped ${days} dny`;
  }
  const hours = diff.getHours();
  if (hours > 0) {
    if (hours === 1) {
      return `ped 1 hodinou`;
    }
    return `ped ${hours} hodinami`;
  }
  const minutes = diff.getMinutes();
  if (minutes <= 1) {
    return `ped 1 minutou`;
  }
  return `ped ${minutes} minutami`;
}
var PlaylistAdd = {};
var _interopRequireDefault$m = interopRequireDefaultExports;
Object.defineProperty(PlaylistAdd, "__esModule", {
  value: true
});
var default_1$k = PlaylistAdd.default = void 0;
var _createSvgIcon$k = _interopRequireDefault$m(requireCreateSvgIcon());
var _jsxRuntime$k = require$$2;
var _default$k = (0, _createSvgIcon$k.default)(/* @__PURE__ */ (0, _jsxRuntime$k.jsx)("path", {
  d: "M14 10H3v2h11v-2zm0-4H3v2h11V6zm4 8v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zM3 16h7v-2H3v2z"
}), "PlaylistAdd");
default_1$k = PlaylistAdd.default = _default$k;
function AddToPlaylistDropdown({
  onClose,
  onClick,
  parentObjectId
}) {
  var _a;
  const [open, setOpen] = reactExports.useState(false);
  const myPlaylistsQuery = useMyPlaylistsQuery();
  const videoPlaylists2 = useVideoPlaylistsQuery(
    { id: parentObjectId ?? "" },
    { enabled: parentObjectId !== void 0 }
  );
  const handleClickOpen = () => {
    setOpen(true);
  };
  const handleClose = (e2) => {
    setOpen(false);
    onClose == null ? void 0 : onClose(e2);
  };
  const handleChange = async (playlistId, checked) => {
    if (!parentObjectId) {
      return;
    }
    await video$1(playlistId, parentObjectId, checked);
    videoPlaylists2.refetch();
  };
  return /* @__PURE__ */ jsxs("div", { children: [
    /* @__PURE__ */ jsxs(
      MenuItem$2,
      {
        onClick: (e2) => {
          onClick == null ? void 0 : onClick(e2);
          handleClickOpen();
        },
        children: [
          /* @__PURE__ */ jsx(ListItemIcon$1, { children: /* @__PURE__ */ jsx(default_1$k, {}) }),
          /* @__PURE__ */ jsx(ListItemText$1, { children: "Pidat do playlistu" })
        ]
      },
      "AddToPlaylist"
    ),
    open && /* @__PURE__ */ jsxs(
      Dialog$1,
      {
        onClose: (e2) => {
          e2.stopPropagation();
          handleClose(void 0);
        },
        open,
        fullWidth: true,
        maxWidth: "xs",
        children: [
          /* @__PURE__ */ jsx(DialogTitle$1, { children: "Pidat do playlistu" }),
          /* @__PURE__ */ jsx(DialogContent$1, { onClick: (e2) => e2.stopPropagation(), children: /* @__PURE__ */ jsx(Box$1, { sx: { display: "flex", flexDirection: "column", ml: 3 }, children: (_a = myPlaylistsQuery == null ? void 0 : myPlaylistsQuery.data) == null ? void 0 : _a.map((playlist) => {
            var _a2;
            return /* @__PURE__ */ jsx(
              FormControlLabel$1,
              {
                label: playlist.name,
                control: /* @__PURE__ */ jsx(
                  Checkbox$1,
                  {
                    checked: ((_a2 = videoPlaylists2 == null ? void 0 : videoPlaylists2.data) == null ? void 0 : _a2.includes(playlist.id)) ?? false,
                    onChange: (_2, checked) => {
                      handleChange(playlist.id, checked);
                    }
                  }
                )
              },
              playlist.id
            );
          }) }) }),
          /* @__PURE__ */ jsx(DialogActions$1, { children: /* @__PURE__ */ jsx(Button$2, { onClick: handleClose, children: "Zavt" }) })
        ]
      }
    )
  ] });
}
function AddToPlaylistDropDownFactory({
  onClose,
  onClick,
  parentObjectId
}) {
  return /* @__PURE__ */ jsx(
    AddToPlaylistDropdown,
    {
      onClose,
      onClick,
      parentObjectId
    },
    parentObjectId
  );
}
function VideoCard({
  video: video2,
  fullWidth,
  smallThumbnail,
  showDescription,
  showAvatar,
  showChannel,
  showStats,
  showTags,
  withPlayer,
  currentlyPlaying,
  urlParams
}) {
  var _a;
  const { imageUrl, name, id: id2, duration: duration5, description } = video2;
  const userContext = reactExports.useContext(UserContext);
  const navigate = useNavigate();
  const dropdownActions = [
    {
      elementFactory: (props) => AddToPlaylistDropDownFactory({ ...props, parentObjectId: video2.id })
    }
  ];
  return /* @__PURE__ */ jsx(Grid$1, { container: true, style: { textDecoration: "none" }, children: /* @__PURE__ */ jsxs(
    Card$1,
    {
      variant: "outlined",
      sx: {
        ...fullWidth && {
          display: "flex"
        },
        ...!fullWidth && {
          height: "100%"
        },
        width: "100%"
      },
      children: [
        /* @__PURE__ */ jsx(
          Grid$1,
          {
            item: true,
            xs: fullWidth ? smallThumbnail ? 2.5 : 4 : 12,
            sx: { position: "relative", ...fullWidth && { display: "flex" } },
            children: withPlayer ? /* @__PURE__ */ jsx(VideoPlayer, { videoSrc: "/sampleVideo.mp4", autoplay: true, muted: true }) : /* @__PURE__ */ jsxs(Box$3, { component: Link, to: `${videoUrl(video2)}${urlParams || ""}`, width: "100%", children: [
              /* @__PURE__ */ jsxs(AspectRatio, { ratio: 16 / 9, sx: { position: "relative" }, children: [
                /* @__PURE__ */ jsx(
                  CardMedia$1,
                  {
                    component: "img",
                    draggable: false,
                    image: ApiPath(imageUrl),
                    alt: imageUrl,
                    sx: {
                      maxHeight: "100%",
                      width: "100%",
                      objectFit: "cover",
                      ...currentlyPlaying && {
                        boxSizing: "border-box",
                        border: `3px solid ${theme.palette.primary.main}}`
                      }
                    }
                  }
                ),
                currentlyPlaying && /* @__PURE__ */ jsx(
                  Box$3,
                  {
                    className: "overlay",
                    sx: {
                      position: "absolute",
                      display: "flex",
                      color: `${theme.palette.primary.main}`,
                      height: "100%",
                      width: "100%",
                      top: 0,
                      left: 0,
                      alignItems: "center",
                      justifyContent: "center",
                      zIndex: 1
                    },
                    children: /* @__PURE__ */ jsx(
                      default_1$m,
                      {
                        fontSize: "large",
                        sx: { backgroundColor: "#ffffffdd", padding: "0.25em", borderRadius: "50%" }
                      }
                    )
                  }
                )
              ] }),
              /* @__PURE__ */ jsx(
                Typography$1,
                {
                  variant: "caption",
                  padding: 0.5,
                  sx: {
                    height: 16,
                    color: "white",
                    position: "absolute",
                    right: 0,
                    bottom: 0,
                    backgroundColor: "#333333bb",
                    borderRadius: "10%"
                  },
                  children: TimeSpanToReadableFormat(duration5)
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ jsx(
          Grid$1,
          {
            item: true,
            xs: fullWidth ? smallThumbnail ? 9.5 : 8 : 12,
            display: "flex",
            component: Link,
            to: `/${Route.video}/${id2}`,
            style: { textDecoration: "none" },
            children: /* @__PURE__ */ jsxs(
              CardContent$1,
              {
                sx: {
                  display: "grid",
                  paddingBottom: "4px !important",
                  width: "calc(100% - 8px)",
                  // 8px => left padding
                  padding: 1,
                  paddingRight: 0,
                  paddingTop: 0,
                  gridTemplateColumns: "100%",
                  ...!fullWidth && {
                    minHeight: 64
                  },
                  ...fullWidth && {
                    paddingRight: 1
                  },
                  ...smallThumbnail && {
                    maxHeight: "100%",
                    paddingBottom: "4px !important"
                  }
                },
                children: [
                  /* @__PURE__ */ jsxs(Box$3, { children: [
                    /* @__PURE__ */ jsxs(Box$3, { display: "flex", position: "relative", children: [
                      /* @__PURE__ */ jsx(
                        Typography$1,
                        {
                          variant: "subtitle2",
                          component: "div",
                          width: "100%",
                          height: fullWidth ? 24 : "auto",
                          textOverflow: "ellipsis",
                          overflow: "hidden",
                          display: "-webkit-box",
                          pb: "4px",
                          pt: 1,
                          sx: { WebkitLineClamp: 2, WebkitBoxOrient: "vertical" },
                          children: name
                        }
                      ),
                      (userContext == null ? void 0 : userContext.user) && /* @__PURE__ */ jsx(DropDownMenu, { actions: dropdownActions, icon: /* @__PURE__ */ jsx(default_1$l, {}) })
                    ] }),
                    (showDescription ?? false) && /* @__PURE__ */ jsx(
                      Typography$1,
                      {
                        variant: "caption",
                        sx: {
                          display: "-webkit-box",
                          WebkitLineClamp: 2,
                          WebkitBoxOrient: "vertical",
                          overflow: "hidden",
                          textOverflow: "ellipsis"
                        },
                        children: description
                      }
                    ),
                    (showStats ?? true) && /* @__PURE__ */ jsxs(Box$3, { pb: "4px", children: [
                      /* @__PURE__ */ jsxs(Typography$1, { variant: "caption", children: [
                        video2.views,
                        " zhldnut  "
                      ] }),
                      /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: TimestampToAgoWords(video2.uploadTimestamp) })
                    ] }),
                    (showTags ?? true) && ((_a = video2.tags) == null ? void 0 : _a.length) && /* @__PURE__ */ jsx(ChipLine, { chipData: video2.tags })
                  ] }),
                  (showChannel ?? true) && /* @__PURE__ */ jsxs(
                    Box$3,
                    {
                      display: "flex",
                      alignItems: "center",
                      onClick: (e2) => {
                        e2.preventDefault();
                        navigate(`/${Route.channel}/${video2.channelId}`);
                      },
                      sx: {
                        textDecoration: "none",
                        color: "unset",
                        "&:hover": {
                          backgroundColor: "rgba(0, 0, 0, 0.04)"
                        },
                        borderRadius: "15px",
                        zIndex: 999,
                        cursor: "pointer"
                      },
                      children: [
                        (showAvatar ?? true) && /* @__PURE__ */ jsx(
                          ChannelAvatar,
                          {
                            imageSrc: ApiPath(video2 == null ? void 0 : video2.channelAvatarUrl),
                            avatarInitials: video2.channelName
                          }
                        ),
                        /* @__PURE__ */ jsx(Typography$1, { paddingLeft: 1, variant: smallThumbnail ? "caption" : "body1", children: video2.channelName })
                      ]
                    }
                  )
                ]
              }
            )
          }
        )
      ]
    }
  ) });
}
var ArrowForwardIos = {};
var _interopRequireDefault$l = interopRequireDefaultExports;
Object.defineProperty(ArrowForwardIos, "__esModule", {
  value: true
});
var default_1$j = ArrowForwardIos.default = void 0;
var _createSvgIcon$j = _interopRequireDefault$l(requireCreateSvgIcon());
var _jsxRuntime$j = require$$2;
var _default$j = (0, _createSvgIcon$j.default)(/* @__PURE__ */ (0, _jsxRuntime$j.jsx)("path", {
  d: "M6.23 20.23 8 22l10-10L8 2 6.23 3.77 14.46 12z"
}), "ArrowForwardIos");
default_1$j = ArrowForwardIos.default = _default$j;
var ArrowBackIosNew = {};
var _interopRequireDefault$k = interopRequireDefaultExports;
Object.defineProperty(ArrowBackIosNew, "__esModule", {
  value: true
});
var default_1$i = ArrowBackIosNew.default = void 0;
var _createSvgIcon$i = _interopRequireDefault$k(requireCreateSvgIcon());
var _jsxRuntime$i = require$$2;
var _default$i = (0, _createSvgIcon$i.default)(/* @__PURE__ */ (0, _jsxRuntime$i.jsx)("path", {
  d: "M17.77 3.77 16 2 6 12l10 10 1.77-1.77L9.54 12z"
}), "ArrowBackIosNew");
default_1$i = ArrowBackIosNew.default = _default$i;
function InlineList({ children }) {
  const videosListRef = reactExports.useRef(null);
  const [showLeft, setShowLeft] = React.useState(false);
  const [showRight, setShowRight] = React.useState(true);
  const scrollByButton = () => {
    setTimeout(() => {
      if (!videosListRef.current) {
        return;
      }
      if (videosListRef.current.scrollLeft > videosListRef.current.scrollWidth - videosListRef.current.clientWidth - 200) {
        setShowRight(false);
      } else {
        setShowRight(true);
      }
      if (videosListRef.current.scrollLeft < 200) {
        setShowLeft(false);
      } else {
        setShowLeft(true);
      }
    }, 300);
  };
  const scroll3 = (scrollRight) => {
    if (videosListRef.current) {
      if (scrollRight) {
        videosListRef.current.scrollLeft += videosListRef.current.scrollWidth / 2;
      } else {
        videosListRef.current.scrollLeft -= videosListRef.current.scrollWidth / 2;
      }
    }
  };
  return /* @__PURE__ */ jsxs(Box$3, { display: "flex", sx: { maxWidth: "100%", minWidth: "100%" }, alignItems: "center", position: "relative", children: [
    showLeft && /* @__PURE__ */ jsx(
      Button$2,
      {
        sx: {
          position: "absolute",
          zIndex: "100",
          height: "100%",
          "&:hover": {
            backgroundColor: "#ffffff99",
            "& .arrowButton": { backgroundColor: "transparent" }
          }
        },
        onClick: () => scroll3(false),
        children: /* @__PURE__ */ jsx(
          default_1$i,
          {
            className: "arrowButton",
            sx: {
              padding: "10px",
              backgroundColor: "#ffffff99",
              borderRadius: "50px",
              transition: "background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;"
            }
          }
        )
      }
    ),
    /* @__PURE__ */ jsx(
      ImageList$1,
      {
        ref: videosListRef,
        onScroll: () => scrollByButton(),
        sx: {
          scrollBehavior: "smooth",
          gridAutoFlow: "column",
          gridTemplateColumns: "repeat(auto-fill,minmax(280px,1fr)) !important",
          gridAutoColumns: "minmax(280px, 1fr)",
          gap: "8px !important",
          width: "100%",
          overflowX: "scroll",
          overflowY: "hidden",
          scrollbarWidth: "thin",
          "&::-webkit-scrollbar": {
            width: "10px",
            height: "0.3em"
          },
          "&::-webkit-scrollbar-track": {
            background: "#f1f1f1"
          },
          "&::-webkit-scrollbar-thumb": {
            background: "linear-gradient(to right, transparent 0%,#AAA 25%,#AAA 75%, transparent 100%)"
          },
          ...!showLeft && {
            "&::-webkit-scrollbar-thumb": {
              background: "linear-gradient(to right, #AAA 0%,#AAA 25%,#AAA 75%, transparent 100%)"
            }
          },
          ...!showRight && {
            "&::-webkit-scrollbar-thumb": {
              background: "linear-gradient(to right, transparent 0%,#AAA 25%,#AAA 75%, #AAA 100%)"
            }
          },
          "&::-webkit-scrollbar-thumb:hover": {
            background: "#555"
          }
        },
        children
      }
    ),
    showRight && /* @__PURE__ */ jsx(
      Button$2,
      {
        sx: {
          position: "absolute",
          zIndex: "100",
          right: "0",
          height: "100%",
          "&:hover": {
            backgroundColor: "#ffffff99",
            "& .arrowButton": { backgroundColor: "transparent" }
          }
        },
        onClick: () => scroll3(true),
        children: /* @__PURE__ */ jsx(
          default_1$j,
          {
            className: "arrowButton",
            sx: {
              padding: "10px",
              backgroundColor: "#ffffff99",
              borderRadius: "50px",
              transition: "background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,border-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;"
            }
          }
        )
      }
    )
  ] });
}
function VideoInlineList({
  videos,
  currentlyPlaying,
  urlParamsGenerator,
  skeletonCount = 5,
  showChannel = false,
  showDescription = false
}) {
  return /* @__PURE__ */ jsx(InlineList, { children: videos ? videos.map((_video, index2) => /* @__PURE__ */ jsx(
    VideoCard,
    {
      video: _video,
      showChannel,
      showDescription,
      smallThumbnail: true,
      currentlyPlaying: currentlyPlaying === index2,
      urlParams: urlParamsGenerator ? urlParamsGenerator(_video, index2) : ""
    },
    _video.id
  )) : [...Array(skeletonCount)].map((_2, i) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ jsx(Skeleton$1, { variant: "rounded", animation: "wave", height: 220 }, `skeleton-${i}`)
  )) });
}
function HomePage() {
  var _a;
  const videos = useVideosAllQuery(void 0, 5);
  const channels = useChannelsAllQuery();
  const tags2 = useTagsAllQuery();
  return /* @__PURE__ */ jsxs(Grid$1, { container: true, p: 2, children: [
    /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", children: "Nejnovj videa" }),
      /* @__PURE__ */ jsx(Grid$1, { container: true, spacing: 1, p: 2, sx: { overflow: "hidden", gridRow: 1 }, children: /* @__PURE__ */ jsx(VideoInlineList, { videos: videos.data, showChannel: true }) })
    ] }),
    /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, md: 6, children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", children: "Populrn tagy" }),
      /* @__PURE__ */ jsx(Grid$1, { container: true, gap: 0.5, pt: 1, children: (tags2 == null ? void 0 : tags2.data) ? tags2 == null ? void 0 : tags2.data.map((tag) => /* @__PURE__ */ jsx(CustomChip, { text: tag.name }, tag.id)) : [...Array(6)].map((_2, i) => (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 6, p: 0.5, children: /* @__PURE__ */ jsx(Skeleton$1, { variant: "rounded", animation: "wave", width: "100%", height: "32px" }) }, `${i}-skeleton`)
      )) }),
      " "
    ] }),
    /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, md: 6, children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", children: "Kanly" }),
      /* @__PURE__ */ jsx(Grid$1, { container: true, children: !channels.isLoading ? (_a = channels == null ? void 0 : channels.data) == null ? void 0 : _a.map((channel) => /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 6, children: /* @__PURE__ */ jsx(
        AvatarButton,
        {
          url: `/${Route.channel}/${channel.id}`,
          text: channel.name,
          image: ApiPath(channel.avatarUrl)
        }
      ) }, channel.id)) : [...Array(6)].map((_2, i) => (
        // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 6, p: 0.5, children: /* @__PURE__ */ jsx(Skeleton$1, { variant: "rounded", animation: "wave", width: "100%", height: "64px" }) }, `${i}-skeleton`)
      )) })
    ] })
  ] });
}
var ExpandMore = {};
var _interopRequireDefault$j = interopRequireDefaultExports;
Object.defineProperty(ExpandMore, "__esModule", {
  value: true
});
var default_1$h = ExpandMore.default = void 0;
var _createSvgIcon$h = _interopRequireDefault$j(requireCreateSvgIcon());
var _jsxRuntime$h = require$$2;
var _default$h = (0, _createSvgIcon$h.default)(/* @__PURE__ */ (0, _jsxRuntime$h.jsx)("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore");
default_1$h = ExpandMore.default = _default$h;
var lib$1 = {};
var renderer = {};
var classnamesExports = {};
var classnames = {
  get exports() {
    return classnamesExports;
  },
  set exports(v2) {
    classnamesExports = v2;
  }
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames.default = classNames;
      module.exports = classNames;
    } else {
      window.classNames = classNames;
    }
  })();
})(classnames);
var invariant$3 = function(condition, format, a2, b2, c2, d3, e2, f2) {
  if (!condition) {
    var error;
    if (format === void 0) {
      error = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    } else {
      var args = [a2, b2, c2, d3, e2, f2];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() {
          return args[argIndex++];
        })
      );
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
};
var browser = invariant$3;
var stringTag = "[object String]";
var objectProto$1 = Object.prototype;
var objectToString$1 = objectProto$1.toString;
var isArray$1 = Array.isArray;
function isObjectLike$1(value) {
  return !!value && typeof value == "object";
}
function isString$1(value) {
  return typeof value == "string" || !isArray$1(value) && isObjectLike$1(value) && objectToString$1.call(value) == stringTag;
}
var lodash_isstring = isString$1;
var MAX_SAFE_INTEGER = 9007199254740991;
var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal || freeSelf || Function("return this")();
function arrayPush(array, values3) {
  var index2 = -1, length2 = values3.length, offset3 = array.length;
  while (++index2 < length2) {
    array[offset3 + index2] = values3[index2];
  }
  return array;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectToString = objectProto.toString;
var Symbol$1 = root$1.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length2 = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length2) {
    var value = array[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
function flatten$1(array) {
  var length2 = array ? array.length : 0;
  return length2 ? baseFlatten(array, 1) : [];
}
function isArguments(value) {
  return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
var isArray = Array.isArray;
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function isFunction$1(value) {
  var tag = isObject2(value) ? objectToString.call(value) : "";
  return tag == funcTag || tag == genTag;
}
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isObject2(value) {
  var type2 = typeof value;
  return !!value && (type2 == "object" || type2 == "function");
}
function isObjectLike(value) {
  return !!value && typeof value == "object";
}
var lodash_flatten = flatten$1;
var invariant$2 = browser, isString = lodash_isstring, flatten2 = lodash_flatten;
function replace(string, regexpOrSubstr, newValueOrFn) {
  invariant$2(typeof string === "string", "First param must be a string");
  invariant$2(typeof regexpOrSubstr === "string" || regexpOrSubstr instanceof RegExp, "Second param must be a string pattern or a regular expression");
  var fn2 = typeof regexpOrSubstr === "string" ? replaceUsingString : replaceUsingRegexp;
  return fn2(string, regexpOrSubstr, newValueOrFn);
}
function replaceUsingString(string, patternString, newValueOrFn) {
  var index2 = string.indexOf(patternString);
  if (index2 >= 0) {
    var arr = [];
    var endIndex = index2 + patternString.length;
    if (index2 > 0) {
      arr.push(string.substring(0, index2));
    }
    arr.push(
      typeof newValueOrFn === "function" ? newValueOrFn(
        string.substring(index2, endIndex),
        index2,
        string
      ) : newValueOrFn
    );
    if (endIndex < string.length) {
      arr.push(string.substring(endIndex));
    }
    return arr;
  } else {
    return [string];
  }
}
function replaceUsingRegexp(string, regexp, newValueOrFn) {
  var output = [];
  var replacerIsFn = typeof newValueOrFn === "function";
  var storedLastIndex = regexp.lastIndex;
  regexp.lastIndex = 0;
  var result;
  var lastIndex = 0;
  while (result = regexp.exec(string)) {
    var index2 = result.index;
    if (result[0] === "") {
      regexp.lastIndex++;
    }
    if (index2 !== lastIndex) {
      output.push(string.substring(lastIndex, index2));
    }
    var match2 = result[0];
    lastIndex = index2 + match2.length;
    var out = replacerIsFn ? newValueOrFn.apply(this, result.concat(index2, result.input)) : newValueOrFn;
    output.push(out);
    if (!regexp.global) {
      break;
    }
  }
  if (lastIndex < string.length) {
    output.push(string.substring(lastIndex));
  }
  regexp.lastIndex = storedLastIndex;
  return output;
}
var stringReplaceToArray = function stringReplaceToArray2(string, regexpOrSubstr, newSubStrOrFn) {
  if (isString(string)) {
    return replace(string, regexpOrSubstr, newSubStrOrFn);
  } else if (!Array.isArray(string) || !string[0]) {
    throw new TypeError("First argument must be an array or non-empty string");
  } else {
    return flatten2(string.map(function(string2) {
      if (!isString(string2))
        return string2;
      return replace(string2, regexpOrSubstr, newSubStrOrFn);
    }));
  }
};
var emojiRegex = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
var aliasRegex = {};
var asciiAliases = {
  angry: [">:(", ">:-("],
  blush: [':")', ':-")'],
  broken_heart: ["</3", "<\\3"],
  confused: [":/", ":-/"],
  cry: [":'(", ":'-(", ":,(", ":,-("],
  frowning: [":(", ":-("],
  heart: ["<3"],
  imp: ["]:(", "]:-("],
  innocent: ["o:)", "O:)", "o:-)", "O:-)", "0:)", "0:-)"],
  joy: [":')", ":'-)", ":,)", ":,-)", ":'D", ":'-D", ":,D", ":,-D"],
  kissing: [":*", ":-*"],
  laughing: ["x-)", "X-)"],
  neutral_face: [":|", ":-|"],
  open_mouth: [":o", ":-o", ":O", ":-O"],
  rage: [":@", ":-@"],
  smile: [":D", ":-D"],
  smiley: [":)", ":-)"],
  smiling_imp: ["]:)", "]:-)"],
  sob: [":,'(", ":,'-(", ";(", ";-("],
  stuck_out_tongue: [":P", ":-P", ":p", ":-p"],
  sunglasses: ["8-)", "B-)"],
  sweat: [",:(", ",:-("],
  sweat_smile: [",:)", ",:-)"],
  unamused: [":s", ":-S", ":z", ":-Z", ":$", ":-$"],
  wink: [";)", ";-)"]
};
var utils = {};
Object.defineProperty(utils, "__esModule", {
  value: true
});
utils.escapeStringToBeUsedInRegExp = escapeStringToBeUsedInRegExp;
utils.stripNonStringElements = stripNonStringElements;
utils.returnNonStringStrippedElements = returnNonStringStrippedElements;
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var NON_STRING_PLACEHOLDER = "__REACT_EMOJI_RENDER_PLACEHOLDER__";
function escapeStringToBeUsedInRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function stripNonStringElements(children) {
  var strippedChildren = children.map(function(child) {
    return typeof child === "string" ? child : NON_STRING_PLACEHOLDER;
  }).join("");
  var elements = children.filter(function(child) {
    return typeof child !== "string";
  });
  return [strippedChildren, elements];
}
function flatMap(array, mapper) {
  var result = [];
  for (var i = 0; i < array.length; ++i) {
    var item = mapper(array[i], i, array);
    if (!Array.isArray(item)) {
      item = [item];
    }
    for (var j2 = 0; j2 < item.length; ++j2) {
      result.push(item[j2]);
    }
  }
  return result;
}
function returnNonStringStrippedElements(stripped, elements) {
  if (!stripped || !Array.isArray(stripped))
    return stripped;
  if (!elements || !elements.length)
    return stripped;
  var count2 = -1;
  function replacePlaceholder(string) {
    var split2 = string.split(NON_STRING_PLACEHOLDER);
    if (split2.length > 1) {
      return flatMap(split2, function(item, index2) {
        if (index2 === 0)
          return [item];
        else {
          count2++;
          return [elements[count2], item];
        }
      });
    } else {
      count2++;
      return [].concat(_toConsumableArray(split2), [elements[count2]]);
    }
  }
  return flatMap(stripped, function(item) {
    if (typeof item === "string") {
      if (item.trim() === NON_STRING_PLACEHOLDER) {
        count2++;
        return elements[count2];
      } else if (item.includes(NON_STRING_PLACEHOLDER)) {
        return replacePlaceholder(item);
      }
    }
    return item;
  });
}
Object.defineProperty(aliasRegex, "__esModule", {
  value: true
});
var _asciiAliases$1 = asciiAliases;
var _asciiAliases2$1 = _interopRequireDefault$i(_asciiAliases$1);
var _lodash = lodash_flatten;
var _lodash2 = _interopRequireDefault$i(_lodash);
var _utils$1 = utils;
function _interopRequireDefault$i(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var allowedAliasCharacters = "\\w\\-\\_\\+\\*\\(\\)\\!#&,";
var startOfURL = "https?\\S*";
var names = (0, _lodash2.default)(Object.keys(_asciiAliases2$1.default).map(function(name) {
  return _asciiAliases2$1.default[name].map(_utils$1.escapeStringToBeUsedInRegExp);
})).sort().reverse().join("|");
var edgeCases = [startOfURL].join("|");
function getAliasesRegex() {
  return new RegExp(
    // edge cases will be skipped
    // match both (and later distinguish between)
    // * ascii aliases like :o
    // * full emoji like :open_mouth:
    "(" + edgeCases + ")?(" + names + "|:)([" + allowedAliasCharacters + "]*:)?",
    "g"
  );
}
aliasRegex.default = getAliasesRegex;
var normalizeProtocol$1 = {};
Object.defineProperty(normalizeProtocol$1, "__esModule", {
  value: true
});
normalizeProtocol$1.default = normalizeProtocol;
function normalizeProtocol(protocol) {
  if (protocol && !protocol.endsWith(":"))
    return protocol + ":";
  return protocol;
}
var unicodeToCodepoint$1 = {};
Object.defineProperty(unicodeToCodepoint$1, "__esModule", {
  value: true
});
unicodeToCodepoint$1.default = unicodeToCodepoint;
var UFE0Fg = /\uFE0F/g;
var U200D = String.fromCharCode(8205);
function toCodePoint(input) {
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "-";
  var codePoints = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = void 0;
  try {
    for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion2 = (_step = _iterator.next()).done); _iteratorNormalCompletion2 = true) {
      var codePoint = _step.value;
      codePoints.push(codePoint.codePointAt(0).toString(16));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
  return codePoints.join(separator);
}
function unicodeToCodepoint(input) {
  return toCodePoint(input.indexOf(U200D) < 0 ? input.replace(UFE0Fg, "") : input);
}
var aliases = {
  "0": "0",
  "1": "1",
  "2": "2",
  "3": "3",
  "4": "4",
  "5": "5",
  "6": "6",
  "7": "7",
  "8": "8",
  "9": "9",
  "10": "",
  "100": "",
  "1234": "",
  grinning_face: "",
  grinning_face_with_big_eyes: "",
  grinning_face_with_smiling_eyes: "",
  beaming_face_with_smiling_eyes: "",
  grinning_squinting_face: "",
  grinning_face_with_sweat: "",
  rolling_on_the_floor_laughing: "",
  face_with_tears_of_joy: "",
  slightly_smiling_face: "",
  upside_down_face: "",
  winking_face: "",
  smiling_face_with_smiling_eyes: "",
  smiling_face_with_halo: "",
  smiling_face_with_hearts: "",
  smiling_face_with_heart_eyes: "",
  smiling_face_with_tear: "",
  star_struck: "",
  face_blowing_a_kiss: "",
  kissing_face: "",
  smiling_face: "",
  kissing_face_with_closed_eyes: "",
  kissing_face_with_smiling_eyes: "",
  face_savoring_food: "",
  face_with_tongue: "",
  winking_face_with_tongue: "",
  zany_face: "",
  squinting_face_with_tongue: "",
  money_mouth_face: "",
  hugging_face: "",
  face_with_hand_over_mouth: "",
  shushing_face: "",
  thinking_face: "",
  zipper_mouth_face: "",
  face_with_raised_eyebrow: "",
  neutral_face: "",
  expressionless_face: "",
  face_without_mouth: "",
  smirking_face: "",
  unamused_face: "",
  face_with_rolling_eyes: "",
  grimacing_face: "",
  lying_face: "",
  relieved_face: "",
  pensive_face: "",
  sleepy_face: "",
  drooling_face: "",
  sleeping_face: "",
  face_with_medical_mask: "",
  face_with_thermometer: "",
  face_with_head_bandage: "",
  nauseated_face: "",
  face_vomiting: "",
  sneezing_face: "",
  hot_face: "",
  cold_face: "",
  woozy_face: "",
  dizzy_face: "",
  exploding_head: "",
  cowboy_hat_face: "",
  partying_face: "",
  smiling_face_with_sunglasses: "",
  nerd_face: "",
  face_with_monocle: "",
  confused_face: "",
  worried_face: "",
  slightly_frowning_face: "",
  frowning_face: "",
  face_with_open_mouth: "",
  hushed_face: "",
  astonished_face: "",
  flushed_face: "",
  pleading_face: "",
  frowning_face_with_open_mouth: "",
  anguished_face: "",
  fearful_face: "",
  anxious_face_with_sweat: "",
  sad_but_relieved_face: "",
  crying_face: "",
  loudly_crying_face: "",
  face_screaming_in_fear: "",
  confounded_face: "",
  persevering_face: "",
  disappointed_face: "",
  downcast_face_with_sweat: "",
  weary_face: "",
  tired_face: "",
  yawning_face: "",
  face_with_steam_from_nose: "",
  pouting_face: "",
  angry_face: "",
  face_with_symbols_on_mouth: "",
  smiling_face_with_horns: "",
  angry_face_with_horns: "",
  skull: "",
  skull_and_crossbones: "",
  pile_of_poo: "",
  clown_face: "",
  ogre: "",
  goblin: "",
  ghost: "",
  alien: "",
  alien_monster: "",
  robot: "",
  grinning_cat: "",
  grinning_cat_with_smiling_eyes: "",
  cat_with_tears_of_joy: "",
  smiling_cat_with_heart_eyes: "",
  cat_with_wry_smile: "",
  kissing_cat: "",
  weary_cat: "",
  crying_cat: "",
  pouting_cat: "",
  see_no_evil_monkey: "",
  hear_no_evil_monkey: "",
  speak_no_evil_monkey: "",
  kiss_mark: "",
  love_letter: "",
  heart_with_arrow: "",
  heart_with_ribbon: "",
  sparkling_heart: "",
  growing_heart: "",
  beating_heart: "",
  revolving_hearts: "",
  two_hearts: "",
  heart_decoration: "",
  heart_exclamation: "",
  broken_heart: "",
  red_heart: "",
  orange_heart: "",
  yellow_heart: "",
  green_heart: "",
  blue_heart: "",
  purple_heart: "",
  brown_heart: "",
  black_heart: "",
  white_heart: "",
  hundred_points: "",
  anger_symbol: "",
  collision: "",
  dizzy: "",
  sweat_droplets: "",
  dashing_away: "",
  hole: "",
  bomb: "",
  speech_balloon: "",
  eye_in_speech_bubble: "",
  left_speech_bubble: "",
  right_anger_bubble: "",
  thought_balloon: "",
  zzz: "",
  waving_hand: "",
  raised_back_of_hand: "",
  hand_with_fingers_splayed: "",
  raised_hand: "",
  vulcan_salute: "",
  ok_hand: "",
  pinching_hand: "",
  victory_hand: "",
  crossed_fingers: "",
  love_you_gesture: "",
  sign_of_the_horns: "",
  call_me_hand: "",
  backhand_index_pointing_left: "",
  backhand_index_pointing_right: "",
  backhand_index_pointing_up: "",
  middle_finger: "",
  backhand_index_pointing_down: "",
  index_pointing_up: "",
  thumbs_up: "",
  thumbs_down: "",
  raised_fist: "",
  oncoming_fist: "",
  left_facing_fist: "",
  right_facing_fist: "",
  clapping_hands: "",
  raising_hands: "",
  open_hands: "",
  palms_up_together: "",
  handshake: "",
  folded_hands: "",
  writing_hand: "",
  nail_polish: "",
  selfie: "",
  flexed_biceps: "",
  mechanical_arm: "",
  mechanical_leg: "",
  leg: "",
  foot: "",
  ear: "",
  ear_with_hearing_aid: "",
  nose: "",
  brain: "",
  tooth: "",
  bone: "",
  eyes: "",
  eye: "",
  tongue: "",
  mouth: "",
  baby: "",
  child: "",
  boy: "",
  girl: "",
  person: "",
  person_blond_hair: "",
  man: "",
  man_beard: "",
  man_red_hair: "",
  man_curly_hair: "",
  man_white_hair: "",
  man_bald: "",
  woman: "",
  woman_red_hair: "",
  person_red_hair: "",
  woman_curly_hair: "",
  person_curly_hair: "",
  woman_white_hair: "",
  person_white_hair: "",
  woman_bald: "",
  person_bald: "",
  woman_blond_hair: "",
  man_blond_hair: "",
  older_person: "",
  old_man: "",
  old_woman: "",
  person_frowning: "",
  man_frowning: "",
  woman_frowning: "",
  person_pouting: "",
  man_pouting: "",
  woman_pouting: "",
  person_gesturing_no: "",
  man_gesturing_no: "",
  woman_gesturing_no: "",
  person_gesturing_ok: "",
  man_gesturing_ok: "",
  woman_gesturing_ok: "",
  person_tipping_hand: "",
  man_tipping_hand: "",
  woman_tipping_hand: "",
  person_raising_hand: "",
  man_raising_hand: "",
  woman_raising_hand: "",
  deaf_person: "",
  deaf_man: "",
  deaf_woman: "",
  person_bowing: "",
  man_bowing: "",
  woman_bowing: "",
  person_facepalming: "",
  man_facepalming: "",
  woman_facepalming: "",
  person_shrugging: "",
  man_shrugging: "",
  woman_shrugging: "",
  health_worker: "",
  man_health_worker: "",
  woman_health_worker: "",
  student: "",
  man_student: "",
  woman_student: "",
  teacher: "",
  man_teacher: "",
  woman_teacher: "",
  judge: "",
  man_judge: "",
  woman_judge: "",
  farmer: "",
  man_farmer: "",
  woman_farmer: "",
  cook: "",
  man_cook: "",
  woman_cook: "",
  mechanic: "",
  man_mechanic: "",
  woman_mechanic: "",
  factory_worker: "",
  man_factory_worker: "",
  woman_factory_worker: "",
  office_worker: "",
  man_office_worker: "",
  woman_office_worker: "",
  scientist: "",
  man_scientist: "",
  woman_scientist: "",
  technologist: "",
  man_technologist: "",
  woman_technologist: "",
  singer: "",
  man_singer: "",
  woman_singer: "",
  artist: "",
  man_artist: "",
  woman_artist: "",
  pilot: "",
  man_pilot: "",
  woman_pilot: "",
  astronaut: "",
  man_astronaut: "",
  woman_astronaut: "",
  firefighter: "",
  man_firefighter: "",
  woman_firefighter: "",
  police_officer: "",
  man_police_officer: "",
  woman_police_officer: "",
  detective: "",
  man_detective: "",
  woman_detective: "",
  guard: "",
  man_guard: "",
  woman_guard: "",
  construction_worker: "",
  man_construction_worker: "",
  woman_construction_worker: "",
  prince: "",
  princess: "",
  person_wearing_turban: "",
  man_wearing_turban: "",
  woman_wearing_turban: "",
  man_with_skullcap: "",
  woman_with_headscarf: "",
  man_in_tuxedo: "",
  bride_with_veil: "",
  pregnant_woman: "",
  breast_feeding: "",
  baby_angel: "",
  santa_claus: "",
  mrs_claus: "",
  superhero: "",
  man_superhero: "",
  woman_superhero: "",
  supervillain: "",
  man_supervillain: "",
  woman_supervillain: "",
  mage: "",
  man_mage: "",
  woman_mage: "",
  fairy: "",
  man_fairy: "",
  woman_fairy: "",
  vampire: "",
  man_vampire: "",
  woman_vampire: "",
  merperson: "",
  merman: "",
  mermaid: "",
  elf: "",
  man_elf: "",
  woman_elf: "",
  genie: "",
  man_genie: "",
  woman_genie: "",
  zombie: "",
  man_zombie: "",
  woman_zombie: "",
  person_getting_massage: "",
  man_getting_massage: "",
  woman_getting_massage: "",
  person_getting_haircut: "",
  man_getting_haircut: "",
  woman_getting_haircut: "",
  person_walking: "",
  man_walking: "",
  woman_walking: "",
  person_standing: "",
  man_standing: "",
  woman_standing: "",
  person_kneeling: "",
  man_kneeling: "",
  woman_kneeling: "",
  person_with_probing_cane: "",
  man_with_probing_cane: "",
  woman_with_probing_cane: "",
  person_in_motorized_wheelchair: "",
  man_in_motorized_wheelchair: "",
  woman_in_motorized_wheelchair: "",
  person_in_manual_wheelchair: "",
  man_in_manual_wheelchair: "",
  woman_in_manual_wheelchair: "",
  person_running: "",
  man_running: "",
  woman_running: "",
  woman_dancing: "",
  man_dancing: "",
  man_in_suit_levitating: "",
  people_with_bunny_ears: "",
  men_with_bunny_ears: "",
  women_with_bunny_ears: "",
  person_in_steamy_room: "",
  man_in_steamy_room: "",
  woman_in_steamy_room: "",
  person_climbing: "",
  man_climbing: "",
  woman_climbing: "",
  person_fencing: "",
  horse_racing: "",
  skier: "",
  snowboarder: "",
  person_golfing: "",
  man_golfing: "",
  woman_golfing: "",
  person_surfing: "",
  man_surfing: "",
  woman_surfing: "",
  person_rowing_boat: "",
  man_rowing_boat: "",
  woman_rowing_boat: "",
  person_swimming: "",
  man_swimming: "",
  woman_swimming: "",
  person_bouncing_ball: "",
  man_bouncing_ball: "",
  woman_bouncing_ball: "",
  person_lifting_weights: "",
  man_lifting_weights: "",
  woman_lifting_weights: "",
  person_biking: "",
  man_biking: "",
  woman_biking: "",
  person_mountain_biking: "",
  man_mountain_biking: "",
  woman_mountain_biking: "",
  person_cartwheeling: "",
  man_cartwheeling: "",
  woman_cartwheeling: "",
  people_wrestling: "",
  men_wrestling: "",
  women_wrestling: "",
  person_playing_water_polo: "",
  man_playing_water_polo: "",
  woman_playing_water_polo: "",
  person_playing_handball: "",
  man_playing_handball: "",
  woman_playing_handball: "",
  person_juggling: "",
  man_juggling: "",
  woman_juggling: "",
  person_in_lotus_position: "",
  man_in_lotus_position: "",
  woman_in_lotus_position: "",
  person_taking_bath: "",
  person_in_bed: "",
  people_holding_hands: "",
  women_holding_hands: "",
  woman_and_man_holding_hands: "",
  men_holding_hands: "",
  kiss: "",
  kiss_woman_man: "",
  kiss_man_man: "",
  kiss_woman_woman: "",
  couple_with_heart: "",
  couple_with_heart_woman_man: "",
  couple_with_heart_man_man: "",
  couple_with_heart_woman_woman: "",
  family: "",
  family_man_woman_boy: "",
  family_man_woman_girl: "",
  family_man_woman_girl_boy: "",
  family_man_woman_boy_boy: "",
  family_man_woman_girl_girl: "",
  family_man_man_boy: "",
  family_man_man_girl: "",
  family_man_man_girl_boy: "",
  family_man_man_boy_boy: "",
  family_man_man_girl_girl: "",
  family_woman_woman_boy: "",
  family_woman_woman_girl: "",
  family_woman_woman_girl_boy: "",
  family_woman_woman_boy_boy: "",
  family_woman_woman_girl_girl: "",
  family_man_boy: "",
  family_man_boy_boy: "",
  family_man_girl: "",
  family_man_girl_boy: "",
  family_man_girl_girl: "",
  family_woman_boy: "",
  family_woman_boy_boy: "",
  family_woman_girl: "",
  family_woman_girl_boy: "",
  family_woman_girl_girl: "",
  speaking_head: "",
  bust_in_silhouette: "",
  busts_in_silhouette: "",
  footprints: "",
  monkey_face: "",
  monkey: "",
  gorilla: "",
  orangutan: "",
  dog_face: "",
  dog: "",
  guide_dog: "",
  service_dog: "",
  poodle: "",
  wolf: "",
  fox: "",
  raccoon: "",
  cat_face: "",
  cat: "",
  lion: "",
  tiger_face: "",
  tiger: "",
  leopard: "",
  horse_face: "",
  horse: "",
  unicorn: "",
  zebra: "",
  deer: "",
  cow_face: "",
  ox: "",
  water_buffalo: "",
  cow: "",
  pig_face: "",
  pig: "",
  boar: "",
  pig_nose: "",
  ram: "",
  ewe: "",
  goat: "",
  camel: "",
  two_hump_camel: "",
  llama: "",
  giraffe: "",
  elephant: "",
  rhinoceros: "",
  hippopotamus: "",
  mouse_face: "",
  mouse: "",
  rat: "",
  hamster: "",
  rabbit_face: "",
  rabbit: "",
  chipmunk: "",
  hedgehog: "",
  bat: "",
  bear: "",
  koala: "",
  panda: "",
  sloth: "",
  otter: "",
  skunk: "",
  kangaroo: "",
  badger: "",
  paw_prints: "",
  turkey: "",
  chicken: "",
  rooster: "",
  hatching_chick: "",
  baby_chick: "",
  front_facing_baby_chick: "",
  bird: "",
  penguin: "",
  dove: "",
  eagle: "",
  duck: "",
  swan: "",
  owl: "",
  flamingo: "",
  peacock: "",
  parrot: "",
  frog: "",
  crocodile: "",
  turtle: "",
  lizard: "",
  snake: "",
  dragon_face: "",
  dragon: "",
  sauropod: "",
  t_rex: "",
  spouting_whale: "",
  whale: "",
  dolphin: "",
  fish: "",
  tropical_fish: "",
  blowfish: "",
  shark: "",
  octopus: "",
  spiral_shell: "",
  snail: "",
  butterfly: "",
  bug: "",
  ant: "",
  honeybee: "",
  lady_beetle: "",
  cricket: "",
  spider: "",
  spider_web: "",
  scorpion: "",
  mosquito: "",
  microbe: "",
  bouquet: "",
  cherry_blossom: "",
  white_flower: "",
  rosette: "",
  rose: "",
  wilted_flower: "",
  hibiscus: "",
  sunflower: "",
  blossom: "",
  tulip: "",
  seedling: "",
  evergreen_tree: "",
  deciduous_tree: "",
  palm_tree: "",
  cactus: "",
  sheaf_of_rice: "",
  herb: "",
  shamrock: "",
  four_leaf_clover: "",
  maple_leaf: "",
  fallen_leaf: "",
  leaf_fluttering_in_wind: "",
  grapes: "",
  melon: "",
  watermelon: "",
  tangerine: "",
  lemon: "",
  banana: "",
  pineapple: "",
  mango: "",
  red_apple: "",
  green_apple: "",
  pear: "",
  peach: "",
  cherries: "",
  strawberry: "",
  kiwi_fruit: "",
  tomato: "",
  coconut: "",
  avocado: "",
  eggplant: "",
  potato: "",
  carrot: "",
  ear_of_corn: "",
  hot_pepper: "",
  cucumber: "",
  leafy_green: "",
  broccoli: "",
  garlic: "",
  onion: "",
  mushroom: "",
  peanuts: "",
  chestnut: "",
  bread: "",
  croissant: "",
  baguette_bread: "",
  pretzel: "",
  bagel: "",
  pancakes: "",
  waffle: "",
  cheese_wedge: "",
  meat_on_bone: "",
  poultry_leg: "",
  cut_of_meat: "",
  bacon: "",
  hamburger: "",
  french_fries: "",
  pizza: "",
  hot_dog: "",
  sandwich: "",
  taco: "",
  burrito: "",
  stuffed_flatbread: "",
  falafel: "",
  egg: "",
  cooking: "",
  shallow_pan_of_food: "",
  pot_of_food: "",
  bowl_with_spoon: "",
  green_salad: "",
  popcorn: "",
  butter: "",
  salt: "",
  canned_food: "",
  bento_box: "",
  rice_cracker: "",
  rice_ball: "",
  cooked_rice: "",
  curry_rice: "",
  steaming_bowl: "",
  spaghetti: "",
  roasted_sweet_potato: "",
  oden: "",
  sushi: "",
  fried_shrimp: "",
  fish_cake_with_swirl: "",
  moon_cake: "",
  dango: "",
  dumpling: "",
  fortune_cookie: "",
  takeout_box: "",
  crab: "",
  lobster: "",
  shrimp: "",
  squid: "",
  oyster: "",
  soft_ice_cream: "",
  shaved_ice: "",
  ice_cream: "",
  doughnut: "",
  cookie: "",
  birthday_cake: "",
  shortcake: "",
  cupcake: "",
  pie: "",
  chocolate_bar: "",
  candy: "",
  lollipop: "",
  custard: "",
  honey_pot: "",
  baby_bottle: "",
  glass_of_milk: "",
  hot_beverage: "",
  teacup_without_handle: "",
  sake: "",
  bottle_with_popping_cork: "",
  wine_glass: "",
  cocktail_glass: "",
  tropical_drink: "",
  beer_mug: "",
  clinking_beer_mugs: "",
  clinking_glasses: "",
  tumbler_glass: "",
  cup_with_straw: "",
  beverage_box: "",
  mate: "",
  ice: "",
  chopsticks: "",
  fork_and_knife_with_plate: "",
  fork_and_knife: "",
  spoon: "",
  kitchen_knife: "",
  amphora: "",
  globe_showing_europe_africa: "",
  globe_showing_americas: "",
  globe_showing_asia_australia: "",
  globe_with_meridians: "",
  world_map: "",
  map_of_japan: "",
  compass: "",
  snow_capped_mountain: "",
  mountain: "",
  volcano: "",
  mount_fuji: "",
  camping: "",
  beach_with_umbrella: "",
  desert: "",
  desert_island: "",
  national_park: "",
  stadium: "",
  classical_building: "",
  building_construction: "",
  brick: "",
  houses: "",
  derelict_house: "",
  house: "",
  house_with_garden: "",
  office_building: "",
  japanese_post_office: "",
  post_office: "",
  hospital: "",
  bank: "",
  hotel: "",
  love_hotel: "",
  convenience_store: "",
  school: "",
  department_store: "",
  factory: "",
  japanese_castle: "",
  castle: "",
  wedding: "",
  tokyo_tower: "",
  statue_of_liberty: "",
  church: "",
  mosque: "",
  hindu_temple: "",
  synagogue: "",
  shinto_shrine: "",
  kaaba: "",
  fountain: "",
  tent: "",
  foggy: "",
  night_with_stars: "",
  cityscape: "",
  sunrise_over_mountains: "",
  sunrise: "",
  cityscape_at_dusk: "",
  sunset: "",
  bridge_at_night: "",
  hot_springs: "",
  carousel_horse: "",
  ferris_wheel: "",
  roller_coaster: "",
  barber_pole: "",
  circus_tent: "",
  locomotive: "",
  railway_car: "",
  high_speed_train: "",
  bullet_train: "",
  train: "",
  metro: "",
  light_rail: "",
  station: "",
  tram: "",
  monorail: "",
  mountain_railway: "",
  tram_car: "",
  bus: "",
  oncoming_bus: "",
  trolleybus: "",
  minibus: "",
  ambulance: "",
  fire_engine: "",
  police_car: "",
  oncoming_police_car: "",
  taxi: "",
  oncoming_taxi: "",
  automobile: "",
  oncoming_automobile: "",
  sport_utility_vehicle: "",
  delivery_truck: "",
  articulated_lorry: "",
  tractor: "",
  racing_car: "",
  motorcycle: "",
  motor_scooter: "",
  manual_wheelchair: "",
  motorized_wheelchair: "",
  auto_rickshaw: "",
  bicycle: "",
  kick_scooter: "",
  skateboard: "",
  bus_stop: "",
  motorway: "",
  railway_track: "",
  oil_drum: "",
  fuel_pump: "",
  police_car_light: "",
  horizontal_traffic_light: "",
  vertical_traffic_light: "",
  stop_sign: "",
  construction: "",
  anchor: "",
  sailboat: "",
  canoe: "",
  speedboat: "",
  passenger_ship: "",
  ferry: "",
  motor_boat: "",
  ship: "",
  airplane: "",
  small_airplane: "",
  airplane_departure: "",
  airplane_arrival: "",
  parachute: "",
  seat: "",
  helicopter: "",
  suspension_railway: "",
  mountain_cableway: "",
  aerial_tramway: "",
  satellite: "",
  rocket: "",
  flying_saucer: "",
  bellhop_bell: "",
  luggage: "",
  hourglass_done: "",
  hourglass_not_done: "",
  watch: "",
  alarm_clock: "",
  stopwatch: "",
  timer_clock: "",
  mantelpiece_clock: "",
  twelve_o_clock: "",
  twelve_thirty: "",
  one_o_clock: "",
  one_thirty: "",
  two_o_clock: "",
  two_thirty: "",
  three_o_clock: "",
  three_thirty: "",
  four_o_clock: "",
  four_thirty: "",
  five_o_clock: "",
  five_thirty: "",
  six_o_clock: "",
  six_thirty: "",
  seven_o_clock: "",
  seven_thirty: "",
  eight_o_clock: "",
  eight_thirty: "",
  nine_o_clock: "",
  nine_thirty: "",
  ten_o_clock: "",
  ten_thirty: "",
  eleven_o_clock: "",
  eleven_thirty: "",
  new_moon: "",
  waxing_crescent_moon: "",
  first_quarter_moon: "",
  waxing_gibbous_moon: "",
  full_moon: "",
  waning_gibbous_moon: "",
  last_quarter_moon: "",
  waning_crescent_moon: "",
  crescent_moon: "",
  new_moon_face: "",
  first_quarter_moon_face: "",
  last_quarter_moon_face: "",
  thermometer: "",
  sun: "",
  full_moon_face: "",
  sun_with_face: "",
  ringed_planet: "",
  star: "",
  glowing_star: "",
  shooting_star: "",
  milky_way: "",
  cloud: "",
  sun_behind_cloud: "",
  cloud_with_lightning_and_rain: "",
  sun_behind_small_cloud: "",
  sun_behind_large_cloud: "",
  sun_behind_rain_cloud: "",
  cloud_with_rain: "",
  cloud_with_snow: "",
  cloud_with_lightning: "",
  tornado: "",
  fog: "",
  wind_face: "",
  cyclone: "",
  rainbow: "",
  closed_umbrella: "",
  umbrella: "",
  umbrella_with_rain_drops: "",
  umbrella_on_ground: "",
  high_voltage: "",
  snowflake: "",
  snowman: "",
  snowman_without_snow: "",
  comet: "",
  fire: "",
  droplet: "",
  water_wave: "",
  jack_o_lantern: "",
  christmas_tree: "",
  fireworks: "",
  sparkler: "",
  firecracker: "",
  sparkles: "",
  balloon: "",
  party_popper: "",
  confetti_ball: "",
  tanabata_tree: "",
  pine_decoration: "",
  japanese_dolls: "",
  carp_streamer: "",
  wind_chime: "",
  moon_viewing_ceremony: "",
  red_envelope: "",
  ribbon: "",
  wrapped_gift: "",
  reminder_ribbon: "",
  admission_tickets: "",
  ticket: "",
  military_medal: "",
  trophy: "",
  sports_medal: "",
  "1st_place_medal": "",
  "2nd_place_medal": "",
  "3rd_place_medal": "",
  soccer_ball: "",
  baseball: "",
  softball: "",
  basketball: "",
  volleyball: "",
  american_football: "",
  rugby_football: "",
  tennis: "",
  flying_disc: "",
  bowling: "",
  cricket_game: "",
  field_hockey: "",
  ice_hockey: "",
  lacrosse: "",
  ping_pong: "",
  badminton: "",
  boxing_glove: "",
  martial_arts_uniform: "",
  goal_net: "",
  flag_in_hole: "",
  ice_skate: "",
  fishing_pole: "",
  diving_mask: "",
  running_shirt: "",
  skis: "",
  sled: "",
  curling_stone: "",
  direct_hit: "",
  yo_yo: "",
  kite: "",
  pool_8_ball: "",
  crystal_ball: "",
  nazar_amulet: "",
  video_game: "",
  joystick: "",
  slot_machine: "",
  game_die: "",
  puzzle_piece: "",
  teddy_bear: "",
  spade_suit: "",
  heart_suit: "",
  diamond_suit: "",
  club_suit: "",
  chess_pawn: "",
  joker: "",
  mahjong_red_dragon: "",
  flower_playing_cards: "",
  performing_arts: "",
  framed_picture: "",
  artist_palette: "",
  thread: "",
  yarn: "",
  glasses: "",
  sunglasses: "",
  goggles: "",
  lab_coat: "",
  safety_vest: "",
  necktie: "",
  t_shirt: "",
  jeans: "",
  scarf: "",
  gloves: "",
  coat: "",
  socks: "",
  dress: "",
  kimono: "",
  sari: "",
  one_piece_swimsuit: "",
  briefs: "",
  shorts: "",
  bikini: "",
  woman_s_clothes: "",
  purse: "",
  handbag: "",
  clutch_bag: "",
  shopping_bags: "",
  backpack: "",
  man_s_shoe: "",
  running_shoe: "",
  hiking_boot: "",
  flat_shoe: "",
  high_heeled_shoe: "",
  woman_s_sandal: "",
  ballet_shoes: "",
  woman_s_boot: "",
  crown: "",
  woman_s_hat: "",
  top_hat: "",
  graduation_cap: "",
  billed_cap: "",
  rescue_worker_s_helmet: "",
  prayer_beads: "",
  lipstick: "",
  ring: "",
  gem_stone: "",
  muted_speaker: "",
  speaker_low_volume: "",
  speaker_medium_volume: "",
  speaker_high_volume: "",
  loudspeaker: "",
  megaphone: "",
  postal_horn: "",
  bell: "",
  bell_with_slash: "",
  musical_score: "",
  musical_note: "",
  musical_notes: "",
  studio_microphone: "",
  level_slider: "",
  control_knobs: "",
  microphone: "",
  headphone: "",
  radio: "",
  saxophone: "",
  guitar: "",
  musical_keyboard: "",
  trumpet: "",
  violin: "",
  banjo: "",
  drum: "",
  mobile_phone: "",
  mobile_phone_with_arrow: "",
  telephone: "",
  telephone_receiver: "",
  pager: "",
  fax_machine: "",
  battery: "",
  electric_plug: "",
  laptop: "",
  desktop_computer: "",
  printer: "",
  keyboard: "",
  computer_mouse: "",
  trackball: "",
  computer_disk: "",
  floppy_disk: "",
  optical_disk: "",
  dvd: "",
  abacus: "",
  movie_camera: "",
  film_frames: "",
  film_projector: "",
  clapper_board: "",
  television: "",
  camera: "",
  camera_with_flash: "",
  video_camera: "",
  videocassette: "",
  magnifying_glass_tilted_left: "",
  magnifying_glass_tilted_right: "",
  candle: "",
  light_bulb: "",
  flashlight: "",
  red_paper_lantern: "",
  diya_lamp: "",
  notebook_with_decorative_cover: "",
  closed_book: "",
  open_book: "",
  green_book: "",
  blue_book: "",
  orange_book: "",
  books: "",
  notebook: "",
  ledger: "",
  page_with_curl: "",
  scroll: "",
  page_facing_up: "",
  newspaper: "",
  rolled_up_newspaper: "",
  bookmark_tabs: "",
  bookmark: "",
  label: "",
  money_bag: "",
  yen_banknote: "",
  dollar_banknote: "",
  euro_banknote: "",
  pound_banknote: "",
  money_with_wings: "",
  credit_card: "",
  receipt: "",
  chart_increasing_with_yen: "",
  currency_exchange: "",
  heavy_dollar_sign: "",
  envelope: "",
  e_mail: "",
  incoming_envelope: "",
  envelope_with_arrow: "",
  outbox_tray: "",
  inbox_tray: "",
  package: "",
  closed_mailbox_with_raised_flag: "",
  closed_mailbox_with_lowered_flag: "",
  open_mailbox_with_raised_flag: "",
  open_mailbox_with_lowered_flag: "",
  postbox: "",
  ballot_box_with_ballot: "",
  pencil: "",
  black_nib: "",
  fountain_pen: "",
  pen: "",
  paintbrush: "",
  crayon: "",
  memo: "",
  briefcase: "",
  file_folder: "",
  open_file_folder: "",
  card_index_dividers: "",
  calendar: "",
  tear_off_calendar: "",
  spiral_notepad: "",
  spiral_calendar: "",
  card_index: "",
  chart_increasing: "",
  chart_decreasing: "",
  bar_chart: "",
  clipboard: "",
  pushpin: "",
  round_pushpin: "",
  paperclip: "",
  linked_paperclips: "",
  straight_ruler: "",
  triangular_ruler: "",
  scissors: "",
  card_file_box: "",
  file_cabinet: "",
  wastebasket: "",
  locked: "",
  unlocked: "",
  locked_with_pen: "",
  locked_with_key: "",
  key: "",
  old_key: "",
  hammer: "",
  axe: "",
  pick: "",
  hammer_and_pick: "",
  hammer_and_wrench: "",
  dagger: "",
  crossed_swords: "",
  pistol: "",
  bow_and_arrow: "",
  shield: "",
  wrench: "",
  nut_and_bolt: "",
  gear: "",
  clamp: "",
  balance_scale: "",
  probing_cane: "",
  link: "",
  chains: "",
  toolbox: "",
  magnet: "",
  alembic: "",
  test_tube: "",
  petri_dish: "",
  dna: "",
  microscope: "",
  telescope: "",
  satellite_antenna: "",
  syringe: "",
  drop_of_blood: "",
  pill: "",
  adhesive_bandage: "",
  stethoscope: "",
  door: "",
  bed: "",
  couch_and_lamp: "",
  chair: "",
  toilet: "",
  shower: "",
  bathtub: "",
  razor: "",
  lotion_bottle: "",
  safety_pin: "",
  broom: "",
  basket: "",
  roll_of_paper: "",
  soap: "",
  sponge: "",
  fire_extinguisher: "",
  shopping_cart: "",
  cigarette: "",
  coffin: "",
  funeral_urn: "",
  moai: "",
  atm_sign: "",
  litter_in_bin_sign: "",
  potable_water: "",
  wheelchair_symbol: "",
  men_s_room: "",
  women_s_room: "",
  restroom: "",
  baby_symbol: "",
  water_closet: "",
  passport_control: "",
  customs: "",
  baggage_claim: "",
  left_luggage: "",
  warning: "",
  children_crossing: "",
  no_entry: "",
  prohibited: "",
  no_bicycles: "",
  no_smoking: "",
  no_littering: "",
  non_potable_water: "",
  no_pedestrians: "",
  no_mobile_phones: "",
  no_one_under_eighteen: "",
  radioactive: "",
  biohazard: "",
  up_arrow: "",
  up_right_arrow: "",
  right_arrow: "",
  down_right_arrow: "",
  down_arrow: "",
  down_left_arrow: "",
  left_arrow: "",
  up_left_arrow: "",
  up_down_arrow: "",
  left_right_arrow: "",
  right_arrow_curving_left: "",
  left_arrow_curving_right: "",
  right_arrow_curving_up: "",
  right_arrow_curving_down: "",
  clockwise_vertical_arrows: "",
  counterclockwise_arrows_button: "",
  back_arrow: "",
  end_arrow: "",
  on_arrow: "",
  soon_arrow: "",
  top_arrow: "",
  place_of_worship: "",
  atom_symbol: "",
  om: "",
  star_of_david: "",
  wheel_of_dharma: "",
  yin_yang: "",
  latin_cross: "",
  orthodox_cross: "",
  star_and_crescent: "",
  peace_symbol: "",
  menorah: "",
  dotted_six_pointed_star: "",
  aries: "",
  taurus: "",
  gemini: "",
  cancer: "",
  leo: "",
  virgo: "",
  libra: "",
  scorpio: "",
  sagittarius: "",
  capricorn: "",
  aquarius: "",
  pisces: "",
  ophiuchus: "",
  shuffle_tracks_button: "",
  repeat_button: "",
  repeat_single_button: "",
  play_button: "",
  fast_forward_button: "",
  next_track_button: "",
  play_or_pause_button: "",
  reverse_button: "",
  fast_reverse_button: "",
  last_track_button: "",
  upwards_button: "",
  fast_up_button: "",
  downwards_button: "",
  fast_down_button: "",
  pause_button: "",
  stop_button: "",
  record_button: "",
  eject_button: "",
  cinema: "",
  dim_button: "",
  bright_button: "",
  antenna_bars: "",
  vibration_mode: "",
  mobile_phone_off: "",
  female_sign: "",
  male_sign: "",
  medical_symbol: "",
  infinity: "",
  recycling_symbol: "",
  fleur_de_lis: "",
  trident_emblem: "",
  name_badge: "",
  japanese_symbol_for_beginner: "",
  hollow_red_circle: "",
  check_mark_button: "",
  check_box_with_check: "",
  check_mark: "",
  multiplication_sign: "",
  cross_mark: "",
  cross_mark_button: "",
  plus_sign: "",
  minus_sign: "",
  division_sign: "",
  curly_loop: "",
  double_curly_loop: "",
  part_alternation_mark: "",
  eight_spoked_asterisk: "",
  eight_pointed_star: "",
  sparkle: "",
  double_exclamation_mark: "",
  exclamation_question_mark: "",
  question_mark: "",
  white_question_mark: "",
  white_exclamation_mark: "",
  exclamation_mark: "",
  wavy_dash: "",
  copyright: "",
  registered: "",
  trade_mark: "",
  keycap_: "*",
  keycap_0: "0",
  keycap_1: "1",
  keycap_2: "2",
  keycap_3: "3",
  keycap_4: "4",
  keycap_5: "5",
  keycap_6: "6",
  keycap_7: "7",
  keycap_8: "8",
  keycap_9: "9",
  keycap_10: "",
  input_latin_uppercase: "",
  input_latin_lowercase: "",
  input_numbers: "",
  input_symbols: "",
  input_latin_letters: "",
  a_button: "",
  ab_button: "",
  b_button: "",
  cl_button: "",
  cool_button: "",
  free_button: "",
  information: "",
  id_button: "",
  circled_m: "",
  new_button: "",
  ng_button: "",
  o_button: "",
  ok_button: "",
  p_button: "",
  sos_button: "",
  up_button: "",
  vs_button: "",
  japanese_here_button: "",
  japanese_service_charge_button: "",
  japanese_monthly_amount_button: "",
  japanese_not_free_of_charge_button: "",
  japanese_reserved_button: "",
  japanese_bargain_button: "",
  japanese_discount_button: "",
  japanese_free_of_charge_button: "",
  japanese_prohibited_button: "",
  japanese_acceptable_button: "",
  japanese_application_button: "",
  japanese_passing_grade_button: "",
  japanese_vacancy_button: "",
  japanese_congratulations_button: "",
  japanese_secret_button: "",
  japanese_open_for_business_button: "",
  japanese_no_vacancy_button: "",
  red_circle: "",
  orange_circle: "",
  yellow_circle: "",
  green_circle: "",
  blue_circle: "",
  purple_circle: "",
  brown_circle: "",
  black_circle: "",
  white_circle: "",
  red_square: "",
  orange_square: "",
  yellow_square: "",
  green_square: "",
  blue_square: "",
  purple_square: "",
  brown_square: "",
  black_large_square: "",
  white_large_square: "",
  large_red_square: "",
  black_medium_square: "",
  white_medium_square: "",
  black_medium_small_square: "",
  white_medium_small_square: "",
  black_small_square: "",
  white_small_square: "",
  large_orange_diamond: "",
  large_blue_diamond: "",
  small_orange_diamond: "",
  small_blue_diamond: "",
  red_triangle_pointed_up: "",
  red_triangle_pointed_down: "",
  diamond_with_a_dot: "",
  radio_button: "",
  white_square_button: "",
  black_square_button: "",
  chequered_flag: "",
  triangular_flag: "",
  crossed_flags: "",
  black_flag: "",
  white_flag: "",
  rainbow_flag: "",
  pirate_flag: "",
  flag_ascension_island: "",
  flag_andorra: "",
  flag_united_arab_emirates: "",
  flag_afghanistan: "",
  flag_antigua_barbuda: "",
  flag_anguilla: "",
  flag_albania: "",
  flag_armenia: "",
  flag_angola: "",
  flag_antarctica: "",
  flag_argentina: "",
  flag_american_samoa: "",
  flag_austria: "",
  flag_australia: "",
  flag_aruba: "",
  flag_land_islands: "",
  flag_azerbaijan: "",
  flag_bosnia_herzegovina: "",
  flag_barbados: "",
  flag_bangladesh: "",
  flag_belgium: "",
  flag_burkina_faso: "",
  flag_bulgaria: "",
  flag_bahrain: "",
  flag_burundi: "",
  flag_benin: "",
  flag_st_barth_lemy: "",
  flag_bermuda: "",
  flag_brunei: "",
  flag_bolivia: "",
  flag_caribbean_netherlands: "",
  flag_brazil: "",
  flag_bahamas: "",
  flag_bhutan: "",
  flag_bouvet_island: "",
  flag_botswana: "",
  flag_belarus: "",
  flag_belize: "",
  flag_canada: "",
  flag_cocos_islands: "",
  flag_congo_kinshasa: "",
  flag_central_african_republic: "",
  flag_congo_brazzaville: "",
  flag_switzerland: "",
  flag_c_te_d_ivoire: "",
  flag_cook_islands: "",
  flag_chile: "",
  flag_cameroon: "",
  flag_china: "",
  flag_colombia: "",
  flag_clipperton_island: "",
  flag_costa_rica: "",
  flag_cuba: "",
  flag_cape_verde: "",
  flag_cura_ao: "",
  flag_christmas_island: "",
  flag_cyprus: "",
  flag_czechia: "",
  flag_germany: "",
  flag_diego_garcia: "",
  flag_djibouti: "",
  flag_denmark: "",
  flag_dominica: "",
  flag_dominican_republic: "",
  flag_algeria: "",
  flag_ceuta_melilla: "",
  flag_ecuador: "",
  flag_estonia: "",
  flag_egypt: "",
  flag_western_sahara: "",
  flag_eritrea: "",
  flag_spain: "",
  flag_ethiopia: "",
  flag_european_union: "",
  flag_finland: "",
  flag_fiji: "",
  flag_falkland_islands: "",
  flag_micronesia: "",
  flag_faroe_islands: "",
  flag_france: "",
  flag_gabon: "",
  flag_united_kingdom: "",
  flag_grenada: "",
  flag_georgia: "",
  flag_french_guiana: "",
  flag_guernsey: "",
  flag_ghana: "",
  flag_gibraltar: "",
  flag_greenland: "",
  flag_gambia: "",
  flag_guinea: "",
  flag_guadeloupe: "",
  flag_equatorial_guinea: "",
  flag_greece: "",
  flag_south_georgia_south_sandwich_islands: "",
  flag_guatemala: "",
  flag_guam: "",
  flag_guinea_bissau: "",
  flag_guyana: "",
  flag_hong_kong_sar_china: "",
  flag_heard_mcdonald_islands: "",
  flag_honduras: "",
  flag_croatia: "",
  flag_haiti: "",
  flag_hungary: "",
  flag_canary_islands: "",
  flag_indonesia: "",
  flag_ireland: "",
  flag_israel: "",
  flag_isle_of_man: "",
  flag_india: "",
  flag_british_indian_ocean_territory: "",
  flag_iraq: "",
  flag_iran: "",
  flag_iceland: "",
  flag_italy: "",
  flag_jersey: "",
  flag_jamaica: "",
  flag_jordan: "",
  flag_japan: "",
  flag_kenya: "",
  flag_kyrgyzstan: "",
  flag_cambodia: "",
  flag_kiribati: "",
  flag_comoros: "",
  flag_st_kitts_nevis: "",
  flag_north_korea: "",
  flag_south_korea: "",
  flag_kuwait: "",
  flag_cayman_islands: "",
  flag_kazakhstan: "",
  flag_laos: "",
  flag_lebanon: "",
  flag_st_lucia: "",
  flag_liechtenstein: "",
  flag_sri_lanka: "",
  flag_liberia: "",
  flag_lesotho: "",
  flag_lithuania: "",
  flag_luxembourg: "",
  flag_latvia: "",
  flag_libya: "",
  flag_morocco: "",
  flag_monaco: "",
  flag_moldova: "",
  flag_montenegro: "",
  flag_st_martin: "",
  flag_madagascar: "",
  flag_marshall_islands: "",
  flag_north_macedonia: "",
  flag_mali: "",
  flag_myanmar: "",
  flag_mongolia: "",
  flag_macao_sar_china: "",
  flag_northern_mariana_islands: "",
  flag_martinique: "",
  flag_mauritania: "",
  flag_montserrat: "",
  flag_malta: "",
  flag_mauritius: "",
  flag_maldives: "",
  flag_malawi: "",
  flag_mexico: "",
  flag_malaysia: "",
  flag_mozambique: "",
  flag_namibia: "",
  flag_new_caledonia: "",
  flag_niger: "",
  flag_norfolk_island: "",
  flag_nigeria: "",
  flag_nicaragua: "",
  flag_netherlands: "",
  flag_norway: "",
  flag_nepal: "",
  flag_nauru: "",
  flag_niue: "",
  flag_new_zealand: "",
  flag_oman: "",
  flag_panama: "",
  flag_peru: "",
  flag_french_polynesia: "",
  flag_papua_new_guinea: "",
  flag_philippines: "",
  flag_pakistan: "",
  flag_poland: "",
  flag_st_pierre_miquelon: "",
  flag_pitcairn_islands: "",
  flag_puerto_rico: "",
  flag_palestinian_territories: "",
  flag_portugal: "",
  flag_palau: "",
  flag_paraguay: "",
  flag_qatar: "",
  flag_r_union: "",
  flag_romania: "",
  flag_serbia: "",
  flag_russia: "",
  flag_rwanda: "",
  flag_saudi_arabia: "",
  flag_solomon_islands: "",
  flag_seychelles: "",
  flag_sudan: "",
  flag_sweden: "",
  flag_singapore: "",
  flag_st_helena: "",
  flag_slovenia: "",
  flag_svalbard_jan_mayen: "",
  flag_slovakia: "",
  flag_sierra_leone: "",
  flag_san_marino: "",
  flag_senegal: "",
  flag_somalia: "",
  flag_suriname: "",
  flag_south_sudan: "",
  flag_s_o_tom_pr_ncipe: "",
  flag_el_salvador: "",
  flag_sint_maarten: "",
  flag_syria: "",
  flag_eswatini: "",
  flag_tristan_da_cunha: "",
  flag_turks_caicos_islands: "",
  flag_chad: "",
  flag_french_southern_territories: "",
  flag_togo: "",
  flag_thailand: "",
  flag_tajikistan: "",
  flag_tokelau: "",
  flag_timor_leste: "",
  flag_turkmenistan: "",
  flag_tunisia: "",
  flag_tonga: "",
  flag_turkey: "",
  flag_trinidad_tobago: "",
  flag_tuvalu: "",
  flag_taiwan: "",
  flag_tanzania: "",
  flag_ukraine: "",
  flag_uganda: "",
  flag_u_s_outlying_islands: "",
  flag_united_nations: "",
  flag_united_states: "",
  flag_uruguay: "",
  flag_uzbekistan: "",
  flag_vatican_city: "",
  flag_st_vincent_grenadines: "",
  flag_venezuela: "",
  flag_british_virgin_islands: "",
  flag_u_s_virgin_islands: "",
  flag_vietnam: "",
  flag_vanuatu: "",
  flag_wallis_futuna: "",
  flag_samoa: "",
  flag_kosovo: "",
  flag_yemen: "",
  flag_mayotte: "",
  flag_south_africa: "",
  flag_zambia: "",
  flag_zimbabwe: "",
  flag_england: "",
  flag_scotland: "",
  flag_wales: "",
  grinning: "",
  smiley: "",
  smile: "",
  grin: "",
  laughing: "",
  satisfied: "",
  sweat_smile: "",
  rofl: "",
  joy: "",
  wink: "",
  blush: "",
  innocent: "",
  smiling_face_with_three_hearts: "",
  smiling_face_with_3_hearts: "",
  heart_eyes: "",
  kissing_heart: "",
  kissing: "",
  relaxed: "",
  kissing_closed_eyes: "",
  kissing_smiling_eyes: "",
  yum: "",
  stuck_out_tongue: "",
  stuck_out_tongue_winking_eye: "",
  stuck_out_tongue_closed_eyes: "",
  hugs: "",
  hand_over_mouth: "",
  thinking: "",
  raised_eyebrow: "",
  expressionless: "",
  no_mouth: "",
  smirk: "",
  unamused: "",
  roll_eyes: "",
  grimacing: "",
  relieved: "",
  pensive: "",
  sleepy: "",
  sleeping: "",
  mask: "",
  vomiting_face: "",
  monocle_face: "",
  confused: "",
  worried: "",
  open_mouth: "",
  hushed: "",
  astonished: "",
  flushed: "",
  frowning: "",
  anguished: "",
  fearful: "",
  cold_sweat: "",
  disappointed_relieved: "",
  cry: "",
  sob: "",
  scream: "",
  confounded: "",
  persevere: "",
  disappointed: "",
  sweat: "",
  weary: "",
  triumph: "",
  rage: "",
  pout: "",
  angry: "",
  cursing_face: "",
  smiling_imp: "",
  imp: "",
  hankey: "",
  poop: "",
  shit: "",
  japanese_ogre: "",
  japanese_goblin: "",
  space_invader: "",
  smiley_cat: "",
  smile_cat: "",
  joy_cat: "",
  heart_eyes_cat: "",
  smirk_cat: "",
  scream_cat: "",
  crying_cat_face: "",
  see_no_evil: "",
  hear_no_evil: "",
  speak_no_evil: "",
  cupid: "",
  gift_heart: "",
  heartpulse: "",
  heartbeat: "",
  heavy_heart_exclamation: "",
  heart: "",
  anger: "",
  boom: "",
  sweat_drops: "",
  dash: "",
  eye_speech_bubble: "",
  wave: "",
  raised_hand_with_fingers_splayed: "",
  hand: "",
  v: "",
  metal: "",
  point_left: "",
  point_right: "",
  point_up_2: "",
  fu: "",
  point_down: "",
  point_up: "",
  "+1": "",
  thumbsup: "",
  "-1": "",
  thumbsdown: "",
  fist_raised: "",
  fist: "",
  fist_oncoming: "",
  facepunch: "",
  punch: "",
  fist_left: "",
  fist_right: "",
  clap: "",
  raised_hands: "",
  pray: "",
  nail_care: "",
  muscle: "",
  lips: "",
  adult: "",
  blond_haired_person: "",
  bearded_person: "",
  red_haired_man: "",
  curly_haired_man: "",
  white_haired_man: "",
  bald_man: "",
  red_haired_woman: "",
  curly_haired_woman: "",
  white_haired_woman: "",
  bald_woman: "",
  blond_haired_woman: "",
  blonde_woman: "",
  blond_haired_man: "",
  older_adult: "",
  older_man: "",
  older_woman: "",
  frowning_person: "",
  frowning_man: "",
  frowning_woman: "",
  pouting_man: "",
  pouting_woman: "",
  no_good: "",
  no_good_man: "",
  ng_man: "",
  no_good_woman: "",
  ng_woman: "",
  ok_person: "",
  ok_man: "",
  ok_woman: "",
  tipping_hand_person: "",
  information_desk_person: "",
  tipping_hand_man: "",
  sassy_man: "",
  tipping_hand_woman: "",
  sassy_woman: "",
  raising_hand: "",
  raising_hand_man: "",
  raising_hand_woman: "",
  bow: "",
  bowing_man: "",
  bowing_woman: "",
  facepalm: "",
  shrug: "",
  cop: "",
  policeman: "",
  policewoman: "",
  male_detective: "",
  female_detective: "",
  guardsman: "",
  guardswoman: "",
  construction_worker_man: "",
  construction_worker_woman: "",
  person_with_turban: "",
  man_with_turban: "",
  woman_with_turban: "",
  man_with_gua_pi_mao: "",
  angel: "",
  santa: "",
  superhero_man: "",
  superhero_woman: "",
  supervillain_man: "",
  supervillain_woman: "",
  mage_man: "",
  mage_woman: "",
  fairy_man: "",
  fairy_woman: "",
  vampire_man: "",
  vampire_woman: "",
  elf_man: "",
  elf_woman: "",
  genie_man: "",
  genie_woman: "",
  zombie_man: "",
  zombie_woman: "",
  massage: "",
  massage_man: "",
  massage_woman: "",
  haircut: "",
  haircut_man: "",
  haircut_woman: "",
  walking: "",
  walking_man: "",
  walking_woman: "",
  standing_person: "",
  standing_man: "",
  standing_woman: "",
  kneeling_person: "",
  kneeling_man: "",
  kneeling_woman: "",
  runner: "",
  running: "",
  running_man: "",
  running_woman: "",
  dancer: "",
  business_suit_levitating: "",
  dancers: "",
  dancing_men: "",
  dancing_women: "",
  sauna_person: "",
  sauna_man: "",
  sauna_woman: "",
  climbing: "",
  climbing_man: "",
  climbing_woman: "",
  golfing: "",
  golfing_man: "",
  golfing_woman: "",
  surfer: "",
  surfing_man: "",
  surfing_woman: "",
  rowboat: "",
  rowing_man: "",
  rowing_woman: "",
  swimmer: "",
  swimming_man: "",
  swimming_woman: "",
  bouncing_ball_person: "",
  bouncing_ball_man: "",
  basketball_man: "",
  bouncing_ball_woman: "",
  basketball_woman: "",
  weight_lifting: "",
  weight_lifting_man: "",
  weight_lifting_woman: "",
  bicyclist: "",
  biking_man: "",
  biking_woman: "",
  mountain_bicyclist: "",
  mountain_biking_man: "",
  mountain_biking_woman: "",
  cartwheeling: "",
  wrestling: "",
  water_polo: "",
  handball_person: "",
  juggling_person: "",
  lotus_position: "",
  lotus_position_man: "",
  lotus_position_woman: "",
  bath: "",
  sleeping_bed: "",
  two_women_holding_hands: "",
  couple: "",
  two_men_holding_hands: "",
  couplekiss: "",
  couplekiss_man_woman: "",
  couplekiss_man_man: "",
  couplekiss_woman_woman: "",
  dog2: "",
  fox_face: "",
  cat2: "",
  tiger2: "",
  racehorse: "",
  cow2: "",
  pig2: "",
  sheep: "",
  dromedary_camel: "",
  mouse2: "",
  rabbit2: "",
  panda_face: "",
  feet: "",
  hatched_chick: "",
  "t-rex": "",
  whale2: "",
  flipper: "",
  shell: "",
  bee: "",
  beetle: "",
  ear_of_rice: "",
  leaves: "",
  orange: "",
  mandarin: "",
  apple: "",
  corn: "",
  cheese: "",
  fries: "",
  hotdog: "",
  fried_egg: "",
  stew: "",
  bento: "",
  rice: "",
  curry: "",
  ramen: "",
  sweet_potato: "",
  fish_cake: "",
  icecream: "",
  birthday: "",
  cake: "",
  milk_glass: "",
  coffee: "",
  tea: "",
  champagne: "",
  cocktail: "",
  beer: "",
  beers: "",
  ice_cube: "",
  plate_with_cutlery: "",
  hocho: "",
  knife: "",
  earth_africa: "",
  earth_americas: "",
  earth_asia: "",
  japan: "",
  mountain_snow: "",
  beach_umbrella: "",
  bricks: "",
  office: "",
  european_post_office: "",
  european_castle: "",
  city_sunset: "",
  city_sunrise: "",
  hotsprings: "",
  barber: "",
  steam_locomotive: "",
  bullettrain_side: "",
  bullettrain_front: "",
  train2: "",
  car: "",
  red_car: "",
  blue_car: "",
  truck: "",
  bike: "",
  busstop: "",
  fuelpump: "",
  rotating_light: "",
  traffic_light: "",
  boat: "",
  flight_departure: "",
  flight_arrival: "",
  artificial_satellite: "",
  hourglass: "",
  hourglass_flowing_sand: "",
  clock12: "",
  clock1230: "",
  clock1: "",
  clock130: "",
  clock2: "",
  clock230: "",
  clock3: "",
  clock330: "",
  clock4: "",
  clock430: "",
  clock5: "",
  clock530: "",
  clock6: "",
  clock630: "",
  clock7: "",
  clock730: "",
  clock8: "",
  clock830: "",
  clock9: "",
  clock930: "",
  clock10: "",
  clock1030: "",
  clock11: "",
  clock1130: "",
  moon: "",
  new_moon_with_face: "",
  first_quarter_moon_with_face: "",
  last_quarter_moon_with_face: "",
  sunny: "",
  full_moon_with_face: "",
  star2: "",
  stars: "",
  partly_sunny: "",
  open_umbrella: "",
  parasol_on_ground: "",
  zap: "",
  snowman_with_snow: "",
  ocean: "",
  tada: "",
  bamboo: "",
  dolls: "",
  flags: "",
  rice_scene: "",
  gift: "",
  tickets: "",
  medal_military: "",
  medal_sports: "",
  soccer: "",
  football: "",
  golf: "",
  fishing_pole_and_fish: "",
  running_shirt_with_sash: "",
  ski: "",
  dart: "",
  "8ball": "",
  jigsaw: "",
  spades: "",
  hearts: "",
  diamonds: "",
  clubs: "",
  black_joker: "",
  mahjong: "",
  art: "",
  eyeglasses: "",
  dark_sunglasses: "",
  shirt: "",
  tshirt: "",
  swim_brief: "",
  womans_clothes: "",
  pouch: "",
  shopping: "",
  school_satchel: "",
  mans_shoe: "",
  shoe: "",
  athletic_shoe: "",
  high_heel: "",
  sandal: "",
  boot: "",
  womans_hat: "",
  tophat: "",
  mortar_board: "",
  rescue_worker_helmet: "",
  gem: "",
  mute: "",
  speaker: "",
  sound: "",
  loud_sound: "",
  mega: "",
  no_bell: "",
  notes: "",
  headphones: "",
  iphone: "",
  calling: "",
  phone: "",
  fax: "",
  computer: "",
  minidisc: "",
  cd: "",
  film_strip: "",
  clapper: "",
  tv: "",
  camera_flash: "",
  vhs: "",
  mag: "",
  mag_right: "",
  bulb: "",
  izakaya_lantern: "",
  lantern: "",
  book: "",
  newspaper_roll: "",
  moneybag: "",
  yen: "",
  dollar: "",
  euro: "",
  pound: "",
  chart: "",
  email: "",
  "e-mail": "",
  mailbox: "",
  mailbox_closed: "",
  mailbox_with_mail: "",
  mailbox_with_no_mail: "",
  ballot_box: "",
  pencil2: "",
  date: "",
  chart_with_upwards_trend: "",
  chart_with_downwards_trend: "",
  paperclips: "",
  lock: "",
  unlock: "",
  lock_with_ink_pen: "",
  closed_lock_with_key: "",
  gun: "",
  smoking: "",
  moyai: "",
  atm: "",
  put_litter_in_its_place: "",
  wheelchair: "",
  mens: "",
  womens: "",
  wc: "",
  no_entry_sign: "",
  do_not_litter: "",
  "non-potable_water": "",
  underage: "",
  arrow_up: "",
  arrow_upper_right: "",
  arrow_right: "",
  arrow_lower_right: "",
  arrow_down: "",
  arrow_lower_left: "",
  arrow_left: "",
  arrow_upper_left: "",
  arrow_up_down: "",
  leftwards_arrow_with_hook: "",
  arrow_right_hook: "",
  arrow_heading_up: "",
  arrow_heading_down: "",
  arrows_clockwise: "",
  arrows_counterclockwise: "",
  back: "",
  end: "",
  on: "",
  soon: "",
  top: "",
  six_pointed_star: "",
  scorpius: "",
  twisted_rightwards_arrows: "",
  repeat: "",
  repeat_one: "",
  arrow_forward: "",
  fast_forward: "",
  arrow_backward: "",
  rewind: "",
  previous_track_button: "",
  arrow_up_small: "",
  arrow_double_up: "",
  arrow_down_small: "",
  arrow_double_down: "",
  low_brightness: "",
  high_brightness: "",
  signal_strength: "",
  recycle: "",
  trident: "",
  beginner: "",
  o: "",
  white_check_mark: "",
  ballot_box_with_check: "",
  heavy_check_mark: "",
  heavy_multiplication_x: "",
  x: "",
  negative_squared_cross_mark: "",
  heavy_plus_sign: "",
  heavy_minus_sign: "",
  heavy_division_sign: "",
  loop: "",
  eight_pointed_black_star: "",
  bangbang: "",
  interrobang: "",
  question: "",
  grey_question: "",
  grey_exclamation: "",
  exclamation: "",
  heavy_exclamation_mark: "",
  tm: "",
  hash: "#",
  asterisk: "*",
  zero: "0",
  one: "1",
  two: "2",
  three: "3",
  four: "4",
  five: "5",
  six: "6",
  seven: "7",
  eight: "8",
  nine: "9",
  keycap_ten: "",
  capital_abcd: "",
  abcd: "",
  symbols: "",
  abc: "",
  a: "",
  ab: "",
  b: "",
  cl: "",
  cool: "",
  free: "",
  information_source: "",
  id: "",
  m: "",
  new: "",
  ng: "",
  o2: "",
  ok: "",
  parking: "",
  sos: "",
  up: "",
  vs: "",
  koko: "",
  sa: "",
  u6708: "",
  u6709: "",
  u6307: "",
  ideograph_advantage: "",
  u5272: "",
  u7121: "",
  u7981: "",
  accept: "",
  u7533: "",
  u5408: "",
  u7a7a: "",
  congratulations: "",
  secret: "",
  u55b6: "",
  u6e80: "",
  large_blue_circle: "",
  small_red_triangle: "",
  small_red_triangle_down: "",
  diamond_shape_with_a_dot_inside: "",
  checkered_flag: "",
  triangular_flag_on_post: "",
  ascension_island: "",
  andorra: "",
  united_arab_emirates: "",
  afghanistan: "",
  antigua_barbuda: "",
  anguilla: "",
  albania: "",
  armenia: "",
  angola: "",
  antarctica: "",
  argentina: "",
  american_samoa: "",
  austria: "",
  australia: "",
  aruba: "",
  aland_islands: "",
  azerbaijan: "",
  bosnia_herzegovina: "",
  barbados: "",
  bangladesh: "",
  belgium: "",
  burkina_faso: "",
  bulgaria: "",
  bahrain: "",
  burundi: "",
  benin: "",
  st_barthelemy: "",
  bermuda: "",
  brunei: "",
  bolivia: "",
  caribbean_netherlands: "",
  brazil: "",
  bahamas: "",
  bhutan: "",
  bouvet_island: "",
  botswana: "",
  belarus: "",
  belize: "",
  canada: "",
  cocos_islands: "",
  congo_kinshasa: "",
  central_african_republic: "",
  congo_brazzaville: "",
  switzerland: "",
  cote_divoire: "",
  cook_islands: "",
  chile: "",
  cameroon: "",
  cn: "",
  colombia: "",
  clipperton_island: "",
  costa_rica: "",
  cuba: "",
  cape_verde: "",
  curacao: "",
  christmas_island: "",
  cyprus: "",
  czech_republic: "",
  de: "",
  diego_garcia: "",
  djibouti: "",
  denmark: "",
  dominica: "",
  dominican_republic: "",
  algeria: "",
  ceuta_melilla: "",
  ecuador: "",
  estonia: "",
  egypt: "",
  western_sahara: "",
  eritrea: "",
  es: "",
  ethiopia: "",
  eu: "",
  european_union: "",
  finland: "",
  fiji: "",
  falkland_islands: "",
  micronesia: "",
  faroe_islands: "",
  fr: "",
  gabon: "",
  gb: "",
  uk: "",
  grenada: "",
  georgia: "",
  french_guiana: "",
  guernsey: "",
  ghana: "",
  gibraltar: "",
  greenland: "",
  gambia: "",
  guinea: "",
  guadeloupe: "",
  equatorial_guinea: "",
  greece: "",
  south_georgia_south_sandwich_islands: "",
  guatemala: "",
  guam: "",
  guinea_bissau: "",
  guyana: "",
  hong_kong: "",
  heard_mcdonald_islands: "",
  honduras: "",
  croatia: "",
  haiti: "",
  hungary: "",
  canary_islands: "",
  indonesia: "",
  ireland: "",
  israel: "",
  isle_of_man: "",
  india: "",
  british_indian_ocean_territory: "",
  iraq: "",
  iran: "",
  iceland: "",
  it: "",
  jersey: "",
  jamaica: "",
  jordan: "",
  jp: "",
  kenya: "",
  kyrgyzstan: "",
  cambodia: "",
  kiribati: "",
  comoros: "",
  st_kitts_nevis: "",
  north_korea: "",
  kr: "",
  kuwait: "",
  cayman_islands: "",
  kazakhstan: "",
  laos: "",
  lebanon: "",
  st_lucia: "",
  liechtenstein: "",
  sri_lanka: "",
  liberia: "",
  lesotho: "",
  lithuania: "",
  luxembourg: "",
  latvia: "",
  libya: "",
  morocco: "",
  monaco: "",
  moldova: "",
  montenegro: "",
  st_martin: "",
  madagascar: "",
  marshall_islands: "",
  macedonia: "",
  mali: "",
  myanmar: "",
  mongolia: "",
  macau: "",
  northern_mariana_islands: "",
  martinique: "",
  mauritania: "",
  montserrat: "",
  malta: "",
  mauritius: "",
  maldives: "",
  malawi: "",
  mexico: "",
  malaysia: "",
  mozambique: "",
  namibia: "",
  new_caledonia: "",
  niger: "",
  norfolk_island: "",
  nigeria: "",
  nicaragua: "",
  netherlands: "",
  norway: "",
  nepal: "",
  nauru: "",
  niue: "",
  new_zealand: "",
  oman: "",
  panama: "",
  peru: "",
  french_polynesia: "",
  papua_new_guinea: "",
  philippines: "",
  pakistan: "",
  poland: "",
  st_pierre_miquelon: "",
  pitcairn_islands: "",
  puerto_rico: "",
  palestinian_territories: "",
  portugal: "",
  palau: "",
  paraguay: "",
  qatar: "",
  reunion: "",
  romania: "",
  serbia: "",
  ru: "",
  rwanda: "",
  saudi_arabia: "",
  solomon_islands: "",
  seychelles: "",
  sudan: "",
  sweden: "",
  singapore: "",
  st_helena: "",
  slovenia: "",
  svalbard_jan_mayen: "",
  slovakia: "",
  sierra_leone: "",
  san_marino: "",
  senegal: "",
  somalia: "",
  suriname: "",
  south_sudan: "",
  sao_tome_principe: "",
  el_salvador: "",
  sint_maarten: "",
  syria: "",
  swaziland: "",
  tristan_da_cunha: "",
  turks_caicos_islands: "",
  chad: "",
  french_southern_territories: "",
  togo: "",
  thailand: "",
  tajikistan: "",
  tokelau: "",
  timor_leste: "",
  turkmenistan: "",
  tunisia: "",
  tonga: "",
  tr: "",
  trinidad_tobago: "",
  tuvalu: "",
  taiwan: "",
  tanzania: "",
  ukraine: "",
  uganda: "",
  us_outlying_islands: "",
  united_nations: "",
  us: "",
  uruguay: "",
  uzbekistan: "",
  vatican_city: "",
  st_vincent_grenadines: "",
  venezuela: "",
  british_virgin_islands: "",
  us_virgin_islands: "",
  vietnam: "",
  vanuatu: "",
  wallis_futuna: "",
  samoa: "",
  kosovo: "",
  yemen: "",
  mayotte: "",
  south_africa: "",
  zambia: "",
  zimbabwe: "",
  england: "",
  scotland: "",
  wales: "",
  hundred_points_symbol: "",
  input_symbol_for_numbers: "",
  "#": "#",
  keycap_star: "*",
  "*": "*",
  mahjong_tile_red_dragon: "",
  playing_card_black_joker: "",
  "a_button_(blood_type)": "",
  "b_button_(blood_type)": "",
  "o_button_(blood_type)": "",
  negative_squared_ab: "",
  "ab_button_(blood_type)": "",
  squared_cl: "",
  squared_cool: "",
  squared_free: "",
  squared_id: "",
  squared_new: "",
  squared_ng: "",
  squared_ok: "",
  squared_sos: "",
  squared_up_with_exclamation_mark: "",
  "up!_button": "",
  squared_vs: "",
  "flag-ac": "",
  "flag-ad": "",
  ad: "",
  "flag-ae": "",
  ae: "",
  "flag-af": "",
  af: "",
  "flag-ag": "",
  ag: "",
  "antigua_&_barbuda": "",
  "flag-ai": "",
  ai: "",
  "flag-al": "",
  al: "",
  "flag-am": "",
  am: "",
  "flag-ao": "",
  ao: "",
  "flag-aq": "",
  "flag-ar": "",
  ar: "",
  "flag-as": "",
  as: "",
  "flag-at": "",
  at: "",
  "flag-au": "",
  au: "",
  "flag-aw": "",
  aw: "",
  "flag-ax": "",
  land_islands: "",
  "flag-az": "",
  az: "",
  "flag-ba": "",
  ba: "",
  "bosnia_&_herzegovina": "",
  "flag-bb": "",
  bb: "",
  "flag-bd": "",
  bd: "",
  "flag-be": "",
  be: "",
  "flag-bf": "",
  bf: "",
  "flag-bg": "",
  bg: "",
  "flag-bh": "",
  bh: "",
  "flag-bi": "",
  bi: "",
  "flag-bj": "",
  bj: "",
  "flag-bl": "",
  "flag-bm": "",
  bm: "",
  "flag-bn": "",
  bn: "",
  "flag-bo": "",
  bo: "",
  "flag-bq": "",
  "flag-br": "",
  br: "",
  "flag-bs": "",
  bs: "",
  "flag-bt": "",
  bt: "",
  "flag-bv": "",
  "flag-bw": "",
  bw: "",
  "flag-by": "",
  by: "",
  "flag-bz": "",
  bz: "",
  "flag-ca": "",
  ca: "",
  "flag-cc": "",
  "cocos_(keeling)_islands": "",
  "flag-cd": "",
  cd_flag: "",
  "congo_-_kinshasa": "",
  "flag-cf": "",
  cf: "",
  "flag-cg": "",
  cg: "",
  "congo_-_brazzaville": "",
  "flag-ch": "",
  ch: "",
  "flag-ci": "",
  ci: "",
  "cte_divoire": "",
  "flag-ck": "",
  ck: "",
  "flag-cl": "",
  cl_flag: "",
  "flag-cm": "",
  cm: "",
  "flag-cn": "",
  china: "",
  "flag-co": "",
  co: "",
  "flag-cp": "",
  "flag-cr": "",
  cr: "",
  "flag-cu": "",
  cu: "",
  "flag-cv": "",
  cv: "",
  "flag-cw": "",
  cw: "",
  curaao: "",
  "flag-cx": "",
  "flag-cy": "",
  cy: "",
  "flag-cz": "",
  cz: "",
  czechia: "",
  "flag-de": "",
  germany: "",
  "flag-dg": "",
  "flag-dj": "",
  dj: "",
  "flag-dk": "",
  dk: "",
  "flag-dm": "",
  dm: "",
  "flag-do": "",
  do: "",
  "flag-dz": "",
  dz: "",
  "flag-ea": "",
  "ceuta_&_melilla": "",
  "flag-ec": "",
  ec: "",
  "flag-ee": "",
  ee: "",
  "flag-eg": "",
  eg: "",
  "flag-eh": "",
  "flag-er": "",
  er: "",
  "flag-es": "",
  spain: "",
  "flag-et": "",
  et: "",
  "flag-eu": "",
  "flag-fi": "",
  fi: "",
  "flag-fj": "",
  fj: "",
  "flag-fk": "",
  "flag-fm": "",
  "flag-fo": "",
  fo: "",
  "flag-fr": "",
  france: "",
  "flag-ga": "",
  ga: "",
  "flag-gb": "",
  united_kingdom: "",
  "flag-gd": "",
  gd: "",
  "flag-ge": "",
  ge: "",
  "flag-gf": "",
  gf: "",
  "flag-gg": "",
  "flag-gh": "",
  gh: "",
  "flag-gi": "",
  gi: "",
  "flag-gl": "",
  "flag-gm": "",
  gm: "",
  "flag-gn": "",
  gn: "",
  "flag-gp": "",
  gp: "",
  "flag-gq": "",
  gq: "",
  "flag-gr": "",
  gr: "",
  "flag-gs": "",
  "south_georgia_&_south_sandwich_islands": "",
  "flag-gt": "",
  gt: "",
  "flag-gu": "",
  gu: "",
  "flag-gw": "",
  gw: "",
  "guinea-bissau": "",
  "flag-gy": "",
  gy: "",
  "flag-hk": "",
  hk: "",
  hong_kong_sar_china: "",
  "flag-hm": "",
  "heard_&_mcdonald_islands": "",
  "flag-hn": "",
  hn: "",
  "flag-hr": "",
  hr: "",
  "flag-ht": "",
  ht: "",
  "flag-hu": "",
  hu: "",
  "flag-ic": "",
  "flag-id": "",
  id_flag: "",
  "flag-ie": "",
  ie: "",
  "flag-il": "",
  il: "",
  "flag-im": "",
  "flag-in": "",
  in: "",
  "flag-io": "",
  "flag-iq": "",
  iq: "",
  "flag-ir": "",
  ir: "",
  "flag-is": "",
  is: "",
  "flag-it": "",
  italy: "",
  "flag-je": "",
  "flag-jm": "",
  jm: "",
  "flag-jo": "",
  jo: "",
  "flag-jp": "",
  "flag-ke": "",
  ke: "",
  "flag-kg": "",
  kg: "",
  "flag-kh": "",
  kh: "",
  "flag-ki": "",
  ki: "",
  "flag-km": "",
  km: "",
  "flag-kn": "",
  "flag-kp": "",
  kp: "",
  "flag-kr": "",
  south_korea: "",
  "flag-kw": "",
  kw: "",
  "flag-ky": "",
  ky: "",
  "flag-kz": "",
  kz: "",
  "flag-la": "",
  la: "",
  "flag-lb": "",
  lb: "",
  "flag-lc": "",
  "flag-li": "",
  li: "",
  "flag-lk": "",
  lk: "",
  "flag-lr": "",
  lr: "",
  "flag-ls": "",
  ls: "",
  "flag-lt": "",
  lt: "",
  "flag-lu": "",
  lu: "",
  "flag-lv": "",
  lv: "",
  "flag-ly": "",
  ly: "",
  "flag-ma": "",
  ma: "",
  "flag-mc": "",
  "flag-md": "",
  md: "",
  "flag-me": "",
  me: "",
  "flag-mf": "",
  "flag-mg": "",
  mg: "",
  "flag-mh": "",
  "flag-mk": "",
  mk: "",
  "flag-ml": "",
  ml: "",
  "flag-mm": "",
  mm: "",
  "myanmar_(burma)": "",
  "flag-mn": "",
  mn: "",
  "flag-mo": "",
  mo: "",
  macao_sar_china: "",
  "flag-mp": "",
  mp: "",
  "flag-mq": "",
  mq: "",
  "flag-mr": "",
  mr: "",
  "flag-ms": "",
  ms: "",
  "flag-mt": "",
  mt: "",
  "flag-mu": "",
  "flag-mv": "",
  mv: "",
  "flag-mw": "",
  mw: "",
  "flag-mx": "",
  mx: "",
  "flag-my": "",
  my: "",
  "flag-mz": "",
  mz: "",
  "flag-na": "",
  na: "",
  "flag-nc": "",
  nc: "",
  "flag-ne": "",
  ne: "",
  "flag-nf": "",
  "flag-ng": "",
  "flag-ni": "",
  ni: "",
  "flag-nl": "",
  nl: "",
  "flag-no": "",
  no: "",
  "flag-np": "",
  np: "",
  "flag-nr": "",
  "flag-nu": "",
  nu: "",
  "flag-nz": "",
  nz: "",
  "flag-om": "",
  "flag-pa": "",
  pa: "",
  "flag-pe": "",
  pe: "",
  "flag-pf": "",
  "flag-pg": "",
  pg: "",
  "flag-ph": "",
  ph: "",
  "flag-pk": "",
  pk: "",
  "flag-pl": "",
  pl: "",
  "flag-pm": "",
  "flag-pn": "",
  "flag-pr": "",
  pr: "",
  "flag-ps": "",
  ps: "",
  "flag-pt": "",
  pt: "",
  "flag-pw": "",
  pw: "",
  "flag-py": "",
  py: "",
  "flag-qa": "",
  qa: "",
  "flag-re": "",
  re: "",
  runion: "",
  "flag-ro": "",
  ro: "",
  "flag-rs": "",
  rs: "",
  "flag-ru": "",
  russia: "",
  "flag-rw": "",
  rw: "",
  "flag-sa": "",
  sa_flag: "",
  "flag-sb": "",
  sb: "",
  "flag-sc": "",
  sc: "",
  "flag-sd": "",
  sd: "",
  "flag-se": "",
  se: "",
  "flag-sg": "",
  sg: "",
  "flag-sh": "",
  "flag-si": "",
  si: "",
  "flag-sj": "",
  "svalbard_&_jan_mayen": "",
  "flag-sk": "",
  sk: "",
  "flag-sl": "",
  sl: "",
  "flag-sm": "",
  sm: "",
  "flag-sn": "",
  sn: "",
  "flag-so": "",
  so: "",
  "flag-sr": "",
  sr: "",
  "flag-ss": "",
  ss: "",
  "flag-st": "",
  st: "",
  "so_tom_&_prncipe": "",
  "flag-sv": "",
  sv: "",
  "flag-sx": "",
  "flag-sy": "",
  sy: "",
  "flag-sz": "",
  sz: "",
  eswatini: "",
  "flag-ta": "",
  "flag-tc": "",
  tc: "",
  "turks_&_caicos_islands": "",
  "flag-td": "",
  "flag-tf": "",
  tf: "",
  "flag-tg": "",
  tg: "",
  "flag-th": "",
  th: "",
  "flag-tj": "",
  tj: "",
  "flag-tk": "",
  "flag-tl": "",
  tl: "",
  "timor-leste": "",
  "flag-tm": "",
  tm_flag: "",
  "flag-tn": "",
  tn: "",
  "flag-to": "",
  to: "",
  "flag-tr": "",
  "flag-tt": "",
  tt: "",
  "trinidad_&_tobago": "",
  "flag-tv": "",
  tv_flag: "",
  "flag-tw": "",
  "flag-tz": "",
  tz: "",
  "flag-ua": "",
  ua: "",
  "flag-ug": "",
  ug: "",
  "flag-um": "",
  "flag-un": "",
  "flag-us": "",
  united_states: "",
  "flag-uy": "",
  uy: "",
  "flag-uz": "",
  uz: "",
  "flag-va": "",
  "flag-vc": "",
  vc: "",
  "flag-ve": "",
  ve: "",
  "flag-vg": "",
  vg: "",
  "flag-vi": "",
  vi: "",
  "flag-vn": "",
  vn: "",
  "flag-vu": "",
  vu: "",
  "flag-wf": "",
  "wallis_&_futuna": "",
  "flag-ws": "",
  ws: "",
  "flag-xk": "",
  "flag-ye": "",
  ye: "",
  "flag-yt": "",
  "flag-za": "",
  za: "",
  "flag-zm": "",
  zm: "",
  "flag-zw": "",
  zw: "",
  squared_katakana_koko: "",
  "japanese_here_button": "",
  "japanese_service_charge_button": "",
  "squared_cjk_unified_ideograph-7121": "",
  "japanese_free_of_charge_button": "",
  "squared_cjk_unified_ideograph-6307": "",
  "japanese_reserved_button": "",
  "squared_cjk_unified_ideograph-7981": "",
  "japanese_prohibited_button": "",
  "squared_cjk_unified_ideograph-7a7a": "",
  "japanese_vacancy_button": "",
  "squared_cjk_unified_ideograph-5408": "",
  "japanese_passing_grade_button": "",
  "squared_cjk_unified_ideograph-6e80": "",
  "japanese_no_vacancy_button": "",
  "squared_cjk_unified_ideograph-6709": "",
  "japanese_not_free_of_charge_button": "",
  "japanese_monthly_amount_button": "",
  "squared_cjk_unified_ideograph-7533": "",
  "japanese_application_button": "",
  "squared_cjk_unified_ideograph-5272": "",
  "japanese_discount_button": "",
  "squared_cjk_unified_ideograph-55b6": "",
  "japanese_open_for_business_button": "",
  circled_ideograph_advantage: "",
  "japanese_bargain_button": "",
  circled_ideograph_accept: "",
  "japanese_acceptable_button": "",
  sunset_over_buildings: "",
  "earth_globe_europe-africa": "",
  "globe_showing_europe-africa": "",
  earth_globe_americas: "",
  "earth_globe_asia-australia": "",
  "globe_showing_asia-australia": "",
  new_moon_symbol: "",
  waxing_crescent_moon_symbol: "",
  first_quarter_moon_symbol: "",
  waxing_gibbous_moon_symbol: "",
  full_moon_symbol: "",
  waning_gibbous_moon_symbol: "",
  last_quarter_moon_symbol: "",
  waning_crescent_moon_symbol: "",
  mostly_sunny: "",
  barely_sunny: "",
  partly_sunny_rain: "",
  rain_cloud: "",
  snow_cloud: "",
  lightning: "",
  wind_blowing_face: "",
  wrap: "",
  ear_of_maize: "",
  aubergine: "",
  slice_of_pizza: "",
  curry_and_rice: "",
  fish_cake_with_swirl_design: "",
  sake_bottle_and_cup: "",
  knife_fork_plate: "",
  sparkling_wine: "",
  wrapped_present: "",
  "jack-o-lantern": "",
  father_christmas: "",
  firework_sparkler: "",
  medal: "",
  billiards: "",
  multiple_musical_notes: "",
  tennis_racquet_and_ball: "",
  ski_and_ski_boot: "",
  basketball_and_hoop: "",
  "woman-running": "",
  "man-running": "",
  "woman-surfing": "",
  "man-surfing": "",
  sports_decoration: "",
  "woman-swimming": "",
  "man-swimming": "",
  "woman-lifting-weights": "",
  "man-lifting-weights": "",
  weight_lifter: "",
  "woman-golfing": "",
  "man-golfing": "",
  golfer: "",
  racing_motorcycle: "",
  cricket_bat_and_ball: "",
  field_hockey_stick_and_ball: "",
  ice_hockey_stick_and_puck: "",
  table_tennis_paddle_and_ball: "",
  table_tennis: "",
  house_buildings: "",
  derelict_house_building: "",
  house_building: "",
  automated_teller_machine: "",
  "rainbow-flag": "",
  waving_white_flag: "",
  "flag-england": "",
  "flag-scotland": "",
  "flag-wales": "",
  waving_black_flag: "",
  badminton_racquet_and_shuttlecock: "",
  badminton_racket_and_shuttlecock: "",
  bow_arrow: "",
  archery: "",
  jar: "",
  vase: "",
  "skin-tone-2": "",
  "skin-tone-3": "",
  "skin-tone-4": "",
  "skin-tone-5": "",
  "skin-tone-6": "",
  "front-facing_baby_chick": "",
  bactrian_camel: "",
  "two-hump_camel": "",
  frog_face: "",
  hamster_face: "",
  wolf_face: "",
  bear_face: "",
  "eye-in-speech-bubble": "",
  white_up_pointing_backhand_index: "",
  white_down_pointing_backhand_index: "",
  white_left_pointing_backhand_index: "",
  white_right_pointing_backhand_index: "",
  fisted_hand_sign: "",
  waving_hand_sign: "",
  ok_hand_sign: "",
  thumbs_up_sign: "",
  thumbs_down_sign: "",
  clapping_hands_sign: "",
  open_hands_sign: "",
  "womans_hat": "",
  "t-shirt": "",
  "womans_clothes": "",
  "mans_shoe": "",
  "high-heeled_shoe": "",
  womans_sandal: "",
  "womans_sandal": "",
  womans_boots: "",
  "womans_boot": "",
  "male-farmer": "",
  male_farmer: "",
  "male-cook": "",
  male_cook: "",
  "male-student": "",
  male_student: "",
  "male-singer": "",
  male_singer: "",
  "male-artist": "",
  male_artist: "",
  "male-teacher": "",
  male_teacher: "",
  "male-factory-worker": "",
  male_factory_worker: "",
  "man-boy-boy": "",
  "man,_boy,_boy": "",
  "man-boy": "",
  "man,_boy": "",
  "man-girl-boy": "",
  "man,_girl,_boy": "",
  "man-girl-girl": "",
  "man,_girl,_girl": "",
  "man-girl": "",
  "man,_girl": "",
  "man-man-boy": "",
  "family_(man,_man,_boy)": "",
  "man,_man,_boy": "",
  "man-man-boy-boy": "",
  "family_(man,_man,_boy,_boy)": "",
  "man,_man,_boy,_boy": "",
  "man-man-girl": "",
  "family_(man,_man,_girl)": "",
  "man,_man,_girl": "",
  "man-man-girl-boy": "",
  "family_(man,_man,_girl,_boy)": "",
  "man,_man,_girl,_boy": "",
  "man-man-girl-girl": "",
  "family_(man,_man,_girl,_girl)": "",
  "man,_man,_girl,_girl": "",
  "man-woman-boy": "",
  "family_(man,_woman,_boy)": "",
  "man,_woman,_boy": "",
  "man-woman-boy-boy": "",
  "family_(man,_woman,_boy,_boy)": "",
  "man,_woman,_boy,_boy": "",
  "man-woman-girl": "",
  "family_(man,_woman,_girl)": "",
  "man,_woman,_girl": "",
  "man-woman-girl-boy": "",
  "family_(man,_woman,_girl,_boy)": "",
  "man,_woman,_girl,_boy": "",
  "man-woman-girl-girl": "",
  "family_(man,_woman,_girl,_girl)": "",
  "man,_woman,_girl,_girl": "",
  "male-technologist": "",
  male_technologist: "",
  "male-office-worker": "",
  male_office_worker: "",
  "male-mechanic": "",
  male_mechanic: "",
  "male-scientist": "",
  male_scientist: "",
  "male-astronaut": "",
  male_astronaut: "",
  "male-firefighter": "",
  male_firefighter: "",
  "male-doctor": "",
  male_health_worker: "",
  "male-judge": "",
  male_judge: "",
  "male-pilot": "",
  male_pilot: "",
  "man-heart-man": "",
  "man-kiss-man": "",
  "man,_man": "",
  "female-farmer": "",
  female_farmer: "",
  woman_famer: "",
  "female-cook": "",
  female_cook: "",
  "female-student": "",
  female_student: "",
  "female-singer": "",
  female_singer: "",
  "female-artist": "",
  female_artist: "",
  "female-teacher": "",
  female_teacher: "",
  "female-factory-worker": "",
  female_factory_worker: "",
  "woman-boy-boy": "",
  "woman,_boy,_boy": "",
  "woman-boy": "",
  "woman,_boy": "",
  "woman-girl-boy": "",
  "woman,_girl,_boy": "",
  "woman-girl-girl": "",
  "woman,_girl,_girl": "",
  "woman-girl": "",
  "woman,_girl": "",
  "woman-woman-boy": "",
  "family_(woman,_woman,_boy)": "",
  "woman,_woman,_boy": "",
  "woman-woman-boy-boy": "",
  "family_(woman,_woman,_boy,_boy)": "",
  "woman,_woman,_boy,_boy": "",
  "woman-woman-girl": "",
  "family_(woman,_woman,_girl)": "",
  "woman,_woman,_girl": "",
  "woman-woman-girl-boy": "",
  "family_(woman,_woman,_girl,_boy)": "",
  "woman,_woman,_girl,_boy": "",
  "woman-woman-girl-girl": "",
  "family_(woman,_woman,_girl,_girl)": "",
  "woman,_woman,_girl,_girl": "",
  "female-technologist": "",
  female_technologist: "",
  "female-office-worker": "",
  female_office_worker: "",
  "female-mechanic": "",
  female_mechanic: "",
  "female-scientist": "",
  female_scientist: "",
  "female-astronaut": "",
  female_astronaut: "",
  "female-firefighter": "",
  female_firefighter: "",
  "female-doctor": "",
  female_health_worker: "",
  "female-judge": "",
  female_judge: "",
  "female-pilot": "",
  female_pilot: "",
  "woman-heart-man": "",
  "woman-heart-woman": "",
  "woman-kiss-man": "",
  "woman,_man": "",
  "woman-kiss-woman": "",
  "kiss_(woman,_woman)": "",
  "woman,_woman": "",
  man_and_woman_holding_hands: "",
  "female-police-officer": "",
  "male-police-officer": "",
  "woman-with-bunny-ears-partying": "",
  "man-with-bunny-ears-partying": "",
  woman_with_bunny_ears: "",
  "blond-haired-woman": "",
  "blond-haired-man": "",
  person_with_blond_hair: "",
  blond_hair: "",
  man_with_chinese_cap: "",
  "woman-wearing-turban": "",
  "man-wearing-turban": "",
  "female-construction-worker": "",
  "male-construction-worker": "",
  extraterrestrial_alien: "",
  "woman-tipping-hand": "",
  "man-tipping-hand": "",
  "female-guard": "",
  "male-guard": "",
  "woman-getting-massage": "",
  "man-getting-massage": "",
  face_massage: "",
  "woman-getting-haircut": "",
  "man-getting-haircut": "",
  electric_light_bulb: "",
  sleeping_symbol: "",
  collision_symbol: "",
  splashing_sweat_symbol: "",
  dash_symbol: "",
  dizzy_symbol: "",
  banknote_with_yen_sign: "",
  banknote_with_dollar_sign: "",
  banknote_with_euro_sign: "",
  banknote_with_pound_sign: "",
  chart_with_upwards_trend_and_yen_sign: "",
  personal_computer: "",
  laptop_computer: "",
  optical_disc: "",
  "tear-off_calendar": "",
  public_address_loudspeaker: "",
  cheering_megaphone: "",
  "e-mail_symbol": "",
  envelope_with_downwards_arrow_above: "",
  mobile_phone_with_rightwards_arrow_at_left: "",
  antenna_with_bars: "",
  dhikr_beads: "",
  rosary_beads: "",
  clockwise_rightwards_and_leftwards_open_circle_arrows: "",
  clockwise_rightwards_and_leftwards_open_circle_arrows_with_circled_one_overlay: "",
  clockwise_downwards_and_upwards_open_circle_arrows: "",
  anticlockwise_downwards_and_upwards_open_circle_arrows: "",
  low_brightness_symbol: "",
  high_brightness_symbol: "",
  speaker_with_cancellation_stroke: "",
  speaker_with_one_sound_wave: "",
  speaker_with_three_sound_waves: "",
  "left-pointing_magnifying_glass": "",
  "right-pointing_magnifying_glass": "",
  open_lock: "",
  bell_with_cancellation_stroke: "",
  link_symbol: "",
  back_with_leftwards_arrow_above: "",
  end_with_leftwards_arrow_above: "",
  on_with_exclamation_mark_with_left_right_arrow_above: "",
  "on!_arrow": "",
  soon_with_rightwards_arrow_above: "",
  top_with_upwards_arrow_above: "",
  no_one_under_eighteen_symbol: "",
  input_symbol_for_latin_capital_letters: "",
  input_symbol_for_latin_small_letters: "",
  input_symbol_for_symbols: "",
  input_symbol_for_latin_letters: "",
  electric_torch: "",
  six_pointed_star_with_middle_dot: "",
  "dotted_six-pointed_star": "",
  large_red_circle: "",
  "up-pointing_red_triangle": "",
  "down-pointing_red_triangle": "",
  "up-pointing_small_red_triangle": "",
  "down-pointing_small_red_triangle": "",
  om_symbol: "",
  dove_of_peace: "",
  mecca: "",
  minaret: "",
  domed_roof: "",
  mosque_with_domed_roof_and_minaret: "",
  temple: "",
  jewish: "",
  synagogue_with_star_of_david: "",
  menorah_with_nine_branches: "",
  candelabrum: "",
  chanukiah: "",
  clock_face_one_oclock: "",
  "one_oclock": "",
  clock_face_two_oclock: "",
  "two_oclock": "",
  clock_face_three_oclock: "",
  "three_oclock": "",
  clock_face_four_oclock: "",
  "four_oclock": "",
  clock_face_five_oclock: "",
  "five_oclock": "",
  clock_face_six_oclock: "",
  "six_oclock": "",
  clock_face_seven_oclock: "",
  "seven_oclock": "",
  clock_face_eight_oclock: "",
  "eight_oclock": "",
  clock_face_nine_oclock: "",
  "nine_oclock": "",
  clock_face_ten_oclock: "",
  "ten_oclock": "",
  clock_face_eleven_oclock: "",
  "eleven_oclock": "",
  clock_face_twelve_oclock: "",
  "twelve_oclock": "",
  "clock_face_one-thirty": "",
  "one-thirty": "",
  "clock_face_two-thirty": "",
  "two-thirty": "",
  "clock_face_three-thirty": "",
  "three-thirty": "",
  "clock_face_four-thirty": "",
  "four-thirty": "",
  "clock_face_five-thirty": "",
  "five-thirty": "",
  "clock_face_six-thirty": "",
  "six-thirty": "",
  "clock_face_seven-thirty": "",
  "seven-thirty": "",
  "clock_face_eight-thirty": "",
  "eight-thirty": "",
  "clock_face_nine-thirty": "",
  "nine-thirty": "",
  "clock_face_ten-thirty": "",
  "ten-thirty": "",
  "clock_face_eleven-thirty": "",
  "eleven-thirty": "",
  "clock_face_twelve-thirty": "",
  "twelve-thirty": "",
  man_in_business_suit_levitating: "",
  "female-detective": "",
  "male-detective": "",
  sleuth_or_spy: "",
  lower_left_ballpoint_pen: "",
  lower_left_fountain_pen: "",
  lower_left_paintbrush: "",
  lower_left_crayon: "",
  reversed_hand_with_middle_finger_extended: "",
  "spock-hand": "",
  raised_hand_with_part_between_middle_and_ring_fingers: "",
  three_button_mouse: "",
  frame_with_picture: "",
  spiral_note_pad: "",
  spiral_calendar_pad: "",
  compression: "",
  dagger_knife: "",
  speaking_head_in_silhouette: "",
  silhouette_of_japan: "",
  smiling_face_with_open_mouth: "",
  smiling_face_with_open_mouth_and_smiling_eyes: "",
  smiling_face_with_open_mouth_and_cold_sweat: "",
  "smiling_face_with_open_mouth_and_tightly-closed_eyes": "",
  face_savouring_delicious_food: "",
  "smiling_face_with_heart-shaped_eyes": "",
  "smiling_face_with_heart-eyes": "",
  face_with_cold_sweat: "",
  face_throwing_a_kiss: "",
  "face_with_stuck-out_tongue": "",
  "face_with_stuck-out_tongue_and_winking_eye": "",
  "face_with_stuck-out_tongue_and_tightly-closed_eyes": "",
  face_with_look_of_triumph: "",
  disappointed_but_relieved_face: "",
  face_with_open_mouth_and_cold_sweat: "",
  grinning_cat_face_with_smiling_eyes: "",
  cat_face_with_tears_of_joy: "",
  smiling_cat_face_with_open_mouth: "",
  "smiling_cat_face_with_heart-shaped_eyes": "",
  "smiling_cat_with_heart-eyes": "",
  cat_face_with_wry_smile: "",
  kissing_cat_face_with_closed_eyes: "",
  pouting_cat_face: "",
  weary_cat_face: "",
  slightly_frowning: "",
  slightly_smiling: "",
  slight_smile: "",
  upside_down: "",
  flipped_face: "",
  "upside-down_face": "",
  eye_roll: "",
  rolling_eyes: "",
  "woman-gesturing-no": "",
  "man-gesturing-no": "",
  face_with_no_good_gesture: "",
  "woman-gesturing-ok": "",
  "man-gesturing-ok": "",
  face_with_ok_gesture: "",
  "woman-bowing": "",
  woman_bow: "",
  female_bow: "",
  woman_bowing_deeply: "",
  "man-bowing": "",
  man_bow: "",
  male_bow: "",
  man_bowing_deeply: "",
  person_bowing_deeply: "",
  "see-no-evil_monkey": "",
  "hear-no-evil_monkey": "",
  "speak-no-evil_monkey": "",
  "woman-raising-hand": "",
  "man-raising-hand": "",
  happy_person_raising_one_hand: "",
  person_raising_both_hands_in_celebration: "",
  "woman-frowning": "",
  "man-frowning": "",
  "woman-pouting": "",
  "man-pouting": "",
  person_with_pouting_face: "",
  person_with_folded_hands: "",
  "high-speed_train": "",
  "high-speed_train_with_bullet_nose": "",
  recreational_vehicle: "",
  "woman-rowing-boat": "",
  "man-rowing-boat": "",
  construction_sign: "",
  police_cars_revolving_light: "",
  smoking_symbol: "",
  no_smoking_symbol: "",
  put_litter_in_its_place_symbol: "",
  do_not_litter_symbol: "",
  potable_water_symbol: "",
  "non-potable_water_symbol": "",
  "woman-biking": "",
  "man-biking": "",
  "woman-mountain-biking": "",
  "man-mountain-biking": "",
  "woman-walking": "",
  "man-walking": "",
  pedestrian: "",
  mens_symbol: "",
  "mens_room": "",
  womens_symbol: "",
  "womens_room": "",
  sleeping_accommodation: "",
  worship_building: "",
  worship_place: "",
  religious_building: "",
  religious_place: "",
  octagonal_sign: "",
  shopping_trolley: "",
  take_off: "",
  airplane_arriving: "",
  landing: "",
  scooter: "",
  zipper_mouth: "",
  zip_it: "",
  sealed_lips: "",
  lips_sealed: "",
  "zipper-mouth_face": "",
  money_mouth: "",
  money_face: "",
  "money-mouth_face": "",
  sick: "",
  ill: "",
  thermometer_face: "",
  nerd: "",
  nerdy: "",
  think: "",
  thinker: "",
  injured: "",
  head_bandage: "",
  head_bandaged: "",
  bandaged: "",
  "face_with_head-bandage": "",
  robot_face: "",
  bot_face: "",
  hugging: "",
  hug: "",
  the_horns: "",
  horns_sign: "",
  rock_on: "",
  heavy_metal: "",
  devil_fingers: "",
  "left-facing_fist": "",
  "right-facing_fist": "",
  hand_with_index_and_middle_fingers_crossed: "",
  i_love_you_hand_sign: "",
  "love-you_gesture": "",
  face_with_cowboy_hat: "",
  cowboy: "",
  clown: "",
  "woman-facepalming": "",
  female_facepalm: "",
  woman_facepalm: "",
  "man-facepalming": "",
  face_palm: "",
  "star-struck": "",
  "breast-feeding": "",
  mother_christmas: "",
  "woman-shrugging": "",
  female_shrug: "",
  woman_shrug: "",
  "man-shrugging": "",
  male_shrug: "",
  man_shrug: "",
  "woman-cartwheeling": "",
  woman_doing_cartwheel: "",
  female_doing_cartwheel: "",
  "man-cartwheeling": "",
  man_doing_cartwheel: "",
  male_doing_cartwheel: "",
  person_doing_cartwheel: "",
  "woman-juggling": "",
  female_juggling: "",
  "man-juggling": "",
  male_juggling: "",
  juggling: "",
  fencer: "",
  "woman-wrestling": "",
  woman_wrestlers: "",
  female_wrestlers: "",
  "man-wrestling": "",
  man_wrestlers: "",
  male_wrestlers: "",
  wrestlers: "",
  "woman-playing-water-polo": "",
  woman_water_polo: "",
  female_water_polo: "",
  "man-playing-water-polo": "",
  man_water_polo: "",
  male_water_polo: "",
  "woman-playing-handball": "",
  woman_handball: "",
  female_handball: "",
  "man-playing-handball": "",
  man_handball: "",
  male_handball: "",
  handball: "",
  drum_with_drumsticks: "",
  first_place_medal: "",
  second_place_medal: "",
  third_place_medal: "",
  kiwifruit: "",
  red_crab: "",
  lion_face: "",
  cute_lion: "",
  timid_lion: "",
  unicorn_face: "",
  giraffe_face: "",
  zebra_face: "",
  beard: "",
  person_with_headscarf: "",
  female_mage: "",
  male_mage: "",
  female_fairy: "",
  male_fairy: "",
  female_vampire: "",
  male_vampire: "",
  female_elf: "",
  male_elf: "",
  female_genie: "",
  male_genie: "",
  female_zombie: "",
  male_zombie: "",
  "left-right_arrow": "",
  "up-down_arrow": "",
  "up-left_arrow": "",
  "up-right_arrow": "",
  "down-right_arrow": "",
  "down-left_arrow": "",
  eject: "",
  "black_right-pointing_double_triangle": "",
  "fast-forward_button": "",
  "black_left-pointing_double_triangle": "",
  "black_up-pointing_double_triangle": "",
  "black_down-pointing_double_triangle": "",
  black_right_pointing_double_triangle_with_vertical_bar: "",
  black_left_pointing_double_triangle_with_vertical_bar: "",
  black_right_pointing_triangle_with_double_vertical_bar: "",
  hourglass_with_flowing_sand: "",
  double_vertical_bar: "",
  black_square_for_stop: "",
  black_circle_for_record: "",
  "white_medium-small_square": "",
  "black_medium-small_square": "",
  radioactive_sign: "",
  biohazard_sign: "",
  white_frowning_face: "",
  staff_of_aesculapius: "",
  scales: "",
  high_voltage_sign: "",
  medium_white_circle: "",
  medium_black_circle: "",
  thunder_cloud_and_rain: "",
  helmet_with_white_cross: "",
  "woman-bouncing-ball": "",
  "man-bouncing-ball": "",
  person_with_ball: "",
  white_heavy_check_mark: "",
  "eight-spoked_asterisk": "",
  "eight-pointed_star": "",
  black_question_mark_ornament: "",
  white_question_mark_ornament: "",
  white_exclamation_mark_ornament: "",
  heavy_exclamation_mark_symbol: "",
  heavy_heart_exclamation_mark_ornament: "",
  white_medium_star: "",
  heavy_large_circle: "",
  "japanese_congratulations_button": "",
  "japanese_secret_button": "",
  white_smiling_face: "",
  white_up_pointing_index: "",
  heavy_black_heart: "",
  black_sun_with_rays: "",
  black_telephone: "",
  black_scissors: "",
  warning_sign: "",
  upwards_black_arrow: "",
  downwards_black_arrow: "",
  leftwards_black_arrow: "",
  black_rightwards_arrow: "",
  north_east_arrow: "",
  north_west_arrow: "",
  south_east_arrow: "",
  south_west_arrow: "",
  "black_left-pointing_triangle": "",
  "black_right-pointing_triangle": "",
  rightwards_arrow_with_hook: "",
  arrow_pointing_rightwards_then_curving_downwards: "",
  arrow_pointing_rightwards_then_curving_upwards: "",
  negative_squared_latin_capital_letter_p: "",
  "squared_cjk_unified_ideograph-6708": "",
  squared_katakana_sa: "",
  circled_latin_capital_letter_m: "",
  circled_ideograph_secret: "",
  circled_ideograph_congratulation: "",
  negative_squared_latin_capital_letter_a: "",
  negative_squared_latin_capital_letter_b: "",
  negative_squared_latin_capital_letter_o: "",
  black_universal_recycling_symbol: "",
  copyright_sign: "",
  registered_sign: "",
  trade_mark_sign: "",
  black_spade_suit: "",
  black_heart_suit: "",
  black_club_suit: "",
  black_diamond_suit: "",
  regional_indicator_symbol_a: "",
  regional_indicator_symbol_letter_a: "",
  regional_indicator_symbol_b: "",
  regional_indicator_symbol_letter_b: "",
  regional_indicator_symbol_c: "",
  regional_indicator_symbol_letter_c: "",
  regional_indicator_symbol_d: "",
  regional_indicator_symbol_letter_d: "",
  regional_indicator_symbol_e: "",
  regional_indicator_symbol_letter_e: "",
  regional_indicator_symbol_f: "",
  regional_indicator_symbol_letter_f: "",
  regional_indicator_symbol_g: "",
  regional_indicator_symbol_letter_g: "",
  regional_indicator_symbol_h: "",
  regional_indicator_symbol_letter_h: "",
  regional_indicator_symbol_i: "",
  regional_indicator_symbol_letter_i: "",
  regional_indicator_symbol_j: "",
  regional_indicator_symbol_letter_j: "",
  regional_indicator_symbol_k: "",
  regional_indicator_symbol_letter_k: "",
  regional_indicator_symbol_l: "",
  regional_indicator_symbol_letter_l: "",
  regional_indicator_symbol_m: "",
  regional_indicator_symbol_letter_m: "",
  regional_indicator_symbol_n: "",
  regional_indicator_symbol_letter_n: "",
  regional_indicator_symbol_o: "",
  regional_indicator_symbol_letter_o: "",
  regional_indicator_symbol_p: "",
  regional_indicator_symbol_letter_p: "",
  regional_indicator_symbol_q: "",
  regional_indicator_symbol_letter_q: "",
  regional_indicator_symbol_r: "",
  regional_indicator_symbol_letter_r: "",
  regional_indicator_symbol_s: "",
  regional_indicator_symbol_letter_s: "",
  regional_indicator_symbol_t: "",
  regional_indicator_symbol_letter_t: "",
  regional_indicator_symbol_u: "",
  regional_indicator_symbol_letter_u: "",
  regional_indicator_symbol_v: "",
  regional_indicator_symbol_letter_v: "",
  regional_indicator_symbol_w: "",
  regional_indicator_symbol_letter_w: "",
  regional_indicator_symbol_x: "",
  regional_indicator_symbol_letter_x: "",
  regional_indicator_symbol_y: "",
  regional_indicator_symbol_letter_y: "",
  regional_indicator_symbol_z: "",
  regional_indicator_symbol_letter_z: "",
  "couple_with_heart_(woman,_woman)": "",
  "couple_with_heart_(man,_man)": "",
  "kiss_(man,_man)": "",
  helmet_white_cross: "",
  helmet_with_white_crosse: "",
  "rescue_workers_helmet": "",
  sleuth: "",
  private_eye: "",
  spy: "",
  hovering_man: "",
  levitating_man: "",
  splayed_hand: "",
  raised_hand_with_five_fingers_splayed: "",
  writing: "",
  exclamation_heart: "",
  zig_zag_bubble: "",
  skull_crossbones: "",
  squirrel: "",
  dove_peace: "",
  "dove_of_peace,_carrying_an_olive_branch": "",
  black_spider_with_eight_legs: "",
  cobweb: "",
  spider_web_in_orb_form: "",
  st_patrick: "",
  chili_pepper: "",
  spice: "",
  spicy: "",
  fork_knife_plate: "",
  mont_fuji: "",
  "snow-capped_mountain": "",
  campsite: "",
  camping_with_tent_and_tree: "",
  breach: "",
  desert_with_cactus: "",
  desert_island_with_palm_tree: "",
  crane: "",
  building_in_construction_with_crane: "",
  multiple_houses: "",
  old_house: "",
  abandoned_house: "",
  picture_frame: "",
  painting: "",
  gallery: "",
  frame_with_picture_or_painting: "",
  highway: "",
  road: "",
  interstate: "",
  freeway: "",
  bedroom: "",
  bed_or_bedroom: "",
  couch_lamp: "",
  couch: "",
  sofa: "",
  lounge: "",
  hot_weather: "",
  temperature: "",
  thunder_cloud_rain: "",
  white_sun_small_cloud: "",
  white_sun_with_small_cloud: "",
  white_sun_behind_cloud: "",
  white_sun_behind_cloud_rain: "",
  white_sun_behind_cloud_with_rain: "",
  cloud_rain: "",
  cloud_snow: "",
  cloud_lightning: "",
  cloud_tornado: "",
  cloud_with_tornado: "",
  mother_nature: "",
  blowing_wind: "",
  planted_umbrella: "",
  umbrella_planted_on_the_ground: "",
  snowing_snowman: "",
  light_beam: "",
  blue_beam: "",
  military_decoration: "",
  military_medal_with_ribbon: "",
  awareness_ribbon: "",
  admission_ticket: "",
  golf_club: "",
  golfer_swinging_a_golf_club: "",
  man_golfer: "",
  male_golfer: "",
  male_golfing: "",
  woman_golfer: "",
  female_golfer: "",
  female_golfing: "",
  ice_skating: "",
  single_ice_skate: "",
  formula_one: "",
  f1: "",
  motorbike: "",
  "black_right-pointing_double_triangle_with_vertical_bar": "",
  "black_right-pointing_triangle_with_double_vertical_bar": "",
  "black_left-pointing_double_triangle_with_vertical_bar": "",
  keycap_asterisk: "*",
  star_keycap: "*",
  pc_tower: "",
  imac: "",
  candle_burning: "",
  newspaper_delivery: "",
  newspaper_rolled_up_for_delivery: "",
  "rolled-up_newspaper": "",
  ballot: "",
  ballot_bow_with_ballot: "",
  multiple_paperclips_linked_together: "",
  an_ornate_old_key: "",
  scales_of_justice: "",
  knife_weapon: "",
  funeral: "",
  casket: "",
  scouts: "",
  "fleur-de-lis": "",
  atom: "",
  pranava: "",
  aumkara: "",
  omkara: "",
  christian_cross: "",
  kami_no_michi: "",
  star_crescent: "",
  peace_sign: "",
  radioactive_symbol: "",
  biohazard_symbol: "",
  i_am_a_witness: "",
  red_hair: "",
  curly_hair: "",
  white_hair: "",
  bald: "",
  "yo-yo": "",
  "one-piece_swimsuit": ""
};
Object.defineProperty(renderer, "__esModule", {
  value: true
});
var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e2 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var _extends$5 = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
renderer.toArray = toArray$1;
renderer.default = Emoji$1;
var _react = reactExports;
var _react2 = _interopRequireDefault$h(_react);
var _propTypes = propTypesExports;
var _propTypes2 = _interopRequireDefault$h(_propTypes);
var _classnames2 = classnamesExports;
var _classnames3 = _interopRequireDefault$h(_classnames2);
var _stringReplaceToArray = stringReplaceToArray;
var _stringReplaceToArray2 = _interopRequireDefault$h(_stringReplaceToArray);
var _emojiRegex = emojiRegex;
var _emojiRegex2 = _interopRequireDefault$h(_emojiRegex);
var _aliasRegex = aliasRegex;
var _aliasRegex2 = _interopRequireDefault$h(_aliasRegex);
var _normalizeProtocol = normalizeProtocol$1;
var _normalizeProtocol2 = _interopRequireDefault$h(_normalizeProtocol);
var _unicodeToCodepoint = unicodeToCodepoint$1;
var _unicodeToCodepoint2 = _interopRequireDefault$h(_unicodeToCodepoint);
var _aliases = aliases;
var _aliases2 = _interopRequireDefault$h(_aliases);
var _asciiAliases = asciiAliases;
var _asciiAliases2 = _interopRequireDefault$h(_asciiAliases);
var _utils = utils;
function _interopRequireDefault$h(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties(obj, keys3) {
  var target = {};
  for (var i in obj) {
    if (keys3.indexOf(i) >= 0)
      continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i))
      continue;
    target[i] = obj[i];
  }
  return target;
}
var unicodeEmojiRegex = (0, _emojiRegex2.default)();
var style$1 = {
  width: "1em",
  height: "1em",
  margin: "0 .05em 0 .1em",
  verticalAlign: "-0.1em"
};
var asciiToAlias = { ":": ":" };
var _iteratorNormalCompletion = true;
var _didIteratorError = false;
var _iteratorError = void 0;
try {
  for (var _iterator = Object.keys(_asciiAliases2.default)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
    var alias = _step.value;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = void 0;
    try {
      for (var _iterator2 = _asciiAliases2.default[alias][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var ascii = _step2.value;
        asciiToAlias[ascii] = _aliases2.default[alias];
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }
} catch (err) {
  _didIteratorError = true;
  _iteratorError = err;
} finally {
  try {
    if (!_iteratorNormalCompletion && _iterator.return) {
      _iterator.return();
    }
  } finally {
    if (_didIteratorError) {
      throw _iteratorError;
    }
  }
}
function toArray$1(text) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var protocol = (0, _normalizeProtocol2.default)(options.protocol);
  function replaceUnicodeEmoji(match2, i) {
    if (!options.baseUrl) {
      return _react2.default.createElement(
        "span",
        { key: i, style: style$1, className: options.className },
        match2
      );
    }
    var codepoint = (0, _unicodeToCodepoint2.default)(match2, removeHelperCharacters);
    var removeHelperCharacters = options.emojione;
    if (removeHelperCharacters) {
      codepoint = codepoint.replace(/-200d/g, "").replace(/-fe0f/g, "");
    }
    var separator = options.size ? "/" : "";
    var src = "" + protocol + options.baseUrl + options.size + separator + codepoint + "." + options.ext;
    return _react2.default.createElement("img", _extends$5({
      key: i,
      alt: match2,
      src,
      style: style$1,
      className: options.className
    }, options.props));
  }
  function replaceAliases(text2) {
    var regex = (0, _aliasRegex2.default)();
    var textWithEmoji = [];
    var match2 = void 0, pos = 0;
    while (match2 = regex.exec(text2)) {
      var _match$slice = match2.slice(1, 4), _match$slice2 = _slicedToArray(_match$slice, 3), edgeCase = _match$slice2[0], asciiAlias = _match$slice2[1], fullEmoji = _match$slice2[2];
      var emoji = _aliases2.default[(asciiAlias + fullEmoji).slice(1, -1)];
      if (match2.index > pos) {
        textWithEmoji.push(text2.slice(pos, match2.index));
      }
      if (edgeCase) {
        textWithEmoji.push(match2[0]);
      } else if (asciiAlias[0] === ":" && fullEmoji && emoji) {
        textWithEmoji.push(emoji);
      } else {
        textWithEmoji.push(asciiToAlias[asciiAlias]);
        if (fullEmoji) {
          regex.lastIndex -= fullEmoji.length;
        }
      }
      pos = regex.lastIndex;
    }
    textWithEmoji.push(text2.slice(pos));
    return textWithEmoji.join("");
  }
  return (0, _stringReplaceToArray2.default)(replaceAliases(text), unicodeEmojiRegex, replaceUnicodeEmoji);
}
function Emoji$1(_ref) {
  var text = _ref.text, onlyEmojiClassName = _ref.onlyEmojiClassName, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, className = _ref.className, children = _ref.children, rest = _objectWithoutProperties(_ref, ["text", "onlyEmojiClassName", "options", "className", "children"]);
  var nonStringElements = [];
  if (!!children && Array.isArray(children)) {
    var _stripNonStringElemen = (0, _utils.stripNonStringElements)(children), _stripNonStringElemen2 = _slicedToArray(_stripNonStringElemen, 2), strippedChildren = _stripNonStringElemen2[0], elements = _stripNonStringElemen2[1];
    text = strippedChildren;
    nonStringElements = elements;
  } else if (!!children && typeof children === "string") {
    text = children;
  } else if (!!children) {
    var _stripNonStringElemen3 = (0, _utils.stripNonStringElements)([children]), _stripNonStringElemen4 = _slicedToArray(_stripNonStringElemen3, 2), _strippedChildren = _stripNonStringElemen4[0], _elements = _stripNonStringElemen4[1];
    text = _strippedChildren;
    nonStringElements = _elements;
  } else if (!text) {
    throw new Error("react-emoji-render: either children or text prop must be provided");
  }
  function isOnlyEmoji(output2) {
    if (output2.length > 3)
      return false;
    for (var i = 0; i < output2.length; i++) {
      if (typeof output2[i] === "string")
        return false;
    }
    return true;
  }
  var output = (0, _utils.returnNonStringStrippedElements)(toArray$1(text, options), nonStringElements);
  var classes = (0, _classnames3.default)(className, _defineProperty$2({}, onlyEmojiClassName, isOnlyEmoji(output)));
  return _react2.default.createElement(
    "span",
    _extends$5({}, rest, { className: classes }),
    output
  );
}
Emoji$1.propTypes = {
  text: _propTypes2.default.string,
  props: _propTypes2.default.object,
  onlyEmojiClassName: _propTypes2.default.string,
  options: _propTypes2.default.shape({
    baseUrl: _propTypes2.default.string,
    size: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.string]),
    ext: _propTypes2.default.string,
    className: _propTypes2.default.string
  })
};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.toArray = void 0;
  var _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  var _renderer = renderer;
  Object.defineProperty(exports, "toArray", {
    enumerable: true,
    get: function get8() {
      return _renderer.toArray;
    }
  });
  exports.Twemoji = Twemoji;
  exports.Emojione = Emojione;
  exports.EmojioneV4 = EmojioneV4;
  var _react3 = reactExports;
  var _react22 = _interopRequireDefault2(_react3);
  var _propTypes3 = propTypesExports;
  var _propTypes22 = _interopRequireDefault2(_propTypes3);
  var _renderer2 = _interopRequireDefault2(_renderer);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _objectWithoutProperties2(obj, keys3) {
    var target = {};
    for (var i in obj) {
      if (keys3.indexOf(i) >= 0)
        continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i))
        continue;
      target[i] = obj[i];
    }
    return target;
  }
  var protocol = "https";
  if (typeof location !== "undefined" && location.protocol === "http:") {
    protocol = "http";
  }
  exports.default = _renderer2.default;
  function Twemoji(_ref) {
    var svg = _ref.svg, options = _ref.options, rest = _objectWithoutProperties2(_ref, ["svg", "options"]);
    var size = svg ? "" : "72x72";
    var ext = svg ? "svg" : "png";
    options = _extends2({
      protocol,
      baseUrl: "//cdnjs.cloudflare.com/ajax/libs/twemoji/12.0.4/2/" + (svg ? "svg/" : ""),
      size,
      ext
    }, options);
    return _react22.default.createElement(_renderer2.default, _extends2({ options }, rest));
  }
  Twemoji.propTypes = {
    text: _propTypes22.default.string,
    options: _propTypes22.default.object,
    svg: _propTypes22.default.bool,
    children: _propTypes22.default.oneOfType([_propTypes22.default.arrayOf(_propTypes22.default.node), _propTypes22.default.node])
  };
  function Emojione(_ref2) {
    var svg = _ref2.svg, options = _ref2.options, rest = _objectWithoutProperties2(_ref2, ["svg", "options"]);
    var ext = svg ? "svg" : "png";
    options = _extends2({
      protocol,
      baseUrl: "//cdnjs.cloudflare.com/ajax/libs/emojione/2.2.7/assets/" + ext + "/",
      size: "",
      ext,
      emojione: true
    }, options);
    return _react22.default.createElement(_renderer2.default, _extends2({ options }, rest));
  }
  Emojione.propTypes = {
    text: _propTypes22.default.string,
    options: _propTypes22.default.object,
    svg: _propTypes22.default.bool,
    children: _propTypes22.default.oneOfType([_propTypes22.default.arrayOf(_propTypes22.default.node), _propTypes22.default.node])
  };
  function EmojioneV4(_ref3) {
    var size = _ref3.size, options = _ref3.options, rest = _objectWithoutProperties2(_ref3, ["size", "options"]);
    var ext = "png";
    options = _extends2({
      protocol,
      baseUrl: "//cdn.jsdelivr.net/emojione/assets/4.0/" + ext + "/",
      size,
      ext,
      emojione: true
    }, options);
    return _react22.default.createElement(_renderer2.default, _extends2({ options }, rest));
  }
  EmojioneV4.propTypes = {
    text: _propTypes22.default.string,
    options: _propTypes22.default.object,
    size: _propTypes22.default.oneOf([32, 64, 128]),
    children: _propTypes22.default.oneOfType([_propTypes22.default.arrayOf(_propTypes22.default.node), _propTypes22.default.node])
  };
  EmojioneV4.defaultProps = {
    size: 64
  };
})(lib$1);
const Emoji = /* @__PURE__ */ getDefaultExportFromCjs(lib$1);
var Delete = {};
var _interopRequireDefault$g = interopRequireDefaultExports;
Object.defineProperty(Delete, "__esModule", {
  value: true
});
var default_1$g = Delete.default = void 0;
var _createSvgIcon$g = _interopRequireDefault$g(requireCreateSvgIcon());
var _jsxRuntime$g = require$$2;
var _default$g = (0, _createSvgIcon$g.default)(/* @__PURE__ */ (0, _jsxRuntime$g.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"
}), "Delete");
default_1$g = Delete.default = _default$g;
function Comment({ comment: comment2, canEdit, invalidate }) {
  const deleteCommentMutation = useCommentsDELETEMutation(comment2.id, {
    onSuccess: () => {
      invalidate();
    }
  });
  const handleDeleteClick = () => {
    deleteCommentMutation.mutate();
  };
  return /* @__PURE__ */ jsxs(Box$3, { display: "flex", paddingTop: 2, justifyContent: "space-between", children: [
    /* @__PURE__ */ jsxs(Box$3, { display: "flex", children: [
      /* @__PURE__ */ jsx(Avatar$2, { children: comment2.user.initials }),
      /* @__PURE__ */ jsxs(Box$3, { marginLeft: 1, display: "flex", flexDirection: "column", children: [
        /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: comment2.user.name }),
        /* @__PURE__ */ jsx(Typography$1, { variant: "body2", children: /* @__PURE__ */ jsx(Emoji, { text: comment2.text }) })
      ] })
    ] }),
    /* @__PURE__ */ jsx(Box$3, { children: canEdit && /* @__PURE__ */ jsx(IconButton$1, { color: "error", onClick: handleDeleteClick, children: /* @__PURE__ */ jsx(default_1$g, {}) }) })
  ] });
}
var ThumbUp = {};
var _interopRequireDefault$f = interopRequireDefaultExports;
Object.defineProperty(ThumbUp, "__esModule", {
  value: true
});
var default_1$f = ThumbUp.default = void 0;
var _createSvgIcon$f = _interopRequireDefault$f(requireCreateSvgIcon());
var _jsxRuntime$f = require$$2;
var _default$f = (0, _createSvgIcon$f.default)(/* @__PURE__ */ (0, _jsxRuntime$f.jsx)("path", {
  d: "M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-2z"
}), "ThumbUp");
default_1$f = ThumbUp.default = _default$f;
var ThumbDown = {};
var _interopRequireDefault$e = interopRequireDefaultExports;
Object.defineProperty(ThumbDown, "__esModule", {
  value: true
});
var default_1$e = ThumbDown.default = void 0;
var _createSvgIcon$e = _interopRequireDefault$e(requireCreateSvgIcon());
var _jsxRuntime$e = require$$2;
var _default$e = (0, _createSvgIcon$e.default)(/* @__PURE__ */ (0, _jsxRuntime$e.jsx)("path", {
  d: "M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v2c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"
}), "ThumbDown");
default_1$e = ThumbDown.default = _default$e;
var Share = {};
var _interopRequireDefault$d = interopRequireDefaultExports;
Object.defineProperty(Share, "__esModule", {
  value: true
});
var default_1$d = Share.default = void 0;
var _createSvgIcon$d = _interopRequireDefault$d(requireCreateSvgIcon());
var _jsxRuntime$d = require$$2;
var _default$d = (0, _createSvgIcon$d.default)(/* @__PURE__ */ (0, _jsxRuntime$d.jsx)("path", {
  d: "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"
}), "Share");
default_1$d = Share.default = _default$d;
var Queue = {};
var _interopRequireDefault$c = interopRequireDefaultExports;
Object.defineProperty(Queue, "__esModule", {
  value: true
});
var default_1$c = Queue.default = void 0;
var _createSvgIcon$c = _interopRequireDefault$c(requireCreateSvgIcon());
var _jsxRuntime$c = require$$2;
var _default$c = (0, _createSvgIcon$c.default)(/* @__PURE__ */ (0, _jsxRuntime$c.jsx)("path", {
  d: "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9h-4v4h-2v-4H9V9h4V5h2v4h4v2z"
}), "Queue");
default_1$c = Queue.default = _default$c;
const Item = styled$2(Box$1)(() => ({
  backgroundColor: theme.palette.mode === "dark" ? "#1A2027" : "#fff",
  textAlign: "center",
  color: theme.palette.text.secondary,
  width: "48px"
}));
function LikeDislikeMenu({
  likeCount,
  dislikeCount,
  videoId,
  userStatsQuery,
  enabled = true
}) {
  var _a, _b, _c;
  const [snackbarOpen, setSnackbarOpen] = reactExports.useState(false);
  const videoUserStatsMutation = useUserVideoStatsPUTMutation(videoId, {
    onSuccess: () => {
      userStatsQuery == null ? void 0 : userStatsQuery.refetch();
    }
  });
  const dropdownActions = [
    {
      elementFactory: (props) => AddToPlaylistDropDownFactory({ ...props, parentObjectId: videoId })
    }
  ];
  const handleLikeClick = () => {
    var _a2;
    if (userStatsQuery == null ? void 0 : userStatsQuery.data) {
      videoUserStatsMutation.mutateAsync(
        new UserVideoStats({
          ...userStatsQuery == null ? void 0 : userStatsQuery.data,
          like: !((_a2 = userStatsQuery == null ? void 0 : userStatsQuery.data) == null ? void 0 : _a2.like),
          dislike: false
        })
      );
    }
  };
  const handleDislikeClick = () => {
    var _a2;
    if (userStatsQuery == null ? void 0 : userStatsQuery.data) {
      videoUserStatsMutation.mutateAsync(
        new UserVideoStats({
          ...userStatsQuery == null ? void 0 : userStatsQuery.data,
          like: false,
          dislike: !((_a2 = userStatsQuery == null ? void 0 : userStatsQuery.data) == null ? void 0 : _a2.dislike)
        })
      );
    }
  };
  const handleShareClick = () => {
    navigator.clipboard.writeText(window.location.href);
    setSnackbarOpen(true);
  };
  const handleShareClose = (event, reason) => {
    if (reason === "clickaway") {
      return;
    }
    setSnackbarOpen(false);
  };
  return /* @__PURE__ */ jsxs(
    Stack$1,
    {
      direction: "row",
      justifyContent: "space-between",
      alignItems: "center",
      marginLeft: 2,
      marginRight: 2,
      height: "38px",
      marginTop: 2,
      children: [
        /* @__PURE__ */ jsxs(Item, { children: [
          /* @__PURE__ */ jsx(
            IconButton$1,
            {
              color: ((_a = userStatsQuery == null ? void 0 : userStatsQuery.data) == null ? void 0 : _a.like) ? "primary" : "default",
              onClick: handleLikeClick,
              disabled: !enabled,
              children: /* @__PURE__ */ jsx(default_1$f, {})
            }
          ),
          /* @__PURE__ */ jsx(Typography$1, { children: NumberToWords(likeCount) })
        ] }),
        /* @__PURE__ */ jsxs(Item, { children: [
          /* @__PURE__ */ jsx(
            IconButton$1,
            {
              color: ((_b = userStatsQuery == null ? void 0 : userStatsQuery.data) == null ? void 0 : _b.dislike) ? "primary" : "default",
              onClick: handleDislikeClick,
              disabled: !enabled,
              children: /* @__PURE__ */ jsx(default_1$e, {})
            }
          ),
          /* @__PURE__ */ jsx(Typography$1, { children: NumberToWords(dislikeCount) })
        ] }),
        /* @__PURE__ */ jsxs(Item, { children: [
          /* @__PURE__ */ jsx(
            IconButton$1,
            {
              disabled: !enabled,
              onClick: handleShareClick,
              color: ((_c = userStatsQuery == null ? void 0 : userStatsQuery.data) == null ? void 0 : _c.addedToPlaylist) ? "success" : "default",
              children: /* @__PURE__ */ jsx(default_1$d, {})
            }
          ),
          /* @__PURE__ */ jsx(Typography$1, { children: "Sdlen" })
        ] }),
        /* @__PURE__ */ jsx(Item, { children: /* @__PURE__ */ jsx(
          DropDownMenu,
          {
            actions: dropdownActions,
            text: "Uloit",
            icon: /* @__PURE__ */ jsx(default_1$c, {}),
            enabled
          }
        ) }),
        /* @__PURE__ */ jsx(
          Snackbar$1,
          {
            anchorOrigin: { vertical: "bottom", horizontal: "center" },
            open: snackbarOpen,
            onClose: handleShareClose,
            autoHideDuration: 4e3,
            message: "Odkaz byl zkoprovn do schrnky!"
          }
        )
      ]
    }
  );
}
function ScrollToTop() {
  window.scrollTo(0, 0);
}
var PlayArrow = {};
var _interopRequireDefault$b = interopRequireDefaultExports;
Object.defineProperty(PlayArrow, "__esModule", {
  value: true
});
var default_1$b = PlayArrow.default = void 0;
var _createSvgIcon$b = _interopRequireDefault$b(requireCreateSvgIcon());
var _jsxRuntime$b = require$$2;
var _default$b = (0, _createSvgIcon$b.default)(/* @__PURE__ */ (0, _jsxRuntime$b.jsx)("path", {
  d: "M8 5v14l11-7z"
}), "PlayArrow");
default_1$b = PlayArrow.default = _default$b;
function PlaylistCard({ playlist, fullWidth, smallThumbnail }) {
  var _a, _b, _c;
  if (playlist)
    return /* @__PURE__ */ jsx(
      Grid$1,
      {
        container: true,
        component: Link,
        to: ((_a = playlist == null ? void 0 : playlist.videos) == null ? void 0 : _a.length) ? videoUrl(playlist == null ? void 0 : playlist.videos[0]) + playlistParams(playlist, 0) : `/${Route.playlist}/${playlist == null ? void 0 : playlist.id}`,
        style: { textDecoration: "none" },
        children: /* @__PURE__ */ jsxs(
          Card$1,
          {
            variant: "outlined",
            sx: {
              ...fullWidth && {
                display: "flex"
              },
              ...!fullWidth && {
                height: "100%"
              },
              width: "100%"
            },
            children: [
              /* @__PURE__ */ jsxs(
                Grid$1,
                {
                  item: true,
                  xs: fullWidth ? smallThumbnail ? 2.5 : 4 : 12,
                  sx: {
                    position: "relative",
                    ...fullWidth && { display: "flex" },
                    "&:hover .overlay": { display: "flex" }
                  },
                  children: [
                    /* @__PURE__ */ jsx(AspectRatio, { ratio: 16 / 9, children: /* @__PURE__ */ jsx(
                      CardMedia$1,
                      {
                        component: "img",
                        draggable: false,
                        sx: { maxHeight: "100%", width: "100%", objectFit: "cover" },
                        image: ApiPath(
                          (playlist == null ? void 0 : playlist.thumbnailUrl) ? playlist.thumbnailUrl : ((_b = playlist == null ? void 0 : playlist.videos) == null ? void 0 : _b.length) ? playlist == null ? void 0 : playlist.videos[0].imageUrl : void 0
                        ),
                        alt: "Nhled playlistu"
                      }
                    ) }),
                    /* @__PURE__ */ jsxs(
                      Box$3,
                      {
                        className: "overlay",
                        sx: {
                          position: "absolute",
                          color: "white",
                          height: "100%",
                          width: "100%",
                          top: 0,
                          left: 0,
                          backgroundColor: "#333333ee",
                          display: "none",
                          alignItems: "center",
                          justifyContent: "center",
                          zIndex: 1
                        },
                        children: [
                          /* @__PURE__ */ jsx(default_1$b, { fontSize: "large" }),
                          /* @__PURE__ */ jsx(Typography$1, { variant: "button", children: "Pehrt ve" })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxs(
                      Box$3,
                      {
                        sx: {
                          height: "100%",
                          width: "40%",
                          position: "absolute",
                          right: 0,
                          top: 0,
                          backgroundColor: "#333333bb",
                          color: "white"
                        },
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        flexDirection: "column",
                        children: [
                          /* @__PURE__ */ jsx(Typography$1, { variant: "body1", children: ((_c = playlist == null ? void 0 : playlist.videos) == null ? void 0 : _c.length) ?? 0 }),
                          /* @__PURE__ */ jsx(default_1$o, {})
                        ]
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsx(Grid$1, { item: true, xs: fullWidth ? smallThumbnail ? 9.5 : 8 : 12, display: "flex", children: /* @__PURE__ */ jsxs(
                CardContent$1,
                {
                  sx: {
                    display: "grid",
                    paddingBottom: "4px !important",
                    width: "100%",
                    padding: 1,
                    ...!fullWidth && {
                      minHeight: 64
                    },
                    ...smallThumbnail && {
                      maxHeight: "100%",
                      paddingBottom: "4px !important"
                    }
                  },
                  children: [
                    /* @__PURE__ */ jsx(Box$3, { display: "flex", position: "relative", children: /* @__PURE__ */ jsx(
                      Typography$1,
                      {
                        variant: "subtitle2",
                        component: "div",
                        width: "100%",
                        height: fullWidth ? 24 : "auto",
                        textOverflow: "ellipsis",
                        overflow: "hidden",
                        display: "-webkit-box",
                        mb: "2px",
                        sx: { WebkitLineClamp: 2, WebkitBoxOrient: "vertical" },
                        children: playlist.name
                      }
                    ) }),
                    /* @__PURE__ */ jsx(
                      Box$3,
                      {
                        display: "flex",
                        alignItems: "center",
                        component: Link,
                        to: `/${Route.playlist}/${playlist.id}`,
                        sx: {
                          textDecoration: "none",
                          color: "unset",
                          "&:hover": {
                            backgroundColor: "rgba(0, 0, 0, 0.04)"
                          },
                          borderRadius: "15px"
                        },
                        children: /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: "Zobrazit playlist" })
                      }
                    )
                  ]
                }
              ) })
            ]
          }
        )
      }
    );
}
var Edit = {};
var _interopRequireDefault$a = interopRequireDefaultExports;
Object.defineProperty(Edit, "__esModule", {
  value: true
});
var default_1$a = Edit.default = void 0;
var _createSvgIcon$a = _interopRequireDefault$a(requireCreateSvgIcon());
var _jsxRuntime$a = require$$2;
var _default$a = (0, _createSvgIcon$a.default)(/* @__PURE__ */ (0, _jsxRuntime$a.jsx)("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"
}), "Edit");
default_1$a = Edit.default = _default$a;
function LinkButton({ to, text, icon }) {
  return /* @__PURE__ */ jsx(
    Button$2,
    {
      sx: { marginLeft: 2, fontSize: 11, color: "black", borderColor: "black" },
      startIcon: icon,
      variant: "outlined",
      component: Link,
      to,
      children: text
    }
  );
}
function PlaylistInlineList({ playlists }) {
  return /* @__PURE__ */ jsx(InlineList, { children: playlists.map((_playlist) => /* @__PURE__ */ jsx(PlaylistCard, { playlist: { ..._playlist }, smallThumbnail: true }, _playlist.id)) });
}
function ExpandedPlaylistInlineList({
  playlist,
  currentlyPlaying,
  editable,
  showPlayAllButton
}) {
  var _a;
  return ((_a = playlist == null ? void 0 : playlist.videos) == null ? void 0 : _a.length) ? /* @__PURE__ */ jsxs(Box$3, { children: [
    /* @__PURE__ */ jsx(Typography$1, { variant: "h6", display: "inline-block", sx: { verticalAlign: "middle" }, children: playlist.name }),
    /* @__PURE__ */ jsx(Typography$1, { variant: "caption", display: "inline-block", pl: 1, sx: { verticalAlign: "middle" }, children: `[${(currentlyPlaying ?? 0) + 1}/${playlist.videos.length}]` }),
    (showPlayAllButton ?? true) && /* @__PURE__ */ jsx(
      LinkButton,
      {
        to: videoUrl(playlist.videos[0]) + playlistParams(playlist, 0),
        text: "Pehrt ve",
        icon: /* @__PURE__ */ jsx(default_1$b, {})
      }
    ),
    editable && /* userPlaylistInfo?.editable ?? */
    false,
    /* @__PURE__ */ jsx(Typography$1, { variant: "body2", pt: 1, children: playlist.description }),
    /* @__PURE__ */ jsx(
      VideoInlineList,
      {
        videos: playlist.videos,
        currentlyPlaying,
        urlParamsGenerator: (_2, index2) => playlistParams(playlist, index2)
      }
    )
  ] }) : /* @__PURE__ */ jsx(Fragment, {});
}
async function loader$9({ params }) {
  return getVideoById(params.videoId);
}
function VideoDetail() {
  var _a, _b, _c, _d, _e2;
  const [expanded, setExpanded] = React.useState(true);
  const commentInput = React.createRef();
  const video2 = useLoaderData();
  const context = reactExports.useContext(NavigationContext);
  const [searchParams] = useSearchParams();
  const [playlist, setPlaylist] = React.useState(void 0);
  const [playlistIndex, setPlaylistIndex] = React.useState(void 0);
  const [commentTimeout, setCommentTimeout] = React.useState(false);
  const userContext = reactExports.useContext(UserContext);
  const relatedVideosQuery = useRelatedVideosQuery({ id: video2.id });
  const commentsQuery = useCommentsAllQuery({ videoId: video2.id }, { refetchOnWindowFocus: false });
  const userVideoStatsMutation = useWatchedMutation(video2.id);
  const userVideoStatsQuery = useUserVideoStatsGETQuery({ videoId: video2.id });
  const commentMutation = useCommentsPOSTMutation({
    onSuccess: () => {
      commentsQuery.refetch();
      if (commentInput == null ? void 0 : commentInput.current) {
        commentInput.current.value = "";
      }
      setCommentTimeout(true);
      setTimeout(() => {
        setCommentTimeout(false);
      }, 10 * 1e3);
    }
  });
  reactExports.useEffect(() => {
    const playlistId = searchParams.get("playlist");
    const index2 = searchParams.get("index") ?? "0";
    (async () => {
      if (playlistId) {
        setPlaylist(await playlistsGET(playlistId));
        setPlaylistIndex(parseInt(index2, 10));
      }
    })();
  }, [searchParams]);
  reactExports.useEffect(() => {
    context == null ? void 0 : context.setOpen(false);
  }, []);
  const addComment = async (commentText) => {
    if (commentText) {
      commentMutation.mutate(
        new CommentPostDTO({
          text: commentText,
          videoId: video2.id
        })
      );
    }
  };
  const ExpandMore2 = styled$4((props) => {
    const { expand: expand3, ...other } = props;
    return /* @__PURE__ */ jsx(IconButton$1, { ...other });
  })(({ expand: expand3 }) => ({
    transform: !expand3 ? "rotate(0deg)" : "rotate(180deg)",
    marginLeft: "auto",
    transition: theme.transitions.create("transform", {
      duration: theme.transitions.duration.shortest
    })
  }));
  const handleExpandClick = () => {
    setExpanded(!expanded);
  };
  const userWatchedHandle = (sec) => {
    userVideoStatsMutation.mutate(sec);
  };
  reactExports.useEffect(() => {
    ScrollToTop();
  }, [video2]);
  reactExports.useEffect(() => {
    userVideoStatsQuery.refetch();
  }, [userContext]);
  return /* @__PURE__ */ jsxs(Grid$1, { container: true, children: [
    /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: (video2 == null ? void 0 : video2.dataUrl) ? /* @__PURE__ */ jsx(
      VideoPlayer,
      {
        videoSrc: ApiPath(video2.dataUrl),
        triggerWatched: userWatchedHandle,
        watchedTimeSec: !(userVideoStatsQuery == null ? void 0 : userVideoStatsQuery.isRefetchError) ? ((_a = userVideoStatsQuery == null ? void 0 : userVideoStatsQuery.data) == null ? void 0 : _a.timeWatchedSec) ?? 0 : 0
      }
    ) : /* @__PURE__ */ jsx(Typography$1, { variant: "h1", children: "Video nenalezeno." }) }),
    /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, display: "flex", justifyContent: "center", alignItems: "center", pb: 8, children: /* @__PURE__ */ jsxs(Box$3, { width: "95%", mt: 2, children: [
      /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 2, minHeight: 170, children: [
        /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 8, children: [
          /* @__PURE__ */ jsxs(Box$3, { display: "flex", onClick: handleExpandClick, children: [
            /* @__PURE__ */ jsx(Typography$1, { variant: "subtitle1", lineHeight: "24px", width: "100%", children: video2.name }),
            /* @__PURE__ */ jsx(ExpandMore2, { expand: expanded, "aria-expanded": expanded, "aria-label": "show more", children: /* @__PURE__ */ jsx(default_1$h, {}) })
          ] }),
          /* @__PURE__ */ jsxs(Collapse$1, { in: expanded, timeout: "auto", unmountOnExit: true, children: [
            /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: "Popis:" }),
            /* @__PURE__ */ jsx(Typography$1, { variant: "subtitle1", paddingBottom: "16px", children: video2.description }),
            (((_b = video2 == null ? void 0 : video2.tags) == null ? void 0 : _b.length) ?? 0) > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
              /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: "Tagy:" }),
              /* @__PURE__ */ jsx(Grid$1, { container: true, gap: 0.5, pt: 1, sx: { position: "relative" }, children: /* @__PURE__ */ jsx(ChipLine, { chipData: video2.tags }) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxs(Grid$1, { container: true, item: true, xs: 4, direction: "column", justifyContent: "flex-start", height: 170, children: [
          /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 6, height: 65, width: "100%", children: /* @__PURE__ */ jsx(
            LikeDislikeMenu,
            {
              videoId: video2.id,
              likeCount: video2.likeCount,
              dislikeCount: video2.dislikeCount,
              enabled: !!(userContext == null ? void 0 : userContext.user),
              userStatsQuery: userVideoStatsQuery
            }
          ) }),
          /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 6, height: 65, width: "100%", children: /* @__PURE__ */ jsxs(
            Box$3,
            {
              display: "flex",
              component: Link,
              to: `/${Route.channel}/${video2.channelId}`,
              mt: 2,
              ml: "10px",
              mr: 2,
              alignItems: "center",
              children: [
                /* @__PURE__ */ jsx(
                  ChannelAvatar,
                  {
                    imageSrc: ApiPath(video2.channelAvatarUrl),
                    avatarInitials: video2.channelName,
                    large: true
                  }
                ),
                /* @__PURE__ */ jsx(Typography$1, { paddingLeft: 1, children: video2.channelName })
              ]
            }
          ) })
        ] })
      ] }),
      playlist && /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Divider$1, { sx: { marginTop: 2 } }),
        /* @__PURE__ */ jsx(Box$3, { mt: 2, children: /* @__PURE__ */ jsx(
          ExpandedPlaylistInlineList,
          {
            playlist,
            currentlyPlaying: playlistIndex,
            showPlayAllButton: false,
            editable: true
          }
        ) })
      ] }),
      /* @__PURE__ */ jsx(Divider$1, { sx: { marginTop: 2 } }),
      (relatedVideosQuery == null ? void 0 : relatedVideosQuery.data) && /* @__PURE__ */ jsxs(Box$3, { mt: 2, children: [
        /* @__PURE__ */ jsx(Typography$1, { variant: "body1", children: "Podobn videa" }),
        /* @__PURE__ */ jsx(Box$3, { mt: 2, children: /* @__PURE__ */ jsx(VideoInlineList, { videos: relatedVideosQuery.data, showChannel: true }) })
      ] }),
      /* @__PURE__ */ jsx(Divider$1, { sx: { marginTop: 2 } }),
      /* @__PURE__ */ jsxs(Box$3, { mt: 1, children: [
        /* @__PURE__ */ jsxs(Typography$1, { variant: "body1", children: [
          "Komente (",
          ((_c = commentsQuery == null ? void 0 : commentsQuery.data) == null ? void 0 : _c.length) ?? 0,
          ")"
        ] }),
        /* @__PURE__ */ jsxs(Box$3, { display: "flex", mt: 2, children: [
          /* @__PURE__ */ jsx(Avatar$2, { children: (_d = userContext == null ? void 0 : userContext.user) == null ? void 0 : _d.initials }),
          commentsQuery.isLoading ? /* @__PURE__ */ jsx(
            TailSpin,
            {
              height: "80",
              width: "80",
              color: "#4fa94d",
              ariaLabel: "tail-spin-loading",
              radius: "1",
              wrapperStyle: {},
              wrapperClass: ""
            }
          ) : /* @__PURE__ */ jsx(
            TextField$1,
            {
              sx: { ml: 1 },
              fullWidth: true,
              id: "outlined-basic",
              label: "",
              variant: "outlined",
              multiline: true,
              disabled: !(userContext == null ? void 0 : userContext.user),
              placeholder: !(userContext == null ? void 0 : userContext.user) ? "Pro pidn komente se nejprve pihlaste." : "",
              inputRef: commentInput
            }
          ),
          /* @__PURE__ */ jsx(
            Button$2,
            {
              variant: "text",
              disabled: !(userContext == null ? void 0 : userContext.user) || commentTimeout,
              onClick: () => {
                var _a2;
                return addComment((_a2 = commentInput.current) == null ? void 0 : _a2.value);
              },
              children: "Odeslat"
            }
          )
        ] }),
        (_e2 = commentsQuery == null ? void 0 : commentsQuery.data) == null ? void 0 : _e2.map((comment2) => {
          var _a2;
          return /* @__PURE__ */ jsx(
            Comment,
            {
              comment: comment2,
              canEdit: (_a2 = userContext == null ? void 0 : userContext.user) == null ? void 0 : _a2.roles.administrator,
              invalidate: commentsQuery.refetch
            },
            comment2.created + comment2.user.id
          );
        })
      ] })
    ] }) })
  ] });
}
function descendingComparator(a2, b2, orderBy) {
  if (b2[orderBy] < a2[orderBy]) {
    return -1;
  }
  if (b2[orderBy] > a2[orderBy]) {
    return 1;
  }
  return 0;
}
function getComparator(order2, orderBy) {
  return order2 === "desc" ? (a2, b2) => descendingComparator(a2, b2, orderBy) : (a2, b2) => -descendingComparator(a2, b2, orderBy);
}
function stableSort2(array, comparator) {
  const stabilizedThis = array.map((el2, index2) => [el2, index2]);
  stabilizedThis.sort((a2, b2) => {
    const order2 = comparator(a2[0], b2[0]);
    if (order2 !== 0) {
      return order2;
    }
    return a2[1] - b2[1];
  });
  return stabilizedThis.map((el2) => el2[0]);
}
function EnhancedTableHead(props) {
  const {
    onSelectAllClick,
    order: order2,
    orderBy,
    numSelected,
    rowCount,
    onRequestSort,
    attributes,
    checkVisible
  } = props;
  const createSortHandler = (property) => (event) => {
    onRequestSort(event, property);
  };
  return /* @__PURE__ */ jsx(TableHead$1, { children: /* @__PURE__ */ jsxs(TableRow$1, { children: [
    checkVisible ?? /* @__PURE__ */ jsx(TableCell$1, { padding: "checkbox", children: /* @__PURE__ */ jsx(
      Checkbox$1,
      {
        color: "primary",
        indeterminate: numSelected > 0 && numSelected < rowCount,
        checked: rowCount > 0 && numSelected === rowCount,
        onChange: onSelectAllClick,
        inputProps: {
          "aria-label": "select all desserts"
        }
      }
    ) }),
    attributes.map((headCell) => /* @__PURE__ */ jsx(
      TableCell$1,
      {
        align: headCell.align ?? "left",
        sortDirection: orderBy === headCell.id ? order2 : false,
        children: /* @__PURE__ */ jsxs(
          TableSortLabel$1,
          {
            active: orderBy === headCell.id,
            direction: orderBy === headCell.id ? order2 : "asc",
            onClick: createSortHandler(headCell.id),
            children: [
              headCell.label,
              orderBy === headCell.id ? /* @__PURE__ */ jsx(Box$3, { component: "span", sx: visuallyHidden$2, children: order2 === "desc" ? "sorted descending" : "sorted ascending" }) : null
            ]
          }
        )
      },
      headCell.id
    ))
  ] }) });
}
function EnhancedTableToolbar({ selected, buttons, staticButtons }) {
  return /* @__PURE__ */ jsxs(
    Toolbar$1,
    {
      sx: {
        height: "48px !important",
        pl: { sm: 2 },
        pr: { xs: 1, sm: 1 },
        ...(selected.length > 0 || staticButtons) && {
          bgcolor: (theme2) => alpha(theme2.palette.primary.main, theme2.palette.action.activatedOpacity)
        }
      },
      children: [
        staticButtons == null ? void 0 : staticButtons.map((button) => /* @__PURE__ */ jsx(
          Button$2,
          {
            startIcon: button.icon,
            variant: "contained",
            onClick: () => button.onClick(),
            children: button.label
          },
          button.label
        )),
        staticButtons && selected.length > 0 && /* @__PURE__ */ jsx(Divider$1, { orientation: "vertical", flexItem: true, sx: { margin: "8px 4px 8px 8px" } }),
        selected.length > 0 && (buttons == null ? void 0 : buttons.map((button) => /* @__PURE__ */ jsx(
          Button$2,
          {
            sx: { ml: "4px", mr: "4px" },
            startIcon: button.icon,
            onClick: () => {
              button.onClick(selected);
            },
            variant: "contained",
            children: button.label
          },
          button.label
        )))
      ]
    }
  );
}
function EnhancedTable({
  rows,
  orderBy: _orderby,
  desc,
  attributes,
  buttons,
  rowClick,
  checkVisible,
  staticButtons
}) {
  const [order2, setOrder] = React.useState(desc ?? "asc");
  const [orderBy, setOrderBy] = React.useState(_orderby ?? "id");
  const [selected, setSelected] = React.useState([]);
  const [page, setPage] = React.useState(0);
  const [rowsPerPage, setRowsPerPage] = React.useState(8);
  const handleRequestSort = (event, property) => {
    const isAsc = orderBy === property && order2 === "asc";
    setOrder(isAsc ? "desc" : "asc");
    setOrderBy(property);
  };
  const handleSelectAllClick = (event) => {
    if (event.target.checked) {
      const newSelected = rows.map((n2) => n2.id);
      setSelected(newSelected);
      return;
    }
    setSelected([]);
  };
  reactExports.useEffect(() => {
    if ((selected == null ? void 0 : selected.length) > 0) {
      setSelected([]);
    }
  }, [rows]);
  const handleCheckboxClick = (event, name) => {
    event.preventDefault();
    event.stopPropagation();
    const selectedIndex = selected.indexOf(name);
    let newSelected = [];
    if (selectedIndex === -1) {
      newSelected = newSelected.concat(selected, name);
    } else if (selectedIndex === 0) {
      newSelected = newSelected.concat(selected.slice(1));
    } else if (selectedIndex === selected.length - 1) {
      newSelected = newSelected.concat(selected.slice(0, -1));
    } else if (selectedIndex > 0) {
      newSelected = newSelected.concat(
        selected.slice(0, selectedIndex),
        selected.slice(selectedIndex + 1)
      );
    }
    setSelected(newSelected);
  };
  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };
  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };
  const isSelected = (name) => selected.indexOf(name) !== -1;
  const emptyRows = page > 0 ? Math.max(0, (1 + page) * rowsPerPage - rows.length) : 0;
  return /* @__PURE__ */ jsx(Box$3, { sx: { width: "100%" }, children: /* @__PURE__ */ jsxs(Paper$1, { sx: { width: "100%", mb: 2 }, children: [
    /* @__PURE__ */ jsx(EnhancedTableToolbar, { buttons, selected, staticButtons }),
    /* @__PURE__ */ jsx(TableContainer$1, { children: /* @__PURE__ */ jsxs(Table$1, { sx: { minWidth: 750 }, "aria-labelledby": "tableTitle", size: "medium", children: [
      /* @__PURE__ */ jsx(
        EnhancedTableHead,
        {
          attributes,
          numSelected: selected.length,
          order: order2,
          orderBy,
          onSelectAllClick: handleSelectAllClick,
          onRequestSort: handleRequestSort,
          rowCount: rows.length,
          checkVisible
        }
      ),
      /* @__PURE__ */ jsxs(TableBody$1, { children: [
        stableSort2(rows, getComparator(order2, orderBy)).slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage).map((row, index2) => {
          const isItemSelected = isSelected(row.id);
          const labelId = `enhanced-table-checkbox-${index2}`;
          return /* @__PURE__ */ jsxs(
            TableRow$1,
            {
              hover: true,
              onClick: (event) => {
                if (rowClick) {
                  rowClick(event, row.id);
                }
              },
              sx: { cursor: "pointer" },
              role: "checkbox",
              "aria-checked": isItemSelected,
              tabIndex: -1,
              selected: isItemSelected,
              children: [
                checkVisible ?? /* @__PURE__ */ jsx(
                  TableCell$1,
                  {
                    padding: "checkbox",
                    onClick: (event) => handleCheckboxClick(event, row.id),
                    children: /* @__PURE__ */ jsx(
                      Checkbox$1,
                      {
                        color: "primary",
                        checked: isItemSelected,
                        inputProps: {
                          "aria-labelledby": labelId
                        }
                      }
                    )
                  }
                ),
                attributes.map((attr) => /* @__PURE__ */ jsx(
                  TableCell$1,
                  {
                    align: "left",
                    sx: {
                      paddingTop: 1,
                      paddingBottom: 1,
                      ...attr.image && {
                        width: 130
                      }
                    },
                    children: attr.imageCustomElement ? attr.imageCustomElement(row) : attr.image ?? false ? /* @__PURE__ */ jsx(AspectRatio, { ratio: 16 / 9, children: row[attr.id] && /* @__PURE__ */ jsx(
                      "img",
                      {
                        style: { maxHeight: "100%", width: "100%", objectFit: "contain" },
                        src: ApiPath(String(row[attr.id]))
                      }
                    ) }) : String(
                      attr.customFormat ? attr.customFormat(row[attr.id]) : row[attr.id]
                    )
                  },
                  String(attr.id)
                ))
              ]
            },
            row.id
          );
        }),
        emptyRows > 0 && /* @__PURE__ */ jsx(
          TableRow$1,
          {
            style: {
              height: 90 * emptyRows
            },
            children: /* @__PURE__ */ jsx(TableCell$1, { colSpan: 6 })
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsx(
      TablePagination$1,
      {
        rowsPerPageOptions: [8, 25],
        component: "div",
        count: rows.length,
        rowsPerPage,
        page,
        onPageChange: handleChangePage,
        onRowsPerPageChange: handleChangeRowsPerPage
      }
    )
  ] }) });
}
var Add = {};
var _interopRequireDefault$9 = interopRequireDefaultExports;
Object.defineProperty(Add, "__esModule", {
  value: true
});
var default_1$9 = Add.default = void 0;
var _createSvgIcon$9 = _interopRequireDefault$9(requireCreateSvgIcon());
var _jsxRuntime$9 = require$$2;
var _default$9 = (0, _createSvgIcon$9.default)(/* @__PURE__ */ (0, _jsxRuntime$9.jsx)("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"
}), "Add");
default_1$9 = Add.default = _default$9;
function MyVideos() {
  var _a;
  const myVideosQuery = useMyVideosQuery();
  const navigate = useNavigate();
  const [statusText, setStatusText] = reactExports.useState();
  const [addToPlaylistDialogOpen, setAddToPlaylistDialogOpen] = reactExports.useState(false);
  const [selectedPlaylist, setSelectedPlaylist] = reactExports.useState();
  const [selectedIds, setSelectedIds] = reactExports.useState();
  const myPlaylistsQuery = useMyPlaylistsQuery();
  const attributes = [
    {
      id: "imageUrl",
      label: "URL obrzku",
      image: true
    },
    {
      id: "name",
      label: "Nzev"
    },
    {
      id: "description",
      label: "Popis"
    },
    {
      id: "duration",
      label: "Dlka"
    },
    {
      id: "uploadTimestamp",
      label: "Datum nahrn",
      customFormat: (value) => {
        return value.toLocaleString();
      }
    }
  ];
  const staticButtons = [
    {
      icon: /* @__PURE__ */ jsx(default_1$9, {}),
      label: "Nahrt video",
      onClick: () => navigate(`/${Route.upload}/`)
    }
  ];
  const buttons = [];
  buttons.push(
    {
      label: "Pidat do playlistu",
      icon: /* @__PURE__ */ jsx(default_1$k, {}),
      onClick: (_selectedIDs) => {
        setSelectedIds(_selectedIDs);
        setAddToPlaylistDialogOpen(true);
        setStatusText(void 0);
      }
    },
    {
      label: "Smazat",
      icon: /* @__PURE__ */ jsx(default_1$g, {}),
      onClick: (selectedIDs) => {
        setStatusText(void 0);
        const promises = Promise.all(selectedIDs.map((id2) => videosDELETE(id2)));
        promises.then(() => {
          myVideosQuery.refetch();
          setStatusText("Video spn smazn");
        }).catch(() => {
          setStatusText("Video se nepodailo smazat");
        });
      }
    }
  );
  const rowClick = (event, id2) => {
    navigate({
      pathname: `/${Route.videoEdit}/${id2}`
    });
  };
  const handleDialogClose = () => {
    setAddToPlaylistDialogOpen(false);
  };
  const handleAddToPlaylist = () => {
    if (!selectedIds || !selectedPlaylist) {
      return;
    }
    Promise.all(
      selectedIds.map((videoId) => video$1(selectedPlaylist, videoId, true))
    ).then(() => setStatusText("Videa byly spn pidny do playlistu")).catch(() => setStatusText("Videa se nepovedlo pidat do playlistu")).finally(() => handleDialogClose());
  };
  return /* @__PURE__ */ jsxs(Box$3, { margin: 4, children: [
    statusText && /* @__PURE__ */ jsx(Box$3, { mb: 1, children: /* @__PURE__ */ jsx(Alert$1, { severity: "info", children: statusText }) }),
    (myVideosQuery == null ? void 0 : myVideosQuery.data) && /* @__PURE__ */ jsx(
      EnhancedTable,
      {
        attributes,
        rows: myVideosQuery.data,
        orderBy: "uploadTimestamp",
        desc: "desc",
        buttons,
        rowClick,
        staticButtons
      }
    ),
    /* @__PURE__ */ jsxs(
      Dialog$1,
      {
        onClose: (e2) => {
          e2.stopPropagation();
          handleDialogClose();
        },
        open: addToPlaylistDialogOpen,
        fullWidth: true,
        maxWidth: "xs",
        children: [
          /* @__PURE__ */ jsx(DialogTitle$1, { children: "Pidat do playlistu" }),
          /* @__PURE__ */ jsx(DialogContent$1, { onClick: (e2) => e2.stopPropagation(), children: /* @__PURE__ */ jsx(FormControl$1, { fullWidth: true, children: /* @__PURE__ */ jsx(
            Select$1,
            {
              id: "addtoPlayList",
              onChange: (e2) => setSelectedPlaylist(e2.target.value),
              children: (_a = myPlaylistsQuery == null ? void 0 : myPlaylistsQuery.data) == null ? void 0 : _a.map((playlist) => {
                return /* @__PURE__ */ jsx(MenuItem$2, { value: playlist.id, children: playlist.name }, playlist.id);
              })
            }
          ) }) }),
          /* @__PURE__ */ jsxs(DialogActions$1, { children: [
            /* @__PURE__ */ jsx(Button$2, { onClick: handleDialogClose, children: "Zavt" }),
            /* @__PURE__ */ jsx(Button$2, { onClick: handleAddToPlaylist, children: "Pidat do playlistu" })
          ] })
        ]
      }
    )
  ] });
}
var Save = {};
var _interopRequireDefault$8 = interopRequireDefaultExports;
Object.defineProperty(Save, "__esModule", {
  value: true
});
var default_1$8 = Save.default = void 0;
var _createSvgIcon$8 = _interopRequireDefault$8(requireCreateSvgIcon());
var _jsxRuntime$8 = require$$2;
var _default$8 = (0, _createSvgIcon$8.default)(/* @__PURE__ */ (0, _jsxRuntime$8.jsx)("path", {
  d: "M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"
}), "Save");
default_1$8 = Save.default = _default$8;
var Restore = {};
var _interopRequireDefault$7 = interopRequireDefaultExports;
Object.defineProperty(Restore, "__esModule", {
  value: true
});
var default_1$7 = Restore.default = void 0;
var _createSvgIcon$7 = _interopRequireDefault$7(requireCreateSvgIcon());
var _jsxRuntime$7 = require$$2;
var _default$7 = (0, _createSvgIcon$7.default)(/* @__PURE__ */ (0, _jsxRuntime$7.jsx)("path", {
  d: "M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"
}), "Restore");
default_1$7 = Restore.default = _default$7;
const ListItem2 = styled$2("li")(({ theme: theme2 }) => ({
  margin: theme2.spacing(0.5)
}));
const ChipEditLine = reactExports.forwardRef(
  ({ chips: chipsProp, addChipHandle, deleteChipHandle }, ref) => {
    const pleaseSort = (a2, b2) => {
      return Number(b2.active) - Number(a2.active) || a2.label.localeCompare(b2.label);
    };
    const [chipData, setChipData] = reactExports.useState((chipsProp == null ? void 0 : chipsProp.sort(pleaseSort)) ?? []);
    const [addNewDialogOpen, setAddNewDialogOpen] = reactExports.useState(false);
    const addNewInputRef = reactExports.createRef();
    const [dialogError, setDialogError] = reactExports.useState(void 0);
    reactExports.useImperativeHandle(ref, () => ({
      getActiveChips() {
        return chipData.filter((x) => x.active);
      }
    }));
    reactExports.useEffect(() => {
      if (chipData.length === 0) {
        setChipData((chipsProp == null ? void 0 : chipsProp.sort(pleaseSort)) ?? []);
      }
    }, [chipsProp]);
    reactExports.useEffect(() => {
      if (addNewDialogOpen) {
        setTimeout(() => {
          var _a;
          (_a = addNewInputRef.current) == null ? void 0 : _a.focus();
        }, 300);
      }
    }, [addNewDialogOpen]);
    const handleDelete = (chipToDelete) => () => {
      setChipData(
        (chips) => chips.map((chip) => chip.key === chipToDelete.key ? { ...chip, active: false } : chip).sort(pleaseSort)
      );
    };
    const handleClick = (clickedChip) => () => {
      setChipData(
        (chips) => chips.map((chip) => chip.key === clickedChip.key ? { ...chip, active: true } : chip).sort(pleaseSort)
      );
    };
    const handleAddDialogOpen = () => {
      setAddNewDialogOpen(true);
    };
    const handleAddDialogClose = () => {
      setAddNewDialogOpen(false);
      setDialogError(void 0);
    };
    const handleAddDialogConfirm = async () => {
      var _a;
      if (!addNewInputRef.current) {
        setDialogError("Nebyl nalezen textov input.");
        return;
      }
      if (addNewInputRef.current.value === "") {
        setDialogError("Nelze pidat przdn tag.");
        return;
      }
      const newValue = (_a = addNewInputRef == null ? void 0 : addNewInputRef.current) == null ? void 0 : _a.value;
      if (chipData.filter((x) => x.label === newValue).length > 0) {
        setDialogError("Tag se stejnm nzvem ji existuje.");
        return;
      }
      setDialogError(void 0);
      try {
        await addChipHandle(newValue);
      } catch (error) {
        console.log(error);
        setAddNewDialogOpen(false);
        return;
      }
      setChipData(
        (chips) => [
          ...chips,
          {
            active: true,
            key: newValue,
            label: newValue,
            bgColor: GetRandomColor()
          }
        ].sort(pleaseSort)
      );
      setAddNewDialogOpen(false);
    };
    const onKeyDown = (e2) => {
      if (e2.key === "Enter") {
        handleAddDialogConfirm();
      }
    };
    return /* @__PURE__ */ jsxs(
      Paper$1,
      {
        variant: "outlined",
        sx: {
          display: "flex",
          flexWrap: "wrap",
          listStyle: "none",
          p: 0.5,
          m: 0
        },
        component: "ul",
        children: [
          chipData.map((data) => {
            return /* @__PURE__ */ jsx(ListItem2, { children: /* @__PURE__ */ jsx(
              CustomChip,
              {
                active: data.active,
                text: data.label,
                bgColor: data.bgColor,
                onDelete: data.active ? handleDelete(data) : void 0,
                onClick: data.active ? handleDelete(data) : handleClick(data),
                link: false
              }
            ) }, data.key);
          }),
          /* @__PURE__ */ jsx(ListItem2, { children: /* @__PURE__ */ jsx(CustomChip, { icon: /* @__PURE__ */ jsx(default_1$9, {}), onClick: handleAddDialogOpen, link: false }) }, "addButton"),
          /* @__PURE__ */ jsxs(
            Dialog$1,
            {
              open: addNewDialogOpen,
              onClose: () => {
                setAddNewDialogOpen(false);
              },
              disableEnforceFocus: true,
              children: [
                /* @__PURE__ */ jsx(DialogTitle$1, { children: "Pidn novho tagu" }),
                /* @__PURE__ */ jsx(DialogContent$1, { children: /* @__PURE__ */ jsx(
                  TextField$1,
                  {
                    margin: "dense",
                    id: "newTagName",
                    label: "Nzev novho tagu",
                    type: "text",
                    fullWidth: true,
                    variant: "standard",
                    error: !!dialogError,
                    helperText: dialogError,
                    inputRef: addNewInputRef,
                    onKeyDown
                  }
                ) }),
                /* @__PURE__ */ jsxs(DialogActions$1, { children: [
                  /* @__PURE__ */ jsx(Button$2, { onClick: handleAddDialogClose, children: "Zruit" }),
                  /* @__PURE__ */ jsx(Button$2, { onClick: handleAddDialogConfirm, children: "Pidat" })
                ] })
              ]
            }
          )
        ]
      }
    );
  }
);
const duration4 = (file) => {
  const video2 = document.createElement("video");
  video2.preload = "metadata";
  const onLoadedMetaDataPromise = new Promise((resolve) => {
    video2.onloadedmetadata = () => {
      window.URL.revokeObjectURL(video2.src);
      resolve(video2.duration);
      video2.remove();
    };
  });
  video2.src = window.URL.createObjectURL(file);
  return onLoadedMetaDataPromise;
};
const video = { duration: duration4 };
const nanoMetadata = {
  video
};
var functionThrottle = throttle2;
function throttle2(fn2, interval, options) {
  var timeoutId = null;
  var throttledFn = null;
  var leading = options && options.leading;
  var trailing = options && options.trailing;
  if (leading == null) {
    leading = true;
  }
  if (trailing == null) {
    trailing = !leading;
  }
  if (leading == true) {
    trailing = false;
  }
  var cancel = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  var flush3 = function() {
    var call = throttledFn;
    cancel();
    if (call) {
      call();
    }
  };
  var throttleWrapper = function() {
    var callNow = leading && !timeoutId;
    var context = this;
    var args = arguments;
    throttledFn = function() {
      return fn2.apply(context, args);
    };
    if (!timeoutId) {
      timeoutId = setTimeout(function() {
        timeoutId = null;
        if (trailing) {
          return throttledFn();
        }
      }, interval);
    }
    if (callNow) {
      callNow = false;
      return throttledFn();
    }
  };
  throttleWrapper.cancel = cancel;
  throttleWrapper.flush = flush3;
  return throttleWrapper;
}
const DEBUG_LOG_KEY = "__rpldy-logger-debug__";
const BATCH_STATES = {
  PENDING: "pending",
  ADDED: "added",
  PROCESSING: "processing",
  UPLOADING: "uploading",
  CANCELLED: "cancelled",
  FINISHED: "finished",
  ABORTED: "aborted",
  ERROR: "error"
};
const FILE_STATES = {
  PENDING: "pending",
  ADDED: "added",
  UPLOADING: "uploading",
  CANCELLED: "cancelled",
  FINISHED: "finished",
  ERROR: "error",
  ABORTED: "aborted"
};
const hasWindow = () => typeof window === "object" && !!window.document;
let isDebug = null;
const isDebugOn = () => {
  if (typeof isDebug !== "boolean") {
    isDebug = hasWindow() && ("location" in window && !!~window.location.search.indexOf("rpldy_debug=true") || window[DEBUG_LOG_KEY] === true);
  }
  return !!isDebug;
};
const setDebug = (debugOn) => {
  if (hasWindow()) {
    window[DEBUG_LOG_KEY] = debugOn;
  }
  isDebug = debugOn ? true : null;
};
const debugLog = function() {
  if (isDebugOn()) {
    console.log(...arguments);
  }
};
const triggerCancellable = function(trigger2, event) {
  const doTrigger = function(event2) {
    for (var _len2 = arguments.length, args2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args2[_key2 - 1] = arguments[_key2];
    }
    return new Promise((resolve, reject) => {
      const results = trigger2(event2, ...args2);
      if (results && results.length) {
        Promise.all(results).catch(reject).then((resolvedResults) => resolvedResults && resolve(!!~resolvedResults.findIndex((r3) => r3 === false)));
      } else {
        resolve(false);
      }
    });
  };
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  return event ? doTrigger(event, ...args) : doTrigger;
};
function isFunction(f2) {
  return typeof f2 === "function";
}
var isFunction_1 = isFunction;
const getPropsExtractor = (prop3) => {
  const props = [].concat(prop3);
  return (arr) => arr.map((i) => props.map((p2) => i[p2]).join());
};
const isSamePropInArrays = (arr1, arr2, prop3) => {
  let diff = true;
  const propsExtractor = getPropsExtractor(prop3);
  if (arr1 && arr2 && arr1.length === arr2.length) {
    const props1 = propsExtractor(arr1), props2 = propsExtractor(arr2);
    diff = !!props1.find((p2, i) => p2 !== props2[i]);
  }
  return !diff;
};
const devFreeze = (obj) => obj;
const isPlainObject$1 = (obj) => {
  var _Object$getPrototypeO;
  return !!obj && typeof obj === "object" && (((_Object$getPrototypeO = Object.getPrototypeOf(obj)) === null || _Object$getPrototypeO === void 0 ? void 0 : _Object$getPrototypeO.constructor.name) === "Object" || Object.getPrototypeOf(obj) === null);
};
const isMergeObj = (obj) => isPlainObject$1(obj) || Array.isArray(obj);
const getKeys = (obj, options) => {
  const keys3 = Object.keys(obj);
  return options.withSymbols ? keys3.concat(Object.getOwnPropertySymbols(obj)) : keys3;
};
const getMerge = function() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const merge3 = function(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }
    if (target && sources.length) {
      sources.forEach((source) => {
        if (source) {
          getKeys(source, options).forEach((key) => {
            const prop3 = source[key];
            if (!options.predicate || options.predicate(key, prop3)) {
              if (typeof prop3 !== "undefined" || options.undefinedOverwrites) {
                if (isMergeObj(prop3)) {
                  if (typeof target[key] === "undefined" || !isPlainObject$1(target[key])) {
                    target[key] = Array.isArray(prop3) ? [] : {};
                  }
                  merge3(target[key], prop3);
                } else {
                  target[key] = prop3;
                }
              }
            }
          });
        }
      });
    }
    return target;
  };
  return merge3;
};
const merge2 = getMerge();
const clone = function(obj) {
  let mergeFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : merge2;
  return isMergeObj(obj) ? mergeFn(Array.isArray(obj) ? [] : {}, obj) : obj;
};
const pick = (obj, props) => obj && Object.keys(obj).reduce((res, key) => {
  if (~props.indexOf(key)) {
    res[key] = obj[key];
  }
  return res;
}, {});
function isPromise(obj) {
  return !!obj && typeof obj === "object" && typeof obj.then === "function";
}
const supportsIdle = hasWindow() && window.requestIdleCallback;
const scheduler = supportsIdle ? window.requestIdleCallback : setTimeout;
const clear = supportsIdle ? window.cancelIdleCallback : clearTimeout;
const scheduleIdleWork = function(fn2) {
  let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const handler = scheduler(fn2, supportsIdle ? {
    timeout
  } : timeout);
  return () => clear(handler);
};
function isEmpty(val) {
  return val === null || val === void 0;
}
const triggerUpdater = function(trigger2, event) {
  const doTrigger = function(event2) {
    for (var _len2 = arguments.length, args2 = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args2[_key2 - 1] = arguments[_key2];
    }
    return new Promise((resolve, reject) => {
      const results = trigger2(event2, ...args2);
      if (results && results.length) {
        Promise.all(results).catch(reject).then((resolvedResults) => {
          let result;
          if (resolvedResults) {
            while (isEmpty(result) && resolvedResults.length) {
              result = resolvedResults.pop();
            }
          }
          resolve(isEmpty(result) ? void 0 : result);
        });
      } else {
        resolve();
      }
    });
  };
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  return event ? doTrigger(event, ...args) : doTrigger;
};
const BISYM = Symbol.for("__rpldy-bi__");
let iCounter = 0;
const getBatchItemWithUrl = (batchItem, url) => {
  batchItem.url = url;
  return batchItem;
};
const getBatchItemWithFile = (batchItem, file) => {
  batchItem.file = file;
  return batchItem;
};
const isLikeFile = (f2) => f2 && (f2 instanceof File || f2 instanceof Blob || !!(typeof f2 === "object" && f2.name && f2.type));
const getIsBatchItem = (obj) => {
  return !!(typeof obj === "object" && obj.id && obj.batchId && obj[BISYM] === true);
};
const createBatchItem = function(f2, batchId) {
  let isPending = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const isAlreadyBatchItem = getIsBatchItem(f2);
  iCounter += isAlreadyBatchItem ? 0 : 1;
  const id2 = isAlreadyBatchItem && f2.id && typeof f2.id === "string" ? f2.id : `${batchId}.item-${iCounter}`, state = isPending ? FILE_STATES.PENDING : FILE_STATES.ADDED;
  let batchItem = {
    id: id2,
    batchId,
    state,
    uploadStatus: 0,
    completed: 0,
    loaded: 0,
    recycled: isAlreadyBatchItem,
    // $FlowIssue[prop-missing] - flow just doesnt understand...
    previousBatch: isAlreadyBatchItem ? f2.batchId : null
  };
  Object.defineProperty(batchItem, BISYM, {
    value: true,
    //need writable to be able to keep prop when unwrapped from simple-state
    writable: true
  });
  const fileData = isAlreadyBatchItem ? f2.file || f2.url : f2;
  if (typeof fileData === "string") {
    batchItem = getBatchItemWithUrl(batchItem, fileData);
  } else if (isLikeFile(fileData)) {
    batchItem = getBatchItemWithFile(batchItem, fileData);
  } else {
    throw new Error(`Unknown type of file added: ${typeof fileData}`);
  }
  return batchItem;
};
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive$1(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
class XhrPromise extends Promise {
  constructor(fn2, req) {
    super(fn2);
    _defineProperty$1(this, "xhr", void 0);
    this.xhr = req;
  }
}
const setHeaders = (req, headers) => {
  if (headers) {
    Object.keys(headers).forEach((name) => {
      if (headers[name] !== void 0) {
        req.setRequestHeader(name, headers[name]);
      }
    });
  }
};
const request = function(url, data) {
  let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const req = new XMLHttpRequest();
  return new XhrPromise((resolve, reject) => {
    var _options$preSend;
    req.onerror = () => reject(req);
    req.ontimeout = () => reject(req);
    req.onabort = () => reject(req);
    req.onload = () => resolve(req);
    req.open((options === null || options === void 0 ? void 0 : options.method) || "GET", url);
    setHeaders(req, options === null || options === void 0 ? void 0 : options.headers);
    req.withCredentials = !!(options !== null && options !== void 0 && options.withCredentials);
    options === null || options === void 0 ? void 0 : (_options$preSend = options.preSend) === null || _options$preSend === void 0 ? void 0 : _options$preSend.call(options, req);
    req.send(data);
  }, req);
};
const parseResponseHeaders = (xhr) => {
  let resHeaders;
  try {
    resHeaders = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/).reduce((res, line2) => {
      const [key, val] = line2.split(": ");
      res[key] = val;
      return res;
    }, {});
  } catch (ex) {
    debugLog("uploady.request: failed to read response headers", xhr);
  }
  return resHeaders;
};
const defaults$1 = devFreeze({
  allowRegisterNonExistent: true,
  canAddEvents: true,
  canRemoveEvents: true,
  collectStats: false
});
const validateFunction = (f2, name) => {
  if (!isFunction_1(f2)) {
    throw new Error(`'${name}' is not a valid function`);
  }
};
const isUndefined = (val) => typeof val === "undefined";
const LESYM = Symbol.for("__le__");
const LE_PACK_SYM = Symbol.for("__le__pack__");
const getLE = (obj) => obj ? obj[LESYM] : null;
const getValidLE = (obj) => {
  const le2 = getLE(obj);
  if (!le2) {
    throw new Error("Didnt find LE internal object. Something very bad happened!");
  }
  return le2;
};
const isLE = (obj) => !!getLE(obj);
const addRegistration = function(obj, name, cb2) {
  let once = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  validateFunction(cb2, "cb");
  const le2 = getValidLE(obj);
  if (!le2.options.allowRegisterNonExistent && !~le2.events.indexOf(name)) {
    throw new Error(`Cannot register for event ${name.toString()} that wasn't already defined (allowRegisterNonExistent = false)`);
  }
  const namedRegistry = le2.registry[name] || [];
  if (!namedRegistry.find((r3) => r3.cb === cb2)) {
    namedRegistry.push({
      name,
      cb: cb2,
      once
    });
    le2.registry[name] = namedRegistry;
  }
  return () => unregister.call(obj, name, cb2);
};
const findRegistrations = (obj, name) => {
  const registry = getValidLE(obj).registry;
  return name ? registry[name] ? registry[name].slice() : [] : Object.values(registry).flat();
};
const publicMethods = {
  "on": register,
  "once": registerOnce,
  "off": unregister,
  "getEvents": getEvents
};
const getPublicMethods = () => Object.entries(publicMethods).reduce((res, _ref) => {
  let [key, m2] = _ref;
  res[key] = {
    value: m2
  };
  return res;
}, {});
const apiMethods = {
  "trigger": trigger,
  "addEvent": addEvent,
  "removeEvent": removeEvent,
  "hasEvent": hasEvent,
  "hasEventRegistrations": hasEventRegistrations,
  "assign": assign
};
const createApi = (target) => Object.keys(apiMethods).reduce((res, name) => {
  res[name] = apiMethods[name].bind(target);
  return res;
}, {
  target,
  ...apiMethods
});
const cleanRegistryForName = function(obj, name) {
  let force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const registry = getValidLE(obj).registry;
  if (registry[name] && (force || !registry[name].length)) {
    delete registry[name];
  }
};
const removeRegItem = (obj, name, cb2) => {
  const registry = getValidLE(obj).registry;
  if (registry[name]) {
    if (!cb2) {
      cleanRegistryForName(obj, name, true);
    } else {
      registry[name] = registry[name].filter((reg) => reg.cb !== cb2);
      cleanRegistryForName(obj, name);
    }
  }
};
function register(name, cb2) {
  return addRegistration(this, name, cb2);
}
function registerOnce(name, cb2) {
  return addRegistration(this, name, cb2, true);
}
function unregister(name, cb2) {
  removeRegItem(this, name, cb2);
}
function getEvents() {
  return getValidLE(this).events.slice();
}
function trigger(name) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  const regs = findRegistrations(this, name);
  let results;
  if (regs.length) {
    var _args$;
    let packValue;
    if (args.length === 1 && ((_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$[LE_PACK_SYM]) === true) {
      packValue = args[0].resolve();
    }
    results = regs.map((r3) => {
      let result;
      if (r3.once) {
        removeRegItem(this, name, r3.cb);
      }
      if (packValue) {
        result = r3.cb(...packValue);
      } else if (!args.length) {
        result = r3.cb();
      } else if (args.length === 1) {
        result = r3.cb(args[0]);
      } else if (args.length === 2) {
        result = r3.cb(args[0], args[1]);
      } else if (args.length === 3) {
        result = r3.cb(args[0], args[1], args[2]);
      } else {
        result = r3.cb(...args);
      }
      return result;
    }).filter((result) => !isUndefined(result)).map((result) => isPromise(result) ? result : Promise.resolve(result));
  }
  return results && (results.length ? results : void 0);
}
function assign(toObj) {
  const le2 = getValidLE(this);
  defineLifeData(toObj, le2.options, le2.events, le2.registry, le2.stats);
  return createApi(toObj);
}
function addEvent(name) {
  const le2 = getValidLE(this);
  if (le2.options.canAddEvents) {
    const index2 = le2.events.indexOf(name);
    if (!~index2) {
      le2.events.push(name);
    } else {
      throw new Error(`Event '${name}' already defined`);
    }
  } else {
    throw new Error("Cannot add new events (canAddEvents = false)");
  }
}
function removeEvent(name) {
  const le2 = getValidLE(this);
  if (le2.options.canRemoveEvents) {
    const index2 = le2.events.indexOf(name);
    le2.events.splice(index2, 1);
  } else {
    throw new Error("Cannot remove events (canRemoveEvents = false)");
  }
}
function hasEvent(name) {
  const le2 = getValidLE(this);
  return !!~le2.events.indexOf(name);
}
function hasEventRegistrations(name) {
  return !!findRegistrations(this, name).length;
}
const defineLifeData = function(target, options) {
  let events = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  let registry = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  let stats = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  Object.defineProperties(target, {
    // $FlowIssue[invalid-computed-prop] - https://github.com/facebook/flow/issues/3258
    [LESYM]: {
      value: Object.seal({
        registry,
        events,
        options,
        stats
      })
    },
    ...getPublicMethods()
  });
};
const addLife = function(target) {
  let events = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  let options = arguments.length > 2 ? arguments[2] : void 0;
  const useTarget = target || {};
  const usedOptions = {
    ...defaults$1,
    ...options
  };
  if (!isLE(useTarget)) {
    defineLifeData(useTarget, usedOptions, events);
  }
  return createApi(useTarget);
};
const createLifePack = (creator) => {
  const lp = {
    resolve: () => [].concat(creator())
  };
  Object.defineProperty(lp, LE_PACK_SYM, {
    value: true,
    configurable: false
  });
  return lp;
};
const fastAbortBatch = (batch2, aborts) => {
  batch2.items.forEach((_ref) => {
    var _aborts$id;
    let {
      id: id2
    } = _ref;
    return (_aborts$id = aborts[id2]) === null || _aborts$id === void 0 ? void 0 : _aborts$id.call(aborts);
  });
};
const fastAbortAll = (aborts) => {
  Object.values(aborts).forEach((fn2) => fn2());
};
const abortNonUploadingItem = (item, aborts, finalizeItem2) => {
  debugLog(`abort: aborting ${item.state} item  - `, item);
  finalizeItem2(item.id, {
    status: 0,
    state: FILE_STATES.ABORTED,
    response: "aborted"
  });
  return true;
};
const ITEM_STATE_ABORTS = {
  [FILE_STATES.UPLOADING]: (item, aborts) => {
    debugLog(`abort: aborting uploading item  - `, item);
    return aborts[item.id]();
  },
  [FILE_STATES.ADDED]: abortNonUploadingItem,
  [FILE_STATES.PENDING]: abortNonUploadingItem
};
const callAbortOnItem = (item, aborts, finalizeItem2) => {
  const itemState = item === null || item === void 0 ? void 0 : item.state;
  const method = !!itemState && //$FlowIssue[prop-missing]
  ITEM_STATE_ABORTS[itemState];
  return method ? (
    //$FlowExpectedError[extra-arg]
    method(item, aborts, finalizeItem2)
  ) : false;
};
const abortItem = (id2, items, aborts, finalizeItem2) => callAbortOnItem(items[id2], aborts, finalizeItem2);
const getIsFastAbortNeeded = (count2, threshold) => {
  let result = false;
  if (threshold !== 0 && threshold) {
    result = count2 >= threshold;
  }
  return result;
};
const abortAll2 = (items, aborts, queue, finalizeItem2, options) => {
  const itemIds = Object.values(queue).flat();
  const isFastAbort = getIsFastAbortNeeded(itemIds.length, options.fastAbortThreshold);
  debugLog(`abort: doing abort-all (${isFastAbort ? "fast" : "normal"} abort)`);
  if (isFastAbort) {
    fastAbortAll(aborts);
  } else {
    itemIds.forEach((id2) => abortItem(id2, items, aborts, finalizeItem2));
  }
  return {
    isFast: isFastAbort
  };
};
const abortBatch = (batch2, batchOptions, aborts, queue, finalizeItem2, options) => {
  const threshold = batchOptions.fastAbortThreshold === 0 ? 0 : batchOptions.fastAbortThreshold || options.fastAbortThreshold;
  const isFastAbort = getIsFastAbortNeeded(queue[batch2.id].length, threshold);
  debugLog(`abort: doing abort-batch on: ${batch2.id} (${isFastAbort ? "fast" : "normal"} abort)`);
  if (isFastAbort) {
    fastAbortBatch(batch2, aborts);
  } else {
    batch2.items.forEach((bi2) => callAbortOnItem(bi2, aborts, finalizeItem2));
  }
  return {
    isFast: isFastAbort
  };
};
const getAbortEnhancer = () => {
  return (uploader) => {
    uploader.update({
      abortAll: abortAll2,
      abortBatch,
      abortItem
    });
    return uploader;
  };
};
const setIsUpdateable = (proxy, value) => {
};
const unwrapProxy = (proxy) => proxy;
const createState = (obj) => {
  const proxy = obj;
  return {
    state: proxy,
    update: (fn2) => {
      try {
        setIsUpdateable(proxy, true);
        fn2(proxy);
      } finally {
      }
      return proxy;
    },
    unwrap: (entry) => entry ? (
      //simply clone the provided object (if its a proxy)
      unwrapProxy(entry)
    ) : (
      //unwrap entire proxy state
      proxy
    )
  };
};
const UPLOADER_EVENTS = devFreeze({
  BATCH_ADD: "BATCH-ADD",
  BATCH_START: "BATCH-START",
  BATCH_PROGRESS: "BATCH_PROGRESS",
  BATCH_FINISH: "BATCH-FINISH",
  BATCH_ABORT: "BATCH-ABORT",
  BATCH_CANCEL: "BATCH-CANCEL",
  BATCH_ERROR: "BATCH-ERROR",
  BATCH_FINALIZE: "BATCH-FINALIZE",
  ITEM_START: "FILE-START",
  ITEM_CANCEL: "FILE-CANCEL",
  ITEM_PROGRESS: "FILE-PROGRESS",
  ITEM_FINISH: "FILE-FINISH",
  ITEM_ABORT: "FILE-ABORT",
  ITEM_ERROR: "FILE-ERROR",
  ITEM_FINALIZE: "FILE-FINALIZE",
  REQUEST_PRE_SEND: "REQUEST_PRE_SEND",
  ALL_ABORT: "ALL_ABORT"
});
const PROGRESS_DELAY = 50;
const SENDER_EVENTS = devFreeze({
  ITEM_PROGRESS: "ITEM_PROGRESS",
  BATCH_PROGRESS: "BATCH_PROGRESS"
});
const ITEM_FINALIZE_STATES = [FILE_STATES.FINISHED, FILE_STATES.ERROR, FILE_STATES.CANCELLED, FILE_STATES.ABORTED];
const finalizeItem = function(queue, id2) {
  let delItem = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  queue.updateState((state) => {
    const {
      batchId
    } = state.items[id2] || {
      batchId: null
    };
    if (delItem) {
      delete state.items[id2];
    }
    const index2 = batchId ? state.itemQueue[batchId].indexOf(id2) : -1;
    if (~index2 && batchId) {
      state.itemQueue[batchId].splice(index2, 1);
    }
    const activeIndex = state.activeIds.indexOf(id2);
    if (~activeIndex) {
      state.activeIds.splice(activeIndex, 1);
    }
  });
};
const getIsItemExists = (queue, itemId) => !!queue.getState().items[itemId];
const getIsItemFinalized = (item) => ITEM_FINALIZE_STATES.includes(item.state);
const mergeWithUndefined$1 = getMerge({
  undefinedOverwrites: true
});
const processPrepareResponse = (eventType, items, options, updated) => {
  let usedOptions = options, usedItems = items;
  if (updated) {
    debugLog(`uploader.queue: REQUEST_PRE_SEND(${eventType}) event returned updated items/options`, updated);
    if (updated.items) {
      if (updated.items.length !== items.length || !isSamePropInArrays(updated.items, items, ["id", "batchId", "recycled"])) {
        throw new Error(`REQUEST_PRE_SEND(${eventType}) event handlers must return same items with same ids`);
      }
      usedItems = updated.items;
    }
    if (updated.options) {
      usedOptions = mergeWithUndefined$1({}, options, updated.options);
    }
  }
  return {
    items: usedItems,
    options: usedOptions,
    cancelled: updated === false
  };
};
const triggerItemsPrepareEvent = (queue, eventSubject, items, options, eventType, validateResponse) => triggerUpdater(queue.trigger, eventType, eventSubject, options).then((updated) => {
  validateResponse === null || validateResponse === void 0 ? void 0 : validateResponse(updated);
  return processPrepareResponse(eventType, items, options, updated);
});
const persistPrepareResponse = (queue, prepared) => {
  if (prepared.items[0] && queue.getState().batches[prepared.items[0].batchId]) {
    queue.updateState((state) => {
      prepared.items.forEach((i) => {
        if (!getIsItemFinalized(state.items[i.id])) {
          state.items[i.id] = i;
        }
      });
      state.batches[prepared.items[0].batchId].batchOptions = prepared.options;
    });
    const updatedState = queue.getState();
    prepared.items = prepared.items.map((item) => updatedState.items[item.id]);
    prepared.options = updatedState.batches[prepared.items[0].batchId].batchOptions;
  }
};
const prepareItems = (queue, subject, retrieveItemsFromSubject, createEventSubject, validateResponse, eventType) => {
  const items = retrieveItemsFromSubject(subject);
  const batchOptions = queue.getState().batches[items[0].batchId].batchOptions;
  const eventSubject = (createEventSubject === null || createEventSubject === void 0 ? void 0 : createEventSubject(subject, batchOptions)) || subject;
  return triggerItemsPrepareEvent(queue, eventSubject, items, batchOptions, eventType, validateResponse).then((prepared) => {
    if (!prepared.cancelled) {
      persistPrepareResponse(queue, prepared);
    }
    return prepared;
  });
};
const getItemsPrepareUpdater = function(eventType, retrieveItemsFromSubject) {
  let createEventSubject = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  let validateResponse = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return (queue, subject) => prepareItems(queue, subject, retrieveItemsFromSubject, createEventSubject, validateResponse, eventType);
};
const prepareBatchStartItems = getItemsPrepareUpdater(UPLOADER_EVENTS.BATCH_START, (batch2) => batch2.items, null, function() {
  let {
    batch: batch2
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    batch: false
  };
  if (batch2) {
    throw new Error(`BATCH_START event handlers cannot update batch data. Only items & options`);
  }
});
const BATCH_READY_STATES = [BATCH_STATES.ADDED, BATCH_STATES.PROCESSING, BATCH_STATES.UPLOADING];
const BATCH_FINISHED_STATES = [BATCH_STATES.ABORTED, BATCH_STATES.CANCELLED, BATCH_STATES.FINISHED, BATCH_STATES.ERROR];
const getBatchFromState = (state, id2) => state.batches[id2].batch;
const getBatch$1 = (queue, id2) => {
  return getBatchFromState(queue.getState(), id2);
};
const getBatchDataFromItemId = (queue, itemId) => {
  const state = queue.getState();
  const item = state.items[itemId];
  return state.batches[item.batchId];
};
const getBatchFromItemId = (queue, itemId) => {
  return getBatchDataFromItemId(queue, itemId).batch;
};
const removeBatchItems = (queue, batchId) => {
  const batch2 = getBatch$1(queue, batchId);
  batch2.items.forEach((_ref) => {
    let {
      id: id2
    } = _ref;
    return finalizeItem(queue, id2, true);
  });
};
const removeBatch = (queue, batchId) => {
  queue.updateState((state) => {
    delete state.batches[batchId];
    delete state.itemQueue[batchId];
    const batchQueueIndex = state.batchQueue.indexOf(batchId);
    if (~batchQueueIndex) {
      state.batchQueue.splice(batchQueueIndex, 1);
    }
    const pendingFlagIndex = state.batchesStartPending.indexOf(batchId);
    if (~pendingFlagIndex) {
      state.batchesStartPending.splice(pendingFlagIndex, 1);
    }
  });
};
const finalizeBatch = function(queue, batchId, eventType) {
  let finalState = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : BATCH_STATES.FINISHED;
  let additionalInfo = arguments.length > 4 ? arguments[4] : void 0;
  queue.updateState((state) => {
    const batch2 = getBatchFromState(state, batchId);
    batch2.state = finalState;
    if (additionalInfo) {
      batch2.additionalInfo = additionalInfo;
    }
  });
  triggerUploaderBatchEvent(queue, batchId, eventType);
  triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_FINALIZE);
};
const cancelBatchWithId = (queue, batchId) => {
  debugLog("uploady.uploader.batchHelpers: cancelling batch: ", batchId);
  finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_CANCEL, BATCH_STATES.CANCELLED);
  removeBatchItems(queue, batchId);
  removeBatch(queue, batchId);
};
const cancelBatchForItem = (queue, itemId) => {
  if (getIsItemExists(queue, itemId)) {
    const data = getBatchDataFromItemId(queue, itemId), batchId = data === null || data === void 0 ? void 0 : data.batch.id;
    if (batchId) {
      cancelBatchWithId(queue, batchId);
    } else {
      debugLog(`uploady.uploader.batchHelpers: cancel batch called for batch already removed (item id = ${itemId})`);
    }
  }
};
const failBatchForItem = (queue, itemId, err) => {
  const batch2 = getBatchFromItemId(queue, itemId), batchId = batch2.id;
  debugLog("uploady.uploader.batchHelpers: failing batch: ", {
    batch: batch2
  });
  finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_ERROR, BATCH_STATES.ERROR, err.message);
  removeBatchItems(queue, batchId);
  removeBatch(queue, batchId);
};
const isItemBatchStartPending = (queue, itemId) => {
  const batch2 = getBatchFromItemId(queue, itemId);
  return queue.getState().batchesStartPending.includes(batch2.id);
};
const isNewBatchStarting = (queue, itemId) => {
  const batch2 = getBatchFromItemId(queue, itemId);
  return queue.getState().currentBatch !== batch2.id;
};
const loadNewBatchForItem = (queue, itemId) => {
  const batch2 = getBatchFromItemId(queue, itemId);
  queue.updateState((state) => {
    state.batchesStartPending.push(batch2.id);
  });
  return prepareBatchStartItems(queue, batch2).then((_ref2) => {
    let {
      cancelled
    } = _ref2;
    let alreadyFinished = false;
    queue.updateState((state) => {
      const pendingFlagIndex = state.batchesStartPending.indexOf(batch2.id);
      state.batchesStartPending.splice(pendingFlagIndex, 1);
    });
    if (!cancelled) {
      alreadyFinished = !getIsItemExists(queue, itemId);
      if (!alreadyFinished) {
        queue.updateState((state) => {
          state.currentBatch = batch2.id;
        });
      }
    }
    return !cancelled && !alreadyFinished;
  });
};
const cleanUpFinishedBatches = (queue) => {
  scheduleIdleWork(() => {
    const state = queue.getState();
    Object.keys(state.batches).forEach((batchId) => {
      const {
        batch: batch2,
        finishedCounter
      } = state.batches[batchId];
      const {
        orgItemCount
      } = batch2;
      const alreadyFinalized = getIsBatchFinalized(batch2);
      if (orgItemCount === finishedCounter) {
        if (!alreadyFinalized && batch2.completed !== 100) {
          queue.updateState((state2) => {
            const batch3 = getBatchFromState(state2, batchId);
            batch3.completed = 100;
            batch3.loaded = batch3.items.reduce((res, _ref3) => {
              let {
                loaded
              } = _ref3;
              return res + loaded;
            }, 0);
          });
          triggerUploaderBatchEvent(queue, batchId, UPLOADER_EVENTS.BATCH_PROGRESS);
        }
        queue.updateState((state2) => {
          if (state2.currentBatch === batchId) {
            state2.currentBatch = null;
          }
        });
        debugLog(`uploady.uploader.batchHelpers: cleaning up batch: ${batch2.id}`);
        if (!alreadyFinalized) {
          finalizeBatch(queue, batchId, UPLOADER_EVENTS.BATCH_FINISH);
        }
        removeBatchItems(queue, batchId);
        removeBatch(queue, batchId);
      }
    });
  });
};
const triggerUploaderBatchEvent = (queue, batchId, event) => {
  const state = queue.getState(), batch2 = getBatchFromState(state, batchId), stateItems = state.items;
  const eventBatch = {
    ...unwrapProxy(batch2),
    items: batch2.items.map((_ref4) => {
      let {
        id: id2
      } = _ref4;
      return unwrapProxy(stateItems[id2]);
    })
  };
  queue.trigger(event, eventBatch);
};
const getIsBatchReady = (queue, batchId) => {
  const batch2 = getBatchFromState(queue.getState(), batchId);
  return BATCH_READY_STATES.includes(batch2.state);
};
const detachRecycledFromPreviousBatch = (queue, item) => {
  const {
    previousBatch
  } = item;
  if (item.recycled && previousBatch && queue.getState().batches[previousBatch]) {
    const {
      id: batchId
    } = getBatchFromItemId(queue, item.id);
    if (batchId === previousBatch) {
      queue.updateState((state) => {
        const batch2 = getBatchFromState(state, batchId);
        const index2 = batch2.items.findIndex((_ref5) => {
          let {
            id: id2
          } = _ref5;
          return id2 === item.id;
        });
        if (~index2) {
          batch2.items.splice(index2, 1);
        }
      });
    }
  }
};
const preparePendingForUpload = (queue, uploadOptions) => {
  queue.updateState((state) => {
    Object.keys(state.batches).forEach((batchId) => {
      const batchData = state.batches[batchId];
      const {
        batch: batch2,
        batchOptions
      } = batchData;
      if (batch2.state === BATCH_STATES.PENDING) {
        batch2.items.forEach((item) => {
          item.state = FILE_STATES.ADDED;
        });
        batch2.state = BATCH_STATES.ADDED;
        batchData.batchOptions = merge2({}, batchOptions, uploadOptions);
      }
    });
  });
};
const removePendingBatches = (queue) => {
  const batches = queue.getState().batches;
  Object.keys(batches).filter((batchId) => batches[batchId].batch.state === BATCH_STATES.PENDING).forEach((batchId) => {
    removeBatchItems(queue, batchId);
    removeBatch(queue, batchId);
  });
};
const incrementBatchFinishedCounter = (queue, batchId) => {
  queue.updateState((state) => {
    state.batches[batchId].finishedCounter += 1;
  });
};
const getIsBatchFinalized = (batch2) => BATCH_FINISHED_STATES.includes(batch2.state);
const clearBatchData = (queue, batchId) => {
  queue.updateState((state) => {
    const {
      items
    } = getBatchFromState(state, batchId);
    delete state.batches[batchId];
    delete state.itemQueue[batchId];
    const indx = state.batchQueue.indexOf(batchId);
    if (~indx) {
      state.batchQueue.splice(indx, 1);
    }
    if (state.currentBatch === batchId) {
      state.currentBatch = null;
    }
    items.forEach((_ref6) => {
      let {
        id: id2
      } = _ref6;
      delete state.items[id2];
      const activeIndex = state.activeIds.indexOf(id2);
      if (~activeIndex) {
        state.activeIds.splice(activeIndex, 1);
      }
    });
  });
};
const FILE_STATE_TO_EVENT_MAP = {
  [FILE_STATES.PENDING]: null,
  [FILE_STATES.ADDED]: UPLOADER_EVENTS.ITEM_START,
  [FILE_STATES.FINISHED]: UPLOADER_EVENTS.ITEM_FINISH,
  [FILE_STATES.ERROR]: UPLOADER_EVENTS.ITEM_ERROR,
  [FILE_STATES.CANCELLED]: UPLOADER_EVENTS.ITEM_CANCEL,
  [FILE_STATES.ABORTED]: UPLOADER_EVENTS.ITEM_ABORT,
  [FILE_STATES.UPLOADING]: UPLOADER_EVENTS.ITEM_PROGRESS
};
const getIsFinalized = (item) => !!~ITEM_FINALIZE_STATES.indexOf(item.state);
const processFinishedRequest = (queue, finishedData, next2) => {
  finishedData.forEach((itemData) => {
    const state = queue.getState();
    const {
      id: id2,
      info
    } = itemData;
    debugLog("uploader.processor.queue: request finished for item - ", {
      id: id2,
      info
    });
    if (state.items[id2]) {
      queue.updateState((state2) => {
        const item2 = state2.items[id2];
        item2.state = info.state;
        item2.uploadResponse = info.response;
        item2.uploadStatus = info.status;
        if (getIsFinalized(item2)) {
          delete state2.aborts[id2];
        }
      });
      const item = queue.getState().items[id2];
      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {
        queue.handleItemProgress(item, 100, item.file ? item.file.size : 0);
      }
      if (FILE_STATE_TO_EVENT_MAP[item.state]) {
        queue.trigger(FILE_STATE_TO_EVENT_MAP[item.state], item);
      }
      if (getIsFinalized(item)) {
        incrementBatchFinishedCounter(queue, item.batchId);
        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item);
      }
    }
    finalizeItem(queue, id2);
  });
  cleanUpFinishedBatches(queue);
  next2(queue);
};
const preparePreRequestItems = getItemsPrepareUpdater(UPLOADER_EVENTS.REQUEST_PRE_SEND, (items) => items, (items, options) => ({
  items,
  options
}));
const updateUploadingState = (queue, items, sendResult) => {
  queue.updateState((state) => {
    items.forEach((bi2) => {
      const item = state.items[bi2.id];
      item.state = FILE_STATES.UPLOADING;
      state.aborts[bi2.id] = sendResult.abort;
    });
  });
};
const sendAllowedItems = (queue, itemsSendData, next2) => {
  var _queue$getState$batch;
  const {
    items,
    options
  } = itemsSendData;
  const batch2 = (_queue$getState$batch = queue.getState().batches[items[0].batchId]) === null || _queue$getState$batch === void 0 ? void 0 : _queue$getState$batch.batch;
  if (batch2) {
    let sendResult;
    try {
      sendResult = queue.sender.send(items, batch2, options);
    } catch (ex) {
      debugLog(`uploader.queue: sender failed with unexpected error`, ex);
      sendResult = {
        request: Promise.resolve({
          status: 0,
          state: FILE_STATES.ERROR,
          response: ex.message
        }),
        abort: () => false,
        senderType: "exception-handler"
      };
    }
    const {
      request: request2
    } = sendResult;
    updateUploadingState(queue, items, sendResult);
    request2.then((requestInfo) => {
      const finishedData = items.map((item) => ({
        id: item.id,
        info: requestInfo
      }));
      processFinishedRequest(queue, finishedData, next2);
    });
  }
};
const reportCancelledItems = (queue, items, cancelledResults, next2) => {
  const cancelledItemsIds = cancelledResults.map((isCancelled, index2) => isCancelled ? items[index2].id : null).filter(Boolean);
  if (cancelledItemsIds.length) {
    const finishedData = cancelledItemsIds.map((id2) => ({
      id: id2,
      info: {
        status: 0,
        state: FILE_STATES.CANCELLED,
        response: "cancel"
      }
    }));
    processFinishedRequest(queue, finishedData, next2);
  }
  return !!cancelledItemsIds.length;
};
const reportPreparedError = (error, queue, items, next2) => {
  const finishedData = items.map((_ref) => {
    let {
      id: id2
    } = _ref;
    return {
      id: id2,
      info: {
        status: 0,
        state: FILE_STATES.ERROR,
        response: error
      }
    };
  });
  processFinishedRequest(queue, finishedData, next2);
};
const getAllowedItem = (id2, queue) => {
  const item = queue.getState().items[id2];
  return item && !getIsItemFinalized(item) ? item : void 0;
};
const processAllowedItems = (_ref2) => {
  let {
    allowedItems,
    cancelledResults,
    queue,
    items,
    ids,
    next: next2
  } = _ref2;
  const afterPreparePromise = allowedItems.length ? preparePreRequestItems(queue, allowedItems) : Promise.resolve();
  let finalCancelledResults = cancelledResults;
  return afterPreparePromise.catch((err) => {
    debugLog("uploader.queue: encountered error while preparing items for request", err);
    reportPreparedError(err, queue, items, next2);
  }).then((itemsSendData) => {
    let nextP;
    if (itemsSendData) {
      if (itemsSendData.cancelled) {
        finalCancelledResults = ids.map(() => true);
      } else {
        const hasAborted = itemsSendData.items.some((item) => getIsItemFinalized(item));
        if (!hasAborted) {
          sendAllowedItems(queue, {
            items: itemsSendData.items,
            options: itemsSendData.options
          }, next2);
        } else {
          debugLog("uploader.queue: send data contains aborted items - not sending");
        }
      }
    }
    if (!reportCancelledItems(queue, items, finalCancelledResults, next2)) {
      nextP = next2(queue);
    }
    return nextP;
  });
};
const processBatchItems = (queue, ids, next2) => {
  const state = queue.getState();
  let items = Object.values(state.items);
  items = items.filter((item) => (
    //ensure item was not finalized (ex: aborted) while waiting for async BATCH_START
    ids.includes(item.id) && !getIsItemFinalized(item)
  ));
  return Promise.all(items.map((i) => queue.runCancellable(UPLOADER_EVENTS.ITEM_START, i))).then((cancelledResults) => {
    let allowedItems = cancelledResults.map((isCancelled, index2) => isCancelled ? null : getAllowedItem(items[index2].id, queue)).filter(Boolean);
    return {
      allowedItems,
      cancelledResults,
      queue,
      items,
      ids,
      next: next2
    };
  }).then(processAllowedItems);
};
const getIsItemInActiveRequest = (queue, itemId) => {
  return queue.getState().activeIds.flat().includes(itemId);
};
const getIsItemReady = (item) => item.state === FILE_STATES.ADDED;
const findNextItemIndex = (queue) => {
  const state = queue.getState(), itemQueue = state.itemQueue, items = state.items;
  let nextItemId = null, batchIndex = 0, itemIndex = 0, batchId = state.batchQueue[batchIndex];
  while (batchId && !nextItemId) {
    if (getIsBatchReady(queue, batchId)) {
      nextItemId = itemQueue[batchId][itemIndex];
      while (nextItemId && (getIsItemInActiveRequest(queue, nextItemId) || !getIsItemReady(items[nextItemId]))) {
        itemIndex += 1;
        nextItemId = itemQueue[batchId][itemIndex];
      }
    }
    if (!nextItemId) {
      batchIndex += 1;
      batchId = state.batchQueue[batchIndex];
      itemIndex = 0;
    }
  }
  return nextItemId ? [batchId, itemIndex] : null;
};
const getNextIdGroup = (queue) => {
  const state = queue.getState(), itemQueue = state.itemQueue, [nextBatchId, nextItemIndex] = findNextItemIndex(queue) || [];
  let nextId = nextBatchId && ~nextItemIndex ? itemQueue[nextBatchId][nextItemIndex] : null, nextGroup;
  if (nextId) {
    const {
      batchOptions
    } = state.batches[nextBatchId], groupMax = batchOptions.maxGroupSize || 0;
    if (batchOptions.grouped && groupMax > 1) {
      const batchItems = state.itemQueue[nextBatchId];
      nextGroup = batchItems.slice(nextItemIndex, nextItemIndex + groupMax);
    } else {
      nextGroup = [nextId];
    }
  }
  return nextGroup;
};
const updateItemsAsActive = (queue, ids) => {
  queue.updateState((state) => {
    state.activeIds = state.activeIds.concat(ids);
  });
};
const processNextWithBatch = (queue, ids) => {
  let newBatchP;
  if (!isItemBatchStartPending(queue, ids[0])) {
    updateItemsAsActive(queue, ids);
    if (isNewBatchStarting(queue, ids[0])) {
      newBatchP = loadNewBatchForItem(queue, ids[0]).then((allowBatch) => {
        let cancelled = !allowBatch;
        if (cancelled) {
          cancelBatchForItem(queue, ids[0]);
          processNext(queue);
        }
        return cancelled;
      }).catch((err) => {
        debugLog("uploader.processor: encountered error while preparing batch for request", err);
        failBatchForItem(queue, ids[0], err);
        processNext(queue);
        return true;
      });
    } else {
      newBatchP = Promise.resolve(false);
    }
  } else {
    newBatchP = Promise.resolve(true);
  }
  return newBatchP;
};
const processNext = (queue) => {
  let processPromise;
  const ids = getNextIdGroup(queue);
  if (ids) {
    const currentCount = queue.getCurrentActiveCount(), {
      concurrent = false,
      maxConcurrent = 0
    } = queue.getOptions();
    if (!currentCount || concurrent && currentCount < maxConcurrent) {
      debugLog("uploader.processor: Processing next upload - ", {
        ids,
        currentCount
      });
      processPromise = processNextWithBatch(queue, ids).then((failedOrCancelled) => {
        if (!failedOrCancelled) {
          processBatchItems(queue, ids, processNext);
          if (concurrent) {
            processNext(queue);
          }
        }
      });
    }
  }
  return processPromise;
};
const getFinalizeAbortedItem = (queue) => (id2, data) => processFinishedRequest(queue, [{
  id: id2,
  info: data
}], processNext);
const processAbortItem = (queue, id2) => {
  const abortItemMethod = queue.getOptions().abortItem;
  browser(!!abortItemMethod, "Abort Item method not provided yet abortItem was called");
  const state = queue.getState();
  return abortItemMethod(id2, state.items, state.aborts, getFinalizeAbortedItem(queue));
};
const processAbortBatch = (queue, id2) => {
  const abortBatchMethod = queue.getOptions().abortBatch;
  browser(!!abortBatchMethod, "Abort Batch method not provided yet abortItem was called");
  const state = queue.getState(), batchData = state.batches[id2], batch2 = batchData === null || batchData === void 0 ? void 0 : batchData.batch;
  if (batch2 && !getIsBatchFinalized(batch2)) {
    finalizeBatch(queue, id2, UPLOADER_EVENTS.BATCH_ABORT, BATCH_STATES.ABORTED);
    const {
      isFast
    } = abortBatchMethod(batch2, batchData.batchOptions, state.aborts, state.itemQueue, getFinalizeAbortedItem(queue), queue.getOptions());
    if (isFast) {
      queue.clearBatchUploads(batch2.id);
    }
  }
};
const processAbortAll = (queue) => {
  const abortAllMethod = queue.getOptions().abortAll;
  browser(!!abortAllMethod, "Abort All method not provided yet abortAll was called");
  queue.trigger(UPLOADER_EVENTS.ALL_ABORT);
  const state = queue.getState();
  const {
    isFast
  } = abortAllMethod(state.items, state.aborts, state.itemQueue, getFinalizeAbortedItem(queue), queue.getOptions());
  if (isFast) {
    queue.clearAllUploads();
  }
};
const createUploaderQueue = (options, trigger2, cancellable, sender, uploaderId) => {
  const {
    state,
    update: update2
  } = createState({
    itemQueue: {},
    batchQueue: [],
    currentBatch: null,
    batchesStartPending: [],
    batches: {},
    items: {},
    activeIds: [],
    aborts: {}
  });
  const getState = () => state;
  const updateState = (updater) => {
    update2(updater);
  };
  const add3 = (item) => {
    if (state.items[item.id] && !item.recycled) {
      throw new Error(`Uploader queue conflict - item ${item.id} already exists`);
    }
    if (item.recycled) {
      detachRecycledFromPreviousBatch(queueState, item);
    }
    updateState((state2) => {
      state2.items[item.id] = item;
    });
  };
  const handleItemProgress = (item, completed, loaded) => {
    if (state.items[item.id]) {
      updateState((state2) => {
        const stateItem = state2.items[item.id];
        stateItem.loaded = loaded;
        stateItem.completed = completed;
      });
      trigger2(UPLOADER_EVENTS.ITEM_PROGRESS, getState().items[item.id]);
    }
  };
  sender.on(SENDER_EVENTS.ITEM_PROGRESS, handleItemProgress);
  sender.on(SENDER_EVENTS.BATCH_PROGRESS, (batch2) => {
    var _state$batches$batch$;
    const batchItems = (_state$batches$batch$ = state.batches[batch2.id]) === null || _state$batches$batch$ === void 0 ? void 0 : _state$batches$batch$.batch.items;
    if (batchItems) {
      const [completed, loaded] = batchItems.reduce((res, _ref2) => {
        let {
          id: id2
        } = _ref2;
        const {
          completed: completed2,
          loaded: loaded2
        } = state.items[id2];
        res[0] += completed2;
        res[1] += loaded2;
        return res;
      }, [0, 0]);
      updateState((state2) => {
        const stateBatch = state2.batches[batch2.id].batch;
        stateBatch.completed = completed / batchItems.length;
        stateBatch.loaded = loaded;
      });
      trigger2(UPLOADER_EVENTS.BATCH_PROGRESS, state.batches[batch2.id].batch);
    }
  });
  const queueState = {
    uploaderId,
    getOptions: () => options,
    getCurrentActiveCount: () => state.activeIds.length,
    getState,
    updateState,
    trigger: trigger2,
    runCancellable: function(name) {
      if (!isFunction_1(cancellable)) {
        throw new Error("Uploader queue - cancellable is of wrong type");
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return cancellable(name, ...args);
    },
    sender,
    handleItemProgress,
    clearAllUploads: () => {
      queueState.updateState((state2) => {
        state2.itemQueue = {};
        state2.batchQueue = [];
        state2.currentBatch = null;
        state2.batches = {};
        state2.items = {};
        state2.activeIds = [];
      });
    },
    clearBatchUploads: (batchId) => {
      scheduleIdleWork(() => {
        debugLog(`uploader.queue: started scheduled work to clear batch uploads (${batchId})`);
        if (getState().batches[batchId]) {
          clearBatchData(queueState, batchId);
        }
      });
    }
  };
  if (hasWindow() && isDebugOn()) {
    window[`__rpldy_${uploaderId}_queue_state`] = queueState;
  }
  return {
    updateState,
    getState: queueState.getState,
    runCancellable: queueState.runCancellable,
    uploadBatch: (batch2, batchOptions) => {
      if (batchOptions) {
        updateState((state2) => {
          state2.batches[batch2.id].batchOptions = batchOptions;
        });
      }
      processNext(queueState);
    },
    addBatch: (batch2, batchOptions) => {
      updateState((state2) => {
        state2.batches[batch2.id] = {
          batch: batch2,
          batchOptions,
          finishedCounter: 0
        };
        state2.batchQueue.push(batch2.id);
        state2.itemQueue[batch2.id] = batch2.items.map((_ref) => {
          let {
            id: id2
          } = _ref;
          return id2;
        });
      });
      batch2.items.forEach(add3);
      return getBatchFromState(state, batch2.id);
    },
    abortItem: function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return processAbortItem(queueState, ...args);
    },
    abortBatch: function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return processAbortBatch(queueState, ...args);
    },
    abortAll: function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return processAbortAll(queueState, ...args);
    },
    clearPendingBatches: () => {
      removePendingBatches(queueState);
    },
    uploadPendingBatches: (uploadOptions) => {
      preparePendingForUpload(queueState, uploadOptions);
      processNext(queueState);
    },
    cancelBatch: (batch2) => cancelBatchWithId(queueState, batch2.id)
  };
};
const XHR_SENDER_TYPE = "rpldy-sender";
class MissingUrlError extends Error {
  constructor(senderType) {
    super(`${senderType} didn't receive upload URL`);
    this.name = "MissingUrlError";
  }
}
const addToFormData = function(fd2, name) {
  for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    rest[_key - 2] = arguments[_key];
  }
  if ("set" in fd2) {
    fd2.set(name, ...rest);
  } else {
    if ("delete" in fd2) {
      fd2.delete(name);
    }
    fd2.append(name, ...rest);
  }
};
const getFormFileField = (fd2, items, options) => {
  const single = items.length === 1;
  items.forEach((item, i) => {
    const name = single ? options.paramName : isFunction_1(options.formatGroupParamName) ? options.formatGroupParamName(i, options.paramName) : `${options.paramName}[${i}]`;
    if (item.file) {
      addToFormData(fd2, name, item.file, item.file.name);
    } else if (item.url) {
      addToFormData(fd2, name, item.url);
    }
  });
};
const prepareFormData = (items, options) => {
  const fd2 = new FormData();
  if (options.params) {
    Object.entries(options.params).forEach((_ref) => {
      let [key, val] = _ref;
      if (options.formDataAllowUndefined || val !== void 0) {
        addToFormData(fd2, key, val);
      }
    });
  }
  getFormFileField(fd2, items, options);
  return fd2;
};
const SUCCESS_CODES = [200, 201, 202, 203, 204];
const getRequestData = (items, options) => {
  let data;
  if (options.sendWithFormData) {
    debugLog(`uploady.sender: sending ${items.length} item(s) as form data`);
    data = prepareFormData(items, options);
  } else {
    if (items.length > 1) {
      throw new Error(`XHR Sender - Request without form data can only contain 1 item. received ${items.length}`);
    }
    const item = items[0];
    debugLog(`uploady.sender: sending item ${item.id} as request body`);
    data = item.file || item.url;
  }
  return data;
};
const makeRequest = (items, url, options, onProgress, config2) => {
  let xhr;
  const data = config2 !== null && config2 !== void 0 && config2.getRequestData ? config2.getRequestData(items, options) : getRequestData(items, options);
  const issueRequest = function() {
    let requestUrl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : url;
    let requestData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : data;
    let requestOptions = arguments.length > 2 ? arguments[2] : void 0;
    const resolvedRequestOptions = merge2({
      ...pick(options, ["method", "headers", "withCredentials"]),
      preSend: (req) => {
        req.upload.onprogress = (e2) => {
          if (e2.lengthComputable && onProgress) {
            onProgress(e2, items.slice());
          }
        };
      }
    }, requestOptions);
    const realPXhr = request(requestUrl, requestData, resolvedRequestOptions);
    xhr = realPXhr.xhr;
    return realPXhr;
  };
  const pXhr = config2 !== null && config2 !== void 0 && config2.preRequestHandler ? config2.preRequestHandler(issueRequest, items, url, options, onProgress, config2) : issueRequest();
  return {
    url,
    count: items.length,
    pXhr,
    getXhr: () => xhr,
    aborted: false
  };
};
const parseResponseJson = (response, headers, options) => {
  let parsed = response;
  const ct = headers === null || headers === void 0 ? void 0 : headers["content-type"];
  if (options.forceJsonResponse || ct !== null && ct !== void 0 && ct.includes("json")) {
    try {
      parsed = JSON.parse(response);
    } catch {
    }
  }
  return parsed;
};
const checkIsResponseSuccessful = (xhr, options) => {
  const isSuccess = options.isSuccessfulCall ? options.isSuccessfulCall(xhr) : SUCCESS_CODES.includes(xhr.status);
  return isPromise(isSuccess) ? isSuccess : Promise.resolve(isSuccess);
};
const processResponse = (sendRequest, options) => sendRequest.pXhr.then((xhr) => {
  debugLog("uploady.sender: received upload response ", xhr);
  return checkIsResponseSuccessful(xhr, options).then((isSuccess) => {
    var _options$formatServer, _options$formatServer2;
    const state = isSuccess ? FILE_STATES.FINISHED : FILE_STATES.ERROR;
    const status = xhr.status;
    const resHeaders = parseResponseHeaders(xhr);
    const response = {
      data: (_options$formatServer = (_options$formatServer2 = options.formatServerResponse) === null || _options$formatServer2 === void 0 ? void 0 : _options$formatServer2.call(options, xhr.response, status, resHeaders)) !== null && _options$formatServer !== void 0 ? _options$formatServer : parseResponseJson(xhr.response, resHeaders, options),
      headers: resHeaders
    };
    return {
      status,
      state,
      response
    };
  });
}).catch((error) => {
  let state, response;
  if (sendRequest.aborted) {
    state = FILE_STATES.ABORTED;
    response = "aborted";
  } else {
    debugLog("uploady.sender: upload failed: ", error);
    state = FILE_STATES.ERROR;
    response = error;
  }
  return {
    error: true,
    state,
    response,
    status: 0
  };
});
const abortRequest = (sendRequest) => {
  let abortCalled = false;
  const {
    aborted,
    getXhr
  } = sendRequest;
  const xhr = getXhr();
  if (!aborted && xhr && xhr.readyState && xhr.readyState !== 4) {
    debugLog(`uploady.sender: cancelling request with ${sendRequest.count} items to: ${sendRequest.url}`);
    xhr.abort();
    sendRequest.aborted = true;
    abortCalled = true;
  }
  return abortCalled;
};
const getXhrSend = (config2) => (items, url, options, onProgress) => {
  if (!url) {
    throw new MissingUrlError(XHR_SENDER_TYPE);
  }
  debugLog("uploady.sender: sending file: ", {
    items,
    url,
    options
  });
  const sendRequest = makeRequest(items, url, options, onProgress, config2);
  return {
    request: processResponse(sendRequest, options),
    abort: () => abortRequest(sendRequest),
    senderType: XHR_SENDER_TYPE
  };
};
const send = getXhrSend();
const DEFAULT_PARAM_NAME = "file";
const DEFAULT_FILTER = () => true;
const DEFAULT_OPTIONS$1 = devFreeze({
  autoUpload: true,
  clearPendingOnAdd: false,
  inputFieldName: "file",
  concurrent: false,
  maxConcurrent: 2,
  grouped: false,
  maxGroupSize: 5,
  method: "POST",
  params: {},
  fileFilter: DEFAULT_FILTER,
  forceJsonResponse: false,
  withCredentials: false,
  destination: {},
  send: null,
  sendWithFormData: true,
  formDataAllowUndefined: false,
  fastAbortThreshold: 100
});
const reportItemsProgress = (items, completed, loaded, trigger2) => {
  items.forEach((item) => {
    debugLog(`uploady.uploader.processor: file: ${item.id} progress event: loaded(${loaded}) - completed(${completed})`);
    trigger2(SENDER_EVENTS.ITEM_PROGRESS, item, completed, loaded);
  });
};
const onItemUploadProgress = (items, batch2, e2, trigger2) => {
  const completed = Math.min(e2.loaded / e2.total * 100, 100), completedPerItem = completed / items.length, loadedAverage = e2.loaded / items.length;
  reportItemsProgress(items, completedPerItem, loadedAverage, trigger2);
  trigger2(SENDER_EVENTS.BATCH_PROGRESS, batch2);
};
const createBatchItemsSender = () => {
  const {
    trigger: trigger2,
    target: sender
  } = addLife({
    send: (items, batch2, batchOptions) => {
      const destination = batchOptions.destination, url = destination === null || destination === void 0 ? void 0 : destination.url;
      const throttledProgress = functionThrottle((e2) => onItemUploadProgress(items, batch2, e2, trigger2), PROGRESS_DELAY, true);
      const send$1 = isFunction_1(batchOptions.send) ? batchOptions.send : send;
      return send$1(items, url, {
        method: (destination === null || destination === void 0 ? void 0 : destination.method) || batchOptions.method || DEFAULT_OPTIONS$1.method,
        paramName: (destination === null || destination === void 0 ? void 0 : destination.filesParamName) || batchOptions.inputFieldName || DEFAULT_PARAM_NAME,
        params: {
          //TODO: might need to rethink the order here:
          ...batchOptions.params,
          ...destination === null || destination === void 0 ? void 0 : destination.params
        },
        forceJsonResponse: batchOptions.forceJsonResponse,
        withCredentials: batchOptions.withCredentials,
        formatGroupParamName: batchOptions.formatGroupParamName,
        headers: destination === null || destination === void 0 ? void 0 : destination.headers,
        sendWithFormData: batchOptions.sendWithFormData,
        formatServerResponse: batchOptions.formatServerResponse,
        formDataAllowUndefined: batchOptions.formDataAllowUndefined,
        isSuccessfulCall: batchOptions.isSuccessfulCall
      }, throttledProgress);
    }
  }, Object.values(SENDER_EVENTS));
  return sender;
};
const FILE_LIST_SUPPORT = hasWindow() && "FileList" in window;
const getMandatoryDestination = (dest) => {
  return {
    params: {},
    ...dest
  };
};
const getMandatoryOptions$1 = (options) => {
  return {
    ...DEFAULT_OPTIONS$1,
    ...options,
    destination: options && options.destination ? getMandatoryDestination(options.destination) : null
  };
};
const getIsFileList = (files) => (
  //in case files list was created in a different context(window) need to check toString
  FILE_LIST_SUPPORT && files instanceof FileList || files.toString() === "[object FileList]"
);
const deepProxyUnwrap = function(obj) {
  let result = obj;
  return result;
};
let bCounter = 0;
const processFiles = (batchId, files, isPending, fileFilter) => {
  const all2 = fileFilter ? Array.prototype.map.call(files, (f2) => getIsBatchItem(f2) ? f2.file || f2.url : f2) : (
    //in case no filter fn, no need to map it
    []
  );
  return Promise.all(Array.prototype.map.call(files, (f2, index2) => {
    const filterResult = (fileFilter || DEFAULT_FILTER)(all2[index2], index2, all2);
    return isPromise(filterResult) ? filterResult.then((result) => !!result && f2) : !!filterResult && f2;
  })).then((filtered) => filtered.filter(Boolean).map((f2) => createBatchItem(f2, batchId, isPending)));
};
const createBatch = (files, uploaderId, options) => {
  bCounter += 1;
  const id2 = `batch-${bCounter}`;
  const isFileList2 = getIsFileList(files);
  const usedFiles = Array.isArray(files) || isFileList2 ? files : [files];
  const isPending = !options.autoUpload;
  return processFiles(id2, usedFiles, isPending, options.fileFilter).then((items) => {
    return {
      id: id2,
      uploaderId,
      items,
      state: isPending ? BATCH_STATES.PENDING : BATCH_STATES.ADDED,
      completed: 0,
      loaded: 0,
      orgItemCount: items.length,
      additionalInfo: null
    };
  });
};
const createProcessor = (trigger2, cancellable, options, uploaderId) => {
  const sender = createBatchItemsSender(), queue = createUploaderQueue(options, trigger2, cancellable, sender, uploaderId);
  return {
    abortBatch: (batchId) => {
      queue.abortBatch(batchId);
    },
    abort: (id2) => {
      if (id2) {
        queue.abortItem(id2);
      } else {
        queue.abortAll();
      }
    },
    addNewBatch: (files, processOptions) => createBatch(files, uploaderId, processOptions).then((batch2) => {
      let resultP;
      if (batch2.items.length) {
        const addedBatch = queue.addBatch(batch2, processOptions);
        resultP = queue.runCancellable(UPLOADER_EVENTS.BATCH_ADD, addedBatch, processOptions).then((isCancelled) => {
          if (!isCancelled) {
            debugLog(`uploady.uploader [${uploaderId}]: new items added - auto upload =
                       ${String(processOptions.autoUpload)}`, addedBatch.items);
            if (processOptions.autoUpload) {
              queue.uploadBatch(addedBatch);
            }
          } else {
            queue.cancelBatch(addedBatch);
          }
          return addedBatch;
        });
      } else {
        debugLog(`uploady.uploader: no items to add. batch ${batch2.id} is empty. check fileFilter if this isn't intended`);
      }
      return resultP || Promise.resolve(null);
    }),
    clearPendingBatches: () => {
      queue.clearPendingBatches();
    },
    processPendingBatches: (uploadOptions) => {
      queue.uploadPendingBatches(uploadOptions);
    }
  };
};
const composeEnhancers$1 = function() {
  for (var _len = arguments.length, enhancers = new Array(_len), _key = 0; _key < _len; _key++) {
    enhancers[_key] = arguments[_key];
  }
  return function(uploader) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return enhancers.reduce((enhanced, e2) => e2(enhanced, ...args) || enhanced, uploader);
  };
};
const EVENT_NAMES = Object.values(UPLOADER_EVENTS);
const EXT_OUTSIDE_ENHANCER_TIME = "Uploady - uploader extensions can only be registered by enhancers", EXT_ALREADY_EXISTS = "Uploady - uploader extension by this name [%s] already exists";
let counter = 0;
const getComposedEnhancer = (extEnhancer) => composeEnhancers$1(getAbortEnhancer(), extEnhancer);
const getEnhancedUploader = (uploader, options, triggerWithUnwrap, setEnhancerTime) => {
  const enhancer = options.enhancer ? getComposedEnhancer(options.enhancer) : getAbortEnhancer();
  setEnhancerTime(true);
  const enhanced = enhancer(uploader, triggerWithUnwrap);
  setEnhancerTime(false);
  return enhanced || uploader;
};
const createUploader = (options) => {
  counter += 1;
  const uploaderId = `uploader-${counter}`;
  let enhancerTime = false;
  const extensions = {};
  debugLog(`uploady.uploader: creating new instance (${uploaderId})`, {
    options,
    counter
  });
  let uploaderOptions = getMandatoryOptions$1(options);
  const clearPending = () => {
    processor.clearPendingBatches();
  };
  const getOptions2 = () => {
    return clone(uploaderOptions);
  };
  let {
    trigger: trigger2,
    target: uploader
  } = addLife({
    id: uploaderId,
    update: (updateOptions) => {
      uploaderOptions = merge2({}, uploaderOptions, updateOptions);
      return uploader;
    },
    add: (files, addOptions) => {
      const processOptions = merge2({}, uploaderOptions, addOptions);
      if (processOptions.clearPendingOnAdd) {
        clearPending();
      }
      return processor.addNewBatch(files, processOptions).then(() => {
        debugLog(`uploady.uploader: finished adding file data to be processed`);
      });
    },
    upload: (uploadOptions) => {
      processor.processPendingBatches(uploadOptions);
    },
    abort: (id2) => {
      processor.abort(id2);
    },
    abortBatch: (id2) => {
      processor.abortBatch(id2);
    },
    getOptions: getOptions2,
    clearPending,
    registerExtension: (name, methods) => {
      browser(enhancerTime, EXT_OUTSIDE_ENHANCER_TIME);
      browser(!extensions[name], EXT_ALREADY_EXISTS, name);
      debugLog(`uploady.uploader: registering extension: ${name.toString()}`, methods);
      extensions[name] = methods;
    },
    getExtension: (name) => {
      return extensions[name];
    }
  }, EVENT_NAMES, {
    canAddEvents: false,
    canRemoveEvents: false
  });
  const triggerWithUnwrap = function(name) {
    for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      data[_key - 1] = arguments[_key];
    }
    const lp = createLifePack(() => data.map(deepProxyUnwrap));
    return trigger2(name, lp);
  };
  const cancellable = triggerCancellable(triggerWithUnwrap);
  const enhancedUploader = getEnhancedUploader(uploader, uploaderOptions, triggerWithUnwrap, (state) => {
    enhancerTime = state;
  });
  const processor = createProcessor(triggerWithUnwrap, cancellable, uploaderOptions, enhancedUploader.id);
  return devFreeze(enhancedUploader);
};
const GLOBAL_VERSION_SYM = Symbol.for("_rpldy-version_");
const getVersion = () => "1.4.1";
const getGlobal = () => (
  /* istanbul ignore next */
  // $FlowIgnore
  hasWindow() ? window : globalThis || process
);
const getRegisteredVersion = () => {
  return getGlobal()[GLOBAL_VERSION_SYM];
};
const registerUploadyContextVersion = () => {
  getGlobal()[GLOBAL_VERSION_SYM] = getVersion();
};
const getIsVersionRegisteredAndDifferent = () => {
  const registeredVersion = getRegisteredVersion();
  return !!registeredVersion && registeredVersion !== getVersion();
};
const UploadyContext = /* @__PURE__ */ React.createContext(null);
const NO_INPUT_ERROR_MSG = "Uploady - Context. File input isn't available";
const createContextApi = (uploader, internalInputRef) => {
  let fileInputRef, showFileUploadOptions;
  let isUsingExternalInput = false;
  if (internalInputRef) {
    fileInputRef = internalInputRef;
  } else {
    debugLog("Uploady context - didn't receive input field ref - waiting for external ref");
  }
  const getInputField = () => {
    var _fileInputRef;
    return (_fileInputRef = fileInputRef) === null || _fileInputRef === void 0 ? void 0 : _fileInputRef.current;
  };
  const getInternalFileInput = () => {
    if (fileInputRef) {
      isUsingExternalInput = true;
    }
    return fileInputRef;
  };
  const getIsUsingExternalInput = () => isUsingExternalInput;
  const onFileInputChange = () => {
    const input = getInputField();
    browser(input, NO_INPUT_ERROR_MSG);
    input.removeEventListener("change", onFileInputChange);
    const addOptions = showFileUploadOptions;
    showFileUploadOptions = null;
    upload(input.files, addOptions);
  };
  const upload = (files, addOptions) => {
    uploader.add(files, addOptions);
  };
  registerUploadyContextVersion();
  return {
    hasUploader: () => !!uploader,
    getInternalFileInput,
    setExternalFileInput: (extRef) => {
      isUsingExternalInput = true;
      fileInputRef = extRef;
    },
    getIsUsingExternalInput,
    showFileUpload: (addOptions) => {
      const input = getInputField();
      browser(input, NO_INPUT_ERROR_MSG);
      showFileUploadOptions = addOptions;
      input.removeEventListener("change", onFileInputChange);
      input.addEventListener("change", onFileInputChange);
      input.value = "";
      input.click();
    },
    upload,
    processPending: (uploadOptions) => {
      uploader.upload(uploadOptions);
    },
    clearPending: () => {
      uploader.clearPending();
    },
    setOptions: (options) => {
      uploader.update(options);
    },
    getOptions: () => {
      return uploader.getOptions();
    },
    getExtension: (name) => {
      return uploader.getExtension(name);
    },
    abort: (itemId) => {
      uploader.abort(itemId);
    },
    abortBatch: (batchId) => {
      uploader.abortBatch(batchId);
    },
    on: (name, cb2) => {
      return uploader.on(name, cb2);
    },
    once: (name, cb2) => {
      return uploader.once(name, cb2);
    },
    off: (name, cb2) => {
      return uploader.off(name, cb2);
    }
  };
};
const ERROR_MSG = "Uploady - Valid UploadyContext not found. Make sure you render inside <Uploady>";
const DIFFERENT_VERSION_ERROR_MSG = `Uploady - Valid UploadyContext not found.
You may be using packages of different Uploady versions. <Uploady> and all other packages using the context provider must be of the same version: %s`;
const assertContext = (context) => {
  browser(!getIsVersionRegisteredAndDifferent(), DIFFERENT_VERSION_ERROR_MSG, getRegisteredVersion());
  browser(context && context.hasUploader(), ERROR_MSG);
  return context;
};
const useUploadyContext = () => assertContext(reactExports.useContext(UploadyContext));
const useEventEffect = (event, fn2) => {
  const context = useUploadyContext();
  const {
    on: on3,
    off: off2
  } = context;
  reactExports.useEffect(() => {
    on3(event, fn2);
    return () => {
      off2(event, fn2);
    };
  }, [event, fn2, on3, off2]);
};
const generateUploaderEventHookWithState = (event, stateCalculator) => (fn2, id2) => {
  const [eventState, setEventState] = reactExports.useState(null);
  let cbFn = fn2;
  let usedId = id2;
  if (fn2 && !isFunction_1(fn2)) {
    usedId = fn2;
    cbFn = void 0;
  }
  const eventCallback = reactExports.useCallback(function(eventObj) {
    if (!usedId || eventObj.id === usedId) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      setEventState(stateCalculator(eventObj, ...args));
      if (isFunction_1(cbFn)) {
        cbFn(eventObj, ...args);
      }
    }
  }, [cbFn, usedId]);
  useEventEffect(event, eventCallback);
  return eventState;
};
const generateUploaderEventHook = function(event) {
  let canScope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  return (fn2, id2) => {
    const eventCallback = reactExports.useCallback(function(eventObj) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return fn2 && (!canScope || !id2 || eventObj.id === id2) ? fn2(eventObj, ...args) : void 0;
    }, [fn2, id2]);
    useEventEffect(event, eventCallback);
  };
};
const useBatchAddListener = generateUploaderEventHook(UPLOADER_EVENTS.BATCH_ADD, false);
generateUploaderEventHook(UPLOADER_EVENTS.BATCH_START);
generateUploaderEventHook(UPLOADER_EVENTS.BATCH_FINISH);
generateUploaderEventHook(UPLOADER_EVENTS.BATCH_CANCEL);
generateUploaderEventHook(UPLOADER_EVENTS.BATCH_ERROR);
generateUploaderEventHook(UPLOADER_EVENTS.BATCH_FINALIZE);
generateUploaderEventHook(UPLOADER_EVENTS.BATCH_ABORT);
generateUploaderEventHookWithState(UPLOADER_EVENTS.BATCH_PROGRESS, (batch2) => ({
  ...batch2
}));
generateUploaderEventHook(UPLOADER_EVENTS.ITEM_START);
const useItemFinishListener = generateUploaderEventHook(UPLOADER_EVENTS.ITEM_FINISH);
generateUploaderEventHook(UPLOADER_EVENTS.ITEM_CANCEL);
const useItemErrorListener = generateUploaderEventHook(UPLOADER_EVENTS.ITEM_ERROR);
generateUploaderEventHook(UPLOADER_EVENTS.ITEM_ABORT);
generateUploaderEventHook(UPLOADER_EVENTS.ITEM_FINALIZE);
generateUploaderEventHookWithState(UPLOADER_EVENTS.ITEM_PROGRESS, (item) => ({
  ...item
}));
generateUploaderEventHook(UPLOADER_EVENTS.REQUEST_PRE_SEND, false);
generateUploaderEventHook(UPLOADER_EVENTS.ALL_ABORT, false);
const UPLOAD_OPTIONS_COMP = Symbol.for("rpldy_component");
const markAsUploadOptionsComponent = (Component2) => {
  Component2[UPLOAD_OPTIONS_COMP] = true;
};
const useUploader = (options, listeners) => {
  const uploader = reactExports.useMemo(
    () => {
      debugLog("Uploady creating a new uploader instance", options);
      return createUploader(options);
    },
    //dont recreate the uploader when options changed - we do update later
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [options.enhancer]
  );
  uploader.update(options);
  reactExports.useEffect(() => {
    if (listeners) {
      debugLog("Uploady setting event listeners", listeners);
      Object.entries(listeners).forEach((_ref) => {
        let [name, m2] = _ref;
        uploader.on(name, m2);
      });
    }
    return () => {
      if (listeners) {
        debugLog("Uploady removing event listeners", listeners);
        Object.entries(listeners).forEach((_ref2) => {
          let [name, m2] = _ref2;
          return uploader.off(name, m2);
        });
      }
    };
  }, [listeners, uploader]);
  return uploader;
};
const NoDomUploady = (props) => {
  const {
    listeners,
    debug,
    children,
    inputRef,
    ...uploadOptions
  } = props;
  setDebug(!!debug);
  debugLog("@@@@@@ Uploady Rendering @@@@@@", props);
  const uploader = useUploader(uploadOptions, listeners);
  const api = reactExports.useMemo(() => createContextApi(uploader, inputRef), [uploader, inputRef]);
  return /* @__PURE__ */ React.createElement(UploadyContext.Provider, {
    value: api
  }, children);
};
const useUploadOptions = (options) => {
  const context = useUploadyContext();
  if (options) {
    context.setOptions(options);
  }
  return context.getOptions();
};
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
const createRequestUpdateHoc = (_ref) => {
  let {
    eventType,
    getIsValidEventData,
    getRequestData: getRequestData2
  } = _ref;
  return (Component2) => (props) => {
    const context = useUploadyContext();
    const [updater, setUpdater] = reactExports.useState({
      updateRequest: null,
      requestData: null
    });
    const {
      id: id2
    } = props;
    reactExports.useLayoutEffect(() => {
      const handleEvent = function() {
        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
          params[_key] = arguments[_key];
        }
        return getIsValidEventData(id2, ...params) === true ? (
          //returning a promise to event dispatcher so it will await until its resolved by user-land code
          new Promise((resolve) => {
            setUpdater({
              updateRequest: (data) => {
                context.off(eventType, handleEvent);
                resolve(data);
              },
              requestData: getRequestData2(...params)
            });
          })
        ) : (
          //returning false for invalid data will cancel the request so must return undefined!
          void 0
        );
      };
      if (id2) {
        context.on(eventType, handleEvent);
      }
      return () => {
        if (id2) {
          context.off(eventType, handleEvent);
        }
      };
    }, [context, id2]);
    return /* @__PURE__ */ React.createElement(Component2, _extends$4({}, props, updater));
  };
};
createRequestUpdateHoc({
  eventType: UPLOADER_EVENTS.REQUEST_PRE_SEND,
  getIsValidEventData: (id2, _ref) => {
    let {
      items
    } = _ref;
    return !!items.find((item) => item.id === id2);
  },
  getRequestData: (_ref2) => {
    let {
      items,
      options
    } = _ref2;
    return {
      items,
      options
    };
  }
});
createRequestUpdateHoc({
  eventType: UPLOADER_EVENTS.BATCH_START,
  getIsValidEventData: (id2, batch2) => batch2.id === id2,
  getRequestData: (batch2, batchOptions) => ({
    batch: batch2,
    items: batch2.items,
    options: batchOptions
  })
});
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
const NO_CONTAINER_ERROR_MSG = "Uploady - Container for file input must be a valid dom element";
const renderInput = (inputProps, instanceOptions, ref) => /* @__PURE__ */ React.createElement("input", _extends$3({}, inputProps, {
  name: instanceOptions.inputFieldName,
  type: "file",
  ref
}));
const renderInPortal = (container2, isValidContainer, inputProps, instanceOptions, ref) => container2 && isValidContainer ? /* @__PURE__ */ ReactDOM.createPortal(renderInput(inputProps, instanceOptions, ref), container2) : null;
const FileInputField = /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef((_ref, ref) => {
  let {
    container: container2,
    noPortal,
    ...inputProps
  } = _ref;
  const instanceOptions = useUploadOptions();
  const isValidContainer = container2 && container2.nodeType === 1;
  browser(isValidContainer || !hasWindow(), NO_CONTAINER_ERROR_MSG);
  return noPortal ? renderInput(inputProps, instanceOptions, ref) : renderInPortal(container2, isValidContainer, inputProps, instanceOptions, ref);
}));
const Uploady = (props) => {
  const {
    multiple = true,
    capture,
    accept,
    webkitdirectory,
    children,
    inputFieldContainer,
    customInput,
    fileInputId,
    noPortal = false,
    ...noDomProps
  } = props;
  const container2 = !customInput ? inputFieldContainer || (hasWindow() ? document.body : null) : null;
  const internalInputFieldRef = reactExports.useRef();
  return /* @__PURE__ */ React.createElement(NoDomUploady, _extends$3({}, noDomProps, {
    inputRef: internalInputFieldRef
  }), !customInput ? /* @__PURE__ */ React.createElement(FileInputField, {
    container: container2,
    multiple,
    capture,
    accept,
    webkitdirectory: webkitdirectory === null || webkitdirectory === void 0 ? void 0 : webkitdirectory.toString(),
    style: {
      display: "none"
    },
    ref: internalInputFieldRef,
    id: fileInputId,
    noPortal
  }) : null, children);
};
const DEFAULT_OPTIONS = devFreeze({
  chunked: true,
  chunkSize: 5242880,
  retries: 0,
  parallel: 1
});
const getMandatoryOptions = (options) => merge2({}, DEFAULT_OPTIONS, options);
let sliceMethod = null;
const isChunkingSupported = () => {
  sliceMethod = null;
  if (hasWindow() && "Blob" in window) {
    sliceMethod = Blob.prototype.slice || // $FlowIssue[prop-missing] flow doesnt know webkitSlice
    Blob.prototype.webkitSlice || // $FlowIssue[prop-missing] flow doesnt know mozSlice
    Blob.prototype.mozSlice;
  }
  return !!sliceMethod;
};
const CHUNKING_SUPPORT = isChunkingSupported();
const getChunkDataFromFile = (file, start3, end2) => {
  var _sliceMethod;
  const blob = (_sliceMethod = sliceMethod) === null || _sliceMethod === void 0 ? void 0 : _sliceMethod.call(file, start3, end2, file.type);
  if (blob) {
    blob.name = file.name;
    blob.lastModified = file.lastModified;
  }
  return blob;
};
class ChunkedSendError extends Error {
  constructor(message) {
    super(message);
    this.name = "ChunkedSendError";
  }
}
const getChunks = function(item, options) {
  let startByte = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const {
    chunkSize
  } = options;
  const size = startByte ? item.file.size - startByte : item.file.size;
  if (size <= 0) {
    throw new ChunkedSendError(`start byte ${startByte} is invalid. File size: ${item.file.size}`);
  }
  const count2 = size <= chunkSize ? 1 : Math.ceil(size / chunkSize);
  return new Array(count2).fill(null).map((n2, index2) => {
    const start3 = chunkSize * index2 + (startByte || 0);
    return {
      id: `${item.id}_chunk-${index2}`,
      start: start3,
      end: Math.min(start3 + chunkSize, item.file.size),
      data: null,
      attempt: 0,
      uploaded: 0,
      index: index2
    };
  });
};
const CHUNK_EVENTS = devFreeze({
  CHUNK_START: "CHUNK_START",
  CHUNK_FINISH: "CHUNK_FINISH"
});
const CHUNKED_SENDER_TYPE = "rpldy-chunked-sender";
const handleChunkRequest = (chunkedState, item, chunkId, chunkSendResult, trigger2, onProgress) => {
  chunkedState.updateState((state) => {
    state.requests[chunkId] = {
      id: chunkId,
      abort: chunkSendResult.abort
    };
  });
  return chunkSendResult.request.then((result) => {
    debugLog(`chunkedSender: request finished for chunk: ${chunkId} - `, result);
    chunkedState.updateState((state) => {
      delete state.requests[chunkId];
    });
    const chunks = chunkedState.getState().chunks;
    const index2 = chunks.findIndex((c2) => c2.id === chunkId);
    if (~index2) {
      if (result.state === FILE_STATES.FINISHED) {
        const finishedChunk = chunks[index2];
        chunkedState.updateState((state) => {
          state.chunks = state.chunks.slice(0, index2).concat(state.chunks.slice(index2 + 1));
        });
        const chunkSize = finishedChunk.end - finishedChunk.start;
        onProgress({
          loaded: chunkSize,
          total: item.file.size
        }, [finishedChunk]);
        trigger2(CHUNK_EVENTS.CHUNK_FINISH, {
          chunk: pick(finishedChunk, ["id", "start", "end", "index", "attempt"]),
          item: unwrapProxy(item),
          uploadData: result
        });
      } else if (result.state !== FILE_STATES.ABORTED) {
        chunkedState.updateState((state) => {
          state.chunks[index2].attempt += 1;
        });
      }
      chunkedState.updateState((state) => {
        state.responses.push(result.response);
      });
    }
  });
};
const getChunksToSend = (chunkedState) => {
  const state = chunkedState.getState();
  const chunks = [], inProgressIds = Object.keys(state.requests), parallel = state.parallel || 1;
  for (let i = 0; i < state.chunks.length && inProgressIds.length < parallel && chunks.length < parallel; i++) {
    const chunk = state.chunks[i];
    if (!inProgressIds.includes(chunk.id)) {
      if (!chunk.attempt || chunk.attempt < state.retries) {
        chunks.push(chunk);
      } else {
        throw new ChunkedSendError("chunk failure");
      }
    }
  }
  return chunks;
};
const getContentRangeValue = (chunk, data, item) => data && `bytes ${chunk.start}-${chunk.start + data.size - 1}/${item.file.size}`;
const mergeWithUndefined = getMerge({
  undefinedOverwrites: true
});
const getSkippedResult = () => ({
  request: Promise.resolve({
    state: FILE_STATES.FINISHED,
    response: "skipping chunk as instructed by CHUNK_START handler",
    status: 200
  }),
  abort: () => true,
  //passthrough type
  senderType: "chunk-skipped-sender"
});
const uploadChunkWithUpdatedData = (chunk, chunkedState, item, onProgress, trigger2) => {
  const state = chunkedState.getState();
  const unwrappedOptions = unwrapProxy(state.sendOptions);
  const sendOptions = {
    ...unwrappedOptions,
    headers: {
      ...unwrappedOptions.headers,
      "Content-Range": getContentRangeValue(chunk, chunk.data, item)
    }
  };
  const chunkItem = createBatchItem(chunk.data, chunk.id);
  const onChunkProgress = (e2) => {
    onProgress(e2, [chunk]);
  };
  const chunkIndex = state.chunks.indexOf(chunk);
  return triggerUpdater(trigger2, CHUNK_EVENTS.CHUNK_START, {
    item: unwrapProxy(item),
    chunk: pick(chunk, ["id", "start", "end", "index", "attempt"]),
    chunkItem: {
      ...chunkItem
    },
    sendOptions,
    url: state.url,
    chunkIndex,
    remainingCount: state.chunks.length,
    totalCount: state.chunkCount,
    //TODO: should expose chunk_progress event instead of passing callback like this
    onProgress
  }).then((updatedData) => {
    const skipChunk = updatedData === false;
    if (skipChunk) {
      debugLog(`chunkedSender.sendChunk: received false from CHUNK_START handler - skipping chunk ${chunkIndex}, item ${item.id}`);
    }
    return skipChunk ? getSkippedResult() : send([chunkItem], (updatedData === null || updatedData === void 0 ? void 0 : updatedData.url) || state.url, mergeWithUndefined({}, sendOptions, updatedData === null || updatedData === void 0 ? void 0 : updatedData.sendOptions), onChunkProgress);
  });
};
const sendChunk = (chunk, chunkedState, item, onProgress, trigger2) => {
  if (!chunk.data) {
    chunkedState.updateState(() => {
      chunk.data = getChunkDataFromFile(item.file, chunk.start, chunk.end);
    });
  }
  if (!chunk.data) {
    throw new ChunkedSendError("chunk failure - failed to slice");
  }
  const url = chunkedState.getState().url;
  debugLog(`chunkedSender.sendChunk: about to send chunk ${chunk.id} [${chunk.start}-${chunk.end}] to: ${url || ""}`);
  const chunkXhrRequest = uploadChunkWithUpdatedData(chunk, chunkedState, item, onProgress, trigger2);
  return {
    request: chunkXhrRequest.then((_ref2) => {
      let {
        request: request2
      } = _ref2;
      return request2;
    }),
    abort: () => {
      chunkXhrRequest.then((_ref) => {
        let {
          abort: abort2
        } = _ref;
        return abort2();
      });
      return true;
    },
    //this type isnt relevant because it isnt exposed
    senderType: "chunk-passthrough-sender"
  };
};
const resolveOnError = (resolve, ex) => {
  if (ex instanceof ChunkedSendError) {
    resolve({
      state: FILE_STATES.ERROR,
      response: "At least one chunk failed"
    });
  } else {
    resolve({
      state: FILE_STATES.ERROR,
      response: ex.message
    });
  }
};
const finalizeOnFinish = (chunkedState, item, resolve, status) => {
  chunkedState.updateState((state) => {
    state.finished = true;
  });
  resolve({
    state: status,
    response: {
      results: chunkedState.getState().responses
    }
  });
};
const resolveOnAllChunksFinished = (chunkedState, item, resolve) => {
  const state = chunkedState.getState();
  const finished = !state.chunks.length;
  if (state.aborted) {
    debugLog(`chunkedSender: chunked upload aborted for item: ${item.id}`);
    finalizeOnFinish(chunkedState, item, resolve, FILE_STATES.ABORTED);
  } else if (finished && !state.error) {
    debugLog(`chunkedSender: chunked upload finished for item: ${item.id}`, state.responses);
    finalizeOnFinish(chunkedState, item, resolve, FILE_STATES.FINISHED);
  }
  return finished || state.error;
};
const handleChunk = (chunkedState, item, onProgress, chunkResolve, chunk, trigger2) => new Promise((resolve, reject) => {
  try {
    const chunkSendResult = sendChunk(chunk, chunkedState, item, onProgress, trigger2);
    handleChunkRequest(chunkedState, item, chunk.id, chunkSendResult, trigger2, onProgress).then(() => {
      resolve();
      if (!resolveOnAllChunksFinished(chunkedState, item, chunkResolve)) {
        sendChunks(chunkedState, item, onProgress, chunkResolve, trigger2);
      }
    });
  } catch (ex) {
    reject(ex);
  }
});
const sendChunks = (chunkedState, item, onProgress, resolve, trigger2) => {
  const state = chunkedState.getState();
  if (!state.finished && !state.aborted) {
    const inProgress = Object.keys(state.requests).length;
    if (!inProgress || state.parallel && state.parallel > inProgress) {
      let chunks;
      try {
        chunks = getChunksToSend(chunkedState);
      } catch (ex) {
        resolveOnError(resolve, ex);
      }
      if (chunks) {
        chunks.forEach((chunk) => {
          handleChunk(chunkedState, item, onProgress, resolve, chunk, trigger2).catch((ex) => {
            chunkedState.updateState((state2) => {
              state2.error = true;
            });
            resolveOnError(resolve, ex);
          });
        });
      }
    }
  }
};
const processChunkProgressData = (chunkedState, item, chunkId, chunkUploaded) => {
  chunkedState.updateState((state2) => {
    state2.uploaded[chunkId] = Math.max(chunkUploaded, state2.uploaded[chunkId] || 0);
  });
  const state = chunkedState.getState();
  const loadedSum = Object.keys(state.uploaded).reduce(
    (res, id2) => res + state.uploaded[id2],
    //we start from the offset of the first chunk to get an accurate progress on resumed uploads
    state.startByte
  );
  const total = item.file.size;
  return {
    loaded: Math.min(loadedSum, total),
    total
  };
};
const getChunkedState = (chunks, url, sendOptions, chunkedOptions) => {
  const {
    state,
    update: update2
  } = createState({
    finished: false,
    aborted: false,
    error: false,
    uploaded: {},
    requests: {},
    responses: [],
    chunkCount: chunks.length,
    startByte: sendOptions.startByte || 0,
    chunks,
    url,
    sendOptions,
    ...chunkedOptions
  });
  return {
    getState: () => state,
    updateState: (updater) => {
      update2(updater);
    }
  };
};
const abortChunkedRequest = (chunkedState, item) => {
  debugLog(`chunkedSender: aborting chunked upload for item: ${item.id}`);
  const state = chunkedState.getState();
  if (!state.finished && !state.aborted) {
    Object.keys(state.requests).forEach((chunkId) => {
      debugLog(`chunkedSender: aborting chunk: ${chunkId}`);
      state.requests[chunkId].abort();
    });
    chunkedState.updateState((state2) => {
      state2.aborted = true;
    });
  }
  return state.aborted;
};
const process$1 = (chunkedState, item, onProgress, trigger2) => {
  const onChunkProgress = (e2, chunks) => {
    const progressData = processChunkProgressData(chunkedState, item, chunks[0].id, e2.loaded);
    onProgress(progressData, [item]);
  };
  const sendPromise = new Promise((resolve) => {
    sendChunks(chunkedState, item, onChunkProgress, resolve, trigger2);
  });
  return {
    sendPromise,
    abort: () => abortChunkedRequest(chunkedState, item)
  };
};
const processChunks = (item, chunkedOptions, url, sendOptions, onProgress, trigger2) => {
  const chunks = getChunks(item, chunkedOptions, sendOptions.startByte);
  const chunkedState = getChunkedState(chunks, url, sendOptions, chunkedOptions);
  debugLog(`chunkedSender: created ${chunks.length} chunks for: ${item.file.name}`);
  const {
    sendPromise,
    abort: abort2
  } = process$1(chunkedState, item, onProgress, trigger2);
  return {
    request: sendPromise,
    abort: abort2,
    senderType: CHUNKED_SENDER_TYPE
  };
};
const createChunkedSender = (chunkedOptions, trigger2) => {
  const options = getMandatoryOptions(chunkedOptions);
  return {
    send: (items, url, sendOptions, onProgress) => {
      let result;
      if (!options.chunked || items.length > 1 || items[0].url || !items[0].file.size) {
        result = send(items, url, sendOptions, onProgress);
        debugLog(`chunkedSender: sending items as normal, un-chunked requests`);
      } else {
        debugLog(`chunkedSender: sending file as a chunked request`);
        result = processChunks(items[0], options, url, sendOptions, onProgress, trigger2);
      }
      return result;
    }
  };
};
const getChunkedEnhancer = (options) => {
  return (uploader, trigger2) => {
    const sender = createChunkedSender(options, trigger2);
    debugLog("chunkedSenderEnhancer: Created chunked-sender instance with options: ", options);
    uploader.update({
      send: sender.send
    });
    return uploader;
  };
};
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
const getEnhancer = (options, enhancer) => {
  const chunkedEnhancer = getChunkedEnhancer(options);
  return enhancer ? composeEnhancers$1(chunkedEnhancer, enhancer) : chunkedEnhancer;
};
const ChunkedUploady = (props) => {
  const {
    chunked,
    chunkSize,
    retries,
    parallel,
    ...uploadyProps
  } = props;
  const enhancer = reactExports.useMemo(() => CHUNKING_SUPPORT ? getEnhancer({
    chunked,
    chunkSize,
    retries,
    parallel
  }, props.enhancer) : void 0, [props.enhancer, chunked, chunkSize, retries, parallel]);
  return /* @__PURE__ */ React.createElement(Uploady, _extends$2({}, uploadyProps, {
    enhancer
  }));
};
const useChunkStartListener = generateUploaderEventHook(CHUNK_EVENTS.CHUNK_START, false);
generateUploaderEventHook(CHUNK_EVENTS.CHUNK_FINISH, false);
var Autorenew = {};
var _interopRequireDefault$6 = interopRequireDefaultExports;
Object.defineProperty(Autorenew, "__esModule", {
  value: true
});
var default_1$6 = Autorenew.default = void 0;
var _createSvgIcon$6 = _interopRequireDefault$6(requireCreateSvgIcon());
var _jsxRuntime$6 = require$$2;
var _default$6 = (0, _createSvgIcon$6.default)(/* @__PURE__ */ (0, _jsxRuntime$6.jsx)("path", {
  d: "M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"
}), "Autorenew");
default_1$6 = Autorenew.default = _default$6;
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
const asUploadButton = (Component2) => {
  const AsUploadButton = (props, ref) => {
    const {
      showFileUpload
    } = useUploadyContext();
    const {
      id: id2,
      className,
      text,
      children,
      extraProps,
      onClick,
      ...uploadOptions
    } = props;
    const uploadOptionsRef = reactExports.useRef();
    uploadOptionsRef.current = uploadOptions;
    const onButtonClick = reactExports.useCallback((e2) => {
      showFileUpload(uploadOptionsRef.current);
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
    }, [showFileUpload, uploadOptionsRef, onClick]);
    return /* @__PURE__ */ React.createElement(Component2, _extends$1({
      ref,
      onClick: onButtonClick,
      id: id2,
      className,
      children: children || text || "Upload"
    }, extraProps));
  };
  markAsUploadOptionsComponent(AsUploadButton);
  return /* @__PURE__ */ reactExports.forwardRef(AsUploadButton);
};
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
asUploadButton(/* @__PURE__ */ reactExports.forwardRef((props, ref) => /* @__PURE__ */ React.createElement("button", _extends({
  ref
}, props))));
var FileUpload = {};
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(FileUpload, "__esModule", {
  value: true
});
var default_1$5 = FileUpload.default = void 0;
var _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon());
var _jsxRuntime$5 = require$$2;
var _default$5 = (0, _createSvgIcon$5.default)(/* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
  d: "M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"
}), "FileUpload");
default_1$5 = FileUpload.default = _default$5;
function FileUploadWithPreview({
  uploadedFile,
  setUploadedFile,
  existingImageUrl,
  readOnly,
  additionalButtons
}) {
  const [imagePreview, setImagePreview] = reactExports.useState();
  const handleChange = (e2) => {
    var _a, _b;
    if (((_b = (_a = e2.target) == null ? void 0 : _a.files) == null ? void 0 : _b.length) === 1) {
      setUploadedFile(e2.target.files[0]);
    }
  };
  const handleDelete = () => {
    setUploadedFile(void 0);
  };
  reactExports.useEffect(() => {
    if (uploadedFile) {
      setImagePreview(URL.createObjectURL(uploadedFile));
    } else {
      setImagePreview(void 0);
    }
  }, [uploadedFile]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(AspectRatio, { ratio: 16 / 9, sx: { border: "1px solid #30BCED", borderRadius: "6px" }, children: /* @__PURE__ */ jsx(
      "img",
      {
        width: "100%",
        style: { maxHeight: "100%", objectFit: "contain" },
        src: imagePreview ?? existingImageUrl
      }
    ) }),
    !readOnly && /* @__PURE__ */ jsxs(Box$3, { display: "flex", justifyContent: "center", gap: 2, padding: 2, children: [
      /* @__PURE__ */ jsxs(Button$2, { component: "label", startIcon: /* @__PURE__ */ jsx(default_1$5, {}), variant: "outlined", children: [
        /* @__PURE__ */ jsx("input", { hidden: true, accept: "image/*", type: "file", onChange: handleChange }),
        "Nahrt"
      ] }),
      /* @__PURE__ */ jsx(IconButton$1, { onClick: handleDelete, color: "error", children: /* @__PURE__ */ jsx(default_1$g, {}) }),
      (additionalButtons == null ? void 0 : additionalButtons.length) && additionalButtons.map((b2) => {
        return reactExports.cloneElement(b2);
      })
    ] })
  ] });
}
var Clear = {};
var _interopRequireDefault$4 = interopRequireDefaultExports;
Object.defineProperty(Clear, "__esModule", {
  value: true
});
var default_1$4 = Clear.default = void 0;
var _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon());
var _jsxRuntime$4 = require$$2;
var _default$4 = (0, _createSvgIcon$4.default)(/* @__PURE__ */ (0, _jsxRuntime$4.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Clear");
default_1$4 = Clear.default = _default$4;
function MyChannelsDropdown({ channels, defaultValue, required = false }) {
  const [value, setValue] = reactExports.useState(
    defaultValue ?? ((channels == null ? void 0 : channels.length) === 1 ? channels[0].id : "")
  );
  return /* @__PURE__ */ jsx(
    TextField$1,
    {
      fullWidth: true,
      name: "channelSelect",
      select: ((channels == null ? void 0 : channels.length) ?? 0) > 0,
      required,
      label: "Kanl",
      value,
      onChange: (newValue) => {
        setValue(newValue.target.value);
      },
      InputProps: {
        endAdornment: /* @__PURE__ */ jsx(
          IconButton$1,
          {
            sx: { display: value ? void 0 : "none", marginRight: "8px" },
            onClick: () => setValue(void 0),
            children: /* @__PURE__ */ jsx(default_1$4, {})
          }
        )
      },
      children: channels == null ? void 0 : channels.map((channel) => /* @__PURE__ */ jsx(MenuItem$2, { value: channel.id, children: channel.name }, channel.id))
    }
  );
}
var lib = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getVideoDurationFromVideoFile = exports.generateVideoThumbnailViaUrl = exports.getVideoCover = exports.generateVideoThumbnails = exports.importFileandPreview = void 0;
  const importFileandPreview = (file, revoke) => {
    return new Promise((resolve, reject) => {
      window.URL = window.URL || window.webkitURL;
      let preview = window.URL.createObjectURL(file);
      if (revoke) {
        window.URL.revokeObjectURL(preview);
      }
      setTimeout(() => {
        resolve(preview);
      }, 100);
    });
  };
  exports.importFileandPreview = importFileandPreview;
  const generateVideoThumbnails = async (videoFile, numberOfThumbnails, type2) => {
    let thumbnail = [];
    let fractions = [];
    return type2 !== "url" ? new Promise(async (resolve, reject) => {
      var _a;
      if (!((_a = videoFile.type) === null || _a === void 0 ? void 0 : _a.includes("video")))
        reject("not a valid video file");
      await (0, exports.getVideoDurationFromVideoFile)(videoFile).then(async (duration5) => {
        for (let i = 0; i <= duration5; i += duration5 / numberOfThumbnails) {
          fractions.push(Math.floor(i));
        }
        let promiseArray = fractions.map((time2, index2) => getVideoThumbnail(videoFile, index2 >= fractions.length - 1 ? time2 - 2 : time2));
        await Promise.all(promiseArray).then((res) => {
          res.forEach((res2) => {
            thumbnail.push(res2);
          });
          resolve(thumbnail);
        }).catch((err) => {
          reject(err);
        }).finally(() => resolve(thumbnail));
      }).catch((err) => {
        reject(err);
      });
      reject("something went wrong");
    }) : new Promise(async (resolve, reject) => {
      await (0, exports.getVideoDurationFromVideoFile)(videoFile).then(async (duration5) => {
        console.log("duration", duration5);
        for (let i = 0; i <= duration5; i += duration5 / numberOfThumbnails) {
          fractions.push(Math.floor(i));
        }
        let promiseArray = fractions.map((time2, index2) => getVideoThumbnail(videoFile, index2 >= fractions.length - 1 ? time2 - 2 : time2));
        await Promise.all(promiseArray).then((res) => {
          res.forEach((res2) => {
            thumbnail.push(res2);
          });
          resolve(thumbnail);
        }).catch((err) => {
          reject(err);
        }).finally(() => resolve(thumbnail));
      });
      reject("something went wrong");
    });
  };
  exports.generateVideoThumbnails = generateVideoThumbnails;
  const getVideoThumbnail = (file, videoTimeInSeconds) => {
    return new Promise((resolve, reject) => {
      var _a;
      if ((_a = file === null || file === void 0 ? void 0 : file.type) === null || _a === void 0 ? void 0 : _a.match("video")) {
        (0, exports.importFileandPreview)(file).then((urlOfFIle) => {
          (0, exports.getVideoCover)(urlOfFIle, videoTimeInSeconds).then((res) => {
            resolve(res);
          });
        });
      } else if (file) {
        (0, exports.getVideoCover)(file, videoTimeInSeconds).then((res) => {
          resolve(res);
        }).catch((err) => {
          reject(err);
        });
      } else {
        reject("file not valid");
      }
    });
  };
  const getVideoCover = (urlOfFIle, seekTo = 0) => {
    return new Promise((resolve, reject) => {
      try {
        const videoPlayer = document.createElement("video");
        videoPlayer.setAttribute("src", urlOfFIle);
        videoPlayer.crossOrigin = "Anonymous";
        videoPlayer.load();
        videoPlayer.addEventListener("error", (ex) => {
          reject(`error when loading video file ${ex}`);
        });
        videoPlayer.addEventListener("loadedmetadata", () => {
          if (videoPlayer.duration < seekTo) {
            reject("video is too short.");
            return;
          }
          setTimeout(() => {
            videoPlayer.currentTime = seekTo;
          }, 200);
          videoPlayer.addEventListener("seeked", () => {
            const canvas = document.createElement("canvas");
            canvas.width = videoPlayer.videoWidth;
            canvas.height = videoPlayer.videoHeight;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);
            ctx.canvas.toBlob((blob) => {
              var reader = new FileReader();
              reader.readAsDataURL(blob);
              reader.onloadend = function() {
                var base64data = reader.result;
                resolve(base64data);
              };
            }, "image/jpeg", 1);
          });
        });
      } catch (error) {
        reject(error);
      }
    });
  };
  exports.getVideoCover = getVideoCover;
  const generateVideoThumbnailViaUrl = (urlOfFIle, videoTimeInSeconds) => {
    return new Promise((resolve, reject) => {
      try {
        var video2 = document.createElement("video");
        var timeupdate = function() {
          if (snapImage()) {
            video2.removeEventListener("timeupdate", timeupdate);
            video2.pause();
          }
        };
        video2.addEventListener("loadeddata", function() {
          try {
            if (snapImage()) {
              video2.removeEventListener("timeupdate", timeupdate);
            }
          } catch (error) {
            reject(error);
          }
        });
        var snapImage = function() {
          var canvas = document.createElement("canvas");
          canvas.width = video2.videoWidth;
          canvas.height = video2.videoHeight;
          canvas.getContext("2d").drawImage(video2, 0, 0, canvas.width, canvas.height);
          var image = canvas.toBlob((blob) => {
            var reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onloadend = function() {
              var base64data = reader.result;
              resolve(base64data);
            };
          }, "image/jpeg", 1);
          var success = (image === null || image === void 0 ? void 0 : image.length) > 1e5;
          if (success) {
            URL.revokeObjectURL(urlOfFIle);
            resolve(image);
          }
          return success;
        };
        video2.addEventListener("timeupdate", timeupdate);
        video2.preload = "metadata";
        video2.src = urlOfFIle;
        video2.muted = true;
        video2.playsInline = true;
        video2.crossOrigin = "Anonymous";
        video2.currentTime = videoTimeInSeconds;
        video2.play().then().catch((err) => {
          reject({ status: 500, reason: `Access to video at ${urlOfFIle} from origin ${window.location.hostname} has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.`, message: err });
        });
      } catch (error) {
        reject(error);
      }
    });
  };
  exports.generateVideoThumbnailViaUrl = generateVideoThumbnailViaUrl;
  const getVideoDurationFromVideoFile = (videoFile) => {
    return new Promise((resolve, reject) => {
      var _a;
      try {
        if (videoFile) {
          if ((_a = videoFile === null || videoFile === void 0 ? void 0 : videoFile.type) === null || _a === void 0 ? void 0 : _a.match("video")) {
            (0, exports.importFileandPreview)(videoFile).then((url) => {
              generateVideoDurationFromUrl(url).then((res) => {
                resolve(res);
              });
            });
          } else {
            generateVideoDurationFromUrl(videoFile).then((res) => {
              resolve(res);
            });
          }
        } else {
          reject("Cannot generate video duration for this video file.");
        }
      } catch (error) {
        reject(error);
      }
    });
  };
  exports.getVideoDurationFromVideoFile = getVideoDurationFromVideoFile;
  const generateVideoDurationFromUrl = (url) => {
    return new Promise((resolve, reject) => {
      let video2 = document.createElement("video");
      video2.addEventListener("loadeddata", function() {
        resolve(video2.duration);
        window.URL.revokeObjectURL(url);
      });
      video2.preload = "metadata";
      video2.src = url;
      video2.muted = true;
      video2.crossOrigin = "Anonymous";
      video2.playsInline = true;
      video2.play();
    });
  };
})(lib);
function getFileFromBase64(string64, fileName) {
  const trimmedString = string64.replace("data:image/jpeg;base64,", "");
  const imageContent = atob(trimmedString);
  const buffer = new ArrayBuffer(imageContent.length);
  const view = new Uint8Array(buffer);
  for (let n2 = 0; n2 < imageContent.length; n2++) {
    view[n2] = imageContent.charCodeAt(n2);
  }
  const type2 = "image/jpeg";
  const blob = new Blob([buffer], { type: type2 });
  return new File([blob], fileName, { lastModified: new Date().getTime(), type: type2 });
}
async function loader$8({ params }) {
  return getVideoById(params.videoId);
}
const CustomUploadButton = asUploadButton(
  // eslint-disable-next-line react/display-name, @typescript-eslint/no-unused-vars
  reactExports.forwardRef((props, ref) => /* @__PURE__ */ jsx(
    Button$2,
    {
      ...props,
      style: { cursor: "pointer" },
      variant: "outlined",
      startIcon: /* @__PURE__ */ jsx(default_1$5, {})
    }
  ))
);
function VideoEditInner({ newVideo }) {
  var _a;
  let video2;
  if (!newVideo) {
    video2 = useLoaderData();
  }
  const [imageToUpload, setImageToUpload] = reactExports.useState();
  const [statusText, setStatusText] = reactExports.useState();
  const [uploading, setUploading] = reactExports.useState(false);
  const [progress, setProgress] = reactExports.useState(0);
  const [fileUploadInfo, setFileUploadInfo] = reactExports.useState();
  const [generatedThumbnails, setGeneratedThumbnails] = reactExports.useState();
  const tagsRef = reactExports.useRef(null);
  const userContext = reactExports.useContext(UserContext);
  const uploadVideoMutation = useVideosPOSTMutation();
  const updateVideoMutation = useVideosPUTMutation((video2 == null ? void 0 : video2.id) ?? "");
  const myChannels2 = useMyChannelsQuery();
  const uploady = useUploadyContext();
  const allTagsQuery = useTagsAllQuery({ refetchOnWindowFocus: false });
  const createTagMutation = useTagsPOSTMutation();
  const selectRandomThumbnail = () => {
    if (!generatedThumbnails) {
      return;
    }
    setImageToUpload(
      getFileFromBase64(
        generatedThumbnails[Math.floor(Math.random() * generatedThumbnails.length)],
        "generatedThumbnail.jpeg"
      )
    );
  };
  useChunkStartListener((data) => {
    setProgress(data.chunk.index / data.totalCount * 100);
  });
  useItemFinishListener(() => {
    setProgress(100);
    setUploading(false);
    setStatusText("Video spn nahrno ");
  });
  useItemErrorListener(() => {
    setUploading(false);
    setStatusText("Video se nepodailo nahrt ");
  });
  useBatchAddListener((batch2) => {
    (async () => {
      if (batch2.items.length === 1) {
        const { file } = batch2.items[0];
        const dur = await nanoMetadata.video.duration(file);
        setFileUploadInfo({
          name: file.name,
          size: SizeToWords(file.size),
          duration: dur
        });
        setImageToUpload(void 0);
        lib.generateVideoThumbnails(file, 5, "file").then((thumbnailArray) => {
          setGeneratedThumbnails(thumbnailArray);
        });
      }
    })();
  });
  reactExports.useEffect(() => {
    selectRandomThumbnail();
  }, [generatedThumbnails]);
  const handleTagAdd = async (name) => {
    return createTagMutation.mutateAsync(name);
  };
  const thumbnailAdditionalButtons = [
    /* @__PURE__ */ jsx(
      Button$2,
      {
        component: "label",
        startIcon: /* @__PURE__ */ jsx(default_1$6, {}),
        variant: "outlined",
        onClick: () => {
          selectRandomThumbnail();
        },
        children: "Pegenerovat nhled"
      },
      "regenerateButton"
    )
  ];
  const submitHandler = async (event) => {
    var _a2, _b, _c, _d, _e2;
    event.preventDefault();
    const data = new FormData(event.currentTarget);
    const description = (_a2 = data.get("description")) == null ? void 0 : _a2.toString();
    const name = (_b = data.get("name")) == null ? void 0 : _b.toString();
    const channelId = (_c = data.get("channelSelect")) == null ? void 0 : _c.toString();
    const tags2 = ((_e2 = (_d = tagsRef == null ? void 0 : tagsRef.current) == null ? void 0 : _d.getActiveChips()) == null ? void 0 : _e2.map((x) => x.label)) ?? [];
    if (newVideo) {
      if (!imageToUpload) {
        setStatusText("Nebyl vybrn nhledov obrzek.");
        return;
      }
      if (!fileUploadInfo) {
        setStatusText("Nebyl vybrn soubor s videem.");
        return;
      }
      setUploading(true);
      uploadVideoMutation.mutate(
        {
          channelId,
          description,
          durationSec: Math.floor(fileUploadInfo.duration),
          name,
          tags: tags2,
          fileName: fileUploadInfo.name,
          image: imageToUpload ? { data: imageToUpload, fileName: imageToUpload.name } : void 0
        },
        {
          onSuccess: (res) => {
            const token2 = localStorage.getItem("token");
            if (!token2) {
              setUploading(false);
              setStatusText("Dolo k odhlen, prosm pihlaste se znovu.");
            }
            uploady.processPending({
              destination: { headers: { "x-guid": res.dataUrl, authorization: `Bearer ${token2}` } }
            });
          },
          onError: () => {
            setUploading(false);
            setStatusText(`Video se nepodailo nahrt `);
          }
        }
      );
    } else {
      setUploading(true);
      updateVideoMutation.mutate(
        {
          channelId,
          description,
          name,
          tags: tags2,
          image: imageToUpload ? { data: imageToUpload, fileName: imageToUpload.name } : void 0
        },
        {
          onSuccess: () => {
            setProgress(100);
            setUploading(false);
            setStatusText("Video spn aktualizovno ");
          },
          onError: () => {
            setUploading(false);
            setStatusText(`Video se nepodailo aktualizovat `);
          }
        }
      );
    }
  };
  reactExports.useEffect(() => {
    if (!(userContext == null ? void 0 : userContext.isLoading) && !(userContext == null ? void 0 : userContext.user))
      throw new Error("Nejste pihlen nebo nemte oprvnn editovat video.");
  }, [userContext == null ? void 0 : userContext.user, userContext == null ? void 0 : userContext.isLoading]);
  return /* @__PURE__ */ jsxs(Box$1, { margin: 4, component: "form", onSubmit: submitHandler, children: [
    uploading && /* @__PURE__ */ jsx(Box$1, { sx: { width: "100%" }, pt: 2, pb: 2, children: /* @__PURE__ */ jsx(LinearProgress$1, { variant: "determinate", value: progress }) }),
    /* @__PURE__ */ jsxs(Box$1, { display: "flex", justifyContent: "space-between", children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", gutterBottom: true, children: "Editace videa" }),
      /* @__PURE__ */ jsxs(Box$1, { gap: 2, display: "flex", children: [
        /* @__PURE__ */ jsx(Button$2, { variant: "outlined", startIcon: /* @__PURE__ */ jsx(default_1$7, {}), children: "Zahodit zmny" }),
        /* @__PURE__ */ jsx(Button$2, { type: "submit", variant: "contained", startIcon: /* @__PURE__ */ jsx(default_1$8, {}), children: "Uloit" })
      ] })
    ] }),
    /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 3, children: [
      /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: statusText && /* @__PURE__ */ jsx(Alert$1, { severity: "info", children: statusText }) }),
      /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 3, paddingTop: 3, children: [
        /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
          MyChannelsDropdown,
          {
            channels: myChannels2.data,
            defaultValue: video2 == null ? void 0 : video2.channelId,
            required: true
          }
        ) }),
        /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
          TextField$1,
          {
            required: true,
            id: "name",
            name: "name",
            label: "Nzev",
            fullWidth: true,
            defaultValue: video2 == null ? void 0 : video2.name
          }
        ) }),
        /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
          TextField$1,
          {
            required: true,
            id: "description",
            name: "description",
            label: "Popis",
            fullWidth: true,
            defaultValue: video2 == null ? void 0 : video2.description,
            multiline: true,
            minRows: 5,
            maxRows: 14
          }
        ) }),
        newVideo && /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsxs(
          "fieldset",
          {
            style: {
              borderColor: "rgba(0, 0, 0, 0.23)",
              borderWidth: "1px",
              borderRadius: "4px",
              position: "relative",
              padding: 0
            },
            children: [
              /* @__PURE__ */ jsx(
                FormLabel$1,
                {
                  style: {
                    transform: "translate(10px, -9px) scale(0.75)",
                    position: "absolute",
                    left: "0",
                    top: "0",
                    transformOrigin: "top left",
                    zIndex: "1",
                    backgroundColor: "white",
                    paddingLeft: "4px",
                    paddingRight: "4px"
                  },
                  children: "Video soubor"
                }
              ),
              /* @__PURE__ */ jsxs(Box$1, { p: 2, children: [
                /* @__PURE__ */ jsxs(
                  Box$1,
                  {
                    sx: {
                      display: "flex",
                      justifyContent: "space-between"
                    },
                    children: [
                      /* @__PURE__ */ jsx(Typography$1, { children: (fileUploadInfo == null ? void 0 : fileUploadInfo.name) ?? "Nebyl vybrn soubor" }),
                      /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: (fileUploadInfo == null ? void 0 : fileUploadInfo.size) ?? "" })
                    ]
                  }
                ),
                /* @__PURE__ */ jsx(Box$1, { pt: 1, children: /* @__PURE__ */ jsx(
                  CustomUploadButton,
                  {
                    autoUpload: false,
                    extraProps: { type: "button" },
                    text: "Nahrt"
                  }
                ) })
              ] })
            ]
          }
        ) })
      ] }) }),
      /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, sm: 6, children: [
        /* @__PURE__ */ jsx(Typography$1, { children: "Nhledov obrzek:" }),
        /* @__PURE__ */ jsx(
          FileUploadWithPreview,
          {
            uploadedFile: imageToUpload,
            setUploadedFile: setImageToUpload,
            existingImageUrl: ApiPath(video2 == null ? void 0 : video2.imageUrl),
            additionalButtons: thumbnailAdditionalButtons
          }
        ),
        /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, children: [
          /* @__PURE__ */ jsx(Typography$1, { variant: "caption", pl: 2, children: "Tagy" }),
          /* @__PURE__ */ jsx(
            ChipEditLine,
            {
              chips: (_a = allTagsQuery == null ? void 0 : allTagsQuery.data) == null ? void 0 : _a.map(
                (x) => {
                  var _a2;
                  return {
                    active: (_a2 = video2 == null ? void 0 : video2.tags) == null ? void 0 : _a2.some((y2) => y2.name === x.name),
                    bgColor: GetRandomColor(),
                    key: x.id,
                    label: x.name
                  };
                }
              ),
              addChipHandle: handleTagAdd,
              ref: tagsRef
            }
          )
        ] })
      ] })
    ] })
  ] });
}
function VideoEdit({ newVideo = false }) {
  return /* @__PURE__ */ jsx(
    ChunkedUploady,
    {
      method: "POST",
      chunkSize: 1e7,
      destination: { url: uploadUrl() },
      accept: "video/*",
      children: /* @__PURE__ */ jsx(VideoEditInner, { newVideo })
    }
  );
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore$1(reducer2, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore$1)(reducer2, preloadedState);
  }
  if (typeof reducer2 !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer2;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
function bindActionCreators$1(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(formatProdErrorMessage(16));
  }
  var boundActionCreators = {};
  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b2) {
    return function() {
      return a2(b2.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares2 = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares2[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares2.map(function(middleware2) {
        return middleware2(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2(_objectSpread2({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}
var ReactReduxContext = /* @__PURE__ */ React.createContext(null);
function defaultNoopBatch(callback2) {
  callback2();
}
var batch = defaultNoopBatch;
var setBatch = function setBatch2(newBatch) {
  return batch = newBatch;
};
var getBatch = function getBatch2() {
  return batch;
};
function createListenerCollection() {
  var batch2 = getBatch();
  var first = null;
  var last = null;
  return {
    clear: function clear2() {
      first = null;
      last = null;
    },
    notify: function notify2() {
      batch2(function() {
        var listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get8() {
      var listeners = [];
      var listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe: function subscribe(callback2) {
      var isSubscribed = true;
      var listener = last = {
        callback: callback2,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify: function notify() {
  },
  get: function get7() {
    return [];
  }
};
function createSubscription(store, parentSub) {
  var unsubscribe;
  var listeners = nullListeners;
  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return Boolean(unsubscribe);
  }
  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  var subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: function getListeners() {
      return listeners;
    }
  };
  return subscription;
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function Provider(_ref) {
  var store = _ref.store, context = _ref.context, children = _ref.children;
  var contextValue = reactExports.useMemo(function() {
    var subscription = createSubscription(store);
    return {
      store,
      subscription
    };
  }, [store]);
  var previousState = reactExports.useMemo(function() {
    return store.getState();
  }, [store]);
  useIsomorphicLayoutEffect$1(function() {
    var subscription = contextValue.subscription;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return function() {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || ReactReduxContext;
  return /* @__PURE__ */ React.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
var reactIsExports = {};
var reactIs = {
  get exports() {
    return reactIsExports;
  },
  set exports(v2) {
    reactIsExports = v2;
  }
};
var reactIs_production_min = {};
/** @license React v17.0.2
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = 60103, c = 60106, d2 = 60107, e = 60108, f = 60114, g = 60109, h = 60110, k = 60112, l = 60113, m = 60120, n = 60115, p = 60116, q = 60121, r2 = 60122, u = 60117, v = 60129, w = 60131;
if ("function" === typeof Symbol && Symbol.for) {
  var x = Symbol.for;
  b = x("react.element");
  c = x("react.portal");
  d2 = x("react.fragment");
  e = x("react.strict_mode");
  f = x("react.profiler");
  g = x("react.provider");
  h = x("react.context");
  k = x("react.forward_ref");
  l = x("react.suspense");
  m = x("react.suspense_list");
  n = x("react.memo");
  p = x("react.lazy");
  q = x("react.block");
  r2 = x("react.server.block");
  u = x("react.fundamental");
  v = x("react.debug_trace_mode");
  w = x("react.legacy_hidden");
}
function y(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var t3 = a2.$$typeof;
    switch (t3) {
      case b:
        switch (a2 = a2.type, a2) {
          case d2:
          case f:
          case e:
          case l:
          case m:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case h:
              case k:
              case p:
              case n:
              case g:
                return a2;
              default:
                return t3;
            }
        }
      case c:
        return t3;
    }
  }
}
var z = g, A = b, B = k, C = d2, D = p, E = n, F = c, G = f, H = e, I = l;
reactIs_production_min.ContextConsumer = h;
reactIs_production_min.ContextProvider = z;
reactIs_production_min.Element = A;
reactIs_production_min.ForwardRef = B;
reactIs_production_min.Fragment = C;
reactIs_production_min.Lazy = D;
reactIs_production_min.Memo = E;
reactIs_production_min.Portal = F;
reactIs_production_min.Profiler = G;
reactIs_production_min.StrictMode = H;
reactIs_production_min.Suspense = I;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return y(a2) === h;
};
reactIs_production_min.isContextProvider = function(a2) {
  return y(a2) === g;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b;
};
reactIs_production_min.isForwardRef = function(a2) {
  return y(a2) === k;
};
reactIs_production_min.isFragment = function(a2) {
  return y(a2) === d2;
};
reactIs_production_min.isLazy = function(a2) {
  return y(a2) === p;
};
reactIs_production_min.isMemo = function(a2) {
  return y(a2) === n;
};
reactIs_production_min.isPortal = function(a2) {
  return y(a2) === c;
};
reactIs_production_min.isProfiler = function(a2) {
  return y(a2) === f;
};
reactIs_production_min.isStrictMode = function(a2) {
  return y(a2) === e;
};
reactIs_production_min.isSuspense = function(a2) {
  return y(a2) === l;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d2 || a2 === f || a2 === v || a2 === e || a2 === l || a2 === m || a2 === w || "object" === typeof a2 && null !== a2 && (a2.$$typeof === p || a2.$$typeof === n || a2.$$typeof === g || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === u || a2.$$typeof === q || a2[0] === r2) ? true : false;
};
reactIs_production_min.typeOf = y;
(function(module) {
  {
    module.exports = reactIs_production_min;
  }
})(reactIs);
var _excluded$2 = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"], _excluded2 = ["reactReduxForwardedRef"];
var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];
function storeStateUpdatesReducer(state, action) {
  var updateCount = state[1];
  return [action.payload, updateCount + 1];
}
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect$1(function() {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  if (!shouldHandleStateChanges)
    return;
  var didUnsubscribe = false;
  var lastThrownError = null;
  var checkForUpdates = function checkForUpdates2() {
    if (didUnsubscribe) {
      return;
    }
    var latestStoreState = store.getState();
    var newChildProps, error;
    try {
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e2) {
      error = e2;
      lastThrownError = e2;
    }
    if (!error) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      forceComponentUpdateDispatch({
        type: "STORE_UPDATED",
        payload: {
          error
        }
      });
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  var unsubscribeWrapper = function unsubscribeWrapper2() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
var initStateUpdates = function initStateUpdates2() {
  return [null, 0];
};
function connectAdvanced(selectorFactory, _ref) {
  if (_ref === void 0) {
    _ref = {};
  }
  var _ref2 = _ref, _ref2$getDisplayName = _ref2.getDisplayName, getDisplayName = _ref2$getDisplayName === void 0 ? function(name) {
    return "ConnectAdvanced(" + name + ")";
  } : _ref2$getDisplayName, _ref2$methodName = _ref2.methodName, methodName = _ref2$methodName === void 0 ? "connectAdvanced" : _ref2$methodName, _ref2$renderCountProp = _ref2.renderCountProp, renderCountProp = _ref2$renderCountProp === void 0 ? void 0 : _ref2$renderCountProp, _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges, shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta, _ref2$storeKey = _ref2.storeKey, storeKey = _ref2$storeKey === void 0 ? "store" : _ref2$storeKey;
  _ref2.withRef;
  var _ref2$forwardRef = _ref2.forwardRef, forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef, _ref2$context = _ref2.context, context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context, connectOptions = _objectWithoutPropertiesLoose(_ref2, _excluded$2);
  var Context = context;
  return function wrapWithConnect(WrappedComponent) {
    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    var displayName = getDisplayName(wrappedComponentName);
    var selectorFactoryOptions = _extends$8({}, connectOptions, {
      getDisplayName,
      methodName,
      renderCountProp,
      shouldHandleStateChanges,
      storeKey,
      displayName,
      wrappedComponentName,
      WrappedComponent
    });
    var pure = connectOptions.pure;
    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    }
    var usePureOnlyMemo = pure ? reactExports.useMemo : function(callback2) {
      return callback2();
    };
    function ConnectFunction(props) {
      var _useMemo = reactExports.useMemo(function() {
        var reactReduxForwardedRef2 = props.reactReduxForwardedRef, wrapperProps2 = _objectWithoutPropertiesLoose(props, _excluded2);
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]), propsContext = _useMemo[0], reactReduxForwardedRef = _useMemo[1], wrapperProps = _useMemo[2];
      var ContextToUse = reactExports.useMemo(function() {
        return propsContext && propsContext.Consumer && reactIsExports.isContextConsumer(/* @__PURE__ */ React.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]);
      var contextValue = reactExports.useContext(ContextToUse);
      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      Boolean(contextValue) && Boolean(contextValue.store);
      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = reactExports.useMemo(function() {
        return createChildSelector(store);
      }, [store]);
      var _useMemo2 = reactExports.useMemo(function() {
        if (!shouldHandleStateChanges)
          return NO_SUBSCRIPTION_ARRAY;
        var subscription2 = createSubscription(store, didStoreComeFromProps ? null : contextValue.subscription);
        var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]), subscription = _useMemo2[0], notifyNestedSubs = _useMemo2[1];
      var overriddenContextValue = reactExports.useMemo(function() {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return _extends$8({}, contextValue, {
          subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]);
      var _useReducer = reactExports.useReducer(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates), _useReducer$ = _useReducer[0], previousStateUpdateResult = _useReducer$[0], forceComponentUpdateDispatch = _useReducer[1];
      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      }
      var lastChildProps = reactExports.useRef();
      var lastWrapperProps = reactExports.useRef(wrapperProps);
      var childPropsFromStoreUpdate = reactExports.useRef();
      var renderIsScheduled = reactExports.useRef(false);
      var actualChildProps = usePureOnlyMemo(function() {
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        }
        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]);
      var renderedWrappedComponent = reactExports.useMemo(function() {
        return /* @__PURE__ */ React.createElement(WrappedComponent, _extends$8({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      var renderedChild = reactExports.useMemo(function() {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ React.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    var Connect = pure ? React.memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef) {
      var forwarded = React.forwardRef(function forwardConnectRef(props, ref) {
        return /* @__PURE__ */ React.createElement(Connect, _extends$8({}, props, {
          reactReduxForwardedRef: ref
        }));
      });
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoistNonReactStatics_cjs(forwarded, WrappedComponent);
    }
    return hoistNonReactStatics_cjs(Connect, WrappedComponent);
  };
}
function is(x, y2) {
  if (x === y2) {
    return x !== 0 || y2 !== 0 || 1 / x === 1 / y2;
  } else {
    return x !== x && y2 !== y2;
  }
}
function shallowEqual2(objA, objB) {
  if (is(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (var i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
function bindActionCreators(actionCreators, dispatch) {
  var boundActionCreators = {};
  var _loop = function _loop2(key2) {
    var actionCreator = actionCreators[key2];
    if (typeof actionCreator === "function") {
      boundActionCreators[key2] = function() {
        return dispatch(actionCreator.apply(void 0, arguments));
      };
    }
  };
  for (var key in actionCreators) {
    _loop(key);
  }
  return boundActionCreators;
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);
    function constantSelector() {
      return constant;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== void 0 ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    _ref.displayName;
    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      return props;
    };
    return proxy;
  };
}
function whenMapDispatchToPropsIsFunction(mapDispatchToProps2) {
  return typeof mapDispatchToProps2 === "function" ? wrapMapToPropsFunc(mapDispatchToProps2) : void 0;
}
function whenMapDispatchToPropsIsMissing(mapDispatchToProps2) {
  return !mapDispatchToProps2 ? wrapMapToPropsConstant(function(dispatch) {
    return {
      dispatch
    };
  }) : void 0;
}
function whenMapDispatchToPropsIsObject(mapDispatchToProps2) {
  return mapDispatchToProps2 && typeof mapDispatchToProps2 === "object" ? wrapMapToPropsConstant(function(dispatch) {
    return bindActionCreators(mapDispatchToProps2, dispatch);
  }) : void 0;
}
const defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === "function" ? wrapMapToPropsFunc(mapStateToProps) : void 0;
}
function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(function() {
    return {};
  }) : void 0;
}
const defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends$8({}, ownProps, stateProps, dispatchProps);
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    _ref.displayName;
    var pure = _ref.pure, areMergedPropsEqual = _ref.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
      }
      return mergedProps;
    };
  };
}
function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : void 0;
}
function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function() {
    return defaultMergeProps;
  } : void 0;
}
const defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
var _excluded$1 = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps2(dispatch, ownProps), ownProps);
  };
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual, areOwnPropsEqual = _ref.areOwnPropsEqual, areStatePropsEqual = _ref.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged)
      return handleNewPropsAndNewState();
    if (propsChanged)
      return handleNewProps();
    if (stateChanged)
      return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps, initMapDispatchToProps = _ref2.initMapDispatchToProps, initMergeProps = _ref2.initMergeProps, options = _objectWithoutPropertiesLoose(_ref2, _excluded$1);
  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps2 = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);
  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, options);
}
var _excluded = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result)
      return result;
  }
  return function(dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}
function strictEqual(a2, b2) {
  return a2 === b2;
}
function createConnect(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$connectHOC = _ref.connectHOC, connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC, _ref$mapStateToPropsF = _ref.mapStateToPropsFactories, mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? defaultMapStateToPropsFactories : _ref$mapStateToPropsF, _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories, mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? defaultMapDispatchToPropsFactories : _ref$mapDispatchToPro, _ref$mergePropsFactor = _ref.mergePropsFactories, mergePropsFactories = _ref$mergePropsFactor === void 0 ? defaultMergePropsFactories : _ref$mergePropsFactor, _ref$selectorFactory = _ref.selectorFactory, selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
  return function connect2(mapStateToProps, mapDispatchToProps2, mergeProps, _ref2) {
    if (_ref2 === void 0) {
      _ref2 = {};
    }
    var _ref3 = _ref2, _ref3$pure = _ref3.pure, pure = _ref3$pure === void 0 ? true : _ref3$pure, _ref3$areStatesEqual = _ref3.areStatesEqual, areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual, _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual, areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual2 : _ref3$areOwnPropsEqua, _ref3$areStatePropsEq = _ref3.areStatePropsEqual, areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual2 : _ref3$areStatePropsEq, _ref3$areMergedPropsE = _ref3.areMergedPropsEqual, areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual2 : _ref3$areMergedPropsE, extraOptions = _objectWithoutPropertiesLoose(_ref3, _excluded);
    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, "mapStateToProps");
    var initMapDispatchToProps = match(mapDispatchToProps2, mapDispatchToPropsFactories, "mapDispatchToProps");
    var initMergeProps = match(mergeProps, mergePropsFactories, "mergeProps");
    return connectHOC(selectorFactory, _extends$8({
      // used in error messages
      methodName: "connect",
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return "Connect(" + name + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      // passed through to selectorFactory
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual
    }, extraOptions));
  };
}
const connect = /* @__PURE__ */ createConnect();
setBatch(reactDomExports.unstable_batchedUpdates);
function areInputsEqual$1(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (newInputs[i] !== lastInputs[i]) {
      return false;
    }
  }
  return true;
}
function useMemoOne(getResult, inputs) {
  var initial = reactExports.useState(function() {
    return {
      inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = reactExports.useRef(true);
  var committed = reactExports.useRef(initial);
  var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual$1(inputs, committed.current.inputs));
  var cache = useCache ? committed.current : {
    inputs,
    result: getResult()
  };
  reactExports.useEffect(function() {
    isFirstRun.current = false;
    committed.current = cache;
  }, [cache]);
  return cache.result;
}
function useCallbackOne(callback2, inputs) {
  return useMemoOne(function() {
    return callback2;
  }, inputs);
}
var useMemo = useMemoOne;
var useCallback = useCallbackOne;
var isProduction = true;
var prefix$2 = "Invariant failed";
function invariant$1(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix$2);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix$2, ": ").concat(provided) : prefix$2;
  throw new Error(value);
}
var getRect = function getRect2(_ref) {
  var top2 = _ref.top, right2 = _ref.right, bottom2 = _ref.bottom, left2 = _ref.left;
  var width3 = right2 - left2;
  var height3 = bottom2 - top2;
  var rect = {
    top: top2,
    right: right2,
    bottom: bottom2,
    left: left2,
    width: width3,
    height: height3,
    x: left2,
    y: top2,
    center: {
      x: (right2 + left2) / 2,
      y: (bottom2 + top2) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var shift = function shift2(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};
var noSpacing$1 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing$1 : _ref2$margin, _ref2$border = _ref2.border, border2 = _ref2$border === void 0 ? noSpacing$1 : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing$1 : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border2));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border: border2,
    padding
  };
};
var parse2 = function parse3(raw) {
  var value = raw.slice(0, -2);
  var suffix = raw.slice(-2);
  if (suffix !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? invariant$1(false) : void 0;
  return result;
};
var getWindowScroll$1 = function getWindowScroll() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
var offset = function offset2(original, change) {
  var borderBox = original.borderBox, border2 = original.border, margin = original.margin, padding = original.padding;
  var shifted = shift(borderBox, change);
  return createBox({
    borderBox: shifted,
    border: border2,
    margin,
    padding
  });
};
var withScroll = function withScroll2(original, scroll3) {
  if (scroll3 === void 0) {
    scroll3 = getWindowScroll$1();
  }
  return offset(original, scroll3);
};
var calculateBox = function calculateBox2(borderBox, styles2) {
  var margin = {
    top: parse2(styles2.marginTop),
    right: parse2(styles2.marginRight),
    bottom: parse2(styles2.marginBottom),
    left: parse2(styles2.marginLeft)
  };
  var padding = {
    top: parse2(styles2.paddingTop),
    right: parse2(styles2.paddingRight),
    bottom: parse2(styles2.paddingBottom),
    left: parse2(styles2.paddingLeft)
  };
  var border2 = {
    top: parse2(styles2.borderTopWidth),
    right: parse2(styles2.borderRightWidth),
    bottom: parse2(styles2.borderBottomWidth),
    left: parse2(styles2.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border: border2
  });
};
var getBox = function getBox2(el2) {
  var borderBox = el2.getBoundingClientRect();
  var styles2 = window.getComputedStyle(el2);
  return calculateBox(borderBox, styles2);
};
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual$2(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual$2(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual4) {
  if (isEqual4 === void 0) {
    isEqual4 = areInputsEqual;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual4(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var rafSchd = function rafSchd2(fn2) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn2.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
const rafSchd$1 = rafSchd;
function log(type2, message) {
  {
    return;
  }
}
log.bind(null, "warn");
log.bind(null, "error");
function noop() {
}
function getOptions(shared, fromBinding) {
  return _extends$8({}, shared, {}, fromBinding);
}
function bindEvents(el2, bindings, sharedOptions) {
  var unbindings = bindings.map(function(binding) {
    var options = getOptions(sharedOptions, binding.options);
    el2.addEventListener(binding.eventName, binding.fn, options);
    return function unbind() {
      el2.removeEventListener(binding.eventName, binding.fn, options);
    };
  });
  return function unbindAll() {
    unbindings.forEach(function(unbind) {
      unbind();
    });
  };
}
var prefix = "Invariant failed";
function RbdInvariant(message) {
  this.message = message;
}
RbdInvariant.prototype.toString = function toString3() {
  return this.message;
};
function invariant(condition, message) {
  if (condition) {
    return;
  }
  {
    throw new RbdInvariant(prefix);
  }
}
var ErrorBoundary = function(_React$Component) {
  _inheritsLoose(ErrorBoundary2, _React$Component);
  function ErrorBoundary2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.callbacks = null;
    _this.unbind = noop;
    _this.onWindowError = function(event) {
      var callbacks = _this.getCallbacks();
      if (callbacks.isDragging()) {
        callbacks.tryAbort();
      }
      var err = event.error;
      if (err instanceof RbdInvariant) {
        event.preventDefault();
      }
    };
    _this.getCallbacks = function() {
      if (!_this.callbacks) {
        throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");
      }
      return _this.callbacks;
    };
    _this.setCallbacks = function(callbacks) {
      _this.callbacks = callbacks;
    };
    return _this;
  }
  var _proto = ErrorBoundary2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.unbind = bindEvents(window, [{
      eventName: "error",
      fn: this.onWindowError
    }]);
  };
  _proto.componentDidCatch = function componentDidCatch(err) {
    if (err instanceof RbdInvariant) {
      this.setState({});
      return;
    }
    throw err;
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.unbind();
  };
  _proto.render = function render() {
    return this.props.children(this.setCallbacks);
  };
  return ErrorBoundary2;
}(React.Component);
var dragHandleUsageInstructions = "\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n";
var position = function position2(index2) {
  return index2 + 1;
};
var onDragStart = function onDragStart2(start3) {
  return "\n  You have lifted an item in position " + position(start3.source.index) + "\n";
};
var withLocation = function withLocation2(source, destination) {
  var isInHomeList = source.droppableId === destination.droppableId;
  var startPosition = position(source.index);
  var endPosition = position(destination.index);
  if (isInHomeList) {
    return "\n      You have moved the item from position " + startPosition + "\n      to position " + endPosition + "\n    ";
  }
  return "\n    You have moved the item from position " + startPosition + "\n    in list " + source.droppableId + "\n    to list " + destination.droppableId + "\n    in position " + endPosition + "\n  ";
};
var withCombine = function withCombine2(id2, source, combine2) {
  var inHomeList = source.droppableId === combine2.droppableId;
  if (inHomeList) {
    return "\n      The item " + id2 + "\n      has been combined with " + combine2.draggableId;
  }
  return "\n      The item " + id2 + "\n      in list " + source.droppableId + "\n      has been combined with " + combine2.draggableId + "\n      in list " + combine2.droppableId + "\n    ";
};
var onDragUpdate = function onDragUpdate2(update2) {
  var location2 = update2.destination;
  if (location2) {
    return withLocation(update2.source, location2);
  }
  var combine2 = update2.combine;
  if (combine2) {
    return withCombine(update2.draggableId, update2.source, combine2);
  }
  return "You are over an area that cannot be dropped on";
};
var returnedToStart = function returnedToStart2(source) {
  return "\n  The item has returned to its starting position\n  of " + position(source.index) + "\n";
};
var onDragEnd = function onDragEnd2(result) {
  if (result.reason === "CANCEL") {
    return "\n      Movement cancelled.\n      " + returnedToStart(result.source) + "\n    ";
  }
  var location2 = result.destination;
  var combine2 = result.combine;
  if (location2) {
    return "\n      You have dropped the item.\n      " + withLocation(result.source, location2) + "\n    ";
  }
  if (combine2) {
    return "\n      You have dropped the item.\n      " + withCombine(result.draggableId, result.source, combine2) + "\n    ";
  }
  return "\n    The item has been dropped while not over a drop area.\n    " + returnedToStart(result.source) + "\n  ";
};
var preset = {
  dragHandleUsageInstructions,
  onDragStart,
  onDragUpdate,
  onDragEnd
};
var origin = {
  x: 0,
  y: 0
};
var add = function add2(point1, point2) {
  return {
    x: point1.x + point2.x,
    y: point1.y + point2.y
  };
};
var subtract = function subtract2(point1, point2) {
  return {
    x: point1.x - point2.x,
    y: point1.y - point2.y
  };
};
var isEqual = function isEqual2(point1, point2) {
  return point1.x === point2.x && point1.y === point2.y;
};
var negate = function negate2(point) {
  return {
    x: point.x !== 0 ? -point.x : 0,
    y: point.y !== 0 ? -point.y : 0
  };
};
var patch = function patch2(line2, value, otherValue) {
  var _ref;
  if (otherValue === void 0) {
    otherValue = 0;
  }
  return _ref = {}, _ref[line2] = value, _ref[line2 === "x" ? "y" : "x"] = otherValue, _ref;
};
var distance = function distance2(point1, point2) {
  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
};
var closest = function closest2(target, points) {
  return Math.min.apply(Math, points.map(function(point) {
    return distance(target, point);
  }));
};
var apply = function apply2(fn2) {
  return function(point) {
    return {
      x: fn2(point.x),
      y: fn2(point.y)
    };
  };
};
var executeClip = function(frame, subject) {
  var result = getRect({
    top: Math.max(subject.top, frame.top),
    right: Math.min(subject.right, frame.right),
    bottom: Math.min(subject.bottom, frame.bottom),
    left: Math.max(subject.left, frame.left)
  });
  if (result.width <= 0 || result.height <= 0) {
    return null;
  }
  return result;
};
var offsetByPosition = function offsetByPosition2(spacing2, point) {
  return {
    top: spacing2.top + point.y,
    left: spacing2.left + point.x,
    bottom: spacing2.bottom + point.y,
    right: spacing2.right + point.x
  };
};
var getCorners = function getCorners2(spacing2) {
  return [{
    x: spacing2.left,
    y: spacing2.top
  }, {
    x: spacing2.right,
    y: spacing2.top
  }, {
    x: spacing2.left,
    y: spacing2.bottom
  }, {
    x: spacing2.right,
    y: spacing2.bottom
  }];
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var scroll = function scroll2(target, frame) {
  if (!frame) {
    return target;
  }
  return offsetByPosition(target, frame.scroll.diff.displacement);
};
var increase = function increase2(target, axis, withPlaceholder) {
  if (withPlaceholder && withPlaceholder.increasedBy) {
    var _extends2;
    return _extends$8({}, target, (_extends2 = {}, _extends2[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends2));
  }
  return target;
};
var clip = function clip2(target, frame) {
  if (frame && frame.shouldClipSubject) {
    return executeClip(frame.pageMarginBox, target);
  }
  return getRect(target);
};
var getSubject = function(_ref) {
  var page = _ref.page, withPlaceholder = _ref.withPlaceholder, axis = _ref.axis, frame = _ref.frame;
  var scrolled = scroll(page.marginBox, frame);
  var increased = increase(scrolled, axis, withPlaceholder);
  var clipped = clip(increased, frame);
  return {
    page,
    withPlaceholder,
    active: clipped
  };
};
var scrollDroppable = function(droppable2, newScroll) {
  !droppable2.frame ? invariant(false) : void 0;
  var scrollable = droppable2.frame;
  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);
  var scrollDisplacement = negate(scrollDiff);
  var frame = _extends$8({}, scrollable, {
    scroll: {
      initial: scrollable.scroll.initial,
      current: newScroll,
      diff: {
        value: scrollDiff,
        displacement: scrollDisplacement
      },
      max: scrollable.scroll.max
    }
  });
  var subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: droppable2.subject.withPlaceholder,
    axis: droppable2.axis,
    frame
  });
  var result = _extends$8({}, droppable2, {
    frame,
    subject
  });
  return result;
};
function values2(map) {
  if (Object.values) {
    return Object.values(map);
  }
  return Object.keys(map).map(function(key) {
    return map[key];
  });
}
function findIndex2(list, predicate) {
  if (list.findIndex) {
    return list.findIndex(predicate);
  }
  for (var i = 0; i < list.length; i++) {
    if (predicate(list[i])) {
      return i;
    }
  }
  return -1;
}
function find(list, predicate) {
  if (list.find) {
    return list.find(predicate);
  }
  var index2 = findIndex2(list, predicate);
  if (index2 !== -1) {
    return list[index2];
  }
  return void 0;
}
function toArray(list) {
  return Array.prototype.slice.call(list);
}
var toDroppableMap = memoizeOne(function(droppables) {
  return droppables.reduce(function(previous, current) {
    previous[current.descriptor.id] = current;
    return previous;
  }, {});
});
var toDraggableMap = memoizeOne(function(draggables) {
  return draggables.reduce(function(previous, current) {
    previous[current.descriptor.id] = current;
    return previous;
  }, {});
});
var toDroppableList = memoizeOne(function(droppables) {
  return values2(droppables);
});
var toDraggableList = memoizeOne(function(draggables) {
  return values2(draggables);
});
var getDraggablesInsideDroppable = memoizeOne(function(droppableId, draggables) {
  var result = toDraggableList(draggables).filter(function(draggable2) {
    return droppableId === draggable2.descriptor.droppableId;
  }).sort(function(a2, b2) {
    return a2.descriptor.index - b2.descriptor.index;
  });
  return result;
});
function tryGetDestination(impact) {
  if (impact.at && impact.at.type === "REORDER") {
    return impact.at.destination;
  }
  return null;
}
function tryGetCombine(impact) {
  if (impact.at && impact.at.type === "COMBINE") {
    return impact.at.combine;
  }
  return null;
}
var removeDraggableFromList = memoizeOne(function(remove2, list) {
  return list.filter(function(item) {
    return item.descriptor.id !== remove2.descriptor.id;
  });
});
var moveToNextCombine = function(_ref) {
  var isMovingForward = _ref.isMovingForward, draggable2 = _ref.draggable, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var location2 = tryGetDestination(previousImpact);
  if (!location2) {
    return null;
  }
  function getImpact(target) {
    var at = {
      type: "COMBINE",
      combine: {
        draggableId: target,
        droppableId: destination.descriptor.id
      }
    };
    return _extends$8({}, previousImpact, {
      at
    });
  }
  var all2 = previousImpact.displaced.all;
  var closestId = all2.length ? all2[0] : null;
  if (isMovingForward) {
    return closestId ? getImpact(closestId) : null;
  }
  var withoutDraggable = removeDraggableFromList(draggable2, insideDestination);
  if (!closestId) {
    if (!withoutDraggable.length) {
      return null;
    }
    var last = withoutDraggable[withoutDraggable.length - 1];
    return getImpact(last.descriptor.id);
  }
  var indexOfClosest = findIndex2(withoutDraggable, function(d3) {
    return d3.descriptor.id === closestId;
  });
  !(indexOfClosest !== -1) ? invariant(false) : void 0;
  var proposedIndex = indexOfClosest - 1;
  if (proposedIndex < 0) {
    return null;
  }
  var before = withoutDraggable[proposedIndex];
  return getImpact(before.descriptor.id);
};
var isHomeOf = function(draggable2, destination) {
  return draggable2.descriptor.droppableId === destination.descriptor.id;
};
var noDisplacedBy = {
  point: origin,
  value: 0
};
var emptyGroups = {
  invisible: {},
  visible: {},
  all: []
};
var noImpact = {
  displaced: emptyGroups,
  displacedBy: noDisplacedBy,
  at: null
};
var isWithin = function(lowerBound, upperBound) {
  return function(value) {
    return lowerBound <= value && value <= upperBound;
  };
};
var isPartiallyVisibleThroughFrame = function(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function(subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    if (isContained) {
      return true;
    }
    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
    if (isPartiallyContained) {
      return true;
    }
    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
    if (isTargetBiggerThanFrame) {
      return true;
    }
    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
    return isTargetBiggerOnOneAxis;
  };
};
var isTotallyVisibleThroughFrame = function(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function(subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    return isContained;
  };
};
var vertical = {
  direction: "vertical",
  line: "y",
  crossAxisLine: "x",
  start: "top",
  end: "bottom",
  size: "height",
  crossAxisStart: "left",
  crossAxisEnd: "right",
  crossAxisSize: "width"
};
var horizontal = {
  direction: "horizontal",
  line: "x",
  crossAxisLine: "y",
  start: "left",
  end: "right",
  size: "width",
  crossAxisStart: "top",
  crossAxisEnd: "bottom",
  crossAxisSize: "height"
};
var isTotallyVisibleThroughFrameOnAxis = function(axis) {
  return function(frame) {
    var isWithinVertical = isWithin(frame.top, frame.bottom);
    var isWithinHorizontal = isWithin(frame.left, frame.right);
    return function(subject) {
      if (axis === vertical) {
        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
      }
      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    };
  };
};
var getDroppableDisplaced = function getDroppableDisplaced2(target, destination) {
  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
  return offsetByPosition(target, displacement);
};
var isVisibleInDroppable = function isVisibleInDroppable2(target, destination, isVisibleThroughFrameFn) {
  if (!destination.subject.active) {
    return false;
  }
  return isVisibleThroughFrameFn(destination.subject.active)(target);
};
var isVisibleInViewport = function isVisibleInViewport2(target, viewport2, isVisibleThroughFrameFn) {
  return isVisibleThroughFrameFn(viewport2)(target);
};
var isVisible = function isVisible2(_ref) {
  var toBeDisplaced = _ref.target, destination = _ref.destination, viewport2 = _ref.viewport, withDroppableDisplacement2 = _ref.withDroppableDisplacement, isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;
  var displacedTarget = withDroppableDisplacement2 ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport2, isVisibleThroughFrameFn);
};
var isPartiallyVisible = function isPartiallyVisible2(args) {
  return isVisible(_extends$8({}, args, {
    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
  }));
};
var isTotallyVisible = function isTotallyVisible2(args) {
  return isVisible(_extends$8({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
  }));
};
var isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis2(args) {
  return isVisible(_extends$8({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
  }));
};
var getShouldAnimate = function getShouldAnimate2(id2, last, forceShouldAnimate) {
  if (typeof forceShouldAnimate === "boolean") {
    return forceShouldAnimate;
  }
  if (!last) {
    return true;
  }
  var invisible = last.invisible, visible = last.visible;
  if (invisible[id2]) {
    return false;
  }
  var previous = visible[id2];
  return previous ? previous.shouldAnimate : true;
};
function getTarget(draggable2, displacedBy) {
  var marginBox = draggable2.page.marginBox;
  var expandBy = {
    top: displacedBy.point.y,
    right: 0,
    bottom: 0,
    left: displacedBy.point.x
  };
  return getRect(expand(marginBox, expandBy));
}
function getDisplacementGroups(_ref) {
  var afterDragging = _ref.afterDragging, destination = _ref.destination, displacedBy = _ref.displacedBy, viewport2 = _ref.viewport, forceShouldAnimate = _ref.forceShouldAnimate, last = _ref.last;
  return afterDragging.reduce(function process2(groups, draggable2) {
    var target = getTarget(draggable2, displacedBy);
    var id2 = draggable2.descriptor.id;
    groups.all.push(id2);
    var isVisible3 = isPartiallyVisible({
      target,
      destination,
      viewport: viewport2,
      withDroppableDisplacement: true
    });
    if (!isVisible3) {
      groups.invisible[draggable2.descriptor.id] = true;
      return groups;
    }
    var shouldAnimate = getShouldAnimate(id2, last, forceShouldAnimate);
    var displacement = {
      draggableId: id2,
      shouldAnimate
    };
    groups.visible[id2] = displacement;
    return groups;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}
function getIndexOfLastItem(draggables, options) {
  if (!draggables.length) {
    return 0;
  }
  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
}
function goAtEnd(_ref) {
  var insideDestination = _ref.insideDestination, inHomeList = _ref.inHomeList, displacedBy = _ref.displacedBy, destination = _ref.destination;
  var newIndex = getIndexOfLastItem(insideDestination, {
    inHomeList
  });
  return {
    displaced: emptyGroups,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: newIndex
      }
    }
  };
}
function calculateReorderImpact(_ref2) {
  var draggable2 = _ref2.draggable, insideDestination = _ref2.insideDestination, destination = _ref2.destination, viewport2 = _ref2.viewport, displacedBy = _ref2.displacedBy, last = _ref2.last, index2 = _ref2.index, forceShouldAnimate = _ref2.forceShouldAnimate;
  var inHomeList = isHomeOf(draggable2, destination);
  if (index2 == null) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  var match2 = find(insideDestination, function(item) {
    return item.descriptor.index === index2;
  });
  if (!match2) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var sliceFrom = insideDestination.indexOf(match2);
  var impacted = withoutDragging.slice(sliceFrom);
  var displaced = getDisplacementGroups({
    afterDragging: impacted,
    destination,
    displacedBy,
    last,
    viewport: viewport2.frame,
    forceShouldAnimate
  });
  return {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: index2
      }
    }
  };
}
function didStartAfterCritical(draggableId, afterCritical) {
  return Boolean(afterCritical.effected[draggableId]);
}
var fromCombine = function(_ref) {
  var isMovingForward = _ref.isMovingForward, destination = _ref.destination, draggables = _ref.draggables, combine2 = _ref.combine, afterCritical = _ref.afterCritical;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var combineId = combine2.draggableId;
  var combineWith = draggables[combineId];
  var combineWithIndex = combineWith.descriptor.index;
  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
  if (didCombineWithStartAfterCritical) {
    if (isMovingForward) {
      return combineWithIndex;
    }
    return combineWithIndex - 1;
  }
  if (isMovingForward) {
    return combineWithIndex + 1;
  }
  return combineWithIndex;
};
var fromReorder = function(_ref) {
  var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, insideDestination = _ref.insideDestination, location2 = _ref.location;
  if (!insideDestination.length) {
    return null;
  }
  var currentIndex = location2.index;
  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
  var firstIndex = insideDestination[0].descriptor.index;
  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;
  if (proposedIndex < firstIndex) {
    return null;
  }
  if (proposedIndex > upperBound) {
    return null;
  }
  return proposedIndex;
};
var moveToNextIndex = function(_ref) {
  var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, draggable2 = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact, viewport2 = _ref.viewport, afterCritical = _ref.afterCritical;
  var wasAt = previousImpact.at;
  !wasAt ? invariant(false) : void 0;
  if (wasAt.type === "REORDER") {
    var _newIndex = fromReorder({
      isMovingForward,
      isInHomeList,
      location: wasAt.destination,
      insideDestination
    });
    if (_newIndex == null) {
      return null;
    }
    return calculateReorderImpact({
      draggable: draggable2,
      insideDestination,
      destination,
      viewport: viewport2,
      last: previousImpact.displaced,
      displacedBy: previousImpact.displacedBy,
      index: _newIndex
    });
  }
  var newIndex = fromCombine({
    isMovingForward,
    destination,
    displaced: previousImpact.displaced,
    draggables,
    combine: wasAt.combine,
    afterCritical
  });
  if (newIndex == null) {
    return null;
  }
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    last: previousImpact.displaced,
    displacedBy: previousImpact.displacedBy,
    index: newIndex
  });
};
var getCombinedItemDisplacement = function(_ref) {
  var displaced = _ref.displaced, afterCritical = _ref.afterCritical, combineWith = _ref.combineWith, displacedBy = _ref.displacedBy;
  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
  if (didStartAfterCritical(combineWith, afterCritical)) {
    return isDisplaced ? origin : negate(displacedBy.point);
  }
  return isDisplaced ? displacedBy.point : origin;
};
var whenCombining = function(_ref) {
  var afterCritical = _ref.afterCritical, impact = _ref.impact, draggables = _ref.draggables;
  var combine2 = tryGetCombine(impact);
  !combine2 ? invariant(false) : void 0;
  var combineWith = combine2.draggableId;
  var center = draggables[combineWith].page.borderBox.center;
  var displaceBy = getCombinedItemDisplacement({
    displaced: impact.displaced,
    afterCritical,
    combineWith,
    displacedBy: impact.displacedBy
  });
  return add(center, displaceBy);
};
var distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter2(axis, box) {
  return box.margin[axis.start] + box.borderBox[axis.size] / 2;
};
var distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter2(axis, box) {
  return box.margin[axis.end] + box.borderBox[axis.size] / 2;
};
var getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter2(axis, target, isMoving) {
  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
};
var goAfter = function goAfter2(_ref) {
  var axis = _ref.axis, moveRelativeTo = _ref.moveRelativeTo, isMoving = _ref.isMoving;
  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goBefore = function goBefore2(_ref2) {
  var axis = _ref2.axis, moveRelativeTo = _ref2.moveRelativeTo, isMoving = _ref2.isMoving;
  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goIntoStart = function goIntoStart2(_ref3) {
  var axis = _ref3.axis, moveInto = _ref3.moveInto, isMoving = _ref3.isMoving;
  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
};
var whenReordering = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, draggables = _ref.draggables, droppable2 = _ref.droppable, afterCritical = _ref.afterCritical;
  var insideDestination = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  var draggablePage = draggable2.page;
  var axis = droppable2.axis;
  if (!insideDestination.length) {
    return goIntoStart({
      axis,
      moveInto: droppable2.page,
      isMoving: draggablePage
    });
  }
  var displaced = impact.displaced, displacedBy = impact.displacedBy;
  var closestAfter = displaced.all[0];
  if (closestAfter) {
    var closest3 = draggables[closestAfter];
    if (didStartAfterCritical(closestAfter, afterCritical)) {
      return goBefore({
        axis,
        moveRelativeTo: closest3.page,
        isMoving: draggablePage
      });
    }
    var withDisplacement = offset(closest3.page, displacedBy.point);
    return goBefore({
      axis,
      moveRelativeTo: withDisplacement,
      isMoving: draggablePage
    });
  }
  var last = insideDestination[insideDestination.length - 1];
  if (last.descriptor.id === draggable2.descriptor.id) {
    return draggablePage.borderBox.center;
  }
  if (didStartAfterCritical(last.descriptor.id, afterCritical)) {
    var page = offset(last.page, negate(afterCritical.displacedBy.point));
    return goAfter({
      axis,
      moveRelativeTo: page,
      isMoving: draggablePage
    });
  }
  return goAfter({
    axis,
    moveRelativeTo: last.page,
    isMoving: draggablePage
  });
};
var withDroppableDisplacement = function(droppable2, point) {
  var frame = droppable2.frame;
  if (!frame) {
    return point;
  }
  return add(point, frame.scroll.diff.displacement);
};
var getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement2(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, droppable2 = _ref.droppable, draggables = _ref.draggables, afterCritical = _ref.afterCritical;
  var original = draggable2.page.borderBox.center;
  var at = impact.at;
  if (!droppable2) {
    return original;
  }
  if (!at) {
    return original;
  }
  if (at.type === "REORDER") {
    return whenReordering({
      impact,
      draggable: draggable2,
      draggables,
      droppable: droppable2,
      afterCritical
    });
  }
  return whenCombining({
    impact,
    draggables,
    afterCritical
  });
};
var getPageBorderBoxCenterFromImpact = function(args) {
  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);
  var droppable2 = args.droppable;
  var withDisplacement = droppable2 ? withDroppableDisplacement(droppable2, withoutDisplacement) : withoutDisplacement;
  return withDisplacement;
};
var scrollViewport = function(viewport2, newScroll) {
  var diff = subtract(newScroll, viewport2.scroll.initial);
  var displacement = negate(diff);
  var frame = getRect({
    top: newScroll.y,
    bottom: newScroll.y + viewport2.frame.height,
    left: newScroll.x,
    right: newScroll.x + viewport2.frame.width
  });
  var updated = {
    frame,
    scroll: {
      initial: viewport2.scroll.initial,
      max: viewport2.scroll.max,
      current: newScroll,
      diff: {
        value: diff,
        displacement
      }
    }
  };
  return updated;
};
function getDraggables(ids, draggables) {
  return ids.map(function(id2) {
    return draggables[id2];
  });
}
function tryGetVisible(id2, groups) {
  for (var i = 0; i < groups.length; i++) {
    var displacement = groups[i].visible[id2];
    if (displacement) {
      return displacement;
    }
  }
  return null;
}
var speculativelyIncrease = function(_ref) {
  var impact = _ref.impact, viewport2 = _ref.viewport, destination = _ref.destination, draggables = _ref.draggables, maxScrollChange = _ref.maxScrollChange;
  var scrolledViewport = scrollViewport(viewport2, add(viewport2.scroll.current, maxScrollChange));
  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
  var last = impact.displaced;
  var withViewportScroll = getDisplacementGroups({
    afterDragging: getDraggables(last.all, draggables),
    destination,
    displacedBy: impact.displacedBy,
    viewport: scrolledViewport.frame,
    last,
    forceShouldAnimate: false
  });
  var withDroppableScroll2 = getDisplacementGroups({
    afterDragging: getDraggables(last.all, draggables),
    destination: scrolledDroppable,
    displacedBy: impact.displacedBy,
    viewport: viewport2.frame,
    last,
    forceShouldAnimate: false
  });
  var invisible = {};
  var visible = {};
  var groups = [last, withViewportScroll, withDroppableScroll2];
  last.all.forEach(function(id2) {
    var displacement = tryGetVisible(id2, groups);
    if (displacement) {
      visible[id2] = displacement;
      return;
    }
    invisible[id2] = true;
  });
  var newImpact = _extends$8({}, impact, {
    displaced: {
      all: last.all,
      invisible,
      visible
    }
  });
  return newImpact;
};
var withViewportDisplacement = function(viewport2, point) {
  return add(viewport2.scroll.diff.displacement, point);
};
var getClientFromPageBorderBoxCenter = function(_ref) {
  var pageBorderBoxCenter = _ref.pageBorderBoxCenter, draggable2 = _ref.draggable, viewport2 = _ref.viewport;
  var withoutPageScrollChange = withViewportDisplacement(viewport2, pageBorderBoxCenter);
  var offset3 = subtract(withoutPageScrollChange, draggable2.page.borderBox.center);
  return add(draggable2.client.borderBox.center, offset3);
};
var isTotallyVisibleInNewLocation = function(_ref) {
  var draggable2 = _ref.draggable, destination = _ref.destination, newPageBorderBoxCenter = _ref.newPageBorderBoxCenter, viewport2 = _ref.viewport, withDroppableDisplacement2 = _ref.withDroppableDisplacement, _ref$onlyOnMainAxis = _ref.onlyOnMainAxis, onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;
  var changeNeeded = subtract(newPageBorderBoxCenter, draggable2.page.borderBox.center);
  var shifted = offsetByPosition(draggable2.page.borderBox, changeNeeded);
  var args = {
    target: shifted,
    destination,
    withDroppableDisplacement: withDroppableDisplacement2,
    viewport: viewport2
  };
  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
};
var moveToNextPlace = function(_ref) {
  var isMovingForward = _ref.isMovingForward, draggable2 = _ref.draggable, destination = _ref.destination, draggables = _ref.draggables, previousImpact = _ref.previousImpact, viewport2 = _ref.viewport, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, previousClientSelection = _ref.previousClientSelection, afterCritical = _ref.afterCritical;
  if (!destination.isEnabled) {
    return null;
  }
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var isInHomeList = isHomeOf(draggable2, destination);
  var impact = moveToNextCombine({
    isMovingForward,
    draggable: draggable2,
    destination,
    insideDestination,
    previousImpact
  }) || moveToNextIndex({
    isMovingForward,
    isInHomeList,
    draggable: draggable2,
    draggables,
    destination,
    insideDestination,
    previousImpact,
    viewport: viewport2,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
    draggable: draggable2,
    destination,
    newPageBorderBoxCenter: pageBorderBoxCenter,
    viewport: viewport2.frame,
    withDroppableDisplacement: false,
    onlyOnMainAxis: true
  });
  if (isVisibleInNewLocation) {
    var clientSelection = getClientFromPageBorderBoxCenter({
      pageBorderBoxCenter,
      draggable: draggable2,
      viewport: viewport2
    });
    return {
      clientSelection,
      impact,
      scrollJumpRequest: null
    };
  }
  var distance3 = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
  var cautious = speculativelyIncrease({
    impact,
    viewport: viewport2,
    destination,
    draggables,
    maxScrollChange: distance3
  });
  return {
    clientSelection: previousClientSelection,
    impact: cautious,
    scrollJumpRequest: distance3
  };
};
var getKnownActive = function getKnownActive2(droppable2) {
  var rect = droppable2.subject.active;
  !rect ? invariant(false) : void 0;
  return rect;
};
var getBestCrossAxisDroppable = function(_ref) {
  var isMovingForward = _ref.isMovingForward, pageBorderBoxCenter = _ref.pageBorderBoxCenter, source = _ref.source, droppables = _ref.droppables, viewport2 = _ref.viewport;
  var active = source.subject.active;
  if (!active) {
    return null;
  }
  var axis = source.axis;
  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
  var candidates = toDroppableList(droppables).filter(function(droppable2) {
    return droppable2 !== source;
  }).filter(function(droppable2) {
    return droppable2.isEnabled;
  }).filter(function(droppable2) {
    return Boolean(droppable2.subject.active);
  }).filter(function(droppable2) {
    return isPartiallyVisibleThroughFrame(viewport2.frame)(getKnownActive(droppable2));
  }).filter(function(droppable2) {
    var activeOfTarget = getKnownActive(droppable2);
    if (isMovingForward) {
      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
    }
    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
  }).filter(function(droppable2) {
    var activeOfTarget = getKnownActive(droppable2);
    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
  }).sort(function(a2, b2) {
    var first = getKnownActive(a2)[axis.crossAxisStart];
    var second = getKnownActive(b2)[axis.crossAxisStart];
    if (isMovingForward) {
      return first - second;
    }
    return second - first;
  }).filter(function(droppable2, index2, array) {
    return getKnownActive(droppable2)[axis.crossAxisStart] === getKnownActive(array[0])[axis.crossAxisStart];
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0];
  }
  var contains2 = candidates.filter(function(droppable2) {
    var isWithinDroppable = isWithin(getKnownActive(droppable2)[axis.start], getKnownActive(droppable2)[axis.end]);
    return isWithinDroppable(pageBorderBoxCenter[axis.line]);
  });
  if (contains2.length === 1) {
    return contains2[0];
  }
  if (contains2.length > 1) {
    return contains2.sort(function(a2, b2) {
      return getKnownActive(a2)[axis.start] - getKnownActive(b2)[axis.start];
    })[0];
  }
  return candidates.sort(function(a2, b2) {
    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a2)));
    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b2)));
    if (first !== second) {
      return first - second;
    }
    return getKnownActive(a2)[axis.start] - getKnownActive(b2)[axis.start];
  })[0];
};
var getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter2(draggable2, afterCritical) {
  var original = draggable2.page.borderBox.center;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
};
var getCurrentPageBorderBox = function getCurrentPageBorderBox2(draggable2, afterCritical) {
  var original = draggable2.page.borderBox;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
};
var getClosestDraggable = function(_ref) {
  var pageBorderBoxCenter = _ref.pageBorderBoxCenter, viewport2 = _ref.viewport, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;
  var sorted = insideDestination.filter(function(draggable2) {
    return isTotallyVisible({
      target: getCurrentPageBorderBox(draggable2, afterCritical),
      destination,
      viewport: viewport2.frame,
      withDroppableDisplacement: true
    });
  }).sort(function(a2, b2) {
    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a2, afterCritical)));
    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b2, afterCritical)));
    if (distanceToA < distanceToB) {
      return -1;
    }
    if (distanceToB < distanceToA) {
      return 1;
    }
    return a2.descriptor.index - b2.descriptor.index;
  });
  return sorted[0] || null;
};
var getDisplacedBy = memoizeOne(function getDisplacedBy2(axis, displaceBy) {
  var displacement = displaceBy[axis.line];
  return {
    value: displacement,
    point: patch(axis.line, displacement)
  };
});
var getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder2(droppable2, placeholderSize, draggables) {
  var axis = droppable2.axis;
  if (droppable2.descriptor.mode === "virtual") {
    return patch(axis.line, placeholderSize[axis.line]);
  }
  var availableSpace = droppable2.subject.page.contentBox[axis.size];
  var insideDroppable = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  var spaceUsed = insideDroppable.reduce(function(sum, dimension) {
    return sum + dimension.client.marginBox[axis.size];
  }, 0);
  var requiredSpace = spaceUsed + placeholderSize[axis.line];
  var needsToGrowBy = requiredSpace - availableSpace;
  if (needsToGrowBy <= 0) {
    return null;
  }
  return patch(axis.line, needsToGrowBy);
};
var withMaxScroll = function withMaxScroll2(frame, max2) {
  return _extends$8({}, frame, {
    scroll: _extends$8({}, frame.scroll, {
      max: max2
    })
  });
};
var addPlaceholder = function addPlaceholder2(droppable2, draggable2, draggables) {
  var frame = droppable2.frame;
  !!isHomeOf(draggable2, droppable2) ? invariant(false) : void 0;
  !!droppable2.subject.withPlaceholder ? invariant(false) : void 0;
  var placeholderSize = getDisplacedBy(droppable2.axis, draggable2.displaceBy).point;
  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable2, placeholderSize, draggables);
  var added = {
    placeholderSize,
    increasedBy: requiredGrowth,
    oldFrameMaxScroll: droppable2.frame ? droppable2.frame.scroll.max : null
  };
  if (!frame) {
    var _subject = getSubject({
      page: droppable2.subject.page,
      withPlaceholder: added,
      axis: droppable2.axis,
      frame: droppable2.frame
    });
    return _extends$8({}, droppable2, {
      subject: _subject
    });
  }
  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
  var newFrame = withMaxScroll(frame, maxScroll);
  var subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: added,
    axis: droppable2.axis,
    frame: newFrame
  });
  return _extends$8({}, droppable2, {
    subject,
    frame: newFrame
  });
};
var removePlaceholder = function removePlaceholder2(droppable2) {
  var added = droppable2.subject.withPlaceholder;
  !added ? invariant(false) : void 0;
  var frame = droppable2.frame;
  if (!frame) {
    var _subject2 = getSubject({
      page: droppable2.subject.page,
      axis: droppable2.axis,
      frame: null,
      withPlaceholder: null
    });
    return _extends$8({}, droppable2, {
      subject: _subject2
    });
  }
  var oldMaxScroll = added.oldFrameMaxScroll;
  !oldMaxScroll ? invariant(false) : void 0;
  var newFrame = withMaxScroll(frame, oldMaxScroll);
  var subject = getSubject({
    page: droppable2.subject.page,
    axis: droppable2.axis,
    frame: newFrame,
    withPlaceholder: null
  });
  return _extends$8({}, droppable2, {
    subject,
    frame: newFrame
  });
};
var moveToNewDroppable = function(_ref) {
  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, moveRelativeTo = _ref.moveRelativeTo, insideDestination = _ref.insideDestination, draggable2 = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, viewport2 = _ref.viewport, afterCritical = _ref.afterCritical;
  if (!moveRelativeTo) {
    if (insideDestination.length) {
      return null;
    }
    var proposed = {
      displaced: emptyGroups,
      displacedBy: noDisplacedBy,
      at: {
        type: "REORDER",
        destination: {
          droppableId: destination.descriptor.id,
          index: 0
        }
      }
    };
    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
      impact: proposed,
      draggable: draggable2,
      droppable: destination,
      draggables,
      afterCritical
    });
    var withPlaceholder = isHomeOf(draggable2, destination) ? destination : addPlaceholder(destination, draggable2, draggables);
    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
      draggable: draggable2,
      destination: withPlaceholder,
      newPageBorderBoxCenter: proposedPageBorderBoxCenter,
      viewport: viewport2.frame,
      withDroppableDisplacement: false,
      onlyOnMainAxis: true
    });
    return isVisibleInNewLocation ? proposed : null;
  }
  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
  var proposedIndex = function() {
    var relativeTo = moveRelativeTo.descriptor.index;
    if (moveRelativeTo.descriptor.id === draggable2.descriptor.id) {
      return relativeTo;
    }
    if (isGoingBeforeTarget) {
      return relativeTo;
    }
    return relativeTo + 1;
  }();
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    displacedBy,
    last: emptyGroups,
    index: proposedIndex
  });
};
var moveCrossAxis = function(_ref) {
  var isMovingForward = _ref.isMovingForward, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, draggable2 = _ref.draggable, isOver = _ref.isOver, draggables = _ref.draggables, droppables = _ref.droppables, viewport2 = _ref.viewport, afterCritical = _ref.afterCritical;
  var destination = getBestCrossAxisDroppable({
    isMovingForward,
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    source: isOver,
    droppables,
    viewport: viewport2
  });
  if (!destination) {
    return null;
  }
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var moveRelativeTo = getClosestDraggable({
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    viewport: viewport2,
    destination,
    insideDestination,
    afterCritical
  });
  var impact = moveToNewDroppable({
    previousPageBorderBoxCenter,
    destination,
    draggable: draggable2,
    draggables,
    moveRelativeTo,
    insideDestination,
    viewport: viewport2,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  var clientSelection = getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport: viewport2
  });
  return {
    clientSelection,
    impact,
    scrollJumpRequest: null
  };
};
var whatIsDraggedOver = function(impact) {
  var at = impact.at;
  if (!at) {
    return null;
  }
  if (at.type === "REORDER") {
    return at.destination.droppableId;
  }
  return at.combine.droppableId;
};
var getDroppableOver = function getDroppableOver2(impact, droppables) {
  var id2 = whatIsDraggedOver(impact);
  return id2 ? droppables[id2] : null;
};
var moveInDirection = function(_ref) {
  var state = _ref.state, type2 = _ref.type;
  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);
  var isMainAxisMovementAllowed = Boolean(isActuallyOver);
  var home2 = state.dimensions.droppables[state.critical.droppable.id];
  var isOver = isActuallyOver || home2;
  var direction = isOver.axis.direction;
  var isMovingOnMainAxis = direction === "vertical" && (type2 === "MOVE_UP" || type2 === "MOVE_DOWN") || direction === "horizontal" && (type2 === "MOVE_LEFT" || type2 === "MOVE_RIGHT");
  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
    return null;
  }
  var isMovingForward = type2 === "MOVE_DOWN" || type2 === "MOVE_RIGHT";
  var draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
  var _state$dimensions = state.dimensions, draggables = _state$dimensions.draggables, droppables = _state$dimensions.droppables;
  return isMovingOnMainAxis ? moveToNextPlace({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    destination: isOver,
    draggables,
    viewport: state.viewport,
    previousClientSelection: state.current.client.selection,
    previousImpact: state.impact,
    afterCritical: state.afterCritical
  }) : moveCrossAxis({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    isOver,
    draggables,
    droppables,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
};
function isMovementAllowed(state) {
  return state.phase === "DRAGGING" || state.phase === "COLLECTING";
}
function isPositionInFrame(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function run6(point) {
    return isWithinVertical(point.y) && isWithinHorizontal(point.x);
  };
}
function getHasOverlap(first, second) {
  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;
}
function getFurthestAway(_ref) {
  var pageBorderBox = _ref.pageBorderBox, draggable2 = _ref.draggable, candidates = _ref.candidates;
  var startCenter = draggable2.page.borderBox.center;
  var sorted = candidates.map(function(candidate) {
    var axis = candidate.axis;
    var target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
    return {
      id: candidate.descriptor.id,
      distance: distance(startCenter, target)
    };
  }).sort(function(a2, b2) {
    return b2.distance - a2.distance;
  });
  return sorted[0] ? sorted[0].id : null;
}
function getDroppableOver$1(_ref2) {
  var pageBorderBox = _ref2.pageBorderBox, draggable2 = _ref2.draggable, droppables = _ref2.droppables;
  var candidates = toDroppableList(droppables).filter(function(item) {
    if (!item.isEnabled) {
      return false;
    }
    var active = item.subject.active;
    if (!active) {
      return false;
    }
    if (!getHasOverlap(pageBorderBox, active)) {
      return false;
    }
    if (isPositionInFrame(active)(pageBorderBox.center)) {
      return true;
    }
    var axis = item.axis;
    var childCenter = active.center[axis.crossAxisLine];
    var crossAxisStart = pageBorderBox[axis.crossAxisStart];
    var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
    var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
    var isStartContained = isContained(crossAxisStart);
    var isEndContained = isContained(crossAxisEnd);
    if (!isStartContained && !isEndContained) {
      return true;
    }
    if (isStartContained) {
      return crossAxisStart < childCenter;
    }
    return crossAxisEnd > childCenter;
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0].descriptor.id;
  }
  return getFurthestAway({
    pageBorderBox,
    draggable: draggable2,
    candidates
  });
}
var offsetRectByPosition = function offsetRectByPosition2(rect, point) {
  return getRect(offsetByPosition(rect, point));
};
var withDroppableScroll = function(droppable2, area) {
  var frame = droppable2.frame;
  if (!frame) {
    return area;
  }
  return offsetRectByPosition(area, frame.scroll.diff.value);
};
function getIsDisplaced(_ref) {
  var displaced = _ref.displaced, id2 = _ref.id;
  return Boolean(displaced.visible[id2] || displaced.invisible[id2]);
}
function atIndex(_ref) {
  var draggable2 = _ref.draggable, closest3 = _ref.closest, inHomeList = _ref.inHomeList;
  if (!closest3) {
    return null;
  }
  if (!inHomeList) {
    return closest3.descriptor.index;
  }
  if (closest3.descriptor.index > draggable2.descriptor.index) {
    return closest3.descriptor.index - 1;
  }
  return closest3.descriptor.index;
}
var getReorderImpact = function(_ref2) {
  var targetRect = _ref2.pageBorderBoxWithDroppableScroll, draggable2 = _ref2.draggable, destination = _ref2.destination, insideDestination = _ref2.insideDestination, last = _ref2.last, viewport2 = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var closest3 = find(withoutDragging, function(child) {
    var id2 = child.descriptor.id;
    var childCenter = child.page.borderBox.center[axis.line];
    var didStartAfterCritical$1 = didStartAfterCritical(id2, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: last,
      id: id2
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd <= childCenter;
      }
      return targetStart < childCenter - displacement;
    }
    if (isDisplaced) {
      return targetEnd <= childCenter + displacement;
    }
    return targetStart < childCenter;
  });
  var newIndex = atIndex({
    draggable: draggable2,
    closest: closest3,
    inHomeList: isHomeOf(draggable2, destination)
  });
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport: viewport2,
    last,
    displacedBy,
    index: newIndex
  });
};
var combineThresholdDivisor = 4;
var getCombineImpact = function(_ref) {
  var draggable2 = _ref.draggable, targetRect = _ref.pageBorderBoxWithDroppableScroll, previousImpact = _ref.previousImpact, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var combineWith = find(withoutDragging, function(child) {
    var id2 = child.descriptor.id;
    var childRect = child.page.borderBox;
    var childSize = childRect[axis.size];
    var threshold = childSize / combineThresholdDivisor;
    var didStartAfterCritical$1 = didStartAfterCritical(id2, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: previousImpact.displaced,
      id: id2
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
      }
      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
    }
    if (isDisplaced) {
      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
    }
    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
  });
  if (!combineWith) {
    return null;
  }
  var impact = {
    displacedBy,
    displaced: previousImpact.displaced,
    at: {
      type: "COMBINE",
      combine: {
        draggableId: combineWith.descriptor.id,
        droppableId: destination.descriptor.id
      }
    }
  };
  return impact;
};
var getDragImpact = function(_ref) {
  var pageOffset = _ref.pageOffset, draggable2 = _ref.draggable, draggables = _ref.draggables, droppables = _ref.droppables, previousImpact = _ref.previousImpact, viewport2 = _ref.viewport, afterCritical = _ref.afterCritical;
  var pageBorderBox = offsetRectByPosition(draggable2.page.borderBox, pageOffset);
  var destinationId = getDroppableOver$1({
    pageBorderBox,
    draggable: draggable2,
    droppables
  });
  if (!destinationId) {
    return noImpact;
  }
  var destination = droppables[destinationId];
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
  return getCombineImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    previousImpact,
    destination,
    insideDestination,
    afterCritical
  }) || getReorderImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    destination,
    insideDestination,
    last: previousImpact.displaced,
    viewport: viewport2,
    afterCritical
  });
};
var patchDroppableMap = function(droppables, updated) {
  var _extends2;
  return _extends$8({}, droppables, (_extends2 = {}, _extends2[updated.descriptor.id] = updated, _extends2));
};
var clearUnusedPlaceholder = function clearUnusedPlaceholder2(_ref) {
  var previousImpact = _ref.previousImpact, impact = _ref.impact, droppables = _ref.droppables;
  var last = whatIsDraggedOver(previousImpact);
  var now = whatIsDraggedOver(impact);
  if (!last) {
    return droppables;
  }
  if (last === now) {
    return droppables;
  }
  var lastDroppable = droppables[last];
  if (!lastDroppable.subject.withPlaceholder) {
    return droppables;
  }
  var updated = removePlaceholder(lastDroppable);
  return patchDroppableMap(droppables, updated);
};
var recomputePlaceholders = function(_ref2) {
  var draggable2 = _ref2.draggable, draggables = _ref2.draggables, droppables = _ref2.droppables, previousImpact = _ref2.previousImpact, impact = _ref2.impact;
  var cleaned = clearUnusedPlaceholder({
    previousImpact,
    impact,
    droppables
  });
  var isOver = whatIsDraggedOver(impact);
  if (!isOver) {
    return cleaned;
  }
  var droppable2 = droppables[isOver];
  if (isHomeOf(draggable2, droppable2)) {
    return cleaned;
  }
  if (droppable2.subject.withPlaceholder) {
    return cleaned;
  }
  var patched = addPlaceholder(droppable2, draggable2, draggables);
  return patchDroppableMap(cleaned, patched);
};
var update = function(_ref) {
  var state = _ref.state, forcedClientSelection = _ref.clientSelection, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport, forcedImpact = _ref.impact, scrollJumpRequest = _ref.scrollJumpRequest;
  var viewport2 = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var clientSelection = forcedClientSelection || state.current.client.selection;
  var offset3 = subtract(clientSelection, state.initial.client.selection);
  var client = {
    offset: offset3,
    selection: clientSelection,
    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset3)
  };
  var page = {
    selection: add(client.selection, viewport2.scroll.current),
    borderBoxCenter: add(client.borderBoxCenter, viewport2.scroll.current),
    offset: add(client.offset, viewport2.scroll.diff.value)
  };
  var current = {
    client,
    page
  };
  if (state.phase === "COLLECTING") {
    return _extends$8({
      phase: "COLLECTING"
    }, state, {
      dimensions,
      viewport: viewport2,
      current
    });
  }
  var draggable2 = dimensions.draggables[state.critical.draggable.id];
  var newImpact = forcedImpact || getDragImpact({
    pageOffset: page.offset,
    draggable: draggable2,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: state.impact,
    viewport: viewport2,
    afterCritical: state.afterCritical
  });
  var withUpdatedPlaceholders = recomputePlaceholders({
    draggable: draggable2,
    impact: newImpact,
    previousImpact: state.impact,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables
  });
  var result = _extends$8({}, state, {
    current,
    dimensions: {
      draggables: dimensions.draggables,
      droppables: withUpdatedPlaceholders
    },
    impact: newImpact,
    viewport: viewport2,
    scrollJumpRequest: scrollJumpRequest || null,
    forceShouldAnimate: scrollJumpRequest ? false : null
  });
  return result;
};
function getDraggables$1(ids, draggables) {
  return ids.map(function(id2) {
    return draggables[id2];
  });
}
var recompute = function(_ref) {
  var impact = _ref.impact, viewport2 = _ref.viewport, draggables = _ref.draggables, destination = _ref.destination, forceShouldAnimate = _ref.forceShouldAnimate;
  var last = impact.displaced;
  var afterDragging = getDraggables$1(last.all, draggables);
  var displaced = getDisplacementGroups({
    afterDragging,
    destination,
    displacedBy: impact.displacedBy,
    viewport: viewport2.frame,
    forceShouldAnimate,
    last
  });
  return _extends$8({}, impact, {
    displaced
  });
};
var getClientBorderBoxCenter = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, droppable2 = _ref.droppable, draggables = _ref.draggables, viewport2 = _ref.viewport, afterCritical = _ref.afterCritical;
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    draggables,
    droppable: droppable2,
    afterCritical
  });
  return getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport: viewport2
  });
};
var refreshSnap = function(_ref) {
  var state = _ref.state, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport;
  !(state.movementMode === "SNAP") ? invariant(false) : void 0;
  var needsVisibilityCheck = state.impact;
  var viewport2 = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var draggables = dimensions.draggables, droppables = dimensions.droppables;
  var draggable2 = draggables[state.critical.draggable.id];
  var isOver = whatIsDraggedOver(needsVisibilityCheck);
  !isOver ? invariant(false) : void 0;
  var destination = droppables[isOver];
  var impact = recompute({
    impact: needsVisibilityCheck,
    viewport: viewport2,
    destination,
    draggables
  });
  var clientSelection = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    viewport: viewport2,
    afterCritical: state.afterCritical
  });
  return update({
    impact,
    clientSelection,
    state,
    dimensions,
    viewport: viewport2
  });
};
var getHomeLocation = function(descriptor) {
  return {
    index: descriptor.index,
    droppableId: descriptor.droppableId
  };
};
var getLiftEffect = function(_ref) {
  var draggable2 = _ref.draggable, home2 = _ref.home, draggables = _ref.draggables, viewport2 = _ref.viewport;
  var displacedBy = getDisplacedBy(home2.axis, draggable2.displaceBy);
  var insideHome = getDraggablesInsideDroppable(home2.descriptor.id, draggables);
  var rawIndex = insideHome.indexOf(draggable2);
  !(rawIndex !== -1) ? invariant(false) : void 0;
  var afterDragging = insideHome.slice(rawIndex + 1);
  var effected = afterDragging.reduce(function(previous, item) {
    previous[item.descriptor.id] = true;
    return previous;
  }, {});
  var afterCritical = {
    inVirtualList: home2.descriptor.mode === "virtual",
    displacedBy,
    effected
  };
  var displaced = getDisplacementGroups({
    afterDragging,
    destination: home2,
    displacedBy,
    last: null,
    viewport: viewport2.frame,
    forceShouldAnimate: false
  });
  var impact = {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: getHomeLocation(draggable2.descriptor)
    }
  };
  return {
    impact,
    afterCritical
  };
};
var patchDimensionMap = function(dimensions, updated) {
  return {
    draggables: dimensions.draggables,
    droppables: patchDroppableMap(dimensions.droppables, updated)
  };
};
var offsetDraggable = function(_ref) {
  var draggable2 = _ref.draggable, offset$12 = _ref.offset, initialWindowScroll = _ref.initialWindowScroll;
  var client = offset(draggable2.client, offset$12);
  var page = withScroll(client, initialWindowScroll);
  var moved = _extends$8({}, draggable2, {
    placeholder: _extends$8({}, draggable2.placeholder, {
      client
    }),
    client,
    page
  });
  return moved;
};
var getFrame = function(droppable2) {
  var frame = droppable2.frame;
  !frame ? invariant(false) : void 0;
  return frame;
};
var adjustAdditionsForScrollChanges = function(_ref) {
  var additions = _ref.additions, updatedDroppables = _ref.updatedDroppables, viewport2 = _ref.viewport;
  var windowScrollChange = viewport2.scroll.diff.value;
  return additions.map(function(draggable2) {
    var droppableId = draggable2.descriptor.droppableId;
    var modified = updatedDroppables[droppableId];
    var frame = getFrame(modified);
    var droppableScrollChange = frame.scroll.diff.value;
    var totalChange = add(windowScrollChange, droppableScrollChange);
    var moved = offsetDraggable({
      draggable: draggable2,
      offset: totalChange,
      initialWindowScroll: viewport2.scroll.initial
    });
    return moved;
  });
};
var publishWhileDraggingInVirtual = function(_ref) {
  var state = _ref.state, published = _ref.published;
  var withScrollChange = published.modified.map(function(update2) {
    var existing = state.dimensions.droppables[update2.droppableId];
    var scrolled = scrollDroppable(existing, update2.scroll);
    return scrolled;
  });
  var droppables = _extends$8({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));
  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
    additions: published.additions,
    updatedDroppables: droppables,
    viewport: state.viewport
  }));
  var draggables = _extends$8({}, state.dimensions.draggables, {}, updatedAdditions);
  published.removals.forEach(function(id2) {
    delete draggables[id2];
  });
  var dimensions = {
    droppables,
    draggables
  };
  var wasOverId = whatIsDraggedOver(state.impact);
  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
  var draggable2 = dimensions.draggables[state.critical.draggable.id];
  var home2 = dimensions.droppables[state.critical.droppable.id];
  var _getLiftEffect = getLiftEffect({
    draggable: draggable2,
    home: home2,
    draggables,
    viewport: state.viewport
  }), onLiftImpact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;
  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
  var impact = getDragImpact({
    pageOffset: state.current.page.offset,
    draggable: dimensions.draggables[state.critical.draggable.id],
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact,
    viewport: state.viewport,
    afterCritical
  });
  var draggingState = _extends$8({
    phase: "DRAGGING"
  }, state, {
    phase: "DRAGGING",
    impact,
    onLiftImpact,
    dimensions,
    afterCritical,
    forceShouldAnimate: false
  });
  if (state.phase === "COLLECTING") {
    return draggingState;
  }
  var dropPending3 = _extends$8({
    phase: "DROP_PENDING"
  }, draggingState, {
    phase: "DROP_PENDING",
    reason: state.reason,
    isWaiting: false
  });
  return dropPending3;
};
var isSnapping = function isSnapping2(state) {
  return state.movementMode === "SNAP";
};
var postDroppableChange = function postDroppableChange2(state, updated, isEnabledChanging) {
  var dimensions = patchDimensionMap(state.dimensions, updated);
  if (!isSnapping(state) || isEnabledChanging) {
    return update({
      state,
      dimensions
    });
  }
  return refreshSnap({
    state,
    dimensions
  });
};
function removeScrollJumpRequest(state) {
  if (state.isDragging && state.movementMode === "SNAP") {
    return _extends$8({
      phase: "DRAGGING"
    }, state, {
      scrollJumpRequest: null
    });
  }
  return state;
}
var idle = {
  phase: "IDLE",
  completed: null,
  shouldFlush: false
};
var reducer = function(state, action) {
  if (state === void 0) {
    state = idle;
  }
  if (action.type === "FLUSH") {
    return _extends$8({}, idle, {
      shouldFlush: true
    });
  }
  if (action.type === "INITIAL_PUBLISH") {
    !(state.phase === "IDLE") ? invariant(false) : void 0;
    var _action$payload = action.payload, critical = _action$payload.critical, clientSelection = _action$payload.clientSelection, viewport2 = _action$payload.viewport, dimensions = _action$payload.dimensions, movementMode = _action$payload.movementMode;
    var draggable2 = dimensions.draggables[critical.draggable.id];
    var home2 = dimensions.droppables[critical.droppable.id];
    var client = {
      selection: clientSelection,
      borderBoxCenter: draggable2.client.borderBox.center,
      offset: origin
    };
    var initial = {
      client,
      page: {
        selection: add(client.selection, viewport2.scroll.initial),
        borderBoxCenter: add(client.selection, viewport2.scroll.initial),
        offset: add(client.selection, viewport2.scroll.diff.value)
      }
    };
    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function(item) {
      return !item.isFixedOnPage;
    });
    var _getLiftEffect = getLiftEffect({
      draggable: draggable2,
      home: home2,
      draggables: dimensions.draggables,
      viewport: viewport2
    }), impact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;
    var result = {
      phase: "DRAGGING",
      isDragging: true,
      critical,
      movementMode,
      dimensions,
      initial,
      current: initial,
      isWindowScrollAllowed,
      impact,
      afterCritical,
      onLiftImpact: impact,
      viewport: viewport2,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
    return result;
  }
  if (action.type === "COLLECTION_STARTING") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? invariant(false) : void 0;
    var _result = _extends$8({
      phase: "COLLECTING"
    }, state, {
      phase: "COLLECTING"
    });
    return _result;
  }
  if (action.type === "PUBLISH_WHILE_DRAGGING") {
    !(state.phase === "COLLECTING" || state.phase === "DROP_PENDING") ? invariant(false) : void 0;
    return publishWhileDraggingInVirtual({
      state,
      published: action.payload
    });
  }
  if (action.type === "MOVE") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    var _clientSelection = action.payload.client;
    if (isEqual(_clientSelection, state.current.client.selection)) {
      return state;
    }
    return update({
      state,
      clientSelection: _clientSelection,
      impact: isSnapping(state) ? state.impact : null
    });
  }
  if (action.type === "UPDATE_DROPPABLE_SCROLL") {
    if (state.phase === "DROP_PENDING") {
      return removeScrollJumpRequest(state);
    }
    if (state.phase === "COLLECTING") {
      return removeScrollJumpRequest(state);
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    var _action$payload2 = action.payload, id2 = _action$payload2.id, newScroll = _action$payload2.newScroll;
    var target = state.dimensions.droppables[id2];
    if (!target) {
      return state;
    }
    var scrolled = scrollDroppable(target, newScroll);
    return postDroppableChange(state, scrolled, false);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    var _action$payload3 = action.payload, _id = _action$payload3.id, isEnabled3 = _action$payload3.isEnabled;
    var _target = state.dimensions.droppables[_id];
    !_target ? invariant(false) : void 0;
    !(_target.isEnabled !== isEnabled3) ? invariant(false) : void 0;
    var updated = _extends$8({}, _target, {
      isEnabled: isEnabled3
    });
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_COMBINE_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    var _action$payload4 = action.payload, _id2 = _action$payload4.id, isCombineEnabled = _action$payload4.isCombineEnabled;
    var _target2 = state.dimensions.droppables[_id2];
    !_target2 ? invariant(false) : void 0;
    !(_target2.isCombineEnabled !== isCombineEnabled) ? invariant(false) : void 0;
    var _updated = _extends$8({}, _target2, {
      isCombineEnabled
    });
    return postDroppableChange(state, _updated, true);
  }
  if (action.type === "MOVE_BY_WINDOW_SCROLL") {
    if (state.phase === "DROP_PENDING" || state.phase === "DROP_ANIMATING") {
      return state;
    }
    !isMovementAllowed(state) ? invariant(false) : void 0;
    !state.isWindowScrollAllowed ? invariant(false) : void 0;
    var _newScroll = action.payload.newScroll;
    if (isEqual(state.viewport.scroll.current, _newScroll)) {
      return removeScrollJumpRequest(state);
    }
    var _viewport = scrollViewport(state.viewport, _newScroll);
    if (isSnapping(state)) {
      return refreshSnap({
        state,
        viewport: _viewport
      });
    }
    return update({
      state,
      viewport: _viewport
    });
  }
  if (action.type === "UPDATE_VIEWPORT_MAX_SCROLL") {
    if (!isMovementAllowed(state)) {
      return state;
    }
    var maxScroll = action.payload.maxScroll;
    if (isEqual(maxScroll, state.viewport.scroll.max)) {
      return state;
    }
    var withMaxScroll3 = _extends$8({}, state.viewport, {
      scroll: _extends$8({}, state.viewport.scroll, {
        max: maxScroll
      })
    });
    return _extends$8({
      phase: "DRAGGING"
    }, state, {
      viewport: withMaxScroll3
    });
  }
  if (action.type === "MOVE_UP" || action.type === "MOVE_DOWN" || action.type === "MOVE_LEFT" || action.type === "MOVE_RIGHT") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? invariant(false) : void 0;
    var _result2 = moveInDirection({
      state,
      type: action.type
    });
    if (!_result2) {
      return state;
    }
    return update({
      state,
      impact: _result2.impact,
      clientSelection: _result2.clientSelection,
      scrollJumpRequest: _result2.scrollJumpRequest
    });
  }
  if (action.type === "DROP_PENDING") {
    var reason = action.payload.reason;
    !(state.phase === "COLLECTING") ? invariant(false) : void 0;
    var newState = _extends$8({
      phase: "DROP_PENDING"
    }, state, {
      phase: "DROP_PENDING",
      isWaiting: true,
      reason
    });
    return newState;
  }
  if (action.type === "DROP_ANIMATE") {
    var _action$payload5 = action.payload, completed = _action$payload5.completed, dropDuration = _action$payload5.dropDuration, newHomeClientOffset = _action$payload5.newHomeClientOffset;
    !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? invariant(false) : void 0;
    var _result3 = {
      phase: "DROP_ANIMATING",
      completed,
      dropDuration,
      newHomeClientOffset,
      dimensions: state.dimensions
    };
    return _result3;
  }
  if (action.type === "DROP_COMPLETE") {
    var _completed = action.payload.completed;
    return {
      phase: "IDLE",
      completed: _completed,
      shouldFlush: false
    };
  }
  return state;
};
var beforeInitialCapture = function beforeInitialCapture2(args) {
  return {
    type: "BEFORE_INITIAL_CAPTURE",
    payload: args
  };
};
var lift = function lift2(args) {
  return {
    type: "LIFT",
    payload: args
  };
};
var initialPublish = function initialPublish2(args) {
  return {
    type: "INITIAL_PUBLISH",
    payload: args
  };
};
var publishWhileDragging = function publishWhileDragging2(args) {
  return {
    type: "PUBLISH_WHILE_DRAGGING",
    payload: args
  };
};
var collectionStarting = function collectionStarting2() {
  return {
    type: "COLLECTION_STARTING",
    payload: null
  };
};
var updateDroppableScroll = function updateDroppableScroll2(args) {
  return {
    type: "UPDATE_DROPPABLE_SCROLL",
    payload: args
  };
};
var updateDroppableIsEnabled = function updateDroppableIsEnabled2(args) {
  return {
    type: "UPDATE_DROPPABLE_IS_ENABLED",
    payload: args
  };
};
var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled2(args) {
  return {
    type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED",
    payload: args
  };
};
var move = function move2(args) {
  return {
    type: "MOVE",
    payload: args
  };
};
var moveByWindowScroll = function moveByWindowScroll2(args) {
  return {
    type: "MOVE_BY_WINDOW_SCROLL",
    payload: args
  };
};
var updateViewportMaxScroll = function updateViewportMaxScroll2(args) {
  return {
    type: "UPDATE_VIEWPORT_MAX_SCROLL",
    payload: args
  };
};
var moveUp = function moveUp2() {
  return {
    type: "MOVE_UP",
    payload: null
  };
};
var moveDown = function moveDown2() {
  return {
    type: "MOVE_DOWN",
    payload: null
  };
};
var moveRight = function moveRight2() {
  return {
    type: "MOVE_RIGHT",
    payload: null
  };
};
var moveLeft = function moveLeft2() {
  return {
    type: "MOVE_LEFT",
    payload: null
  };
};
var flush = function flush2() {
  return {
    type: "FLUSH",
    payload: null
  };
};
var animateDrop = function animateDrop2(args) {
  return {
    type: "DROP_ANIMATE",
    payload: args
  };
};
var completeDrop = function completeDrop2(args) {
  return {
    type: "DROP_COMPLETE",
    payload: args
  };
};
var drop = function drop2(args) {
  return {
    type: "DROP",
    payload: args
  };
};
var dropPending = function dropPending2(args) {
  return {
    type: "DROP_PENDING",
    payload: args
  };
};
var dropAnimationFinished = function dropAnimationFinished2() {
  return {
    type: "DROP_ANIMATION_FINISHED",
    payload: null
  };
};
var lift$1 = function(marshal) {
  return function(_ref) {
    var getState = _ref.getState, dispatch = _ref.dispatch;
    return function(next2) {
      return function(action) {
        if (action.type !== "LIFT") {
          next2(action);
          return;
        }
        var _action$payload = action.payload, id2 = _action$payload.id, clientSelection = _action$payload.clientSelection, movementMode = _action$payload.movementMode;
        var initial = getState();
        if (initial.phase === "DROP_ANIMATING") {
          dispatch(completeDrop({
            completed: initial.completed
          }));
        }
        !(getState().phase === "IDLE") ? invariant(false) : void 0;
        dispatch(flush());
        dispatch(beforeInitialCapture({
          draggableId: id2,
          movementMode
        }));
        var scrollOptions = {
          shouldPublishImmediately: movementMode === "SNAP"
        };
        var request2 = {
          draggableId: id2,
          scrollOptions
        };
        var _marshal$startPublish = marshal.startPublishing(request2), critical = _marshal$startPublish.critical, dimensions = _marshal$startPublish.dimensions, viewport2 = _marshal$startPublish.viewport;
        dispatch(initialPublish({
          critical,
          dimensions,
          clientSelection,
          movementMode,
          viewport: viewport2
        }));
      };
    };
  };
};
var style = function(marshal) {
  return function() {
    return function(next2) {
      return function(action) {
        if (action.type === "INITIAL_PUBLISH") {
          marshal.dragging();
        }
        if (action.type === "DROP_ANIMATE") {
          marshal.dropping(action.payload.completed.result.reason);
        }
        if (action.type === "FLUSH" || action.type === "DROP_COMPLETE") {
          marshal.resting();
        }
        next2(action);
      };
    };
  };
};
var curves = {
  outOfTheWay: "cubic-bezier(0.2, 0, 0, 1)",
  drop: "cubic-bezier(.2,1,.1,1)"
};
var combine = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
};
var timings = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
};
var outOfTheWayTiming = timings.outOfTheWay + "s " + curves.outOfTheWay;
var transitions = {
  fluid: "opacity " + outOfTheWayTiming,
  snap: "transform " + outOfTheWayTiming + ", opacity " + outOfTheWayTiming,
  drop: function drop3(duration5) {
    var timing = duration5 + "s " + curves.drop;
    return "transform " + timing + ", opacity " + timing;
  },
  outOfTheWay: "transform " + outOfTheWayTiming,
  placeholder: "height " + outOfTheWayTiming + ", width " + outOfTheWayTiming + ", margin " + outOfTheWayTiming
};
var moveTo = function moveTo2(offset3) {
  return isEqual(offset3, origin) ? null : "translate(" + offset3.x + "px, " + offset3.y + "px)";
};
var transforms = {
  moveTo,
  drop: function drop4(offset3, isCombining) {
    var translate = moveTo(offset3);
    if (!translate) {
      return null;
    }
    if (!isCombining) {
      return translate;
    }
    return translate + " scale(" + combine.scale.drop + ")";
  }
};
var minDropTime = timings.minDropTime, maxDropTime = timings.maxDropTime;
var dropTimeRange = maxDropTime - minDropTime;
var maxDropTimeAtDistance = 1500;
var cancelDropModifier = 0.6;
var getDropDuration = function(_ref) {
  var current = _ref.current, destination = _ref.destination, reason = _ref.reason;
  var distance$1 = distance(current, destination);
  if (distance$1 <= 0) {
    return minDropTime;
  }
  if (distance$1 >= maxDropTimeAtDistance) {
    return maxDropTime;
  }
  var percentage = distance$1 / maxDropTimeAtDistance;
  var duration5 = minDropTime + dropTimeRange * percentage;
  var withDuration = reason === "CANCEL" ? duration5 * cancelDropModifier : duration5;
  return Number(withDuration.toFixed(2));
};
var getNewHomeClientOffset = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, dimensions = _ref.dimensions, viewport2 = _ref.viewport, afterCritical = _ref.afterCritical;
  var draggables = dimensions.draggables, droppables = dimensions.droppables;
  var droppableId = whatIsDraggedOver(impact);
  var destination = droppableId ? droppables[droppableId] : null;
  var home2 = droppables[draggable2.descriptor.droppableId];
  var newClientCenter = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    draggables,
    afterCritical,
    droppable: destination || home2,
    viewport: viewport2
  });
  var offset3 = subtract(newClientCenter, draggable2.client.borderBox.center);
  return offset3;
};
var getDropImpact = function(_ref) {
  var draggables = _ref.draggables, reason = _ref.reason, lastImpact = _ref.lastImpact, home2 = _ref.home, viewport2 = _ref.viewport, onLiftImpact = _ref.onLiftImpact;
  if (!lastImpact.at || reason !== "DROP") {
    var recomputedHomeImpact = recompute({
      draggables,
      impact: onLiftImpact,
      destination: home2,
      viewport: viewport2,
      forceShouldAnimate: true
    });
    return {
      impact: recomputedHomeImpact,
      didDropInsideDroppable: false
    };
  }
  if (lastImpact.at.type === "REORDER") {
    return {
      impact: lastImpact,
      didDropInsideDroppable: true
    };
  }
  var withoutMovement = _extends$8({}, lastImpact, {
    displaced: emptyGroups
  });
  return {
    impact: withoutMovement,
    didDropInsideDroppable: true
  };
};
var drop$1 = function(_ref) {
  var getState = _ref.getState, dispatch = _ref.dispatch;
  return function(next2) {
    return function(action) {
      if (action.type !== "DROP") {
        next2(action);
        return;
      }
      var state = getState();
      var reason = action.payload.reason;
      if (state.phase === "COLLECTING") {
        dispatch(dropPending({
          reason
        }));
        return;
      }
      if (state.phase === "IDLE") {
        return;
      }
      var isWaitingForDrop = state.phase === "DROP_PENDING" && state.isWaiting;
      !!isWaitingForDrop ? invariant(false) : void 0;
      !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? invariant(false) : void 0;
      var critical = state.critical;
      var dimensions = state.dimensions;
      var draggable2 = dimensions.draggables[state.critical.draggable.id];
      var _getDropImpact = getDropImpact({
        reason,
        lastImpact: state.impact,
        afterCritical: state.afterCritical,
        onLiftImpact: state.onLiftImpact,
        home: state.dimensions.droppables[state.critical.droppable.id],
        viewport: state.viewport,
        draggables: state.dimensions.draggables
      }), impact = _getDropImpact.impact, didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;
      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
      var combine2 = didDropInsideDroppable ? tryGetCombine(impact) : null;
      var source = {
        index: critical.draggable.index,
        droppableId: critical.droppable.id
      };
      var result = {
        draggableId: draggable2.descriptor.id,
        type: draggable2.descriptor.type,
        source,
        reason,
        mode: state.movementMode,
        destination,
        combine: combine2
      };
      var newHomeClientOffset = getNewHomeClientOffset({
        impact,
        draggable: draggable2,
        dimensions,
        viewport: state.viewport,
        afterCritical: state.afterCritical
      });
      var completed = {
        critical: state.critical,
        afterCritical: state.afterCritical,
        result,
        impact
      };
      var isAnimationRequired = !isEqual(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
      if (!isAnimationRequired) {
        dispatch(completeDrop({
          completed
        }));
        return;
      }
      var dropDuration = getDropDuration({
        current: state.current.client.offset,
        destination: newHomeClientOffset,
        reason
      });
      var args = {
        newHomeClientOffset,
        dropDuration,
        completed
      };
      dispatch(animateDrop(args));
    };
  };
};
var getWindowScroll2 = function() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
function getWindowScrollBinding(update2) {
  return {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: function fn2(event) {
      if (event.target !== window && event.target !== window.document) {
        return;
      }
      update2();
    }
  };
}
function getScrollListener(_ref) {
  var onWindowScroll = _ref.onWindowScroll;
  function updateScroll() {
    onWindowScroll(getWindowScroll2());
  }
  var scheduled = rafSchd$1(updateScroll);
  var binding = getWindowScrollBinding(scheduled);
  var unbind = noop;
  function isActive() {
    return unbind !== noop;
  }
  function start3() {
    !!isActive() ? invariant(false) : void 0;
    unbind = bindEvents(window, [binding]);
  }
  function stop() {
    !isActive() ? invariant(false) : void 0;
    scheduled.cancel();
    unbind();
    unbind = noop;
  }
  return {
    start: start3,
    stop,
    isActive
  };
}
var shouldEnd = function shouldEnd2(action) {
  return action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATE" || action.type === "FLUSH";
};
var scrollListener = function(store) {
  var listener = getScrollListener({
    onWindowScroll: function onWindowScroll(newScroll) {
      store.dispatch(moveByWindowScroll({
        newScroll
      }));
    }
  });
  return function(next2) {
    return function(action) {
      if (!listener.isActive() && action.type === "INITIAL_PUBLISH") {
        listener.start();
      }
      if (listener.isActive() && shouldEnd(action)) {
        listener.stop();
      }
      next2(action);
    };
  };
};
var getExpiringAnnounce = function(announce) {
  var wasCalled = false;
  var isExpired = false;
  var timeoutId = setTimeout(function() {
    isExpired = true;
  });
  var result = function result2(message) {
    if (wasCalled) {
      return;
    }
    if (isExpired) {
      return;
    }
    wasCalled = true;
    announce(message);
    clearTimeout(timeoutId);
  };
  result.wasCalled = function() {
    return wasCalled;
  };
  return result;
};
var getAsyncMarshal = function() {
  var entries = [];
  var execute3 = function execute4(timerId) {
    var index2 = findIndex2(entries, function(item) {
      return item.timerId === timerId;
    });
    !(index2 !== -1) ? invariant(false) : void 0;
    var _entries$splice = entries.splice(index2, 1), entry = _entries$splice[0];
    entry.callback();
  };
  var add3 = function add4(fn2) {
    var timerId = setTimeout(function() {
      return execute3(timerId);
    });
    var entry = {
      timerId,
      callback: fn2
    };
    entries.push(entry);
  };
  var flush3 = function flush4() {
    if (!entries.length) {
      return;
    }
    var shallow = [].concat(entries);
    entries.length = 0;
    shallow.forEach(function(entry) {
      clearTimeout(entry.timerId);
      entry.callback();
    });
  };
  return {
    add: add3,
    flush: flush3
  };
};
var areLocationsEqual = function areLocationsEqual2(first, second) {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.droppableId === second.droppableId && first.index === second.index;
};
var isCombineEqual = function isCombineEqual2(first, second) {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;
};
var isCriticalEqual = function isCriticalEqual2(first, second) {
  if (first === second) {
    return true;
  }
  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;
  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;
  return isDraggableEqual && isDroppableEqual;
};
var withTimings = function withTimings2(key, fn2) {
  fn2();
};
var getDragStart = function getDragStart2(critical, mode) {
  return {
    draggableId: critical.draggable.id,
    type: critical.droppable.type,
    source: {
      droppableId: critical.droppable.id,
      index: critical.draggable.index
    },
    mode
  };
};
var execute = function execute2(responder, data, announce, getDefaultMessage) {
  if (!responder) {
    announce(getDefaultMessage(data));
    return;
  }
  var willExpire = getExpiringAnnounce(announce);
  var provided = {
    announce: willExpire
  };
  responder(data, provided);
  if (!willExpire.wasCalled()) {
    announce(getDefaultMessage(data));
  }
};
var getPublisher = function(getResponders, announce) {
  var asyncMarshal = getAsyncMarshal();
  var dragging = null;
  var beforeCapture = function beforeCapture2(draggableId, mode) {
    !!dragging ? invariant(false) : void 0;
    withTimings("onBeforeCapture", function() {
      var fn2 = getResponders().onBeforeCapture;
      if (fn2) {
        var before = {
          draggableId,
          mode
        };
        fn2(before);
      }
    });
  };
  var beforeStart = function beforeStart2(critical, mode) {
    !!dragging ? invariant(false) : void 0;
    withTimings("onBeforeDragStart", function() {
      var fn2 = getResponders().onBeforeDragStart;
      if (fn2) {
        fn2(getDragStart(critical, mode));
      }
    });
  };
  var start3 = function start4(critical, mode) {
    !!dragging ? invariant(false) : void 0;
    var data = getDragStart(critical, mode);
    dragging = {
      mode,
      lastCritical: critical,
      lastLocation: data.source,
      lastCombine: null
    };
    asyncMarshal.add(function() {
      withTimings("onDragStart", function() {
        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);
      });
    });
  };
  var update2 = function update3(critical, impact) {
    var location2 = tryGetDestination(impact);
    var combine2 = tryGetCombine(impact);
    !dragging ? invariant(false) : void 0;
    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
    if (hasCriticalChanged) {
      dragging.lastCritical = critical;
    }
    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location2);
    if (hasLocationChanged) {
      dragging.lastLocation = location2;
    }
    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine2);
    if (hasGroupingChanged) {
      dragging.lastCombine = combine2;
    }
    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
      return;
    }
    var data = _extends$8({}, getDragStart(critical, dragging.mode), {
      combine: combine2,
      destination: location2
    });
    asyncMarshal.add(function() {
      withTimings("onDragUpdate", function() {
        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);
      });
    });
  };
  var flush3 = function flush4() {
    !dragging ? invariant(false) : void 0;
    asyncMarshal.flush();
  };
  var drop5 = function drop6(result) {
    !dragging ? invariant(false) : void 0;
    dragging = null;
    withTimings("onDragEnd", function() {
      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);
    });
  };
  var abort2 = function abort3() {
    if (!dragging) {
      return;
    }
    var result = _extends$8({}, getDragStart(dragging.lastCritical, dragging.mode), {
      combine: null,
      destination: null,
      reason: "CANCEL"
    });
    drop5(result);
  };
  return {
    beforeCapture,
    beforeStart,
    start: start3,
    update: update2,
    flush: flush3,
    drop: drop5,
    abort: abort2
  };
};
var responders = function(getResponders, announce) {
  var publisher = getPublisher(getResponders, announce);
  return function(store) {
    return function(next2) {
      return function(action) {
        if (action.type === "BEFORE_INITIAL_CAPTURE") {
          publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
          return;
        }
        if (action.type === "INITIAL_PUBLISH") {
          var critical = action.payload.critical;
          publisher.beforeStart(critical, action.payload.movementMode);
          next2(action);
          publisher.start(critical, action.payload.movementMode);
          return;
        }
        if (action.type === "DROP_COMPLETE") {
          var result = action.payload.completed.result;
          publisher.flush();
          next2(action);
          publisher.drop(result);
          return;
        }
        next2(action);
        if (action.type === "FLUSH") {
          publisher.abort();
          return;
        }
        var state = store.getState();
        if (state.phase === "DRAGGING") {
          publisher.update(state.critical, state.impact);
        }
      };
    };
  };
};
var dropAnimationFinish = function(store) {
  return function(next2) {
    return function(action) {
      if (action.type !== "DROP_ANIMATION_FINISHED") {
        next2(action);
        return;
      }
      var state = store.getState();
      !(state.phase === "DROP_ANIMATING") ? invariant(false) : void 0;
      store.dispatch(completeDrop({
        completed: state.completed
      }));
    };
  };
};
var dropAnimationFlushOnScroll = function(store) {
  var unbind = null;
  var frameId = null;
  function clear2() {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }
    if (unbind) {
      unbind();
      unbind = null;
    }
  }
  return function(next2) {
    return function(action) {
      if (action.type === "FLUSH" || action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATION_FINISHED") {
        clear2();
      }
      next2(action);
      if (action.type !== "DROP_ANIMATE") {
        return;
      }
      var binding = {
        eventName: "scroll",
        options: {
          capture: true,
          passive: false,
          once: true
        },
        fn: function flushDropAnimation() {
          var state = store.getState();
          if (state.phase === "DROP_ANIMATING") {
            store.dispatch(dropAnimationFinished());
          }
        }
      };
      frameId = requestAnimationFrame(function() {
        frameId = null;
        unbind = bindEvents(window, [binding]);
      });
    };
  };
};
var dimensionMarshalStopper = function(marshal) {
  return function() {
    return function(next2) {
      return function(action) {
        if (action.type === "DROP_COMPLETE" || action.type === "FLUSH" || action.type === "DROP_ANIMATE") {
          marshal.stopPublishing();
        }
        next2(action);
      };
    };
  };
};
var focus = function(marshal) {
  var isWatching = false;
  return function() {
    return function(next2) {
      return function(action) {
        if (action.type === "INITIAL_PUBLISH") {
          isWatching = true;
          marshal.tryRecordFocus(action.payload.critical.draggable.id);
          next2(action);
          marshal.tryRestoreFocusRecorded();
          return;
        }
        next2(action);
        if (!isWatching) {
          return;
        }
        if (action.type === "FLUSH") {
          isWatching = false;
          marshal.tryRestoreFocusRecorded();
          return;
        }
        if (action.type === "DROP_COMPLETE") {
          isWatching = false;
          var result = action.payload.completed.result;
          if (result.combine) {
            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
          }
          marshal.tryRestoreFocusRecorded();
        }
      };
    };
  };
};
var shouldStop = function shouldStop2(action) {
  return action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATE" || action.type === "FLUSH";
};
var autoScroll = function(autoScroller) {
  return function(store) {
    return function(next2) {
      return function(action) {
        if (shouldStop(action)) {
          autoScroller.stop();
          next2(action);
          return;
        }
        if (action.type === "INITIAL_PUBLISH") {
          next2(action);
          var state = store.getState();
          !(state.phase === "DRAGGING") ? invariant(false) : void 0;
          autoScroller.start(state);
          return;
        }
        next2(action);
        autoScroller.scroll(store.getState());
      };
    };
  };
};
var pendingDrop = function(store) {
  return function(next2) {
    return function(action) {
      next2(action);
      if (action.type !== "PUBLISH_WHILE_DRAGGING") {
        return;
      }
      var postActionState = store.getState();
      if (postActionState.phase !== "DROP_PENDING") {
        return;
      }
      if (postActionState.isWaiting) {
        return;
      }
      store.dispatch(drop({
        reason: postActionState.reason
      }));
    };
  };
};
var composeEnhancers = compose;
var createStore = function(_ref) {
  var dimensionMarshal = _ref.dimensionMarshal, focusMarshal = _ref.focusMarshal, styleMarshal = _ref.styleMarshal, getResponders = _ref.getResponders, announce = _ref.announce, autoScroller = _ref.autoScroller;
  return createStore$1(reducer, composeEnhancers(applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));
};
var clean$1 = function clean() {
  return {
    additions: {},
    removals: {},
    modified: {}
  };
};
function createPublisher(_ref) {
  var registry = _ref.registry, callbacks = _ref.callbacks;
  var staging = clean$1();
  var frameId = null;
  var collect = function collect2() {
    if (frameId) {
      return;
    }
    callbacks.collectionStarting();
    frameId = requestAnimationFrame(function() {
      frameId = null;
      var _staging = staging, additions = _staging.additions, removals = _staging.removals, modified = _staging.modified;
      var added = Object.keys(additions).map(function(id2) {
        return registry.draggable.getById(id2).getDimension(origin);
      }).sort(function(a2, b2) {
        return a2.descriptor.index - b2.descriptor.index;
      });
      var updated = Object.keys(modified).map(function(id2) {
        var entry = registry.droppable.getById(id2);
        var scroll3 = entry.callbacks.getScrollWhileDragging();
        return {
          droppableId: id2,
          scroll: scroll3
        };
      });
      var result = {
        additions: added,
        removals: Object.keys(removals),
        modified: updated
      };
      staging = clean$1();
      callbacks.publish(result);
    });
  };
  var add3 = function add4(entry) {
    var id2 = entry.descriptor.id;
    staging.additions[id2] = entry;
    staging.modified[entry.descriptor.droppableId] = true;
    if (staging.removals[id2]) {
      delete staging.removals[id2];
    }
    collect();
  };
  var remove2 = function remove3(entry) {
    var descriptor = entry.descriptor;
    staging.removals[descriptor.id] = true;
    staging.modified[descriptor.droppableId] = true;
    if (staging.additions[descriptor.id]) {
      delete staging.additions[descriptor.id];
    }
    collect();
  };
  var stop = function stop2() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
    staging = clean$1();
  };
  return {
    add: add3,
    remove: remove2,
    stop
  };
}
var getMaxScroll = function(_ref) {
  var scrollHeight = _ref.scrollHeight, scrollWidth = _ref.scrollWidth, height3 = _ref.height, width3 = _ref.width;
  var maxScroll = subtract({
    x: scrollWidth,
    y: scrollHeight
  }, {
    x: width3,
    y: height3
  });
  var adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
};
var getDocumentElement = function() {
  var doc = document.documentElement;
  !doc ? invariant(false) : void 0;
  return doc;
};
var getMaxWindowScroll = function() {
  var doc = getDocumentElement();
  var maxScroll = getMaxScroll({
    scrollHeight: doc.scrollHeight,
    scrollWidth: doc.scrollWidth,
    width: doc.clientWidth,
    height: doc.clientHeight
  });
  return maxScroll;
};
var getViewport = function() {
  var scroll3 = getWindowScroll2();
  var maxScroll = getMaxWindowScroll();
  var top2 = scroll3.y;
  var left2 = scroll3.x;
  var doc = getDocumentElement();
  var width3 = doc.clientWidth;
  var height3 = doc.clientHeight;
  var right2 = left2 + width3;
  var bottom2 = top2 + height3;
  var frame = getRect({
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2
  });
  var viewport2 = {
    frame,
    scroll: {
      initial: scroll3,
      current: scroll3,
      max: maxScroll,
      diff: {
        value: origin,
        displacement: origin
      }
    }
  };
  return viewport2;
};
var getInitialPublish = function(_ref) {
  var critical = _ref.critical, scrollOptions = _ref.scrollOptions, registry = _ref.registry;
  var viewport2 = getViewport();
  var windowScroll = viewport2.scroll.current;
  var home2 = critical.droppable;
  var droppables = registry.droppable.getAllByType(home2.type).map(function(entry) {
    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);
  });
  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function(entry) {
    return entry.getDimension(windowScroll);
  });
  var dimensions = {
    draggables: toDraggableMap(draggables),
    droppables: toDroppableMap(droppables)
  };
  var result = {
    dimensions,
    critical,
    viewport: viewport2
  };
  return result;
};
function shouldPublishUpdate(registry, dragging, entry) {
  if (entry.descriptor.id === dragging.id) {
    return false;
  }
  if (entry.descriptor.type !== dragging.type) {
    return false;
  }
  var home2 = registry.droppable.getById(entry.descriptor.droppableId);
  if (home2.descriptor.mode !== "virtual") {
    return false;
  }
  return true;
}
var createDimensionMarshal = function(registry, callbacks) {
  var collection = null;
  var publisher = createPublisher({
    callbacks: {
      publish: callbacks.publishWhileDragging,
      collectionStarting: callbacks.collectionStarting
    },
    registry
  });
  var updateDroppableIsEnabled3 = function updateDroppableIsEnabled4(id2, isEnabled3) {
    !registry.droppable.exists(id2) ? invariant(false) : void 0;
    if (!collection) {
      return;
    }
    callbacks.updateDroppableIsEnabled({
      id: id2,
      isEnabled: isEnabled3
    });
  };
  var updateDroppableIsCombineEnabled3 = function updateDroppableIsCombineEnabled4(id2, isCombineEnabled) {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id2) ? invariant(false) : void 0;
    callbacks.updateDroppableIsCombineEnabled({
      id: id2,
      isCombineEnabled
    });
  };
  var updateDroppableScroll3 = function updateDroppableScroll4(id2, newScroll) {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id2) ? invariant(false) : void 0;
    callbacks.updateDroppableScroll({
      id: id2,
      newScroll
    });
  };
  var scrollDroppable2 = function scrollDroppable3(id2, change) {
    if (!collection) {
      return;
    }
    registry.droppable.getById(id2).callbacks.scroll(change);
  };
  var stopPublishing = function stopPublishing2() {
    if (!collection) {
      return;
    }
    publisher.stop();
    var home2 = collection.critical.droppable;
    registry.droppable.getAllByType(home2.type).forEach(function(entry) {
      return entry.callbacks.dragStopped();
    });
    collection.unsubscribe();
    collection = null;
  };
  var subscriber = function subscriber2(event) {
    !collection ? invariant(false) : void 0;
    var dragging = collection.critical.draggable;
    if (event.type === "ADDITION") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.add(event.value);
      }
    }
    if (event.type === "REMOVAL") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.remove(event.value);
      }
    }
  };
  var startPublishing = function startPublishing2(request2) {
    !!collection ? invariant(false) : void 0;
    var entry = registry.draggable.getById(request2.draggableId);
    var home2 = registry.droppable.getById(entry.descriptor.droppableId);
    var critical = {
      draggable: entry.descriptor,
      droppable: home2.descriptor
    };
    var unsubscribe = registry.subscribe(subscriber);
    collection = {
      critical,
      unsubscribe
    };
    return getInitialPublish({
      critical,
      registry,
      scrollOptions: request2.scrollOptions
    });
  };
  var marshal = {
    updateDroppableIsEnabled: updateDroppableIsEnabled3,
    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled3,
    scrollDroppable: scrollDroppable2,
    updateDroppableScroll: updateDroppableScroll3,
    startPublishing,
    stopPublishing
  };
  return marshal;
};
var canStartDrag = function(state, id2) {
  if (state.phase === "IDLE") {
    return true;
  }
  if (state.phase !== "DROP_ANIMATING") {
    return false;
  }
  if (state.completed.result.draggableId === id2) {
    return false;
  }
  return state.completed.result.reason === "DROP";
};
var scrollWindow = function(change) {
  window.scrollBy(change.x, change.y);
};
var getScrollableDroppables = memoizeOne(function(droppables) {
  return toDroppableList(droppables).filter(function(droppable2) {
    if (!droppable2.isEnabled) {
      return false;
    }
    if (!droppable2.frame) {
      return false;
    }
    return true;
  });
});
var getScrollableDroppableOver = function getScrollableDroppableOver2(target, droppables) {
  var maybe = find(getScrollableDroppables(droppables), function(droppable2) {
    !droppable2.frame ? invariant(false) : void 0;
    return isPositionInFrame(droppable2.frame.pageMarginBox)(target);
  });
  return maybe;
};
var getBestScrollableDroppable = function(_ref) {
  var center = _ref.center, destination = _ref.destination, droppables = _ref.droppables;
  if (destination) {
    var _dimension = droppables[destination];
    if (!_dimension.frame) {
      return null;
    }
    return _dimension;
  }
  var dimension = getScrollableDroppableOver(center, droppables);
  return dimension;
};
var config = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: function ease(percentage) {
    return Math.pow(percentage, 2);
  },
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  }
};
var getDistanceThresholds = function(container2, axis) {
  var startScrollingFrom = container2[axis.size] * config.startFromPercentage;
  var maxScrollValueAt = container2[axis.size] * config.maxScrollAtPercentage;
  var thresholds = {
    startScrollingFrom,
    maxScrollValueAt
  };
  return thresholds;
};
var getPercentage = function(_ref) {
  var startOfRange = _ref.startOfRange, endOfRange = _ref.endOfRange, current = _ref.current;
  var range3 = endOfRange - startOfRange;
  if (range3 === 0) {
    return 0;
  }
  var currentInRange = current - startOfRange;
  var percentage = currentInRange / range3;
  return percentage;
};
var minScroll = 1;
var getValueFromDistance = function(distanceToEdge, thresholds) {
  if (distanceToEdge > thresholds.startScrollingFrom) {
    return 0;
  }
  if (distanceToEdge <= thresholds.maxScrollValueAt) {
    return config.maxPixelScroll;
  }
  if (distanceToEdge === thresholds.startScrollingFrom) {
    return minScroll;
  }
  var percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds.maxScrollValueAt,
    endOfRange: thresholds.startScrollingFrom,
    current: distanceToEdge
  });
  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  var scroll3 = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll3);
};
var accelerateAt = config.durationDampening.accelerateAt;
var stopAt = config.durationDampening.stopDampeningAt;
var dampenValueByTime = function(proposedScroll, dragStartTime) {
  var startOfRange = dragStartTime;
  var endOfRange = stopAt;
  var now = Date.now();
  var runTime = now - startOfRange;
  if (runTime >= stopAt) {
    return proposedScroll;
  }
  if (runTime < accelerateAt) {
    return minScroll;
  }
  var betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange,
    current: runTime
  });
  var scroll3 = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll3);
};
var getValue = function(_ref) {
  var distanceToEdge = _ref.distanceToEdge, thresholds = _ref.thresholds, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = getValueFromDistance(distanceToEdge, thresholds);
  if (scroll3 === 0) {
    return 0;
  }
  if (!shouldUseTimeDampening) {
    return scroll3;
  }
  return Math.max(dampenValueByTime(scroll3, dragStartTime), minScroll);
};
var getScrollOnAxis = function(_ref) {
  var container2 = _ref.container, distanceToEdges = _ref.distanceToEdges, dragStartTime = _ref.dragStartTime, axis = _ref.axis, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var thresholds = getDistanceThresholds(container2, axis);
  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
  if (isCloserToEnd) {
    return getValue({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds,
      dragStartTime,
      shouldUseTimeDampening
    });
  }
  return -1 * getValue({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds,
    dragStartTime,
    shouldUseTimeDampening
  });
};
var adjustForSizeLimits = function(_ref) {
  var container2 = _ref.container, subject = _ref.subject, proposedScroll = _ref.proposedScroll;
  var isTooBigVertically = subject.height > container2.height;
  var isTooBigHorizontally = subject.width > container2.width;
  if (!isTooBigHorizontally && !isTooBigVertically) {
    return proposedScroll;
  }
  if (isTooBigHorizontally && isTooBigVertically) {
    return null;
  }
  return {
    x: isTooBigHorizontally ? 0 : proposedScroll.x,
    y: isTooBigVertically ? 0 : proposedScroll.y
  };
};
var clean$2 = apply(function(value) {
  return value === 0 ? 0 : value;
});
var getScroll = function(_ref) {
  var dragStartTime = _ref.dragStartTime, container2 = _ref.container, subject = _ref.subject, center = _ref.center, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var distanceToEdges = {
    top: center.y - container2.top,
    right: container2.right - center.x,
    bottom: container2.bottom - center.y,
    left: center.x - container2.left
  };
  var y2 = getScrollOnAxis({
    container: container2,
    distanceToEdges,
    dragStartTime,
    axis: vertical,
    shouldUseTimeDampening
  });
  var x = getScrollOnAxis({
    container: container2,
    distanceToEdges,
    dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening
  });
  var required = clean$2({
    x,
    y: y2
  });
  if (isEqual(required, origin)) {
    return null;
  }
  var limited = adjustForSizeLimits({
    container: container2,
    subject,
    proposedScroll: required
  });
  if (!limited) {
    return null;
  }
  return isEqual(limited, origin) ? null : limited;
};
var smallestSigned = apply(function(value) {
  if (value === 0) {
    return 0;
  }
  return value > 0 ? 1 : -1;
});
var getOverlap = function() {
  var getRemainder = function getRemainder2(target, max2) {
    if (target < 0) {
      return target;
    }
    if (target > max2) {
      return target - max2;
    }
    return 0;
  };
  return function(_ref) {
    var current = _ref.current, max2 = _ref.max, change = _ref.change;
    var targetScroll = add(current, change);
    var overlap = {
      x: getRemainder(targetScroll.x, max2.x),
      y: getRemainder(targetScroll.y, max2.y)
    };
    if (isEqual(overlap, origin)) {
      return null;
    }
    return overlap;
  };
}();
var canPartiallyScroll = function canPartiallyScroll2(_ref2) {
  var rawMax = _ref2.max, current = _ref2.current, change = _ref2.change;
  var max2 = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  var smallestChange = smallestSigned(change);
  var overlap = getOverlap({
    max: max2,
    current,
    change: smallestChange
  });
  if (!overlap) {
    return true;
  }
  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }
  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }
  return false;
};
var canScrollWindow = function canScrollWindow2(viewport2, change) {
  return canPartiallyScroll({
    current: viewport2.scroll.current,
    max: viewport2.scroll.max,
    change
  });
};
var getWindowOverlap = function getWindowOverlap2(viewport2, change) {
  if (!canScrollWindow(viewport2, change)) {
    return null;
  }
  var max2 = viewport2.scroll.max;
  var current = viewport2.scroll.current;
  return getOverlap({
    current,
    max: max2,
    change
  });
};
var canScrollDroppable = function canScrollDroppable2(droppable2, change) {
  var frame = droppable2.frame;
  if (!frame) {
    return false;
  }
  return canPartiallyScroll({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getDroppableOverlap = function getDroppableOverlap2(droppable2, change) {
  var frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  if (!canScrollDroppable(droppable2, change)) {
    return null;
  }
  return getOverlap({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getWindowScrollChange = function(_ref) {
  var viewport2 = _ref.viewport, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = getScroll({
    dragStartTime,
    container: viewport2.frame,
    subject,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollWindow(viewport2, scroll3) ? scroll3 : null;
};
var getDroppableScrollChange = function(_ref) {
  var droppable2 = _ref.droppable, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  var scroll3 = getScroll({
    dragStartTime,
    container: frame.pageMarginBox,
    subject,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollDroppable(droppable2, scroll3) ? scroll3 : null;
};
var scroll$1 = function(_ref) {
  var state = _ref.state, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening, scrollWindow2 = _ref.scrollWindow, scrollDroppable2 = _ref.scrollDroppable;
  var center = state.current.page.borderBoxCenter;
  var draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  var subject = draggable2.page.marginBox;
  if (state.isWindowScrollAllowed) {
    var viewport2 = state.viewport;
    var _change = getWindowScrollChange({
      dragStartTime,
      viewport: viewport2,
      subject,
      center,
      shouldUseTimeDampening
    });
    if (_change) {
      scrollWindow2(_change);
      return;
    }
  }
  var droppable2 = getBestScrollableDroppable({
    center,
    destination: whatIsDraggedOver(state.impact),
    droppables: state.dimensions.droppables
  });
  if (!droppable2) {
    return;
  }
  var change = getDroppableScrollChange({
    dragStartTime,
    droppable: droppable2,
    subject,
    center,
    shouldUseTimeDampening
  });
  if (change) {
    scrollDroppable2(droppable2.descriptor.id, change);
  }
};
var createFluidScroller = function(_ref) {
  var scrollWindow2 = _ref.scrollWindow, scrollDroppable2 = _ref.scrollDroppable;
  var scheduleWindowScroll = rafSchd$1(scrollWindow2);
  var scheduleDroppableScroll = rafSchd$1(scrollDroppable2);
  var dragging = null;
  var tryScroll = function tryScroll2(state) {
    !dragging ? invariant(false) : void 0;
    var _dragging = dragging, shouldUseTimeDampening = _dragging.shouldUseTimeDampening, dragStartTime = _dragging.dragStartTime;
    scroll$1({
      state,
      scrollWindow: scheduleWindowScroll,
      scrollDroppable: scheduleDroppableScroll,
      dragStartTime,
      shouldUseTimeDampening
    });
  };
  var start$1 = function start$12(state) {
    !!dragging ? invariant(false) : void 0;
    var dragStartTime = Date.now();
    var wasScrollNeeded = false;
    var fakeScrollCallback = function fakeScrollCallback2() {
      wasScrollNeeded = true;
    };
    scroll$1({
      state,
      dragStartTime: 0,
      shouldUseTimeDampening: false,
      scrollWindow: fakeScrollCallback,
      scrollDroppable: fakeScrollCallback
    });
    dragging = {
      dragStartTime,
      shouldUseTimeDampening: wasScrollNeeded
    };
    if (wasScrollNeeded) {
      tryScroll(state);
    }
  };
  var stop = function stop2() {
    if (!dragging) {
      return;
    }
    scheduleWindowScroll.cancel();
    scheduleDroppableScroll.cancel();
    dragging = null;
  };
  return {
    start: start$1,
    stop,
    scroll: tryScroll
  };
};
var createJumpScroller = function(_ref) {
  var move3 = _ref.move, scrollDroppable2 = _ref.scrollDroppable, scrollWindow2 = _ref.scrollWindow;
  var moveByOffset = function moveByOffset2(state, offset3) {
    var client = add(state.current.client.selection, offset3);
    move3({
      client
    });
  };
  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan2(droppable2, change) {
    if (!canScrollDroppable(droppable2, change)) {
      return change;
    }
    var overlap = getDroppableOverlap(droppable2, change);
    if (!overlap) {
      scrollDroppable2(droppable2.descriptor.id, change);
      return null;
    }
    var whatTheDroppableCanScroll = subtract(change, overlap);
    scrollDroppable2(droppable2.descriptor.id, whatTheDroppableCanScroll);
    var remainder = subtract(change, whatTheDroppableCanScroll);
    return remainder;
  };
  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan2(isWindowScrollAllowed, viewport2, change) {
    if (!isWindowScrollAllowed) {
      return change;
    }
    if (!canScrollWindow(viewport2, change)) {
      return change;
    }
    var overlap = getWindowOverlap(viewport2, change);
    if (!overlap) {
      scrollWindow2(change);
      return null;
    }
    var whatTheWindowCanScroll = subtract(change, overlap);
    scrollWindow2(whatTheWindowCanScroll);
    var remainder = subtract(change, whatTheWindowCanScroll);
    return remainder;
  };
  var jumpScroller = function jumpScroller2(state) {
    var request2 = state.scrollJumpRequest;
    if (!request2) {
      return;
    }
    var destination = whatIsDraggedOver(state.impact);
    !destination ? invariant(false) : void 0;
    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request2);
    if (!droppableRemainder) {
      return;
    }
    var viewport2 = state.viewport;
    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport2, droppableRemainder);
    if (!windowRemainder) {
      return;
    }
    moveByOffset(state, windowRemainder);
  };
  return jumpScroller;
};
var createAutoScroller = function(_ref) {
  var scrollDroppable2 = _ref.scrollDroppable, scrollWindow2 = _ref.scrollWindow, move3 = _ref.move;
  var fluidScroller = createFluidScroller({
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  var jumpScroll = createJumpScroller({
    move: move3,
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  var scroll3 = function scroll4(state) {
    if (state.phase !== "DRAGGING") {
      return;
    }
    if (state.movementMode === "FLUID") {
      fluidScroller.scroll(state);
      return;
    }
    if (!state.scrollJumpRequest) {
      return;
    }
    jumpScroll(state);
  };
  var scroller = {
    scroll: scroll3,
    start: fluidScroller.start,
    stop: fluidScroller.stop
  };
  return scroller;
};
var prefix$1 = "data-rbd";
var dragHandle = function() {
  var base = prefix$1 + "-drag-handle";
  return {
    base,
    draggableId: base + "-draggable-id",
    contextId: base + "-context-id"
  };
}();
var draggable = function() {
  var base = prefix$1 + "-draggable";
  return {
    base,
    contextId: base + "-context-id",
    id: base + "-id"
  };
}();
var droppable = function() {
  var base = prefix$1 + "-droppable";
  return {
    base,
    contextId: base + "-context-id",
    id: base + "-id"
  };
}();
var scrollContainer = {
  contextId: prefix$1 + "-scroll-container-context-id"
};
var makeGetSelector = function makeGetSelector2(context) {
  return function(attribute) {
    return "[" + attribute + '="' + context + '"]';
  };
};
var getStyles = function getStyles2(rules, property) {
  return rules.map(function(rule) {
    var value = rule.styles[property];
    if (!value) {
      return "";
    }
    return rule.selector + " { " + value + " }";
  }).join(" ");
};
var noPointerEvents = "pointer-events: none;";
var getStyles$1 = function(contextId) {
  var getSelector2 = makeGetSelector(contextId);
  var dragHandle$1 = function() {
    var grabCursor = "\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";
    return {
      selector: getSelector2(dragHandle.contextId),
      styles: {
        always: "\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",
        resting: grabCursor,
        dragging: noPointerEvents,
        dropAnimating: grabCursor
      }
    };
  }();
  var draggable$1 = function() {
    var transition = "\n      transition: " + transitions.outOfTheWay + ";\n    ";
    return {
      selector: getSelector2(draggable.contextId),
      styles: {
        dragging: transition,
        dropAnimating: transition,
        userCancel: transition
      }
    };
  }();
  var droppable$1 = {
    selector: getSelector2(droppable.contextId),
    styles: {
      always: "overflow-anchor: none;"
    }
  };
  var body = {
    selector: "body",
    styles: {
      dragging: "\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "
    }
  };
  var rules = [draggable$1, dragHandle$1, droppable$1, body];
  return {
    always: getStyles(rules, "always"),
    resting: getStyles(rules, "resting"),
    dragging: getStyles(rules, "dragging"),
    dropAnimating: getStyles(rules, "dropAnimating"),
    userCancel: getStyles(rules, "userCancel")
  };
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var getHead = function getHead2() {
  var head = document.querySelector("head");
  !head ? invariant(false) : void 0;
  return head;
};
var createStyleEl = function createStyleEl2(nonce) {
  var el2 = document.createElement("style");
  if (nonce) {
    el2.setAttribute("nonce", nonce);
  }
  el2.type = "text/css";
  return el2;
};
function useStyleMarshal(contextId, nonce) {
  var styles2 = useMemo(function() {
    return getStyles$1(contextId);
  }, [contextId]);
  var alwaysRef = reactExports.useRef(null);
  var dynamicRef = reactExports.useRef(null);
  var setDynamicStyle = useCallback(memoizeOne(function(proposed) {
    var el2 = dynamicRef.current;
    !el2 ? invariant(false) : void 0;
    el2.textContent = proposed;
  }), []);
  var setAlwaysStyle = useCallback(function(proposed) {
    var el2 = alwaysRef.current;
    !el2 ? invariant(false) : void 0;
    el2.textContent = proposed;
  }, []);
  useIsomorphicLayoutEffect(function() {
    !(!alwaysRef.current && !dynamicRef.current) ? invariant(false) : void 0;
    var always = createStyleEl(nonce);
    var dynamic2 = createStyleEl(nonce);
    alwaysRef.current = always;
    dynamicRef.current = dynamic2;
    always.setAttribute(prefix$1 + "-always", contextId);
    dynamic2.setAttribute(prefix$1 + "-dynamic", contextId);
    getHead().appendChild(always);
    getHead().appendChild(dynamic2);
    setAlwaysStyle(styles2.always);
    setDynamicStyle(styles2.resting);
    return function() {
      var remove2 = function remove3(ref) {
        var current = ref.current;
        !current ? invariant(false) : void 0;
        getHead().removeChild(current);
        ref.current = null;
      };
      remove2(alwaysRef);
      remove2(dynamicRef);
    };
  }, [nonce, setAlwaysStyle, setDynamicStyle, styles2.always, styles2.resting, contextId]);
  var dragging = useCallback(function() {
    return setDynamicStyle(styles2.dragging);
  }, [setDynamicStyle, styles2.dragging]);
  var dropping = useCallback(function(reason) {
    if (reason === "DROP") {
      setDynamicStyle(styles2.dropAnimating);
      return;
    }
    setDynamicStyle(styles2.userCancel);
  }, [setDynamicStyle, styles2.dropAnimating, styles2.userCancel]);
  var resting = useCallback(function() {
    if (!dynamicRef.current) {
      return;
    }
    setDynamicStyle(styles2.resting);
  }, [setDynamicStyle, styles2.resting]);
  var marshal = useMemo(function() {
    return {
      dragging,
      dropping,
      resting
    };
  }, [dragging, dropping, resting]);
  return marshal;
}
var getWindowFromEl = function(el2) {
  return el2 && el2.ownerDocument ? el2.ownerDocument.defaultView : window;
};
function isHtmlElement(el2) {
  return el2 instanceof getWindowFromEl(el2).HTMLElement;
}
function findDragHandle(contextId, draggableId) {
  var selector = "[" + dragHandle.contextId + '="' + contextId + '"]';
  var possible = toArray(document.querySelectorAll(selector));
  if (!possible.length) {
    return null;
  }
  var handle = find(possible, function(el2) {
    return el2.getAttribute(dragHandle.draggableId) === draggableId;
  });
  if (!handle) {
    return null;
  }
  if (!isHtmlElement(handle)) {
    return null;
  }
  return handle;
}
function useFocusMarshal(contextId) {
  var entriesRef = reactExports.useRef({});
  var recordRef = reactExports.useRef(null);
  var restoreFocusFrameRef = reactExports.useRef(null);
  var isMountedRef = reactExports.useRef(false);
  var register2 = useCallback(function register3(id2, focus2) {
    var entry = {
      id: id2,
      focus: focus2
    };
    entriesRef.current[id2] = entry;
    return function unregister2() {
      var entries = entriesRef.current;
      var current = entries[id2];
      if (current !== entry) {
        delete entries[id2];
      }
    };
  }, []);
  var tryGiveFocus = useCallback(function tryGiveFocus2(tryGiveFocusTo) {
    var handle = findDragHandle(contextId, tryGiveFocusTo);
    if (handle && handle !== document.activeElement) {
      handle.focus();
    }
  }, [contextId]);
  var tryShiftRecord = useCallback(function tryShiftRecord2(previous, redirectTo) {
    if (recordRef.current === previous) {
      recordRef.current = redirectTo;
    }
  }, []);
  var tryRestoreFocusRecorded = useCallback(function tryRestoreFocusRecorded2() {
    if (restoreFocusFrameRef.current) {
      return;
    }
    if (!isMountedRef.current) {
      return;
    }
    restoreFocusFrameRef.current = requestAnimationFrame(function() {
      restoreFocusFrameRef.current = null;
      var record = recordRef.current;
      if (record) {
        tryGiveFocus(record);
      }
    });
  }, [tryGiveFocus]);
  var tryRecordFocus = useCallback(function tryRecordFocus2(id2) {
    recordRef.current = null;
    var focused = document.activeElement;
    if (!focused) {
      return;
    }
    if (focused.getAttribute(dragHandle.draggableId) !== id2) {
      return;
    }
    recordRef.current = id2;
  }, []);
  useIsomorphicLayoutEffect(function() {
    isMountedRef.current = true;
    return function clearFrameOnUnmount() {
      isMountedRef.current = false;
      var frameId = restoreFocusFrameRef.current;
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, []);
  var marshal = useMemo(function() {
    return {
      register: register2,
      tryRecordFocus,
      tryRestoreFocusRecorded,
      tryShiftRecord
    };
  }, [register2, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
  return marshal;
}
function createRegistry() {
  var entries = {
    draggables: {},
    droppables: {}
  };
  var subscribers = [];
  function subscribe(cb2) {
    subscribers.push(cb2);
    return function unsubscribe() {
      var index2 = subscribers.indexOf(cb2);
      if (index2 === -1) {
        return;
      }
      subscribers.splice(index2, 1);
    };
  }
  function notify2(event) {
    if (subscribers.length) {
      subscribers.forEach(function(cb2) {
        return cb2(event);
      });
    }
  }
  function findDraggableById(id2) {
    return entries.draggables[id2] || null;
  }
  function getDraggableById(id2) {
    var entry = findDraggableById(id2);
    !entry ? invariant(false) : void 0;
    return entry;
  }
  var draggableAPI = {
    register: function register2(entry) {
      entries.draggables[entry.descriptor.id] = entry;
      notify2({
        type: "ADDITION",
        value: entry
      });
    },
    update: function update2(entry, last) {
      var current = entries.draggables[last.descriptor.id];
      if (!current) {
        return;
      }
      if (current.uniqueId !== entry.uniqueId) {
        return;
      }
      delete entries.draggables[last.descriptor.id];
      entries.draggables[entry.descriptor.id] = entry;
    },
    unregister: function unregister2(entry) {
      var draggableId = entry.descriptor.id;
      var current = findDraggableById(draggableId);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.draggables[draggableId];
      notify2({
        type: "REMOVAL",
        value: entry
      });
    },
    getById: getDraggableById,
    findById: findDraggableById,
    exists: function exists(id2) {
      return Boolean(findDraggableById(id2));
    },
    getAllByType: function getAllByType(type2) {
      return values2(entries.draggables).filter(function(entry) {
        return entry.descriptor.type === type2;
      });
    }
  };
  function findDroppableById(id2) {
    return entries.droppables[id2] || null;
  }
  function getDroppableById(id2) {
    var entry = findDroppableById(id2);
    !entry ? invariant(false) : void 0;
    return entry;
  }
  var droppableAPI = {
    register: function register2(entry) {
      entries.droppables[entry.descriptor.id] = entry;
    },
    unregister: function unregister2(entry) {
      var current = findDroppableById(entry.descriptor.id);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.droppables[entry.descriptor.id];
    },
    getById: getDroppableById,
    findById: findDroppableById,
    exists: function exists(id2) {
      return Boolean(findDroppableById(id2));
    },
    getAllByType: function getAllByType(type2) {
      return values2(entries.droppables).filter(function(entry) {
        return entry.descriptor.type === type2;
      });
    }
  };
  function clean2() {
    entries.draggables = {};
    entries.droppables = {};
    subscribers.length = 0;
  }
  return {
    draggable: draggableAPI,
    droppable: droppableAPI,
    subscribe,
    clean: clean2
  };
}
function useRegistry() {
  var registry = useMemo(createRegistry, []);
  reactExports.useEffect(function() {
    return function unmount() {
      requestAnimationFrame(registry.clean);
    };
  }, [registry]);
  return registry;
}
var StoreContext = React.createContext(null);
var getBodyElement = function() {
  var body = document.body;
  !body ? invariant(false) : void 0;
  return body;
};
var visuallyHidden = {
  position: "absolute",
  width: "1px",
  height: "1px",
  margin: "-1px",
  border: "0",
  padding: "0",
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(100%)"
};
var getId = function getId2(contextId) {
  return "rbd-announcement-" + contextId;
};
function useAnnouncer(contextId) {
  var id2 = useMemo(function() {
    return getId(contextId);
  }, [contextId]);
  var ref = reactExports.useRef(null);
  reactExports.useEffect(function setup() {
    var el2 = document.createElement("div");
    ref.current = el2;
    el2.id = id2;
    el2.setAttribute("aria-live", "assertive");
    el2.setAttribute("aria-atomic", "true");
    _extends$8(el2.style, visuallyHidden);
    getBodyElement().appendChild(el2);
    return function cleanup() {
      setTimeout(function remove2() {
        var body = getBodyElement();
        if (body.contains(el2)) {
          body.removeChild(el2);
        }
        if (el2 === ref.current) {
          ref.current = null;
        }
      });
    };
  }, [id2]);
  var announce = useCallback(function(message) {
    var el2 = ref.current;
    if (el2) {
      el2.textContent = message;
      return;
    }
  }, []);
  return announce;
}
var count = 0;
var defaults = {
  separator: "::"
};
function useUniqueId(prefix2, options) {
  if (options === void 0) {
    options = defaults;
  }
  return useMemo(function() {
    return "" + prefix2 + options.separator + count++;
  }, [options.separator, prefix2]);
}
function getElementId(_ref) {
  var contextId = _ref.contextId, uniqueId = _ref.uniqueId;
  return "rbd-hidden-text-" + contextId + "-" + uniqueId;
}
function useHiddenTextElement(_ref2) {
  var contextId = _ref2.contextId, text = _ref2.text;
  var uniqueId = useUniqueId("hidden-text", {
    separator: "-"
  });
  var id2 = useMemo(function() {
    return getElementId({
      contextId,
      uniqueId
    });
  }, [uniqueId, contextId]);
  reactExports.useEffect(function mount() {
    var el2 = document.createElement("div");
    el2.id = id2;
    el2.textContent = text;
    el2.style.display = "none";
    getBodyElement().appendChild(el2);
    return function unmount() {
      var body = getBodyElement();
      if (body.contains(el2)) {
        body.removeChild(el2);
      }
    };
  }, [id2, text]);
  return id2;
}
var AppContext = React.createContext(null);
function usePrevious(current) {
  var ref = reactExports.useRef(current);
  reactExports.useEffect(function() {
    ref.current = current;
  });
  return ref;
}
function create() {
  var lock = null;
  function isClaimed() {
    return Boolean(lock);
  }
  function isActive(value) {
    return value === lock;
  }
  function claim(abandon) {
    !!lock ? invariant(false) : void 0;
    var newLock = {
      abandon
    };
    lock = newLock;
    return newLock;
  }
  function release() {
    !lock ? invariant(false) : void 0;
    lock = null;
  }
  function tryAbandon() {
    if (lock) {
      lock.abandon();
      release();
    }
  }
  return {
    isClaimed,
    isActive,
    claim,
    release,
    tryAbandon
  };
}
var tab = 9;
var enter = 13;
var escape$1 = 27;
var space = 32;
var pageUp = 33;
var pageDown = 34;
var end = 35;
var home = 36;
var arrowLeft = 37;
var arrowUp = 38;
var arrowRight = 39;
var arrowDown = 40;
var _preventedKeys;
var preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);
var preventStandardKeyEvents = function(event) {
  if (preventedKeys[event.keyCode]) {
    event.preventDefault();
  }
};
var supportedEventName = function() {
  var base = "visibilitychange";
  if (typeof document === "undefined") {
    return base;
  }
  var candidates = [base, "ms" + base, "webkit" + base, "moz" + base, "o" + base];
  var supported = find(candidates, function(eventName) {
    return "on" + eventName in document;
  });
  return supported || base;
}();
var primaryButton = 0;
var sloppyClickThreshold = 5;
function isSloppyClickThresholdExceeded(original, current) {
  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
}
var idle$1 = {
  type: "IDLE"
};
function getCaptureBindings(_ref) {
  var cancel = _ref.cancel, completed = _ref.completed, getPhase = _ref.getPhase, setPhase = _ref.setPhase;
  return [{
    eventName: "mousemove",
    fn: function fn2(event) {
      var button = event.button, clientX = event.clientX, clientY = event.clientY;
      if (button !== primaryButton) {
        return;
      }
      var point = {
        x: clientX,
        y: clientY
      };
      var phase = getPhase();
      if (phase.type === "DRAGGING") {
        event.preventDefault();
        phase.actions.move(point);
        return;
      }
      !(phase.type === "PENDING") ? invariant(false) : void 0;
      var pending = phase.point;
      if (!isSloppyClickThresholdExceeded(pending, point)) {
        return;
      }
      event.preventDefault();
      var actions2 = phase.actions.fluidLift(point);
      setPhase({
        type: "DRAGGING",
        actions: actions2
      });
    }
  }, {
    eventName: "mouseup",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "mousedown",
    fn: function fn2(event) {
      if (getPhase().type === "DRAGGING") {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: "keydown",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type === "PENDING") {
        cancel();
        return;
      }
      if (event.keyCode === escape$1) {
        event.preventDefault();
        cancel();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: function fn2() {
      if (getPhase().type === "PENDING") {
        cancel();
      }
    }
  }, {
    eventName: "webkitmouseforcedown",
    fn: function fn2(event) {
      var phase = getPhase();
      !(phase.type !== "IDLE") ? invariant(false) : void 0;
      if (phase.actions.shouldRespectForcePress()) {
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useMouseSensor(api) {
  var phaseRef = reactExports.useRef(idle$1);
  var unbindEventsRef = reactExports.useRef(noop);
  var startCaptureBinding = useMemo(function() {
    return {
      eventName: "mousedown",
      fn: function onMouseDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.button !== primaryButton) {
          return;
        }
        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var actions2 = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!actions2) {
          return;
        }
        event.preventDefault();
        var point = {
          x: event.clientX,
          y: event.clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions2, point);
      }
    };
  }, [api]);
  var preventForcePressBinding = useMemo(function() {
    return {
      eventName: "webkitmouseforcewillbegin",
      fn: function fn2(event) {
        if (event.defaultPrevented) {
          return;
        }
        var id2 = api.findClosestDraggableId(event);
        if (!id2) {
          return;
        }
        var options = api.findOptionsForDraggable(id2);
        if (!options) {
          return;
        }
        if (options.shouldRespectForcePress) {
          return;
        }
        if (!api.canGetLock(id2)) {
          return;
        }
        event.preventDefault();
      }
    };
  }, [api]);
  var listenForCapture = useCallback(function listenForCapture2() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
  }, [preventForcePressBinding, startCaptureBinding]);
  var stop = useCallback(function() {
    var current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    phaseRef.current = idle$1;
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture]);
  var cancel = useCallback(function() {
    var phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useCallback(function bindCapturingEvents2() {
    var options = {
      capture: true,
      passive: false
    };
    var bindings = getCaptureBindings({
      cancel,
      completed: stop,
      getPhase: function getPhase() {
        return phaseRef.current;
      },
      setPhase: function setPhase(phase) {
        phaseRef.current = phase;
      }
    });
    unbindEventsRef.current = bindEvents(window, bindings, options);
  }, [cancel, stop]);
  var startPendingDrag = useCallback(function startPendingDrag2(actions2, point) {
    !(phaseRef.current.type === "IDLE") ? invariant(false) : void 0;
    phaseRef.current = {
      type: "PENDING",
      point,
      actions: actions2
    };
    bindCapturingEvents();
  }, [bindCapturingEvents]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var _scrollJumpKeys;
function noop$1() {
}
var scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);
function getDraggingBindings(actions2, stop) {
  function cancel() {
    stop();
    actions2.cancel();
  }
  function drop5() {
    stop();
    actions2.drop();
  }
  return [{
    eventName: "keydown",
    fn: function fn2(event) {
      if (event.keyCode === escape$1) {
        event.preventDefault();
        cancel();
        return;
      }
      if (event.keyCode === space) {
        event.preventDefault();
        drop5();
        return;
      }
      if (event.keyCode === arrowDown) {
        event.preventDefault();
        actions2.moveDown();
        return;
      }
      if (event.keyCode === arrowUp) {
        event.preventDefault();
        actions2.moveUp();
        return;
      }
      if (event.keyCode === arrowRight) {
        event.preventDefault();
        actions2.moveRight();
        return;
      }
      if (event.keyCode === arrowLeft) {
        event.preventDefault();
        actions2.moveLeft();
        return;
      }
      if (scrollJumpKeys[event.keyCode]) {
        event.preventDefault();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "mousedown",
    fn: cancel
  }, {
    eventName: "mouseup",
    fn: cancel
  }, {
    eventName: "click",
    fn: cancel
  }, {
    eventName: "touchstart",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "wheel",
    fn: cancel,
    options: {
      passive: true
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useKeyboardSensor(api) {
  var unbindEventsRef = reactExports.useRef(noop$1);
  var startCaptureBinding = useMemo(function() {
    return {
      eventName: "keydown",
      fn: function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.keyCode !== space) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var preDrag = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!preDrag) {
          return;
        }
        event.preventDefault();
        var isCapturing = true;
        var actions2 = preDrag.snapLift();
        unbindEventsRef.current();
        function stop() {
          !isCapturing ? invariant(false) : void 0;
          isCapturing = false;
          unbindEventsRef.current();
          listenForCapture();
        }
        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions2, stop), {
          capture: true,
          passive: false
        });
      }
    };
  }, [api]);
  var listenForCapture = useCallback(function tryStartCapture() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var idle$2 = {
  type: "IDLE"
};
var timeForLongPress = 120;
var forcePressThreshold = 0.15;
function getWindowBindings(_ref) {
  var cancel = _ref.cancel, getPhase = _ref.getPhase;
  return [{
    eventName: "orientationchange",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "contextmenu",
    fn: function fn2(event) {
      event.preventDefault();
    }
  }, {
    eventName: "keydown",
    fn: function fn2(event) {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      if (event.keyCode === escape$1) {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function getHandleBindings(_ref2) {
  var cancel = _ref2.cancel, completed = _ref2.completed, getPhase = _ref2.getPhase;
  return [{
    eventName: "touchmove",
    options: {
      capture: false
    },
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      phase.hasMoved = true;
      var _event$touches$ = event.touches[0], clientX = _event$touches$.clientX, clientY = _event$touches$.clientY;
      var point = {
        x: clientX,
        y: clientY
      };
      event.preventDefault();
      phase.actions.move(point);
    }
  }, {
    eventName: "touchend",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "touchcancel",
    fn: function fn2(event) {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      cancel();
    }
  }, {
    eventName: "touchforcechange",
    fn: function fn2(event) {
      var phase = getPhase();
      !(phase.type !== "IDLE") ? invariant(false) : void 0;
      var touch = event.touches[0];
      if (!touch) {
        return;
      }
      var isForcePress = touch.force >= forcePressThreshold;
      if (!isForcePress) {
        return;
      }
      var shouldRespect = phase.actions.shouldRespectForcePress();
      if (phase.type === "PENDING") {
        if (shouldRespect) {
          cancel();
        }
        return;
      }
      if (shouldRespect) {
        if (phase.hasMoved) {
          event.preventDefault();
          return;
        }
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useTouchSensor(api) {
  var phaseRef = reactExports.useRef(idle$2);
  var unbindEventsRef = reactExports.useRef(noop);
  var getPhase = useCallback(function getPhase2() {
    return phaseRef.current;
  }, []);
  var setPhase = useCallback(function setPhase2(phase) {
    phaseRef.current = phase;
  }, []);
  var startCaptureBinding = useMemo(function() {
    return {
      eventName: "touchstart",
      fn: function onTouchStart(event) {
        if (event.defaultPrevented) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var actions2 = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!actions2) {
          return;
        }
        var touch = event.touches[0];
        var clientX = touch.clientX, clientY = touch.clientY;
        var point = {
          x: clientX,
          y: clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions2, point);
      }
    };
  }, [api]);
  var listenForCapture = useCallback(function listenForCapture2() {
    var options = {
      capture: true,
      passive: false
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  var stop = useCallback(function() {
    var current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    if (current.type === "PENDING") {
      clearTimeout(current.longPressTimerId);
    }
    setPhase(idle$2);
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture, setPhase]);
  var cancel = useCallback(function() {
    var phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useCallback(function bindCapturingEvents2() {
    var options = {
      capture: true,
      passive: false
    };
    var args = {
      cancel,
      completed: stop,
      getPhase
    };
    var unbindTarget = bindEvents(window, getHandleBindings(args), options);
    var unbindWindow = bindEvents(window, getWindowBindings(args), options);
    unbindEventsRef.current = function unbindAll() {
      unbindTarget();
      unbindWindow();
    };
  }, [cancel, getPhase, stop]);
  var startDragging = useCallback(function startDragging2() {
    var phase = getPhase();
    !(phase.type === "PENDING") ? invariant(false) : void 0;
    var actions2 = phase.actions.fluidLift(phase.point);
    setPhase({
      type: "DRAGGING",
      actions: actions2,
      hasMoved: false
    });
  }, [getPhase, setPhase]);
  var startPendingDrag = useCallback(function startPendingDrag2(actions2, point) {
    !(getPhase().type === "IDLE") ? invariant(false) : void 0;
    var longPressTimerId = setTimeout(startDragging, timeForLongPress);
    setPhase({
      type: "PENDING",
      point,
      actions: actions2,
      longPressTimerId
    });
    bindCapturingEvents();
  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
  useIsomorphicLayoutEffect(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
      var phase = getPhase();
      if (phase.type === "PENDING") {
        clearTimeout(phase.longPressTimerId);
        setPhase(idle$2);
      }
    };
  }, [getPhase, listenForCapture, setPhase]);
  useIsomorphicLayoutEffect(function webkitHack() {
    var unbind = bindEvents(window, [{
      eventName: "touchmove",
      fn: function fn2() {
      },
      options: {
        capture: false,
        passive: false
      }
    }]);
    return unbind;
  }, []);
}
var interactiveTagNames = {
  input: true,
  button: true,
  textarea: true,
  select: true,
  option: true,
  optgroup: true,
  video: true,
  audio: true
};
function isAnInteractiveElement(parent, current) {
  if (current == null) {
    return false;
  }
  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);
  if (hasAnInteractiveTag) {
    return true;
  }
  var attribute = current.getAttribute("contenteditable");
  if (attribute === "true" || attribute === "") {
    return true;
  }
  if (current === parent) {
    return false;
  }
  return isAnInteractiveElement(parent, current.parentElement);
}
function isEventInInteractiveElement(draggable2, event) {
  var target = event.target;
  if (!isHtmlElement(target)) {
    return false;
  }
  return isAnInteractiveElement(draggable2, target);
}
var getBorderBoxCenterPosition = function(el2) {
  return getRect(el2.getBoundingClientRect()).center;
};
function isElement(el2) {
  return el2 instanceof getWindowFromEl(el2).Element;
}
var supportedMatchesName = function() {
  var base = "matches";
  if (typeof document === "undefined") {
    return base;
  }
  var candidates = [base, "msMatchesSelector", "webkitMatchesSelector"];
  var value = find(candidates, function(name) {
    return name in Element.prototype;
  });
  return value || base;
}();
function closestPonyfill(el2, selector) {
  if (el2 == null) {
    return null;
  }
  if (el2[supportedMatchesName](selector)) {
    return el2;
  }
  return closestPonyfill(el2.parentElement, selector);
}
function closest$1(el2, selector) {
  if (el2.closest) {
    return el2.closest(selector);
  }
  return closestPonyfill(el2, selector);
}
function getSelector(contextId) {
  return "[" + dragHandle.contextId + '="' + contextId + '"]';
}
function findClosestDragHandleFromEvent(contextId, event) {
  var target = event.target;
  if (!isElement(target)) {
    return null;
  }
  var selector = getSelector(contextId);
  var handle = closest$1(target, selector);
  if (!handle) {
    return null;
  }
  if (!isHtmlElement(handle)) {
    return null;
  }
  return handle;
}
function tryGetClosestDraggableIdFromEvent(contextId, event) {
  var handle = findClosestDragHandleFromEvent(contextId, event);
  if (!handle) {
    return null;
  }
  return handle.getAttribute(dragHandle.draggableId);
}
function findDraggable(contextId, draggableId) {
  var selector = "[" + draggable.contextId + '="' + contextId + '"]';
  var possible = toArray(document.querySelectorAll(selector));
  var draggable$1 = find(possible, function(el2) {
    return el2.getAttribute(draggable.id) === draggableId;
  });
  if (!draggable$1) {
    return null;
  }
  if (!isHtmlElement(draggable$1)) {
    return null;
  }
  return draggable$1;
}
function preventDefault(event) {
  event.preventDefault();
}
function _isActive(_ref) {
  var expected = _ref.expected, phase = _ref.phase, isLockActive = _ref.isLockActive;
  _ref.shouldWarn;
  if (!isLockActive()) {
    return false;
  }
  if (expected !== phase) {
    return false;
  }
  return true;
}
function canStart(_ref2) {
  var lockAPI = _ref2.lockAPI, store = _ref2.store, registry = _ref2.registry, draggableId = _ref2.draggableId;
  if (lockAPI.isClaimed()) {
    return false;
  }
  var entry = registry.draggable.findById(draggableId);
  if (!entry) {
    return false;
  }
  if (!entry.options.isEnabled) {
    return false;
  }
  if (!canStartDrag(store.getState(), draggableId)) {
    return false;
  }
  return true;
}
function tryStart(_ref3) {
  var lockAPI = _ref3.lockAPI, contextId = _ref3.contextId, store = _ref3.store, registry = _ref3.registry, draggableId = _ref3.draggableId, forceSensorStop = _ref3.forceSensorStop, sourceEvent = _ref3.sourceEvent;
  var shouldStart = canStart({
    lockAPI,
    store,
    registry,
    draggableId
  });
  if (!shouldStart) {
    return null;
  }
  var entry = registry.draggable.getById(draggableId);
  var el2 = findDraggable(contextId, entry.descriptor.id);
  if (!el2) {
    return null;
  }
  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el2, sourceEvent)) {
    return null;
  }
  var lock = lockAPI.claim(forceSensorStop || noop);
  var phase = "PRE_DRAG";
  function getShouldRespectForcePress() {
    return entry.options.shouldRespectForcePress;
  }
  function isLockActive() {
    return lockAPI.isActive(lock);
  }
  function tryDispatch(expected, getAction) {
    if (_isActive({
      expected,
      phase,
      isLockActive,
      shouldWarn: true
    })) {
      store.dispatch(getAction());
    }
  }
  var tryDispatchWhenDragging = tryDispatch.bind(null, "DRAGGING");
  function lift$12(args) {
    function completed() {
      lockAPI.release();
      phase = "COMPLETED";
    }
    if (phase !== "PRE_DRAG") {
      completed();
      !(phase === "PRE_DRAG") ? invariant(false) : void 0;
    }
    store.dispatch(lift(args.liftActionArgs));
    phase = "DRAGGING";
    function finish(reason, options) {
      if (options === void 0) {
        options = {
          shouldBlockNextClick: false
        };
      }
      args.cleanup();
      if (options.shouldBlockNextClick) {
        var unbind = bindEvents(window, [{
          eventName: "click",
          fn: preventDefault,
          options: {
            once: true,
            passive: false,
            capture: true
          }
        }]);
        setTimeout(unbind);
      }
      completed();
      store.dispatch(drop({
        reason
      }));
    }
    return _extends$8({
      isActive: function isActive() {
        return _isActive({
          expected: "DRAGGING",
          phase,
          isLockActive,
          shouldWarn: false
        });
      },
      shouldRespectForcePress: getShouldRespectForcePress,
      drop: function drop5(options) {
        return finish("DROP", options);
      },
      cancel: function cancel(options) {
        return finish("CANCEL", options);
      }
    }, args.actions);
  }
  function fluidLift(clientSelection) {
    var move$1 = rafSchd$1(function(client) {
      tryDispatchWhenDragging(function() {
        return move({
          client
        });
      });
    });
    var api = lift$12({
      liftActionArgs: {
        id: draggableId,
        clientSelection,
        movementMode: "FLUID"
      },
      cleanup: function cleanup() {
        return move$1.cancel();
      },
      actions: {
        move: move$1
      }
    });
    return _extends$8({}, api, {
      move: move$1
    });
  }
  function snapLift() {
    var actions2 = {
      moveUp: function moveUp$1() {
        return tryDispatchWhenDragging(moveUp);
      },
      moveRight: function moveRight$1() {
        return tryDispatchWhenDragging(moveRight);
      },
      moveDown: function moveDown$1() {
        return tryDispatchWhenDragging(moveDown);
      },
      moveLeft: function moveLeft$1() {
        return tryDispatchWhenDragging(moveLeft);
      }
    };
    return lift$12({
      liftActionArgs: {
        id: draggableId,
        clientSelection: getBorderBoxCenterPosition(el2),
        movementMode: "SNAP"
      },
      cleanup: noop,
      actions: actions2
    });
  }
  function abortPreDrag() {
    var shouldRelease = _isActive({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: true
    });
    if (shouldRelease) {
      lockAPI.release();
    }
  }
  var preDrag = {
    isActive: function isActive() {
      return _isActive({
        expected: "PRE_DRAG",
        phase,
        isLockActive,
        shouldWarn: false
      });
    },
    shouldRespectForcePress: getShouldRespectForcePress,
    fluidLift,
    snapLift,
    abort: abortPreDrag
  };
  return preDrag;
}
var defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
function useSensorMarshal(_ref4) {
  var contextId = _ref4.contextId, store = _ref4.store, registry = _ref4.registry, customSensors = _ref4.customSensors, enableDefaultSensors = _ref4.enableDefaultSensors;
  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);
  var lockAPI = reactExports.useState(function() {
    return create();
  })[0];
  var tryAbandonLock = useCallback(function tryAbandonLock2(previous, current) {
    if (previous.isDragging && !current.isDragging) {
      lockAPI.tryAbandon();
    }
  }, [lockAPI]);
  useIsomorphicLayoutEffect(function listenToStore() {
    var previous = store.getState();
    var unsubscribe = store.subscribe(function() {
      var current = store.getState();
      tryAbandonLock(previous, current);
      previous = current;
    });
    return unsubscribe;
  }, [lockAPI, store, tryAbandonLock]);
  useIsomorphicLayoutEffect(function() {
    return lockAPI.tryAbandon;
  }, [lockAPI.tryAbandon]);
  var canGetLock = useCallback(function(draggableId) {
    return canStart({
      lockAPI,
      registry,
      store,
      draggableId
    });
  }, [lockAPI, registry, store]);
  var tryGetLock = useCallback(function(draggableId, forceStop, options) {
    return tryStart({
      lockAPI,
      registry,
      contextId,
      store,
      draggableId,
      forceSensorStop: forceStop,
      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
    });
  }, [contextId, lockAPI, registry, store]);
  var findClosestDraggableId = useCallback(function(event) {
    return tryGetClosestDraggableIdFromEvent(contextId, event);
  }, [contextId]);
  var findOptionsForDraggable = useCallback(function(id2) {
    var entry = registry.draggable.findById(id2);
    return entry ? entry.options : null;
  }, [registry.draggable]);
  var tryReleaseLock = useCallback(function tryReleaseLock2() {
    if (!lockAPI.isClaimed()) {
      return;
    }
    lockAPI.tryAbandon();
    if (store.getState().phase !== "IDLE") {
      store.dispatch(flush());
    }
  }, [lockAPI, store]);
  var isLockClaimed = useCallback(lockAPI.isClaimed, [lockAPI]);
  var api = useMemo(function() {
    return {
      canGetLock,
      tryGetLock,
      findClosestDraggableId,
      findOptionsForDraggable,
      tryReleaseLock,
      isLockClaimed
    };
  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
  for (var i = 0; i < useSensors.length; i++) {
    useSensors[i](api);
  }
}
var createResponders = function createResponders2(props) {
  return {
    onBeforeCapture: props.onBeforeCapture,
    onBeforeDragStart: props.onBeforeDragStart,
    onDragStart: props.onDragStart,
    onDragEnd: props.onDragEnd,
    onDragUpdate: props.onDragUpdate
  };
};
function getStore(lazyRef) {
  !lazyRef.current ? invariant(false) : void 0;
  return lazyRef.current;
}
function App$1(props) {
  var contextId = props.contextId, setCallbacks = props.setCallbacks, sensors = props.sensors, nonce = props.nonce, dragHandleUsageInstructions2 = props.dragHandleUsageInstructions;
  var lazyStoreRef = reactExports.useRef(null);
  var lastPropsRef = usePrevious(props);
  var getResponders = useCallback(function() {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);
  var announce = useAnnouncer(contextId);
  var dragHandleUsageInstructionsId = useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions2
  });
  var styleMarshal = useStyleMarshal(contextId, nonce);
  var lazyDispatch = useCallback(function(action) {
    getStore(lazyStoreRef).dispatch(action);
  }, []);
  var marshalCallbacks = useMemo(function() {
    return bindActionCreators$1({
      publishWhileDragging,
      updateDroppableScroll,
      updateDroppableIsEnabled,
      updateDroppableIsCombineEnabled,
      collectionStarting
    }, lazyDispatch);
  }, [lazyDispatch]);
  var registry = useRegistry();
  var dimensionMarshal = useMemo(function() {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);
  var autoScroller = useMemo(function() {
    return createAutoScroller(_extends$8({
      scrollWindow,
      scrollDroppable: dimensionMarshal.scrollDroppable
    }, bindActionCreators$1({
      move
    }, lazyDispatch)));
  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);
  var focusMarshal = useFocusMarshal(contextId);
  var store = useMemo(function() {
    return createStore({
      announce,
      autoScroller,
      dimensionMarshal,
      focusMarshal,
      getResponders,
      styleMarshal
    });
  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
  lazyStoreRef.current = store;
  var tryResetStore = useCallback(function() {
    var current = getStore(lazyStoreRef);
    var state = current.getState();
    if (state.phase !== "IDLE") {
      current.dispatch(flush());
    }
  }, []);
  var isDragging = useCallback(function() {
    var state = getStore(lazyStoreRef).getState();
    return state.isDragging || state.phase === "DROP_ANIMATING";
  }, []);
  var appCallbacks = useMemo(function() {
    return {
      isDragging,
      tryAbort: tryResetStore
    };
  }, [isDragging, tryResetStore]);
  setCallbacks(appCallbacks);
  var getCanLift = useCallback(function(id2) {
    return canStartDrag(getStore(lazyStoreRef).getState(), id2);
  }, []);
  var getIsMovementAllowed = useCallback(function() {
    return isMovementAllowed(getStore(lazyStoreRef).getState());
  }, []);
  var appContext = useMemo(function() {
    return {
      marshal: dimensionMarshal,
      focus: focusMarshal,
      contextId,
      canLift: getCanLift,
      isMovementAllowed: getIsMovementAllowed,
      dragHandleUsageInstructionsId,
      registry
    };
  }, [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
  useSensorMarshal({
    contextId,
    store,
    registry,
    customSensors: sensors,
    enableDefaultSensors: props.enableDefaultSensors !== false
  });
  reactExports.useEffect(function() {
    return tryResetStore;
  }, [tryResetStore]);
  return React.createElement(AppContext.Provider, {
    value: appContext
  }, React.createElement(Provider, {
    context: StoreContext,
    store
  }, props.children));
}
var count$1 = 0;
function useInstanceCount() {
  return useMemo(function() {
    return "" + count$1++;
  }, []);
}
function DragDropContext(props) {
  var contextId = useInstanceCount();
  var dragHandleUsageInstructions2 = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
  return React.createElement(ErrorBoundary, null, function(setCallbacks) {
    return React.createElement(App$1, {
      nonce: props.nonce,
      contextId,
      setCallbacks,
      dragHandleUsageInstructions: dragHandleUsageInstructions2,
      enableDefaultSensors: props.enableDefaultSensors,
      sensors: props.sensors,
      onBeforeCapture: props.onBeforeCapture,
      onBeforeDragStart: props.onBeforeDragStart,
      onDragStart: props.onDragStart,
      onDragUpdate: props.onDragUpdate,
      onDragEnd: props.onDragEnd
    }, props.children);
  });
}
var isEqual$1 = function isEqual3(base) {
  return function(value) {
    return base === value;
  };
};
var isScroll = isEqual$1("scroll");
var isAuto = isEqual$1("auto");
var isEither = function isEither2(overflow2, fn2) {
  return fn2(overflow2.overflowX) || fn2(overflow2.overflowY);
};
var isElementScrollable = function isElementScrollable2(el2) {
  var style2 = window.getComputedStyle(el2);
  var overflow2 = {
    overflowX: style2.overflowX,
    overflowY: style2.overflowY
  };
  return isEither(overflow2, isScroll) || isEither(overflow2, isAuto);
};
var isBodyScrollable = function isBodyScrollable2() {
  {
    return false;
  }
};
var getClosestScrollable = function getClosestScrollable2(el2) {
  if (el2 == null) {
    return null;
  }
  if (el2 === document.body) {
    return isBodyScrollable() ? el2 : null;
  }
  if (el2 === document.documentElement) {
    return null;
  }
  if (!isElementScrollable(el2)) {
    return getClosestScrollable2(el2.parentElement);
  }
  return el2;
};
var getScroll$1 = function(el2) {
  return {
    x: el2.scrollLeft,
    y: el2.scrollTop
  };
};
var getIsFixed = function getIsFixed2(el2) {
  if (!el2) {
    return false;
  }
  var style2 = window.getComputedStyle(el2);
  if (style2.position === "fixed") {
    return true;
  }
  return getIsFixed2(el2.parentElement);
};
var getEnv = function(start3) {
  var closestScrollable = getClosestScrollable(start3);
  var isFixedOnPage = getIsFixed(start3);
  return {
    closestScrollable,
    isFixedOnPage
  };
};
var getDroppableDimension = function(_ref) {
  var descriptor = _ref.descriptor, isEnabled3 = _ref.isEnabled, isCombineEnabled = _ref.isCombineEnabled, isFixedOnPage = _ref.isFixedOnPage, direction = _ref.direction, client = _ref.client, page = _ref.page, closest3 = _ref.closest;
  var frame = function() {
    if (!closest3) {
      return null;
    }
    var scrollSize = closest3.scrollSize, frameClient = closest3.client;
    var maxScroll = getMaxScroll({
      scrollHeight: scrollSize.scrollHeight,
      scrollWidth: scrollSize.scrollWidth,
      height: frameClient.paddingBox.height,
      width: frameClient.paddingBox.width
    });
    return {
      pageMarginBox: closest3.page.marginBox,
      frameClient,
      scrollSize,
      shouldClipSubject: closest3.shouldClipSubject,
      scroll: {
        initial: closest3.scroll,
        current: closest3.scroll,
        max: maxScroll,
        diff: {
          value: origin,
          displacement: origin
        }
      }
    };
  }();
  var axis = direction === "vertical" ? vertical : horizontal;
  var subject = getSubject({
    page,
    withPlaceholder: null,
    axis,
    frame
  });
  var dimension = {
    descriptor,
    isCombineEnabled,
    isFixedOnPage,
    axis,
    isEnabled: isEnabled3,
    client,
    page,
    frame,
    subject
  };
  return dimension;
};
var getClient = function getClient2(targetRef, closestScrollable) {
  var base = getBox(targetRef);
  if (!closestScrollable) {
    return base;
  }
  if (targetRef !== closestScrollable) {
    return base;
  }
  var top2 = base.paddingBox.top - closestScrollable.scrollTop;
  var left2 = base.paddingBox.left - closestScrollable.scrollLeft;
  var bottom2 = top2 + closestScrollable.scrollHeight;
  var right2 = left2 + closestScrollable.scrollWidth;
  var paddingBox = {
    top: top2,
    right: right2,
    bottom: bottom2,
    left: left2
  };
  var borderBox = expand(paddingBox, base.border);
  var client = createBox({
    borderBox,
    margin: base.margin,
    border: base.border,
    padding: base.padding
  });
  return client;
};
var getDimension = function(_ref) {
  var ref = _ref.ref, descriptor = _ref.descriptor, env = _ref.env, windowScroll = _ref.windowScroll, direction = _ref.direction, isDropDisabled = _ref.isDropDisabled, isCombineEnabled = _ref.isCombineEnabled, shouldClipSubject = _ref.shouldClipSubject;
  var closestScrollable = env.closestScrollable;
  var client = getClient(ref, closestScrollable);
  var page = withScroll(client, windowScroll);
  var closest3 = function() {
    if (!closestScrollable) {
      return null;
    }
    var frameClient = getBox(closestScrollable);
    var scrollSize = {
      scrollHeight: closestScrollable.scrollHeight,
      scrollWidth: closestScrollable.scrollWidth
    };
    return {
      client: frameClient,
      page: withScroll(frameClient, windowScroll),
      scroll: getScroll$1(closestScrollable),
      scrollSize,
      shouldClipSubject
    };
  }();
  var dimension = getDroppableDimension({
    descriptor,
    isEnabled: !isDropDisabled,
    isCombineEnabled,
    isFixedOnPage: env.isFixedOnPage,
    direction,
    client,
    page,
    closest: closest3
  });
  return dimension;
};
var immediate = {
  passive: false
};
var delayed = {
  passive: true
};
var getListenerOptions = function(options) {
  return options.shouldPublishImmediately ? immediate : delayed;
};
function useRequiredContext(Context) {
  var result = reactExports.useContext(Context);
  !result ? invariant(false) : void 0;
  return result;
}
var getClosestScrollableFromDrag = function getClosestScrollableFromDrag2(dragging) {
  return dragging && dragging.env.closestScrollable || null;
};
function useDroppablePublisher(args) {
  var whileDraggingRef = reactExports.useRef(null);
  var appContext = useRequiredContext(AppContext);
  var uniqueId = useUniqueId("droppable");
  var registry = appContext.registry, marshal = appContext.marshal;
  var previousRef = usePrevious(args);
  var descriptor = useMemo(function() {
    return {
      id: args.droppableId,
      type: args.type,
      mode: args.mode
    };
  }, [args.droppableId, args.mode, args.type]);
  var publishedDescriptorRef = reactExports.useRef(descriptor);
  var memoizedUpdateScroll = useMemo(function() {
    return memoizeOne(function(x, y2) {
      !whileDraggingRef.current ? invariant(false) : void 0;
      var scroll4 = {
        x,
        y: y2
      };
      marshal.updateDroppableScroll(descriptor.id, scroll4);
    });
  }, [descriptor.id, marshal]);
  var getClosestScroll = useCallback(function() {
    var dragging = whileDraggingRef.current;
    if (!dragging || !dragging.env.closestScrollable) {
      return origin;
    }
    return getScroll$1(dragging.env.closestScrollable);
  }, []);
  var updateScroll = useCallback(function() {
    var scroll4 = getClosestScroll();
    memoizedUpdateScroll(scroll4.x, scroll4.y);
  }, [getClosestScroll, memoizedUpdateScroll]);
  var scheduleScrollUpdate = useMemo(function() {
    return rafSchd$1(updateScroll);
  }, [updateScroll]);
  var onClosestScroll = useCallback(function() {
    var dragging = whileDraggingRef.current;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest3) ? invariant(false) : void 0;
    var options = dragging.scrollOptions;
    if (options.shouldPublishImmediately) {
      updateScroll();
      return;
    }
    scheduleScrollUpdate();
  }, [scheduleScrollUpdate, updateScroll]);
  var getDimensionAndWatchScroll = useCallback(function(windowScroll, options) {
    !!whileDraggingRef.current ? invariant(false) : void 0;
    var previous = previousRef.current;
    var ref = previous.getDroppableRef();
    !ref ? invariant(false) : void 0;
    var env = getEnv(ref);
    var dragging = {
      ref,
      descriptor,
      env,
      scrollOptions: options
    };
    whileDraggingRef.current = dragging;
    var dimension = getDimension({
      ref,
      descriptor,
      env,
      windowScroll,
      direction: previous.direction,
      isDropDisabled: previous.isDropDisabled,
      isCombineEnabled: previous.isCombineEnabled,
      shouldClipSubject: !previous.ignoreContainerClipping
    });
    var scrollable = env.closestScrollable;
    if (scrollable) {
      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
      scrollable.addEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
    }
    return dimension;
  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
  var getScrollWhileDragging = useCallback(function() {
    var dragging = whileDraggingRef.current;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest3) ? invariant(false) : void 0;
    return getScroll$1(closest3);
  }, []);
  var dragStopped = useCallback(function() {
    var dragging = whileDraggingRef.current;
    !dragging ? invariant(false) : void 0;
    var closest3 = getClosestScrollableFromDrag(dragging);
    whileDraggingRef.current = null;
    if (!closest3) {
      return;
    }
    scheduleScrollUpdate.cancel();
    closest3.removeAttribute(scrollContainer.contextId);
    closest3.removeEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
  }, [onClosestScroll, scheduleScrollUpdate]);
  var scroll3 = useCallback(function(change) {
    var dragging = whileDraggingRef.current;
    !dragging ? invariant(false) : void 0;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !closest3 ? invariant(false) : void 0;
    closest3.scrollTop += change.y;
    closest3.scrollLeft += change.x;
  }, []);
  var callbacks = useMemo(function() {
    return {
      getDimensionAndWatchScroll,
      getScrollWhileDragging,
      dragStopped,
      scroll: scroll3
    };
  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll3]);
  var entry = useMemo(function() {
    return {
      uniqueId,
      descriptor,
      callbacks
    };
  }, [callbacks, descriptor, uniqueId]);
  useIsomorphicLayoutEffect(function() {
    publishedDescriptorRef.current = entry.descriptor;
    registry.droppable.register(entry);
    return function() {
      if (whileDraggingRef.current) {
        dragStopped();
      }
      registry.droppable.unregister(entry);
    };
  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
  useIsomorphicLayoutEffect(function() {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
  }, [args.isDropDisabled, marshal]);
  useIsomorphicLayoutEffect(function() {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
  }, [args.isCombineEnabled, marshal]);
}
function noop$2() {
}
var empty = {
  width: 0,
  height: 0,
  margin: noSpacing
};
var getSize = function getSize2(_ref) {
  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount, placeholder = _ref.placeholder, animate2 = _ref.animate;
  if (isAnimatingOpenOnMount) {
    return empty;
  }
  if (animate2 === "close") {
    return empty;
  }
  return {
    height: placeholder.client.borderBox.height,
    width: placeholder.client.borderBox.width,
    margin: placeholder.client.margin
  };
};
var getStyle = function getStyle2(_ref2) {
  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount, placeholder = _ref2.placeholder, animate2 = _ref2.animate;
  var size = getSize({
    isAnimatingOpenOnMount,
    placeholder,
    animate: animate2
  });
  return {
    display: placeholder.display,
    boxSizing: "border-box",
    width: size.width,
    height: size.height,
    marginTop: size.margin.top,
    marginRight: size.margin.right,
    marginBottom: size.margin.bottom,
    marginLeft: size.margin.left,
    flexShrink: "0",
    flexGrow: "0",
    pointerEvents: "none",
    transition: animate2 !== "none" ? transitions.placeholder : null
  };
};
function Placeholder(props) {
  var animateOpenTimerRef = reactExports.useRef(null);
  var tryClearAnimateOpenTimer = useCallback(function() {
    if (!animateOpenTimerRef.current) {
      return;
    }
    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);
  var animate2 = props.animate, onTransitionEnd = props.onTransitionEnd, onClose = props.onClose, contextId = props.contextId;
  var _useState = reactExports.useState(props.animate === "open"), isAnimatingOpenOnMount = _useState[0], setIsAnimatingOpenOnMount = _useState[1];
  reactExports.useEffect(function() {
    if (!isAnimatingOpenOnMount) {
      return noop$2;
    }
    if (animate2 !== "open") {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop$2;
    }
    if (animateOpenTimerRef.current) {
      return noop$2;
    }
    animateOpenTimerRef.current = setTimeout(function() {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });
    return tryClearAnimateOpenTimer;
  }, [animate2, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
  var onSizeChangeEnd = useCallback(function(event) {
    if (event.propertyName !== "height") {
      return;
    }
    onTransitionEnd();
    if (animate2 === "close") {
      onClose();
    }
  }, [animate2, onClose, onTransitionEnd]);
  var style2 = getStyle({
    isAnimatingOpenOnMount,
    animate: props.animate,
    placeholder: props.placeholder
  });
  return React.createElement(props.placeholder.tagName, {
    style: style2,
    "data-rbd-placeholder-context-id": contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props.innerRef
  });
}
var Placeholder$1 = React.memo(Placeholder);
var DroppableContext = React.createContext(null);
var AnimateInOut = function(_React$PureComponent) {
  _inheritsLoose(AnimateInOut2, _React$PureComponent);
  function AnimateInOut2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.state = {
      isVisible: Boolean(_this.props.on),
      data: _this.props.on,
      animate: _this.props.shouldAnimate && _this.props.on ? "open" : "none"
    };
    _this.onClose = function() {
      if (_this.state.animate !== "close") {
        return;
      }
      _this.setState({
        isVisible: false
      });
    };
    return _this;
  }
  AnimateInOut2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (!props.shouldAnimate) {
      return {
        isVisible: Boolean(props.on),
        data: props.on,
        animate: "none"
      };
    }
    if (props.on) {
      return {
        isVisible: true,
        data: props.on,
        animate: "open"
      };
    }
    if (state.isVisible) {
      return {
        isVisible: true,
        data: state.data,
        animate: "close"
      };
    }
    return {
      isVisible: false,
      animate: "close",
      data: null
    };
  };
  var _proto = AnimateInOut2.prototype;
  _proto.render = function render() {
    if (!this.state.isVisible) {
      return null;
    }
    var provided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(provided);
  };
  return AnimateInOut2;
}(React.PureComponent);
var zIndexOptions = {
  dragging: 5e3,
  dropAnimating: 4500
};
var getDraggingTransition = function getDraggingTransition2(shouldAnimateDragMovement, dropping) {
  if (dropping) {
    return transitions.drop(dropping.duration);
  }
  if (shouldAnimateDragMovement) {
    return transitions.snap;
  }
  return transitions.fluid;
};
var getDraggingOpacity = function getDraggingOpacity2(isCombining, isDropAnimating) {
  if (!isCombining) {
    return null;
  }
  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
};
var getShouldDraggingAnimate = function getShouldDraggingAnimate2(dragging) {
  if (dragging.forceShouldAnimate != null) {
    return dragging.forceShouldAnimate;
  }
  return dragging.mode === "SNAP";
};
function getDraggingStyle(dragging) {
  var dimension = dragging.dimension;
  var box = dimension.client;
  var offset3 = dragging.offset, combineWith = dragging.combineWith, dropping = dragging.dropping;
  var isCombining = Boolean(combineWith);
  var shouldAnimate = getShouldDraggingAnimate(dragging);
  var isDropAnimating = Boolean(dropping);
  var transform3 = isDropAnimating ? transforms.drop(offset3, isCombining) : transforms.moveTo(offset3);
  var style2 = {
    position: "fixed",
    top: box.marginBox.top,
    left: box.marginBox.left,
    boxSizing: "border-box",
    width: box.borderBox.width,
    height: box.borderBox.height,
    transition: getDraggingTransition(shouldAnimate, dropping),
    transform: transform3,
    opacity: getDraggingOpacity(isCombining, isDropAnimating),
    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
    pointerEvents: "none"
  };
  return style2;
}
function getSecondaryStyle(secondary) {
  return {
    transform: transforms.moveTo(secondary.offset),
    transition: secondary.shouldAnimateDisplacement ? null : "none"
  };
}
function getStyle$1(mapped) {
  return mapped.type === "DRAGGING" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
}
function getDimension$1(descriptor, el2, windowScroll) {
  if (windowScroll === void 0) {
    windowScroll = origin;
  }
  var computedStyles = window.getComputedStyle(el2);
  var borderBox = el2.getBoundingClientRect();
  var client = calculateBox(borderBox, computedStyles);
  var page = withScroll(client, windowScroll);
  var placeholder = {
    client,
    tagName: el2.tagName.toLowerCase(),
    display: computedStyles.display
  };
  var displaceBy = {
    x: client.marginBox.width,
    y: client.marginBox.height
  };
  var dimension = {
    descriptor,
    placeholder,
    displaceBy,
    client,
    page
  };
  return dimension;
}
function useDraggablePublisher(args) {
  var uniqueId = useUniqueId("draggable");
  var descriptor = args.descriptor, registry = args.registry, getDraggableRef = args.getDraggableRef, canDragInteractiveElements = args.canDragInteractiveElements, shouldRespectForcePress = args.shouldRespectForcePress, isEnabled3 = args.isEnabled;
  var options = useMemo(function() {
    return {
      canDragInteractiveElements,
      shouldRespectForcePress,
      isEnabled: isEnabled3
    };
  }, [canDragInteractiveElements, isEnabled3, shouldRespectForcePress]);
  var getDimension2 = useCallback(function(windowScroll) {
    var el2 = getDraggableRef();
    !el2 ? invariant(false) : void 0;
    return getDimension$1(descriptor, el2, windowScroll);
  }, [descriptor, getDraggableRef]);
  var entry = useMemo(function() {
    return {
      uniqueId,
      descriptor,
      options,
      getDimension: getDimension2
    };
  }, [descriptor, getDimension2, options, uniqueId]);
  var publishedRef = reactExports.useRef(entry);
  var isFirstPublishRef = reactExports.useRef(true);
  useIsomorphicLayoutEffect(function() {
    registry.draggable.register(publishedRef.current);
    return function() {
      return registry.draggable.unregister(publishedRef.current);
    };
  }, [registry.draggable]);
  useIsomorphicLayoutEffect(function() {
    if (isFirstPublishRef.current) {
      isFirstPublishRef.current = false;
      return;
    }
    var last = publishedRef.current;
    publishedRef.current = entry;
    registry.draggable.update(entry, last);
  }, [entry, registry.draggable]);
}
function preventHtml5Dnd(event) {
  event.preventDefault();
}
function Draggable(props) {
  var ref = reactExports.useRef(null);
  var setRef2 = useCallback(function(el2) {
    ref.current = el2;
  }, []);
  var getRef = useCallback(function() {
    return ref.current;
  }, []);
  var _useRequiredContext = useRequiredContext(AppContext), contextId = _useRequiredContext.contextId, dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId, registry = _useRequiredContext.registry;
  var _useRequiredContext2 = useRequiredContext(DroppableContext), type2 = _useRequiredContext2.type, droppableId = _useRequiredContext2.droppableId;
  var descriptor = useMemo(function() {
    return {
      id: props.draggableId,
      index: props.index,
      type: type2,
      droppableId
    };
  }, [props.draggableId, props.index, type2, droppableId]);
  var children = props.children, draggableId = props.draggableId, isEnabled3 = props.isEnabled, shouldRespectForcePress = props.shouldRespectForcePress, canDragInteractiveElements = props.canDragInteractiveElements, isClone = props.isClone, mapped = props.mapped, dropAnimationFinishedAction = props.dropAnimationFinished;
  if (!isClone) {
    var forPublisher = useMemo(function() {
      return {
        descriptor,
        registry,
        getDraggableRef: getRef,
        canDragInteractiveElements,
        shouldRespectForcePress,
        isEnabled: isEnabled3
      };
    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled3]);
    useDraggablePublisher(forPublisher);
  }
  var dragHandleProps = useMemo(function() {
    return isEnabled3 ? {
      tabIndex: 0,
      role: "button",
      "aria-describedby": dragHandleUsageInstructionsId,
      "data-rbd-drag-handle-draggable-id": draggableId,
      "data-rbd-drag-handle-context-id": contextId,
      draggable: false,
      onDragStart: preventHtml5Dnd
    } : null;
  }, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled3]);
  var onMoveEnd = useCallback(function(event) {
    if (mapped.type !== "DRAGGING") {
      return;
    }
    if (!mapped.dropping) {
      return;
    }
    if (event.propertyName !== "transform") {
      return;
    }
    dropAnimationFinishedAction();
  }, [dropAnimationFinishedAction, mapped]);
  var provided = useMemo(function() {
    var style2 = getStyle$1(mapped);
    var onTransitionEnd = mapped.type === "DRAGGING" && mapped.dropping ? onMoveEnd : null;
    var result = {
      innerRef: setRef2,
      draggableProps: {
        "data-rbd-draggable-context-id": contextId,
        "data-rbd-draggable-id": draggableId,
        style: style2,
        onTransitionEnd
      },
      dragHandleProps
    };
    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef2]);
  var rubric = useMemo(function() {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
  return children(provided, mapped.snapshot, rubric);
}
var isStrictEqual = function(a2, b2) {
  return a2 === b2;
};
var whatIsDraggedOverFromResult = function(result) {
  var combine2 = result.combine, destination = result.destination;
  if (destination) {
    return destination.droppableId;
  }
  if (combine2) {
    return combine2.droppableId;
  }
  return null;
};
var getCombineWithFromResult = function getCombineWithFromResult2(result) {
  return result.combine ? result.combine.draggableId : null;
};
var getCombineWithFromImpact = function getCombineWithFromImpact2(impact) {
  return impact.at && impact.at.type === "COMBINE" ? impact.at.combine.draggableId : null;
};
function getDraggableSelector() {
  var memoizedOffset = memoizeOne(function(x, y2) {
    return {
      x,
      y: y2
    };
  });
  var getMemoizedSnapshot = memoizeOne(function(mode, isClone, draggingOver, combineWith, dropping) {
    return {
      isDragging: true,
      isClone,
      isDropAnimating: Boolean(dropping),
      dropAnimation: dropping,
      mode,
      draggingOver,
      combineWith,
      combineTargetFor: null
    };
  });
  var getMemoizedProps = memoizeOne(function(offset3, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {
    return {
      mapped: {
        type: "DRAGGING",
        dropping: null,
        draggingOver,
        combineWith,
        mode,
        offset: offset3,
        dimension,
        forceShouldAnimate,
        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
      }
    };
  });
  var selector = function selector2(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id !== ownProps.draggableId) {
        return null;
      }
      var offset3 = state.current.client.offset;
      var dimension = state.dimensions.draggables[ownProps.draggableId];
      var draggingOver = whatIsDraggedOver(state.impact);
      var combineWith = getCombineWithFromImpact(state.impact);
      var forceShouldAnimate = state.forceShouldAnimate;
      return getMemoizedProps(memoizedOffset(offset3.x, offset3.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (completed.result.draggableId !== ownProps.draggableId) {
        return null;
      }
      var isClone = ownProps.isClone;
      var _dimension = state.dimensions.draggables[ownProps.draggableId];
      var result = completed.result;
      var mode = result.mode;
      var _draggingOver = whatIsDraggedOverFromResult(result);
      var _combineWith = getCombineWithFromResult(result);
      var duration5 = state.dropDuration;
      var dropping = {
        duration: duration5,
        curve: curves.drop,
        moveTo: state.newHomeClientOffset,
        opacity: _combineWith ? combine.opacity.drop : null,
        scale: _combineWith ? combine.scale.drop : null
      };
      return {
        mapped: {
          type: "DRAGGING",
          offset: state.newHomeClientOffset,
          dimension: _dimension,
          dropping,
          draggingOver: _draggingOver,
          combineWith: _combineWith,
          mode,
          forceShouldAnimate: null,
          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)
        }
      };
    }
    return null;
  };
  return selector;
}
function getSecondarySnapshot(combineTargetFor) {
  return {
    isDragging: false,
    isDropAnimating: false,
    isClone: false,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor,
    combineWith: null
  };
}
var atRest = {
  mapped: {
    type: "SECONDARY",
    offset: origin,
    combineTargetFor: null,
    shouldAnimateDisplacement: true,
    snapshot: getSecondarySnapshot(null)
  }
};
function getSecondarySelector() {
  var memoizedOffset = memoizeOne(function(x, y2) {
    return {
      x,
      y: y2
    };
  });
  var getMemoizedSnapshot = memoizeOne(getSecondarySnapshot);
  var getMemoizedProps = memoizeOne(function(offset3, combineTargetFor, shouldAnimateDisplacement) {
    if (combineTargetFor === void 0) {
      combineTargetFor = null;
    }
    return {
      mapped: {
        type: "SECONDARY",
        offset: offset3,
        combineTargetFor,
        shouldAnimateDisplacement,
        snapshot: getMemoizedSnapshot(combineTargetFor)
      }
    };
  });
  var getFallback = function getFallback2(combineTargetFor) {
    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
  };
  var getProps = function getProps2(ownId, draggingId, impact, afterCritical) {
    var visualDisplacement = impact.displaced.visible[ownId];
    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
    var combine2 = tryGetCombine(impact);
    var combineTargetFor = combine2 && combine2.draggableId === ownId ? draggingId : null;
    if (!visualDisplacement) {
      if (!isAfterCriticalInVirtualList) {
        return getFallback(combineTargetFor);
      }
      if (impact.displaced.invisible[ownId]) {
        return null;
      }
      var change = negate(afterCritical.displacedBy.point);
      var _offset = memoizedOffset(change.x, change.y);
      return getMemoizedProps(_offset, combineTargetFor, true);
    }
    if (isAfterCriticalInVirtualList) {
      return getFallback(combineTargetFor);
    }
    var displaceBy = impact.displacedBy.point;
    var offset3 = memoizedOffset(displaceBy.x, displaceBy.y);
    return getMemoizedProps(offset3, combineTargetFor, visualDisplacement.shouldAnimate);
  };
  var selector = function selector2(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (completed.result.draggableId === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
    }
    return null;
  };
  return selector;
}
var makeMapStateToProps = function makeMapStateToProps2() {
  var draggingSelector = getDraggableSelector();
  var secondarySelector = getSecondarySelector();
  var selector = function selector2(state, ownProps) {
    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
  };
  return selector;
};
var mapDispatchToProps = {
  dropAnimationFinished
};
var ConnectedDraggable = connect(makeMapStateToProps, mapDispatchToProps, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Draggable);
function PrivateDraggable(props) {
  var droppableContext = useRequiredContext(DroppableContext);
  var isUsingCloneFor = droppableContext.isUsingCloneFor;
  if (isUsingCloneFor === props.draggableId && !props.isClone) {
    return null;
  }
  return React.createElement(ConnectedDraggable, props);
}
function PublicDraggable(props) {
  var isEnabled3 = typeof props.isDragDisabled === "boolean" ? !props.isDragDisabled : true;
  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
  return React.createElement(PrivateDraggable, _extends$8({}, props, {
    isClone: false,
    isEnabled: isEnabled3,
    canDragInteractiveElements,
    shouldRespectForcePress
  }));
}
function Droppable(props) {
  var appContext = reactExports.useContext(AppContext);
  !appContext ? invariant(false) : void 0;
  var contextId = appContext.contextId, isMovementAllowed2 = appContext.isMovementAllowed;
  var droppableRef = reactExports.useRef(null);
  var placeholderRef = reactExports.useRef(null);
  var children = props.children, droppableId = props.droppableId, type2 = props.type, mode = props.mode, direction = props.direction, ignoreContainerClipping = props.ignoreContainerClipping, isDropDisabled = props.isDropDisabled, isCombineEnabled = props.isCombineEnabled, snapshot = props.snapshot, useClone = props.useClone, updateViewportMaxScroll3 = props.updateViewportMaxScroll, getContainerForClone = props.getContainerForClone;
  var getDroppableRef = useCallback(function() {
    return droppableRef.current;
  }, []);
  var setDroppableRef = useCallback(function(value) {
    droppableRef.current = value;
  }, []);
  useCallback(function() {
    return placeholderRef.current;
  }, []);
  var setPlaceholderRef = useCallback(function(value) {
    placeholderRef.current = value;
  }, []);
  var onPlaceholderTransitionEnd = useCallback(function() {
    if (isMovementAllowed2()) {
      updateViewportMaxScroll3({
        maxScroll: getMaxWindowScroll()
      });
    }
  }, [isMovementAllowed2, updateViewportMaxScroll3]);
  useDroppablePublisher({
    droppableId,
    type: type2,
    mode,
    direction,
    isDropDisabled,
    isCombineEnabled,
    ignoreContainerClipping,
    getDroppableRef
  });
  var placeholder = React.createElement(AnimateInOut, {
    on: props.placeholder,
    shouldAnimate: props.shouldAnimatePlaceholder
  }, function(_ref) {
    var onClose = _ref.onClose, data = _ref.data, animate2 = _ref.animate;
    return React.createElement(Placeholder$1, {
      placeholder: data,
      onClose,
      innerRef: setPlaceholderRef,
      animate: animate2,
      contextId,
      onTransitionEnd: onPlaceholderTransitionEnd
    });
  });
  var provided = useMemo(function() {
    return {
      innerRef: setDroppableRef,
      placeholder,
      droppableProps: {
        "data-rbd-droppable-id": droppableId,
        "data-rbd-droppable-context-id": contextId
      }
    };
  }, [contextId, droppableId, placeholder, setDroppableRef]);
  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
  var droppableContext = useMemo(function() {
    return {
      droppableId,
      type: type2,
      isUsingCloneFor
    };
  }, [droppableId, isUsingCloneFor, type2]);
  function getClone() {
    if (!useClone) {
      return null;
    }
    var dragging = useClone.dragging, render = useClone.render;
    var node2 = React.createElement(PrivateDraggable, {
      draggableId: dragging.draggableId,
      index: dragging.source.index,
      isClone: true,
      isEnabled: true,
      shouldRespectForcePress: false,
      canDragInteractiveElements: true
    }, function(draggableProvided, draggableSnapshot) {
      return render(draggableProvided, draggableSnapshot, dragging);
    });
    return ReactDOM.createPortal(node2, getContainerForClone());
  }
  return React.createElement(DroppableContext.Provider, {
    value: droppableContext
  }, children(provided, snapshot), getClone());
}
var isMatchingType = function isMatchingType2(type2, critical) {
  return type2 === critical.droppable.type;
};
var getDraggable = function getDraggable2(critical, dimensions) {
  return dimensions.draggables[critical.draggable.id];
};
var makeMapStateToProps$1 = function makeMapStateToProps3() {
  var idleWithAnimation = {
    placeholder: null,
    shouldAnimatePlaceholder: true,
    snapshot: {
      isDraggingOver: false,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: false
    },
    useClone: null
  };
  var idleWithoutAnimation = _extends$8({}, idleWithAnimation, {
    shouldAnimatePlaceholder: false
  });
  var getDraggableRubric = memoizeOne(function(descriptor) {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  });
  var getMapProps = memoizeOne(function(id2, isEnabled3, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {
    var draggableId = dragging.descriptor.id;
    var isHome = dragging.descriptor.droppableId === id2;
    if (isHome) {
      var useClone = renderClone ? {
        render: renderClone,
        dragging: getDraggableRubric(dragging.descriptor)
      } : null;
      var _snapshot = {
        isDraggingOver: isDraggingOverForConsumer,
        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
        draggingFromThisWith: draggableId,
        isUsingPlaceholder: true
      };
      return {
        placeholder: dragging.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: _snapshot,
        useClone
      };
    }
    if (!isEnabled3) {
      return idleWithoutAnimation;
    }
    if (!isDraggingOverForImpact) {
      return idleWithAnimation;
    }
    var snapshot = {
      isDraggingOver: isDraggingOverForConsumer,
      draggingOverWith: draggableId,
      draggingFromThisWith: null,
      isUsingPlaceholder: true
    };
    return {
      placeholder: dragging.placeholder,
      shouldAnimatePlaceholder: true,
      snapshot,
      useClone: null
    };
  });
  var selector = function selector2(state, ownProps) {
    var id2 = ownProps.droppableId;
    var type2 = ownProps.type;
    var isEnabled3 = !ownProps.isDropDisabled;
    var renderClone = ownProps.renderClone;
    if (state.isDragging) {
      var critical = state.critical;
      if (!isMatchingType(type2, critical)) {
        return idleWithoutAnimation;
      }
      var dragging = getDraggable(critical, state.dimensions);
      var isDraggingOver = whatIsDraggedOver(state.impact) === id2;
      return getMapProps(id2, isEnabled3, isDraggingOver, isDraggingOver, dragging, renderClone);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (!isMatchingType(type2, completed.critical)) {
        return idleWithoutAnimation;
      }
      var _dragging = getDraggable(completed.critical, state.dimensions);
      return getMapProps(id2, isEnabled3, whatIsDraggedOverFromResult(completed.result) === id2, whatIsDraggedOver(completed.impact) === id2, _dragging, renderClone);
    }
    if (state.phase === "IDLE" && state.completed && !state.shouldFlush) {
      var _completed = state.completed;
      if (!isMatchingType(type2, _completed.critical)) {
        return idleWithoutAnimation;
      }
      var wasOver = whatIsDraggedOver(_completed.impact) === id2;
      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === "COMBINE");
      var isHome = _completed.critical.droppable.id === id2;
      if (wasOver) {
        return wasCombining ? idleWithAnimation : idleWithoutAnimation;
      }
      if (isHome) {
        return idleWithAnimation;
      }
      return idleWithoutAnimation;
    }
    return idleWithoutAnimation;
  };
  return selector;
};
var mapDispatchToProps$1 = {
  updateViewportMaxScroll
};
function getBody() {
  !document.body ? invariant(false) : void 0;
  return document.body;
}
var defaultProps = {
  mode: "standard",
  type: "DEFAULT",
  direction: "vertical",
  isDropDisabled: false,
  isCombineEnabled: false,
  ignoreContainerClipping: false,
  renderClone: null,
  getContainerForClone: getBody
};
var ConnectedDroppable = connect(makeMapStateToProps$1, mapDispatchToProps$1, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Droppable);
ConnectedDroppable.defaultProps = defaultProps;
var Reorder = {};
var _interopRequireDefault$3 = interopRequireDefaultExports;
Object.defineProperty(Reorder, "__esModule", {
  value: true
});
var default_1$3 = Reorder.default = void 0;
var _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon());
var _jsxRuntime$3 = require$$2;
var _default$3 = (0, _createSvgIcon$3.default)(/* @__PURE__ */ (0, _jsxRuntime$3.jsx)("path", {
  d: "M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"
}), "Reorder");
default_1$3 = Reorder.default = _default$3;
function StrictModeDroppable({ children, ...props }) {
  const [enabled, setEnabled] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const animation = requestAnimationFrame(() => setEnabled(true));
    return () => {
      cancelAnimationFrame(animation);
      setEnabled(false);
    };
  }, []);
  if (!enabled) {
    return null;
  }
  return /* @__PURE__ */ jsx(ConnectedDroppable, { ...props, children });
}
function VerticalList({
  videos: videosProp,
  draggable: draggable2,
  onDragEnd: onDragEnd3,
  emptyText,
  urlParamsGenerator
}) {
  const [videos, setVideos] = reactExports.useState(videosProp);
  const onDragEndLocal = (result) => {
    const { destination, source } = result;
    if ((destination == null ? void 0 : destination.droppableId) === source.droppableId && destination.index === source.index) {
      return;
    }
    if (!destination) {
      return;
    }
    const newList = Array.from(videos);
    const removed = newList.splice(source.index, 1);
    newList.splice(destination.index, 0, removed[0]);
    setVideos(newList);
    if (onDragEnd3) {
      onDragEnd3(videos);
    }
  };
  return /* @__PURE__ */ jsx(DragDropContext, { onDragEnd: onDragEndLocal, children: /* @__PURE__ */ jsx(StrictModeDroppable, { droppableId: "playlistOrder", isDropDisabled: !draggable2, children: (provided) => /* @__PURE__ */ jsx(
    Grid$1,
    {
      container: true,
      item: true,
      spacing: 2,
      xs: 12,
      ref: provided.innerRef,
      ...provided.droppableProps,
      sx: { border: "1px solid #30BCED", borderRadius: "10px" },
      minHeight: "100%",
      alignContent: "flex-start",
      children: videos.length > 0 ? videos.map((video2, index2) => {
        return /* @__PURE__ */ jsx(
          PublicDraggable,
          {
            draggableId: video2.id,
            index: index2,
            isDragDisabled: !draggable2,
            children: (draggableProvided) => /* @__PURE__ */ reactExports.createElement(
              Grid$1,
              {
                ref: draggableProvided.innerRef,
                ...draggableProvided.draggableProps,
                key: video2.id,
                item: true,
                xs: 12,
                display: "flex",
                alignItems: "stretch",
                maxHeight: "125px",
                p: 1,
                pl: -1,
                pr: 2
              },
              draggable2 && /* @__PURE__ */ jsx(
                Box$3,
                {
                  ...draggableProvided.dragHandleProps,
                  padding: 1,
                  pl: 0,
                  display: "flex",
                  children: /* @__PURE__ */ jsx(Box$3, { alignSelf: "center", children: /* @__PURE__ */ jsx(default_1$3, {}) })
                }
              ),
              /* @__PURE__ */ jsx(
                VideoCard,
                {
                  video: video2,
                  fullWidth: true,
                  smallThumbnail: true,
                  showDescription: false,
                  urlParams: urlParamsGenerator ? urlParamsGenerator(video2, index2) : ""
                },
                video2.id
              )
            )
          },
          video2.id
        );
      }) : /* @__PURE__ */ jsxs(
        Box$3,
        {
          height: "75vh",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexDirection: "column",
          width: "100%",
          children: [
            /* @__PURE__ */ jsx(Typography$1, { variant: "body1", children: "Seznam neobsahuje dn zznam " }),
            emptyText && /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: emptyText })
          ]
        }
      )
    }
  ) }) });
}
const loader$7 = ({ params }) => {
  return playlistsGET(params.Id);
};
function PlaylistDetail({ newPlaylist }) {
  var _a, _b, _c;
  let playlistProp;
  if (!newPlaylist) {
    playlistProp = useLoaderData();
  }
  const userContext = reactExports.useContext(UserContext);
  const [playlist, setPlaylist] = reactExports.useState(playlistProp ?? new PlaylistDTO());
  const [editMode, setEditMode] = reactExports.useState(newPlaylist ?? false);
  const [canEdit, setCanEdit] = reactExports.useState(false);
  const [imageToUpload, setImageToUpload] = reactExports.useState();
  const [statusText, setStatusText] = reactExports.useState();
  const myChannelsQuery = useMyChannelsQuery();
  const createPlaylistMutation = usePlaylistsPOSTMutation();
  const updatePlaylistMutation = usePlaylistsPUTMutation(playlist.id);
  reactExports.useLayoutEffect(() => ScrollToTop(), [playlist.id]);
  const onListDragEnd = (videos) => {
    setPlaylist(new PlaylistDTO({ ...playlist, videos }));
  };
  const toggleEditMode = (value) => {
    setEditMode(value);
  };
  reactExports.useEffect(() => {
    var _a2;
    setCanEdit((playlistProp == null ? void 0 : playlistProp.ownerId) === ((_a2 = userContext == null ? void 0 : userContext.user) == null ? void 0 : _a2.id));
  }, [playlistProp, userContext]);
  const submitHandler = async (event) => {
    var _a2, _b2, _c2;
    event.preventDefault();
    const data = new FormData(event.currentTarget);
    const description = (_a2 = data.get("description")) == null ? void 0 : _a2.toString();
    const name = (_b2 = data.get("name")) == null ? void 0 : _b2.toString();
    const channelId = (_c2 = data.get("channelSelect")) == null ? void 0 : _c2.toString();
    if (newPlaylist) {
      createPlaylistMutation.mutate(
        {
          name,
          channelId,
          description,
          thumbnail: imageToUpload ? { data: imageToUpload, fileName: imageToUpload.name } : void 0
        },
        {
          onSuccess: () => {
            const token2 = localStorage.getItem("token");
            if (!token2) {
              setStatusText("Dolo k odhlen, prosm pihlaste se znovu.");
            }
            setStatusText("Playlist spn zaloen.");
          },
          onError: () => {
            setStatusText(`Playlist se nepodailo zaloit `);
          }
        }
      );
    } else {
      updatePlaylistMutation.mutate(
        {
          name,
          channelId,
          description,
          thumbnail: imageToUpload ? { data: imageToUpload, fileName: imageToUpload.name } : void 0
        },
        {
          onSuccess: () => {
            setStatusText("Playlist spn aktualizovn ");
          },
          onError: () => {
            setStatusText(`Playlist se nepodailo aktualizovat `);
          }
        }
      );
    }
  };
  return /* @__PURE__ */ jsxs(Box$3, { margin: 4, children: [
    /* @__PURE__ */ jsx(Grid$1, { container: true, xs: 12, sx: { alignItems: "flex-start" }, children: /* @__PURE__ */ jsxs(
      Grid$1,
      {
        item: true,
        position: { xs: "initial", md: "fixed" },
        width: { xs: "100%", md: editMode ? "calc(100%/2.5)" : "calc(100%/4.4)" },
        children: [
          statusText && editMode && /* @__PURE__ */ jsx(Alert$1, { severity: "info", children: statusText }),
          /* @__PURE__ */ jsxs(Box$3, { component: "form", onSubmit: submitHandler, children: [
            editMode && /* @__PURE__ */ jsx(
              Box$3,
              {
                display: "flex",
                position: "absolute",
                zIndex: 1,
                right: 0,
                justifyContent: "space-between",
                children: /* @__PURE__ */ jsxs(Box$3, { gap: 2, display: "flex", pt: 1, children: [
                  /* @__PURE__ */ jsx(
                    Button$2,
                    {
                      variant: "outlined",
                      startIcon: /* @__PURE__ */ jsx(default_1$7, {}),
                      onClick: () => toggleEditMode(false),
                      children: "Zahodit zmny"
                    }
                  ),
                  /* @__PURE__ */ jsx(Button$2, { type: "submit", variant: "contained", startIcon: /* @__PURE__ */ jsx(default_1$8, {}), children: "Uloit" })
                ] })
              }
            ),
            /* @__PURE__ */ jsxs(Box$3, { width: editMode ? "60%" : void 0, pt: editMode ? 4 : 1, children: [
              editMode && /* @__PURE__ */ jsx(Typography$1, { children: "Nhledov obrzek:" }),
              /* @__PURE__ */ jsx(
                FileUploadWithPreview,
                {
                  uploadedFile: imageToUpload,
                  setUploadedFile: setImageToUpload,
                  existingImageUrl: ApiPath(
                    (playlist == null ? void 0 : playlist.thumbnailUrl) ? playlist.thumbnailUrl : ((_a = playlist == null ? void 0 : playlist.videos) == null ? void 0 : _a.length) ? playlist == null ? void 0 : playlist.videos[0].imageUrl : void 0
                  ),
                  readOnly: !editMode
                }
              )
            ] }),
            !editMode && /* @__PURE__ */ jsxs(Box$3, { display: "flex", justifyContent: "space-between", pt: 1, pb: 2, children: [
              /* @__PURE__ */ jsx(
                Button$2,
                {
                  startIcon: /* @__PURE__ */ jsx(default_1$b, {}),
                  variant: "contained",
                  component: Link,
                  to: ((_b = playlist == null ? void 0 : playlist.videos) == null ? void 0 : _b.length) ? videoUrl(playlist == null ? void 0 : playlist.videos[0]) + playlistParams(playlist, 0) : "",
                  children: "Pehrt ve"
                }
              ),
              canEdit && /* @__PURE__ */ jsx(
                Button$2,
                {
                  startIcon: /* @__PURE__ */ jsx(default_1$a, {}),
                  variant: "contained",
                  onClick: () => toggleEditMode(true),
                  children: "Upravit"
                }
              )
            ] }),
            editMode ? /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 2, children: [
              /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
                TextField$1,
                {
                  required: true,
                  id: "name",
                  name: "name",
                  label: "Nzev",
                  fullWidth: true,
                  defaultValue: playlist == null ? void 0 : playlist.name
                }
              ) }),
              /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
                TextField$1,
                {
                  required: true,
                  id: "description",
                  name: "description",
                  label: "Popis",
                  fullWidth: true,
                  defaultValue: playlist == null ? void 0 : playlist.description,
                  multiline: true,
                  minRows: 2,
                  maxRows: 3
                }
              ) }),
              /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
                MyChannelsDropdown,
                {
                  channels: myChannelsQuery.data,
                  defaultValue: (_c = playlist == null ? void 0 : playlist.channel) == null ? void 0 : _c.id
                }
              ) })
            ] }) : /* @__PURE__ */ jsxs(Box$3, { children: [
              /* @__PURE__ */ jsxs(Typography$1, { variant: "body1", padding: 2, pt: 0, pl: 0, children: [
                "Nzev: ",
                playlist == null ? void 0 : playlist.name
              ] }),
              /* @__PURE__ */ jsxs(Typography$1, { variant: "body1", padding: 2, pl: 0, children: [
                "Popis: ",
                playlist == null ? void 0 : playlist.description
              ] })
            ] }),
            !editMode && /* @__PURE__ */ jsxs(Typography$1, { variant: "body1", padding: 2, pl: 0, children: [
              "Celkov dlka: ",
              (playlist == null ? void 0 : playlist.totalDuration) ?? "00:00"
            ] })
          ] })
        ]
      }
    ) }),
    /* @__PURE__ */ jsx(
      Box$3,
      {
        sx: { paddingLeft: editMode ? "calc(100% / 1.8)" : "calc(100% / 3)" },
        pt: 3,
        height: "75vh",
        children: /* @__PURE__ */ jsx(
          VerticalList,
          {
            videos: (playlist == null ? void 0 : playlist.videos) ?? [],
            onDragEnd: onListDragEnd,
            draggable: editMode,
            emptyText: "Pidvat videa lze pmo z detailu videa, pes volbu Pidat do playlistu",
            urlParamsGenerator: (_2, index2) => playlistParams(playlist, index2)
          }
        )
      }
    )
  ] });
}
var OndemandVideo = {};
var _interopRequireDefault$2 = interopRequireDefaultExports;
Object.defineProperty(OndemandVideo, "__esModule", {
  value: true
});
var default_1$2 = OndemandVideo.default = void 0;
var _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon());
var _jsxRuntime$2 = require$$2;
var _default$2 = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
  d: "M21 3H3c-1.11 0-2 .89-2 2v12c0 1.1.89 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.11-.9-2-2-2zm0 14H3V5h18v12zm-5-6-7 4V7z"
}), "OndemandVideo");
default_1$2 = OndemandVideo.default = _default$2;
var VideoLibrary = {};
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(VideoLibrary, "__esModule", {
  value: true
});
var default_1$1 = VideoLibrary.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = require$$2;
var _default$1 = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8 12.5v-9l6 4.5-6 4.5z"
}), "VideoLibrary");
default_1$1 = VideoLibrary.default = _default$1;
var Info = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(Info, "__esModule", {
  value: true
});
var default_1 = Info.default = void 0;
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = require$$2;
var _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"
}), "Info");
default_1 = Info.default = _default;
async function getChannelById(id2) {
  return channelsGET(id2);
}
async function getChannelAdvancedInfo(id2) {
  return channelAdvancedInfo(id2);
}
async function getChannelPlaylists(id2) {
  return channelPlaylists(id2);
}
async function loader$6({ params }) {
  return getChannelById(params.channelId);
}
function Channel2() {
  var _a;
  const channelBasicInfo = useLoaderData();
  const userContext = reactExports.useContext(UserContext);
  const channelUserSpecificInfoQuery = useChannelUserInfoGETQuery(channelBasicInfo.id, {
    enabled: !!(userContext == null ? void 0 : userContext.user),
    staleTime: 1 * 60 * 1e3
  });
  const channelUserInfoPUTMutation = useChannelUserInfoPUTMutation(channelBasicInfo.id, {
    onSuccess: () => {
      channelUserSpecificInfoQuery.refetch();
    }
  });
  const [tab2, setTab] = React.useState(0);
  const handleTabChange = (event, newTab) => {
    setTab(newTab);
  };
  const handleSubscribe = (_2) => {
    channelUserInfoPUTMutation.mutate(new ChannelUserSpecificInfoDTO({ subscribed: true }));
  };
  const handleUnsubscribe = (_2) => {
    channelUserInfoPUTMutation.mutate(new ChannelUserSpecificInfoDTO({ subscribed: false }));
  };
  reactExports.useEffect(() => {
    channelUserSpecificInfoQuery.refetch();
  }, [userContext == null ? void 0 : userContext.user]);
  return /* @__PURE__ */ jsx(Box$3, { children: /* @__PURE__ */ jsxs(Grid$1, { container: true, justifyContent: "center", children: [
    /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: (channelBasicInfo == null ? void 0 : channelBasicInfo.posterUrl) ? /* @__PURE__ */ jsx(
      "img",
      {
        width: "100%",
        height: "200px",
        style: { objectFit: "cover" },
        src: ApiPath(channelBasicInfo.posterUrl),
        alt: "channel poster"
      }
    ) : /* @__PURE__ */ jsx(Box$3, { height: "50px" }) }),
    /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 10, display: "flex", justifyContent: "space-between", children: [
      /* @__PURE__ */ jsxs(Box$3, { display: "flex", alignItems: "center", children: [
        /* @__PURE__ */ jsx(
          Avatar$2,
          {
            sx: {
              width: 64,
              height: 64,
              border: "0.1px solid lightgray",
              padding: "4px",
              img: { objectFit: "fill", borderRadius: "50%" }
            },
            src: ApiPath(channelBasicInfo.avatarUrl),
            children: !channelBasicInfo.avatarUrl ? GetInitials(channelBasicInfo.name) : ""
          }
        ),
        /* @__PURE__ */ jsxs(Box$3, { display: "flex", flexDirection: "column", pl: 2, children: [
          /* @__PURE__ */ jsx(Typography$1, { variant: "h5", children: channelBasicInfo.name }),
          /* @__PURE__ */ jsxs(Typography$1, { variant: "caption", children: [
            NumberToWords(channelBasicInfo.subscribersCount),
            " odbratel"
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsx(Box$3, { display: "flex", alignItems: "center", children: ((_a = channelUserSpecificInfoQuery == null ? void 0 : channelUserSpecificInfoQuery.data) == null ? void 0 : _a.subscribed) ?? false ? /* @__PURE__ */ jsx(
        Button$2,
        {
          variant: "outlined",
          onClick: handleUnsubscribe,
          disabled: channelUserInfoPUTMutation == null ? void 0 : channelUserInfoPUTMutation.isLoading,
          children: "Zruit odbr"
        }
      ) : /* @__PURE__ */ jsx(
        Button$2,
        {
          variant: "contained",
          disabled: !(userContext == null ? void 0 : userContext.user) || (channelUserInfoPUTMutation == null ? void 0 : channelUserInfoPUTMutation.isLoading),
          onClick: handleSubscribe,
          children: "Odebrat"
        }
      ) })
    ] }),
    /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 10, children: /* @__PURE__ */ jsxs(
      Tabs$1,
      {
        value: tab2,
        sx: { height: "48px", minHeight: "48px" },
        onChange: handleTabChange,
        "aria-label": "basic tabs example",
        centered: true,
        children: [
          /* @__PURE__ */ jsx(
            Tab$1,
            {
              icon: /* @__PURE__ */ jsx(default_1$t, {}),
              iconPosition: "start",
              component: Link,
              sx: { height: "48px", minHeight: "48px" },
              to: "./",
              label: "Domovsk strnka"
            }
          ),
          /* @__PURE__ */ jsx(
            Tab$1,
            {
              icon: /* @__PURE__ */ jsx(default_1$2, {}),
              iconPosition: "start",
              component: Link,
              sx: { height: "48px", minHeight: "48px" },
              to: "./videos",
              label: "Videa"
            }
          ),
          /* @__PURE__ */ jsx(
            Tab$1,
            {
              icon: /* @__PURE__ */ jsx(default_1$1, {}),
              iconPosition: "start",
              component: Link,
              sx: { height: "48px", minHeight: "48px" },
              to: "./playlists",
              label: "Playlisty"
            }
          ),
          /* @__PURE__ */ jsx(
            Tab$1,
            {
              icon: /* @__PURE__ */ jsx(default_1, {}),
              iconPosition: "start",
              component: Link,
              sx: { height: "48px", minHeight: "48px" },
              to: "./info",
              label: "Informace"
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 10, margin: 2, children: /* @__PURE__ */ jsx(Outlet, {}) })
  ] }) });
}
async function loader$5({ params }) {
  return {
    channelId: params.channelId,
    pinnedVideoId: params.channelPinnedVideoId
  };
}
function ChannelHomePage() {
  var _a, _b;
  const { channelId, pinnedVideoId } = useLoaderData();
  const [playlists, setPlaylists] = reactExports.useState([]);
  const latestVideos = useChannelVideosQuery(channelId);
  const pinnedVideo = useVideosGETQuery(pinnedVideoId);
  reactExports.useEffect(() => {
    (async () => {
      setPlaylists(await getChannelPlaylists(channelId));
    })();
  }, []);
  return /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 2, children: [
    (pinnedVideo == null ? void 0 : pinnedVideo.data) && /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, mt: 2, mb: 2, children: /* @__PURE__ */ jsx(
      VideoCard,
      {
        video: pinnedVideo.data,
        fullWidth: true,
        withPlayer: true,
        showChannel: false
      },
      pinnedVideo.data.id
    ) }),
    !latestVideos.isLoading && (latestVideos == null ? void 0 : latestVideos.data) && (((_b = (_a = latestVideos == null ? void 0 : latestVideos.data) == null ? void 0 : _a.items) == null ? void 0 : _b.length) ?? 0) > 0 ? /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", children: "Nejnovj videa" }),
      /* @__PURE__ */ jsx(VideoInlineList, { videos: latestVideos == null ? void 0 : latestVideos.data.items, showDescription: true })
    ] }) : /* @__PURE__ */ jsx(Typography$1, { alignSelf: "center", children: "Kanl nem dn videa " }),
    playlists.length > 0 && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, children: [
        /* @__PURE__ */ jsx(Typography$1, { variant: "h6", children: "Playlisty" }),
        /* @__PURE__ */ jsx(PlaylistInlineList, { playlists })
      ] }),
      /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(ExpandedPlaylistInlineList, { playlist: playlists[0] }) })
    ] })
  ] });
}
async function loader$4({ params }) {
  return params.channelId;
}
const pageSize$2 = 8;
function ChannelVideos() {
  var _a, _b;
  const channelId = useLoaderData();
  const videos = useInfiniteQuery({
    queryKey: [...channelVideosQueryKey({ id: channelId }), "infinite"],
    queryFn: async (params) => {
      const pageParam = params.pageParam ?? 0;
      return channelVideos(channelId, pageSize$2, pageParam * pageSize$2);
    },
    getNextPageParam: (lastPage, pages) => {
      return lastPage.totalCount > pages.length * pageSize$2 ? pages.length : void 0;
    },
    refetchOnWindowFocus: false
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Grid$1, { container: true, spacing: 1, children: (_b = (_a = videos == null ? void 0 : videos.data) == null ? void 0 : _a.pages) == null ? void 0 : _b.map((group, i) => /* @__PURE__ */ jsx(React.Fragment, { children: group == null ? void 0 : group.items.map((video2) => {
      return /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsx(VideoCard, { video: video2, showChannel: false }, video2.id) }, video2.id);
    }) }, i)) }),
    videos.hasNextPage && /* @__PURE__ */ jsx(
      Button$2,
      {
        sx: { width: "100%", mt: "1em" },
        variant: "outlined",
        onClick: () => videos.fetchNextPage(),
        disabled: !videos.hasNextPage || videos.isFetchingNextPage,
        children: videos.isFetchingNextPage ? "Natn..." : "Nast dal"
      }
    )
  ] });
}
async function loader$3({ params }) {
  return params.channelId;
}
const pageSize$1 = 8;
function ChannelPlaylists() {
  var _a, _b;
  const channelId = useLoaderData();
  const playlists = useInfiniteQuery({
    queryKey: [...channelPlaylistsQueryKey({ id: channelId }), "infinite"],
    queryFn: async (params) => {
      const pageParam = params.pageParam ?? 0;
      return channelPlaylists(channelId, pageSize$1, pageParam * pageSize$1);
    },
    getNextPageParam: (lastPage, pages) => {
      return lastPage.totalCount > pages.length * pageSize$1 ? pages.length : void 0;
    },
    refetchOnWindowFocus: false
  });
  return /* @__PURE__ */ jsx(Grid$1, { container: true, spacing: 1, children: (_b = (_a = playlists == null ? void 0 : playlists.data) == null ? void 0 : _a.pages) == null ? void 0 : _b.map((group, i) => /* @__PURE__ */ jsx(React.Fragment, { children: group == null ? void 0 : group.items.map((playlist) => {
    return /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, md: 3, children: /* @__PURE__ */ jsx(PlaylistCard, { playlist: { ...playlist } }, playlist.id) }, playlist.id);
  }) }, i)) });
}
async function loader$2({ params }) {
  return getChannelAdvancedInfo(params.channelId);
}
function ChannelInfo() {
  var _a;
  const info = useLoaderData();
  return /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 2, children: [
    /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 7, columns: 2, children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", mb: 1, children: "Informace o kanlu" }),
      /* @__PURE__ */ jsxs(Box$1, { display: "flex", flexDirection: "column", gap: 2, children: [
        /* @__PURE__ */ jsxs(Box$1, { children: [
          /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: "Popis:" }),
          /* @__PURE__ */ jsx(Typography$1, { children: info.description })
        ] }),
        /* @__PURE__ */ jsxs(Box$1, { children: [
          /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: "Datum registrace:" }),
          /* @__PURE__ */ jsx(Typography$1, { children: info.dateOfRegistration.toLocaleString() })
        ] }),
        /* @__PURE__ */ jsx(Box$1, { children: info.email && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(Typography$1, { variant: "caption", children: "Kontaktn email:" }),
          /* @__PURE__ */ jsx(Typography$1, { children: info.email })
        ] }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 5, children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", mb: 1, children: "Pipnut kanly" }),
      /* @__PURE__ */ jsx(Box$1, { display: "flex", flexDirection: "column", children: (_a = info.relatedChannels) == null ? void 0 : _a.map((channel) => /* @__PURE__ */ jsx(Box$1, { children: /* @__PURE__ */ jsx(
        AvatarButton,
        {
          url: `/${Route.channel}/${channel.id}`,
          text: channel.name,
          image: ApiPath(channel.avatarUrl)
        }
      ) }, channel.id)) })
    ] })
  ] });
}
function AvatarButtonInRow({ id: id2, name, avatarUrl }) {
  return /* @__PURE__ */ jsx(AvatarButton, { text: name, image: ApiPath(avatarUrl) });
}
function MyChannels() {
  const myChannelsQuery = useMyChannelsQuery();
  const navigate = useNavigate();
  const [statusText, setStatusText] = reactExports.useState();
  const attributes = [
    {
      id: "avatarUrl",
      imageCustomElement: (row) => AvatarButtonInRow(row),
      label: "Nzev"
    },
    {
      id: "subscribersCount",
      label: "Poet odbratel"
    }
  ];
  const buttons = [
    {
      icon: /* @__PURE__ */ jsx(default_1$g, {}),
      label: "Smazat",
      onClick(selectedIDs) {
        if (!(selectedIDs == null ? void 0 : selectedIDs.length)) {
          return;
        }
        setStatusText(void 0);
        const promises = selectedIDs.map((id2) => channelsDELETE(id2));
        Promise.all(promises).then(() => {
          myChannelsQuery.refetch();
          setStatusText("Kanl byl spn smazn");
        }).catch(() => {
          setStatusText(
            "Kanl se nepodailo smazat, zkontrolujte e jste z nj odebrali vechna videa"
          );
        });
      }
    }
  ];
  const staticButtons = [
    {
      icon: /* @__PURE__ */ jsx(default_1$9, {}),
      label: "Vytvoit nov kanl",
      onClick: () => navigate(`/${Route.myChannels}/create`)
    }
  ];
  const rowClick = (event, id2) => {
    navigate({
      pathname: `/${Route.myChannels}/${id2}`
    });
  };
  return /* @__PURE__ */ jsxs(Box$1, { m: 4, children: [
    statusText && /* @__PURE__ */ jsx(Box$1, { mb: 1, children: /* @__PURE__ */ jsx(Alert$1, { severity: "info", children: statusText }) }),
    (myChannelsQuery == null ? void 0 : myChannelsQuery.data) && /* @__PURE__ */ jsx(
      EnhancedTable,
      {
        attributes,
        rows: myChannelsQuery == null ? void 0 : myChannelsQuery.data,
        orderBy: "name",
        desc: "asc",
        buttons,
        staticButtons,
        rowClick
      }
    )
  ] });
}
const loader$1 = ({ params }) => {
  return channelsGET(params.Id);
};
function ChannelEdit({ newChannel = false }) {
  var _a;
  let channel;
  if (!newChannel) {
    channel = useLoaderData();
  }
  const [statusText, setStatusText] = reactExports.useState();
  const channelAdvancedInfo2 = (channel == null ? void 0 : channel.id) ?? false ? useChannelAdvancedInfoQuery({ id: channel.id }) : void 0;
  const [avatarToUpload, setAvatarToUpload] = reactExports.useState();
  const [posterToUpload, setPosterToUpload] = reactExports.useState();
  const [relatedChannels, setRelatedChannels] = reactExports.useState([]);
  const channelPostMutation = useChannelsPOSTMutation({
    onSuccess: () => setStatusText("Kanl byl spn vytvoen"),
    onError: (e2) => setStatusText(`Kanl se nepovedlo vytvoit - ${e2}`)
  });
  const channelPutMutation = useChannelsPUTMutation((channel == null ? void 0 : channel.id) ?? "", {
    onSuccess: () => setStatusText("Kanl byl spn aktualizovn"),
    onError: (e2) => setStatusText(`Kanl se nepovedlo aktualizovat - ${e2}`)
  });
  const allChannelsQuery = useChannelsAllQuery();
  reactExports.useEffect(() => {
    var _a2, _b, _c;
    if (((_a2 = channelAdvancedInfo2 == null ? void 0 : channelAdvancedInfo2.data) == null ? void 0 : _a2.relatedChannels) && ((_c = (_b = channelAdvancedInfo2 == null ? void 0 : channelAdvancedInfo2.data) == null ? void 0 : _b.relatedChannels) == null ? void 0 : _c.length) > 0) {
      setRelatedChannels(channelAdvancedInfo2.data.relatedChannels);
    }
  }, [channelAdvancedInfo2 == null ? void 0 : channelAdvancedInfo2.data]);
  const submitHandler = async (event) => {
    var _a2, _b;
    event.preventDefault();
    const data = new FormData(event.currentTarget);
    const description = (_a2 = data.get("description")) == null ? void 0 : _a2.toString();
    const name = (_b = data.get("name")) == null ? void 0 : _b.toString();
    setStatusText(void 0);
    if (newChannel) {
      channelPostMutation.mutate({
        name,
        description,
        avatar: avatarToUpload ? { data: avatarToUpload, fileName: avatarToUpload.name } : void 0,
        poster: posterToUpload ? { data: posterToUpload, fileName: posterToUpload.name } : void 0,
        pinnedVideoId: void 0,
        relatedChannels: relatedChannels.map((x) => x.id)
      });
    } else {
      channelPutMutation.mutate({
        name,
        description,
        avatar: avatarToUpload ? { data: avatarToUpload, fileName: avatarToUpload.name } : void 0,
        poster: posterToUpload ? { data: posterToUpload, fileName: posterToUpload.name } : void 0,
        pinnedVideoId: void 0,
        relatedChannels: relatedChannels.map((x) => x.id)
      });
    }
  };
  return /* @__PURE__ */ jsxs(Box$1, { margin: 4, component: "form", onSubmit: submitHandler, children: [
    /* @__PURE__ */ jsxs(Box$1, { display: "flex", justifyContent: "space-between", children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", gutterBottom: true, children: "Editace kanlu" }),
      /* @__PURE__ */ jsxs(Box$1, { gap: 2, display: "flex", children: [
        /* @__PURE__ */ jsx(Button$2, { variant: "outlined", startIcon: /* @__PURE__ */ jsx(default_1$7, {}), children: "Zahodit zmny" }),
        /* @__PURE__ */ jsx(Button$2, { type: "submit", variant: "contained", startIcon: /* @__PURE__ */ jsx(default_1$8, {}), children: "Uloit" })
      ] })
    ] }),
    /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 3, children: [
      /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: statusText && /* @__PURE__ */ jsx(Alert$1, { severity: "info", children: statusText }) }),
      /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 3, paddingTop: 3, children: [
        /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
          TextField$1,
          {
            required: true,
            id: "name",
            name: "name",
            label: "Nzev",
            fullWidth: true,
            defaultValue: channel == null ? void 0 : channel.name
          }
        ) }),
        /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
          TextField$1,
          {
            id: "description",
            name: "description",
            label: "Popis",
            fullWidth: true,
            defaultValue: ((_a = channelAdvancedInfo2 == null ? void 0 : channelAdvancedInfo2.data) == null ? void 0 : _a.description) ?? "",
            multiline: true,
            minRows: 2,
            maxRows: 14
          }
        ) })
      ] }) }),
      /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, sm: 3, children: [
        /* @__PURE__ */ jsx(Typography$1, { children: "Poster:" }),
        /* @__PURE__ */ jsx(
          FileUploadWithPreview,
          {
            uploadedFile: posterToUpload,
            setUploadedFile: setPosterToUpload,
            existingImageUrl: ApiPath(channel == null ? void 0 : channel.posterUrl)
          }
        )
      ] }),
      /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, sm: 3, children: [
        /* @__PURE__ */ jsx(Typography$1, { children: "Avatar:" }),
        /* @__PURE__ */ jsx(
          FileUploadWithPreview,
          {
            uploadedFile: avatarToUpload,
            setUploadedFile: setAvatarToUpload,
            existingImageUrl: ApiPath(channel == null ? void 0 : channel.avatarUrl)
          }
        )
      ] }),
      allChannelsQuery.isSuccess && /* @__PURE__ */ jsxs(Grid$1, { item: true, xs: 12, sm: 3, children: [
        /* @__PURE__ */ jsx(Typography$1, { children: "Pipnut kanly:" }),
        /* @__PURE__ */ jsx(
          Autocomplete$1,
          {
            multiple: true,
            value: relatedChannels,
            onChange: (event, newValue) => {
              setRelatedChannels(newValue);
            },
            id: "relatedChannels",
            options: allChannelsQuery.data,
            getOptionLabel: (option) => option.name,
            isOptionEqualToValue: (option, value) => option.id === value.id,
            renderInput: (params) => /* @__PURE__ */ jsx(
              TextField$1,
              {
                ...params,
                variant: "standard",
                label: "Vyberte kanl",
                placeholder: "kanl"
              }
            )
          }
        )
      ] })
    ] })
  ] });
}
function UsersEdit() {
  const navigate = useNavigate();
  const usersQuery = useUsersAllQuery();
  const attributes = [
    {
      id: "name",
      label: "Jmno"
    },
    {
      id: "email",
      label: "Email"
    }
  ];
  const buttons = [];
  buttons.push({
    label: "Smazat",
    icon: /* @__PURE__ */ jsx(default_1$g, {}),
    onClick: (selectedIDs) => {
      const promises = selectedIDs.map((x) => usersDELETE(x));
      Promise.all(promises).then(() => {
        usersQuery.refetch();
      });
    }
  });
  const staticButtons = [];
  staticButtons.push({
    label: "Nov",
    icon: /* @__PURE__ */ jsx(default_1$9, {}),
    onClick: async () => {
      navigate({
        pathname: `/${Route.userEdit}`
      });
    }
  });
  const rowClick = (event, id2) => {
    navigate({
      pathname: `/${Route.userEdit}/${id2}`
    });
  };
  return /* @__PURE__ */ jsx(Box$3, { margin: 4, children: (usersQuery == null ? void 0 : usersQuery.data) && /* @__PURE__ */ jsx(
    EnhancedTable,
    {
      attributes,
      rows: usersQuery.data,
      orderBy: "id",
      buttons,
      staticButtons,
      rowClick
    }
  ) });
}
const loader = ({ params }) => {
  return usersGET(params.Id);
};
function UserEditor({ newUser = false }) {
  var _a, _b, _c;
  let updateUserMutation;
  let registerMutation;
  const navigate = useNavigate();
  const user = useLoaderData();
  if (newUser) {
    registerMutation = useRegisterMutation();
  }
  if (!newUser) {
    if (user) {
      updateUserMutation = useUsersPUTMutation(user.id);
    }
  }
  const nameRef = reactExports.useRef(null);
  const emailRef = reactExports.useRef(null);
  const passwordRef = reactExports.useRef(null);
  const adminRef = reactExports.useRef(null);
  const editorRef = reactExports.useRef(null);
  const viewerRef = reactExports.useRef(null);
  const handleSubmit = (event) => {
    if (event.currentTarget.name === "Cancel") {
      return;
    }
    event.preventDefault();
    if (newUser) {
      registerMutation == null ? void 0 : registerMutation.mutateAsync(
        new RegisterDTO({
          email: emailRef.current.value,
          name: nameRef.current.value,
          password: passwordRef.current.value
        }),
        {
          onSuccess: (result) => {
          },
          onError: (error) => {
          }
        }
      );
    } else {
      const updatedUser = new UserDTO({
        id: user == null ? void 0 : user.id,
        name: nameRef.current.value,
        email: emailRef.current.value,
        initials: "",
        roles: new UserRoles({
          administrator: adminRef.current.checked,
          videoEditor: editorRef.current.checked,
          user: viewerRef.current.checked
        })
      });
      updateUserMutation == null ? void 0 : updateUserMutation.mutate(updatedUser);
    }
  };
  const handleRevertChanges = async () => {
    navigate(0);
  };
  const onKeyDown = (keyEvent) => {
    if (keyEvent.code === "Enter") {
      keyEvent.preventDefault();
    }
  };
  return /* @__PURE__ */ jsxs(Box$1, { margin: 4, component: "form", onSubmit: handleSubmit, onKeyDown, children: [
    /* @__PURE__ */ jsxs(Box$1, { display: "flex", justifyContent: "space-between", children: [
      /* @__PURE__ */ jsx(Typography$1, { variant: "h6", gutterBottom: true, children: "Editace uivatele" }),
      /* @__PURE__ */ jsxs(Box$1, { gap: 2, display: "flex", children: [
        /* @__PURE__ */ jsx(
          Button$2,
          {
            variant: "outlined",
            onClick: handleRevertChanges,
            startIcon: /* @__PURE__ */ jsx(default_1$7, {}),
            type: "submit",
            children: "Zahodit zmny"
          }
        ),
        /* @__PURE__ */ jsx(Button$2, { type: "submit", variant: "contained", startIcon: /* @__PURE__ */ jsx(default_1$8, {}), children: "Uloit" })
      ] })
    ] }),
    /* @__PURE__ */ jsx(Grid$1, { container: true, spacing: 3, children: /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, sm: 6, children: /* @__PURE__ */ jsxs(Grid$1, { container: true, spacing: 3, paddingTop: 3, children: [
      /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
        TextField$1,
        {
          label: "Jmno",
          defaultValue: user == null ? void 0 : user.name,
          inputRef: nameRef,
          required: true,
          fullWidth: true
        }
      ) }),
      /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
        TextField$1,
        {
          label: "Email",
          type: "email",
          defaultValue: user == null ? void 0 : user.email,
          inputRef: emailRef,
          required: true,
          fullWidth: true
        }
      ) }),
      newUser && /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsx(
        TextField$1,
        {
          label: "Heslo",
          required: true,
          inputRef: passwordRef,
          type: "password",
          fullWidth: true
        }
      ) }),
      !newUser && /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 12, children: /* @__PURE__ */ jsxs(
        FormGroup$1,
        {
          sx: {
            border: "1px solid rgba(0, 0, 0, 0.23)",
            borderRadius: "4px",
            paddingLeft: "14px"
          },
          children: [
            /* @__PURE__ */ jsx(
              FormControlLabel$1,
              {
                control: /* @__PURE__ */ jsx(
                  Checkbox$1,
                  {
                    defaultChecked: (_a = user == null ? void 0 : user.roles) == null ? void 0 : _a.administrator,
                    inputRef: adminRef,
                    name: "admin"
                  }
                ),
                label: "Administrator"
              }
            ),
            /* @__PURE__ */ jsx(
              FormControlLabel$1,
              {
                control: /* @__PURE__ */ jsx(
                  Checkbox$1,
                  {
                    defaultChecked: (_b = user == null ? void 0 : user.roles) == null ? void 0 : _b.videoEditor,
                    inputRef: editorRef,
                    name: "editor"
                  }
                ),
                label: "Video editor"
              }
            ),
            /* @__PURE__ */ jsx(
              FormControlLabel$1,
              {
                control: /* @__PURE__ */ jsx(
                  Checkbox$1,
                  {
                    defaultChecked: (_c = user == null ? void 0 : user.roles) == null ? void 0 : _c.user,
                    inputRef: viewerRef,
                    name: "viewer"
                  }
                ),
                label: "Uivatel"
              }
            )
          ]
        }
      ) })
    ] }) }) })
  ] });
}
const pageSize = 10;
function SearchResult() {
  var _a, _b, _c, _d;
  const { tags: tags2, searchTerm } = useLoaderData();
  const result = useInfiniteQuery({
    queryKey: [...searchMutationKey(searchTerm ?? tags2), "infinite"],
    queryFn: async (params) => {
      const pageParam = params.pageParam ?? 0;
      return search(searchTerm, pageSize, pageParam * pageSize);
    },
    getNextPageParam: (lastPage, pages) => {
      return lastPage.totalCount > pages.length * pageSize ? pages.length : void 0;
    },
    refetchOnWindowFocus: false
  });
  return /* @__PURE__ */ jsx(Box$3, { marginTop: 4, marginBottom: 4, children: (((_b = (_a = result == null ? void 0 : result.data) == null ? void 0 : _a.pages) == null ? void 0 : _b.length) ?? 0) > 0 ? /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Grid$1, { container: true, spacing: 2, sx: { justifyContent: "center" }, children: (_d = (_c = result == null ? void 0 : result.data) == null ? void 0 : _c.pages) == null ? void 0 : _d.map((group, i) => /* @__PURE__ */ jsx(React.Fragment, { children: group == null ? void 0 : group.items.map((video2) => {
      return /* @__PURE__ */ jsx(Grid$1, { item: true, xs: 8, children: /* @__PURE__ */ jsx(VideoCard, { video: video2, fullWidth: true }, video2.id) }, video2.id);
    }) }, i)) }),
    (result == null ? void 0 : result.hasNextPage) && /* @__PURE__ */ jsx(
      Button$2,
      {
        sx: { width: "100%", mt: "1em" },
        variant: "outlined",
        onClick: () => result.fetchNextPage(),
        disabled: !result.hasNextPage || result.isFetchingNextPage,
        children: result.isFetchingNextPage ? "Natn..." : "Nast dal"
      }
    )
  ] }) : (
    // eslint-disable-next-line react/jsx-no-useless-fragment
    /* @__PURE__ */ jsx(Fragment, { children: result.status === "error" && /* @__PURE__ */ jsx(Typography$1, { children: `Bohuel pro vraz '${searchTerm ?? tags2}' nebyl nalezen dn zznam.` }) })
  ) });
}
function TagEdit() {
  const arr = useTagsWithVideosQuery().data;
  const attributes = [
    {
      id: "name",
      label: "Nzev"
    },
    {
      id: "videos",
      label: "Poet pouit",
      customFormat: (value) => {
        const videoArr = value;
        return videoArr.length.toString();
      }
    }
  ];
  const buttons = [];
  buttons.push({
    label: "Smazat",
    icon: /* @__PURE__ */ jsx(default_1$g, {}),
    onClick: (selectedIDs) => {
      console.log(selectedIDs);
      const selected = arr == null ? void 0 : arr.filter((x) => selectedIDs.includes(x.id));
      selected == null ? void 0 : selected.forEach((tag) => {
        tagsDELETE(tag.id);
      });
    }
  });
  return /* @__PURE__ */ jsx(Box$3, { margin: 4, children: arr && /* @__PURE__ */ jsx(
    EnhancedTable,
    {
      attributes,
      rows: arr,
      orderBy: "name",
      desc: "asc",
      buttons
    }
  ) });
}
function MyPlaylistsThumbnail(row) {
  var _a;
  return /* @__PURE__ */ jsx(AspectRatio, { ratio: 16 / 9, children: /* @__PURE__ */ jsx(
    "img",
    {
      alt: "Nhled playlistu",
      style: { maxHeight: "100%", width: "100%", objectFit: "contain" },
      src: ApiPath(
        (row == null ? void 0 : row.thumbnailUrl) ? row.thumbnailUrl : ((_a = row == null ? void 0 : row.videos) == null ? void 0 : _a.length) ? row == null ? void 0 : row.videos[0].imageUrl : void 0
      )
    }
  ) });
}
function MyPlaylists() {
  const playlistQuery = useMyPlaylistsQuery();
  const navigate = useNavigate();
  const [statusText, setStatusText] = reactExports.useState();
  const attributes = [
    {
      id: "thumbnailUrl",
      label: "Nhled",
      imageCustomElement: (row) => MyPlaylistsThumbnail(row)
    },
    {
      id: "name",
      label: "Nzev"
    },
    {
      id: "description",
      label: "Popis"
    },
    {
      id: "videos",
      label: "Poet vide",
      customFormat: (value) => {
        return (value == null ? void 0 : value.length.toString()) ?? 0;
      }
    }
  ];
  const buttons = [];
  buttons.push({
    label: "Smazat",
    icon: /* @__PURE__ */ jsx(default_1$g, {}),
    onClick: (selectedIDs) => {
      setStatusText(void 0);
      const promises = Promise.all(selectedIDs.map((id2) => playlistsDELETE(id2)));
      promises.then(() => {
        playlistQuery.refetch();
        setStatusText("Playlist spn smazn");
      }).catch(() => {
        setStatusText("Playlist se nepodailo smazat");
      });
    }
  });
  const staticButtons = [
    {
      icon: /* @__PURE__ */ jsx(default_1$9, {}),
      label: "Vytvoit nov playlist",
      onClick: () => navigate(`/${Route.myPlaylists}/create`)
    }
  ];
  const rowClick = (event, id2) => {
    navigate({
      pathname: `/${Route.myPlaylists}/${id2}`
    });
  };
  return /* @__PURE__ */ jsxs(Box$3, { margin: 4, children: [
    statusText && /* @__PURE__ */ jsx(Alert$1, { severity: "info", children: statusText }),
    playlistQuery.data && /* @__PURE__ */ jsx(
      EnhancedTable,
      {
        attributes,
        rows: playlistQuery.data,
        orderBy: "createdTimestamp",
        desc: "desc",
        buttons,
        staticButtons,
        rowClick
      }
    )
  ] });
}
function App() {
  const router = createBrowserRouter([
    {
      path: "/",
      element: /* @__PURE__ */ jsx(Root, {}),
      children: [
        {
          errorElement: /* @__PURE__ */ jsx(ErrorPage, {}),
          children: [
            {
              index: true,
              element: /* @__PURE__ */ jsx(HomePage, {})
            },
            {
              path: Route.myVideos,
              element: /* @__PURE__ */ jsx(MyVideos, {})
            },
            {
              path: `${Route.channel}/:channelId`,
              element: /* @__PURE__ */ jsx(Channel2, {}),
              loader: loader$6,
              children: [
                {
                  path: "",
                  element: /* @__PURE__ */ jsx(ChannelHomePage, {}),
                  loader: loader$5
                },
                {
                  path: "videos",
                  element: /* @__PURE__ */ jsx(ChannelVideos, {}),
                  loader: loader$4
                },
                {
                  path: "playlists",
                  element: /* @__PURE__ */ jsx(ChannelPlaylists, {}),
                  loader: loader$3
                },
                {
                  path: "info",
                  element: /* @__PURE__ */ jsx(ChannelInfo, {}),
                  loader: loader$2
                }
              ]
            },
            {
              path: Route.myChannels,
              children: [
                {
                  path: "",
                  element: /* @__PURE__ */ jsx(MyChannels, {})
                },
                {
                  path: "create",
                  element: /* @__PURE__ */ jsx(ChannelEdit, { newChannel: true })
                },
                {
                  path: ":Id",
                  element: /* @__PURE__ */ jsx(ChannelEdit, {}),
                  loader: loader$1
                }
              ]
            },
            {
              path: `${Route.video}/:videoId`,
              element: /* @__PURE__ */ jsx(VideoDetail, {}),
              loader: loader$9
            },
            {
              path: `${Route.videoEdit}/:videoId`,
              element: /* @__PURE__ */ jsx(VideoEdit, {}),
              loader: loader$8
            },
            {
              path: Route.upload,
              element: /* @__PURE__ */ jsx(VideoEdit, { newVideo: true })
            },
            {
              path: Route.search,
              element: /* @__PURE__ */ jsx(SearchResult, {}),
              loader: loader$a
            },
            {
              path: `${Route.playlist}/:Id`,
              element: /* @__PURE__ */ jsx(PlaylistDetail, {}),
              loader: loader$7
            },
            {
              path: Route.users,
              element: /* @__PURE__ */ jsx(UsersEdit, {})
            },
            {
              path: `${Route.userEdit}/:Id`,
              element: /* @__PURE__ */ jsx(UserEditor, {}),
              loader
            },
            {
              path: Route.userEdit,
              element: /* @__PURE__ */ jsx(UserEditor, { newUser: true })
            },
            {
              path: Route.tagEdit,
              element: /* @__PURE__ */ jsx(TagEdit, {})
            },
            {
              path: Route.myPlaylists,
              children: [
                {
                  path: "",
                  element: /* @__PURE__ */ jsx(MyPlaylists, {})
                },
                {
                  path: "create",
                  element: /* @__PURE__ */ jsx(PlaylistDetail, { newPlaylist: true })
                },
                {
                  path: ":Id",
                  element: /* @__PURE__ */ jsx(PlaylistDetail, {}),
                  loader: loader$7
                }
              ]
            }
          ]
        }
      ]
    }
  ]);
  return /* @__PURE__ */ jsx(ThemeProvider, { theme, children: /* @__PURE__ */ jsx(Box$3, { sx: { display: "flex" }, children: /* @__PURE__ */ jsx(RouterProvider, { router }) }) });
}
const container = document.getElementById("root");
const root = createRoot(container);
const queryClient = new QueryClient();
onlineManager.setOnline(true);
setBaseUrl(`${"https://videoportal.panda7789.fun"}`);
setAxiosFactory(() => {
  const instance = axios$1.create();
  instance.interceptors.request.use(
    (config2) => {
      const token2 = localStorage.getItem("token");
      if (token2) {
        config2.headers.Authorization = `Bearer ${token2}`;
      }
      return config2;
    },
    (error) => {
      return Promise.reject(error);
    }
  );
  return instance;
});
root.render(
  /* @__PURE__ */ jsx(React.StrictMode, { children: /* @__PURE__ */ jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsx(App, {}) }) })
);
