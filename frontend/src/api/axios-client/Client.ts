//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../axios-client';
import { getAxios, getBaseUrl } from './helpers';

/**
 * @return Success
 */
export function commentsAll(videoId: string, config?: AxiosRequestConfig | undefined): Promise<Types.CommentDTO[]> {
    let url_ = getBaseUrl() + "/api/Comments/{videoId}";
    if (videoId === undefined || videoId === null)
      throw new Error("The parameter 'videoId' must be defined.");
    url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCommentsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCommentsAll(_response);
    });
}

function processCommentsAll(response: AxiosResponse): Promise<Types.CommentDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.CommentDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.CommentDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CommentDTO[]>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function commentsPUT(id: string, body?: Types.CommentPutDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Comments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCommentsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCommentsPUT(_response);
    });
}

function processCommentsPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function commentsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Comments/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCommentsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCommentsDELETE(_response);
    });
}

function processCommentsDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function commentsPOST(body?: Types.CommentPostDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Comments";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCommentsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCommentsPOST(_response);
    });
}

function processCommentsPOST(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function myPlaylists(config?: AxiosRequestConfig | undefined): Promise<Types.PlaylistDTO[]> {
    let url_ = getBaseUrl() + "/api/Playlists/my-playlists";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMyPlaylists,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMyPlaylists(_response);
    });
}

function processMyPlaylists(response: AxiosResponse): Promise<Types.PlaylistDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.PlaylistDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.PlaylistDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PlaylistDTO[]>(null as any);
}

/**
 * @return Success
 */
export function playlistPermissions(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ObjectPermissions> {
    let url_ = getBaseUrl() + "/api/Playlists/{id}/playlist-permissions";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigPlaylistPermissions,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPlaylistPermissions(_response);
    });
}

function processPlaylistPermissions(response: AxiosResponse): Promise<Types.ObjectPermissions> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ObjectPermissions.fromJS(resultData200);
        return Promise.resolve<Types.ObjectPermissions>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ObjectPermissions>(null as any);
}

/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function playlistsAll(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PlaylistBasicInfoDTO[]> {
    let url_ = getBaseUrl() + "/api/Playlists?";
    if (orderBy === null)
        throw new Error("The parameter 'orderBy' cannot be null.");
    else if (orderBy !== undefined)
        url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
    if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
    else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
    if (offset === null)
        throw new Error("The parameter 'offset' cannot be null.");
    else if (offset !== undefined)
        url_ += "offset=" + encodeURIComponent("" + offset) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigPlaylistsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPlaylistsAll(_response);
    });
}

function processPlaylistsAll(response: AxiosResponse): Promise<Types.PlaylistBasicInfoDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.PlaylistBasicInfoDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.PlaylistBasicInfoDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PlaylistBasicInfoDTO[]>(null as any);
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param thumbnail (optional) 
 * @param videos (optional) 
 * @param isPublic (optional) 
 * @param permissions_UserIds (optional) 
 * @param permissions_GroupIds (optional) 
 * @return Success
 */
export function playlistsPOST(name?: string | null | undefined, description?: string | null | undefined, thumbnail?: Types.FileParameter | null | undefined, videos?: string[] | null | undefined, isPublic?: boolean | undefined, permissions_UserIds?: string[] | null | undefined, permissions_GroupIds?: string[] | null | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Playlists";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (description !== null && description !== undefined)
        content_.append("Description", description.toString());
    if (thumbnail !== null && thumbnail !== undefined)
        content_.append("Thumbnail", thumbnail.data, thumbnail.fileName ? thumbnail.fileName : "Thumbnail");
    if (videos !== null && videos !== undefined)
        videos.forEach(item_ => content_.append("Videos", item_.toString()));
    if (isPublic === null || isPublic === undefined)
        throw new Error("The parameter 'isPublic' cannot be null.");
    else
        content_.append("IsPublic", isPublic.toString());
    if (permissions_UserIds !== null && permissions_UserIds !== undefined)
        permissions_UserIds.forEach(item_ => content_.append("Permissions.UserIds", item_.toString()));
    if (permissions_GroupIds !== null && permissions_GroupIds !== undefined)
        permissions_GroupIds.forEach(item_ => content_.append("Permissions.GroupIds", item_.toString()));

    let options_: AxiosRequestConfig = {
        ..._requestConfigPlaylistsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPlaylistsPOST(_response);
    });
}

function processPlaylistsPOST(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function playlistsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.PlaylistDTO> {
    let url_ = getBaseUrl() + "/api/Playlists/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigPlaylistsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPlaylistsGET(_response);
    });
}

function processPlaylistsGET(response: AxiosResponse): Promise<Types.PlaylistDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.PlaylistDTO.fromJS(resultData200);
        return Promise.resolve<Types.PlaylistDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PlaylistDTO>(null as any);
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param thumbnail (optional) 
 * @param videos (optional) 
 * @param isPublic (optional) 
 * @param permissions_UserIds (optional) 
 * @param permissions_GroupIds (optional) 
 * @return Success
 */
export function playlistsPUT(id: string, name?: string | null | undefined, description?: string | null | undefined, thumbnail?: Types.FileParameter | null | undefined, videos?: string[] | null | undefined, isPublic?: boolean | undefined, permissions_UserIds?: string[] | null | undefined, permissions_GroupIds?: string[] | null | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Playlists/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (description !== null && description !== undefined)
        content_.append("Description", description.toString());
    if (thumbnail !== null && thumbnail !== undefined)
        content_.append("Thumbnail", thumbnail.data, thumbnail.fileName ? thumbnail.fileName : "Thumbnail");
    if (videos !== null && videos !== undefined)
        videos.forEach(item_ => content_.append("Videos", item_.toString()));
    if (isPublic === null || isPublic === undefined)
        throw new Error("The parameter 'isPublic' cannot be null.");
    else
        content_.append("IsPublic", isPublic.toString());
    if (permissions_UserIds !== null && permissions_UserIds !== undefined)
        permissions_UserIds.forEach(item_ => content_.append("Permissions.UserIds", item_.toString()));
    if (permissions_GroupIds !== null && permissions_GroupIds !== undefined)
        permissions_GroupIds.forEach(item_ => content_.append("Permissions.GroupIds", item_.toString()));

    let options_: AxiosRequestConfig = {
        ..._requestConfigPlaylistsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPlaylistsPUT(_response);
    });
}

function processPlaylistsPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function playlistsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Playlists/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigPlaylistsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPlaylistsDELETE(_response);
    });
}

function processPlaylistsDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function watchLaterId(config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/Playlists/watch-later-id";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigWatchLaterId,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWatchLaterId(_response);
    });
}

function processWatchLaterId(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * Přidá nebo odebere video z playlistu 'Přehrát později'. V případě zdařilé operace vrací v odpovědi příznak, zdali se video do playlistu přidávalo(true), nebo odebíralo(false).
 * @param id (optional) 
 * @return Success
 */
export function addRemoveWatchLater(id?: string | undefined, config?: AxiosRequestConfig | undefined): Promise<boolean> {
    let url_ = getBaseUrl() + "/api/Playlists/add-remove-watch-later?";
    if (id === null)
        throw new Error("The parameter 'id' cannot be null.");
    else if (id !== undefined)
        url_ += "id=" + encodeURIComponent("" + id) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigAddRemoveWatchLater,
        ...config,
        method: "POST",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAddRemoveWatchLater(_response);
    });
}

function processAddRemoveWatchLater(response: AxiosResponse): Promise<boolean> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<boolean>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<boolean>(null as any);
}

/**
 * @param q (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function search(q?: string | undefined, limit?: number | undefined, offset?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.WithTotalCountOfVideoDTO> {
    let url_ = getBaseUrl() + "/api/Search?";
    if (q === null)
        throw new Error("The parameter 'q' cannot be null.");
    else if (q !== undefined)
        url_ += "q=" + encodeURIComponent("" + q) + "&";
    if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
    else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
    if (offset === null)
        throw new Error("The parameter 'offset' cannot be null.");
    else if (offset !== undefined)
        url_ += "offset=" + encodeURIComponent("" + offset) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSearch,
        ...config,
        method: "PUT",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSearch(_response);
    });
}

function processSearch(response: AxiosResponse): Promise<Types.WithTotalCountOfVideoDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WithTotalCountOfVideoDTO.fromJS(resultData200);
        return Promise.resolve<Types.WithTotalCountOfVideoDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WithTotalCountOfVideoDTO>(null as any);
}

/**
 * @return Success
 */
export function tagsAll(config?: AxiosRequestConfig | undefined): Promise<Types.TagDTO[]> {
    let url_ = getBaseUrl() + "/api/Tags";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigTagsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processTagsAll(_response);
    });
}

function processTagsAll(response: AxiosResponse): Promise<Types.TagDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.TagDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.TagDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.TagDTO[]>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function tagsPOST(body?: string | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Tags";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigTagsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processTagsPOST(_response);
    });
}

function processTagsPOST(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function tagsWithVideos(config?: AxiosRequestConfig | undefined): Promise<Types.Tag[]> {
    let url_ = getBaseUrl() + "/api/Tags/tagsWithVideos";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigTagsWithVideos,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processTagsWithVideos(_response);
    });
}

function processTagsWithVideos(response: AxiosResponse): Promise<Types.Tag[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.Tag.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.Tag[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Tag[]>(null as any);
}

/**
 * @return Success
 */
export function tagsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Tags/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigTagsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processTagsDELETE(_response);
    });
}

function processTagsDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function userGroupsAll(config?: AxiosRequestConfig | undefined): Promise<Types.UserGroupDTO[]> {
    let url_ = getBaseUrl() + "/api/UserGroups";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserGroupsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserGroupsAll(_response);
    });
}

function processUserGroupsAll(response: AxiosResponse): Promise<Types.UserGroupDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.UserGroupDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.UserGroupDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserGroupDTO[]>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function userGroupsPOST(body?: Types.UserGroupPostPutDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.UserGroup> {
    let url_ = getBaseUrl() + "/api/UserGroups";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserGroupsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserGroupsPOST(_response);
    });
}

function processUserGroupsPOST(response: AxiosResponse): Promise<Types.UserGroup> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserGroup.fromJS(resultData200);
        return Promise.resolve<Types.UserGroup>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserGroup>(null as any);
}

/**
 * @return Success
 */
export function myUsergroups(config?: AxiosRequestConfig | undefined): Promise<Types.UserGroupDTO[]> {
    let url_ = getBaseUrl() + "/api/UserGroups/my-usergroups";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMyUsergroups,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMyUsergroups(_response);
    });
}

function processMyUsergroups(response: AxiosResponse): Promise<Types.UserGroupDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.UserGroupDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.UserGroupDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserGroupDTO[]>(null as any);
}

/**
 * @return Success
 */
export function userGroupsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.UserGroupDTO> {
    let url_ = getBaseUrl() + "/api/UserGroups/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserGroupsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserGroupsGET(_response);
    });
}

function processUserGroupsGET(response: AxiosResponse): Promise<Types.UserGroupDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserGroupDTO.fromJS(resultData200);
        return Promise.resolve<Types.UserGroupDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserGroupDTO>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function userGroupsPUT(id: string, body?: Types.UserGroupPostPutDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/UserGroups/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserGroupsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserGroupsPUT(_response);
    });
}

function processUserGroupsPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function userGroupsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/UserGroups/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserGroupsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserGroupsDELETE(_response);
    });
}

function processUserGroupsDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function login(body?: Types.LoginDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/users/login";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLogin,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLogin(_response);
    });
}

function processLogin(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function register(body?: Types.RegisterDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/users/register";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRegister,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRegister(_response);
    });
}

function processRegister(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @return Success
 */
export function me(config?: AxiosRequestConfig | undefined): Promise<Types.UserDTO> {
    let url_ = getBaseUrl() + "/api/users/me";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMe,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMe(_response);
    });
}

function processMe(response: AxiosResponse): Promise<Types.UserDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserDTO.fromJS(resultData200);
        return Promise.resolve<Types.UserDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserDTO>(null as any);
}

/**
 * @return Success
 */
export function usersAll(config?: AxiosRequestConfig | undefined): Promise<Types.UserDTO[]> {
    let url_ = getBaseUrl() + "/api/users";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUsersAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUsersAll(_response);
    });
}

function processUsersAll(response: AxiosResponse): Promise<Types.UserDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.UserDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.UserDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserDTO[]>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function usersPUT(id: string, body?: Types.UserDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUsersPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUsersPUT(_response);
    });
}

function processUsersPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function usersDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUsersDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUsersDELETE(_response);
    });
}

function processUsersDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function usersGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.UserDTO> {
    let url_ = getBaseUrl() + "/api/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUsersGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUsersGET(_response);
    });
}

function processUsersGET(response: AxiosResponse): Promise<Types.UserDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserDTO.fromJS(resultData200);
        return Promise.resolve<Types.UserDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserDTO>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function resetPassword(body?: string | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/users/reset-password";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigResetPassword,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processResetPassword(_response);
    });
}

function processResetPassword(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function submitResetPassword(body?: Types.PasswordResetDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/users/submit-reset-password";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigSubmitResetPassword,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSubmitResetPassword(_response);
    });
}

function processSubmitResetPassword(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function userVideoStatsGET(videoId: string, config?: AxiosRequestConfig | undefined): Promise<Types.UserVideoStatsDTO> {
    let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";
    if (videoId === undefined || videoId === null)
      throw new Error("The parameter 'videoId' must be defined.");
    url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserVideoStatsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserVideoStatsGET(_response);
    });
}

function processUserVideoStatsGET(response: AxiosResponse): Promise<Types.UserVideoStatsDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserVideoStatsDTO.fromJS(resultData200);
        return Promise.resolve<Types.UserVideoStatsDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserVideoStatsDTO>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function userVideoStatsPUT(videoId: string, body?: Types.UserVideoStatsDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";
    if (videoId === undefined || videoId === null)
      throw new Error("The parameter 'videoId' must be defined.");
    url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserVideoStatsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserVideoStatsPUT(_response);
    });
}

function processUserVideoStatsPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function stats(videoId: string, config?: AxiosRequestConfig | undefined): Promise<Types.LikeDislikeStats> {
    let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}/stats";
    if (videoId === undefined || videoId === null)
      throw new Error("The parameter 'videoId' must be defined.");
    url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigStats,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processStats(_response);
    });
}

function processStats(response: AxiosResponse): Promise<Types.LikeDislikeStats> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.LikeDislikeStats.fromJS(resultData200);
        return Promise.resolve<Types.LikeDislikeStats>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.LikeDislikeStats>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function watched(videoId: string, body?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}/watched";
    if (videoId === undefined || videoId === null)
      throw new Error("The parameter 'videoId' must be defined.");
    url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigWatched,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processWatched(_response);
    });
}

function processWatched(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function videosAll(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO[]> {
    let url_ = getBaseUrl() + "/api/Videos?";
    if (orderBy === null)
        throw new Error("The parameter 'orderBy' cannot be null.");
    else if (orderBy !== undefined)
        url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
    if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
    else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
    if (offset === null)
        throw new Error("The parameter 'offset' cannot be null.");
    else if (offset !== undefined)
        url_ += "offset=" + encodeURIComponent("" + offset) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosAll(_response);
    });
}

function processVideosAll(response: AxiosResponse): Promise<Types.VideoDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.VideoDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.VideoDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO[]>(null as any);
}

/**
 * @param fileName (optional) 
 * @param name (optional) 
 * @param description (optional) 
 * @param durationSec (optional) 
 * @param image (optional) 
 * @param playlistId (optional) 
 * @param tags (optional) 
 * @param includedPermissions_UserIds (optional) 
 * @param includedPermissions_GroupIds (optional) 
 * @param excludedPermissions_UserIds (optional) 
 * @param excludedPermissions_GroupIds (optional) 
 * @return Success
 */
export function videosPOST(fileName?: string | null | undefined, name?: string | null | undefined, description?: string | null | undefined, durationSec?: number | undefined, image?: Types.FileParameter | null | undefined, playlistId?: string | undefined, tags?: string[] | null | undefined, includedPermissions_UserIds?: string[] | null | undefined, includedPermissions_GroupIds?: string[] | null | undefined, excludedPermissions_UserIds?: string[] | null | undefined, excludedPermissions_GroupIds?: string[] | null | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PostVideoResponse> {
    let url_ = getBaseUrl() + "/api/Videos";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (fileName !== null && fileName !== undefined)
        content_.append("FileName", fileName.toString());
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (description !== null && description !== undefined)
        content_.append("Description", description.toString());
    if (durationSec === null || durationSec === undefined)
        throw new Error("The parameter 'durationSec' cannot be null.");
    else
        content_.append("DurationSec", durationSec.toString());
    if (image !== null && image !== undefined)
        content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
    if (playlistId === null || playlistId === undefined)
        throw new Error("The parameter 'playlistId' cannot be null.");
    else
        content_.append("PlaylistId", playlistId.toString());
    if (tags !== null && tags !== undefined)
        tags.forEach(item_ => content_.append("Tags", item_.toString()));
    if (includedPermissions_UserIds !== null && includedPermissions_UserIds !== undefined)
        includedPermissions_UserIds.forEach(item_ => content_.append("IncludedPermissions.UserIds", item_.toString()));
    if (includedPermissions_GroupIds !== null && includedPermissions_GroupIds !== undefined)
        includedPermissions_GroupIds.forEach(item_ => content_.append("IncludedPermissions.GroupIds", item_.toString()));
    if (excludedPermissions_UserIds !== null && excludedPermissions_UserIds !== undefined)
        excludedPermissions_UserIds.forEach(item_ => content_.append("ExcludedPermissions.UserIds", item_.toString()));
    if (excludedPermissions_GroupIds !== null && excludedPermissions_GroupIds !== undefined)
        excludedPermissions_GroupIds.forEach(item_ => content_.append("ExcludedPermissions.GroupIds", item_.toString()));

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosPOST(_response);
    });
}

function processVideosPOST(response: AxiosResponse): Promise<Types.PostVideoResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.PostVideoResponse.fromJS(resultData200);
        return Promise.resolve<Types.PostVideoResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PostVideoResponse>(null as any);
}

/**
 * @return Success
 */
export function videosGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosGET(_response);
    });
}

function processVideosGET(response: AxiosResponse): Promise<Types.VideoDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.VideoDTO.fromJS(resultData200);
        return Promise.resolve<Types.VideoDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO>(null as any);
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param image (optional) 
 * @param playlistId (optional) 
 * @param tags (optional) 
 * @param includedPermissions_UserIds (optional) 
 * @param includedPermissions_GroupIds (optional) 
 * @param excludedPermissions_UserIds (optional) 
 * @param excludedPermissions_GroupIds (optional) 
 * @return Success
 */
export function videosPUT(id: string, name?: string | null | undefined, description?: string | null | undefined, image?: Types.FileParameter | null | undefined, playlistId?: string | undefined, tags?: string[] | null | undefined, includedPermissions_UserIds?: string[] | null | undefined, includedPermissions_GroupIds?: string[] | null | undefined, excludedPermissions_UserIds?: string[] | null | undefined, excludedPermissions_GroupIds?: string[] | null | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (description !== null && description !== undefined)
        content_.append("Description", description.toString());
    if (image !== null && image !== undefined)
        content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
    if (playlistId === null || playlistId === undefined)
        throw new Error("The parameter 'playlistId' cannot be null.");
    else
        content_.append("PlaylistId", playlistId.toString());
    if (tags !== null && tags !== undefined)
        tags.forEach(item_ => content_.append("Tags", item_.toString()));
    if (includedPermissions_UserIds !== null && includedPermissions_UserIds !== undefined)
        includedPermissions_UserIds.forEach(item_ => content_.append("IncludedPermissions.UserIds", item_.toString()));
    if (includedPermissions_GroupIds !== null && includedPermissions_GroupIds !== undefined)
        includedPermissions_GroupIds.forEach(item_ => content_.append("IncludedPermissions.GroupIds", item_.toString()));
    if (excludedPermissions_UserIds !== null && excludedPermissions_UserIds !== undefined)
        excludedPermissions_UserIds.forEach(item_ => content_.append("ExcludedPermissions.UserIds", item_.toString()));
    if (excludedPermissions_GroupIds !== null && excludedPermissions_GroupIds !== undefined)
        excludedPermissions_GroupIds.forEach(item_ => content_.append("ExcludedPermissions.GroupIds", item_.toString()));

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosPUT(_response);
    });
}

function processVideosPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function videosDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosDELETE(_response);
    });
}

function processVideosDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function videoPlaylists(id: string, config?: AxiosRequestConfig | undefined): Promise<string[]> {
    let url_ = getBaseUrl() + "/api/Videos/{id}/video-playlists";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideoPlaylists,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideoPlaylists(_response);
    });
}

function processVideoPlaylists(response: AxiosResponse): Promise<string[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(item);
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<string[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string[]>(null as any);
}

/**
 * @return Success
 */
export function videoPermissions(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.IncludeExcludeObjectPermissions> {
    let url_ = getBaseUrl() + "/api/Videos/{id}/video-permissions";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideoPermissions,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideoPermissions(_response);
    });
}

function processVideoPermissions(response: AxiosResponse): Promise<Types.IncludeExcludeObjectPermissions> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.IncludeExcludeObjectPermissions.fromJS(resultData200);
        return Promise.resolve<Types.IncludeExcludeObjectPermissions>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.IncludeExcludeObjectPermissions>(null as any);
}

/**
 * @return Success
 */
export function myVideos(config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO[]> {
    let url_ = getBaseUrl() + "/api/Videos/my-videos";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMyVideos,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMyVideos(_response);
    });
}

function processMyVideos(response: AxiosResponse): Promise<Types.VideoDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.VideoDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.VideoDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO[]>(null as any);
}

/**
 * @return Success
 */
export function relatedVideos(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO[]> {
    let url_ = getBaseUrl() + "/api/Videos/{id}/related-videos";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigRelatedVideos,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRelatedVideos(_response);
    });
}

function processRelatedVideos(response: AxiosResponse): Promise<Types.VideoDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.VideoDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.VideoDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO[]>(null as any);
}

/**
 * @param file (optional) 
 * @return Success
 */
export function upload(file?: Types.FileParameter | null | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Videos/upload";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file !== null && file !== undefined)
        content_.append("file", file.data, file.fileName ? file.fileName : "file");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpload,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpload(_response);
    });
}

function processUpload(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
let _requestConfigCommentsAll: Partial<AxiosRequestConfig> | undefined;
export function getCommentsAllRequestConfig() {
  return _requestConfigCommentsAll;
}
export function setCommentsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCommentsAll = value;
}
export function patchCommentsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCommentsAll = patch(_requestConfigCommentsAll ?? {});
}

let _requestConfigCommentsPUT: Partial<AxiosRequestConfig> | undefined;
export function getCommentsPUTRequestConfig() {
  return _requestConfigCommentsPUT;
}
export function setCommentsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCommentsPUT = value;
}
export function patchCommentsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCommentsPUT = patch(_requestConfigCommentsPUT ?? {});
}

let _requestConfigCommentsDELETE: Partial<AxiosRequestConfig> | undefined;
export function getCommentsDELETERequestConfig() {
  return _requestConfigCommentsDELETE;
}
export function setCommentsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCommentsDELETE = value;
}
export function patchCommentsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCommentsDELETE = patch(_requestConfigCommentsDELETE ?? {});
}

let _requestConfigCommentsPOST: Partial<AxiosRequestConfig> | undefined;
export function getCommentsPOSTRequestConfig() {
  return _requestConfigCommentsPOST;
}
export function setCommentsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCommentsPOST = value;
}
export function patchCommentsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCommentsPOST = patch(_requestConfigCommentsPOST ?? {});
}

let _requestConfigMyPlaylists: Partial<AxiosRequestConfig> | undefined;
export function getMyPlaylistsRequestConfig() {
  return _requestConfigMyPlaylists;
}
export function setMyPlaylistsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMyPlaylists = value;
}
export function patchMyPlaylistsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMyPlaylists = patch(_requestConfigMyPlaylists ?? {});
}

let _requestConfigPlaylistPermissions: Partial<AxiosRequestConfig> | undefined;
export function getPlaylistPermissionsRequestConfig() {
  return _requestConfigPlaylistPermissions;
}
export function setPlaylistPermissionsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistPermissions = value;
}
export function patchPlaylistPermissionsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistPermissions = patch(_requestConfigPlaylistPermissions ?? {});
}

let _requestConfigPlaylistsAll: Partial<AxiosRequestConfig> | undefined;
export function getPlaylistsAllRequestConfig() {
  return _requestConfigPlaylistsAll;
}
export function setPlaylistsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsAll = value;
}
export function patchPlaylistsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsAll = patch(_requestConfigPlaylistsAll ?? {});
}

let _requestConfigPlaylistsPOST: Partial<AxiosRequestConfig> | undefined;
export function getPlaylistsPOSTRequestConfig() {
  return _requestConfigPlaylistsPOST;
}
export function setPlaylistsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsPOST = value;
}
export function patchPlaylistsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsPOST = patch(_requestConfigPlaylistsPOST ?? {});
}

let _requestConfigPlaylistsGET: Partial<AxiosRequestConfig> | undefined;
export function getPlaylistsGETRequestConfig() {
  return _requestConfigPlaylistsGET;
}
export function setPlaylistsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsGET = value;
}
export function patchPlaylistsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsGET = patch(_requestConfigPlaylistsGET ?? {});
}

let _requestConfigPlaylistsPUT: Partial<AxiosRequestConfig> | undefined;
export function getPlaylistsPUTRequestConfig() {
  return _requestConfigPlaylistsPUT;
}
export function setPlaylistsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsPUT = value;
}
export function patchPlaylistsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsPUT = patch(_requestConfigPlaylistsPUT ?? {});
}

let _requestConfigPlaylistsDELETE: Partial<AxiosRequestConfig> | undefined;
export function getPlaylistsDELETERequestConfig() {
  return _requestConfigPlaylistsDELETE;
}
export function setPlaylistsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsDELETE = value;
}
export function patchPlaylistsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPlaylistsDELETE = patch(_requestConfigPlaylistsDELETE ?? {});
}

let _requestConfigWatchLaterId: Partial<AxiosRequestConfig> | undefined;
export function getWatchLaterIdRequestConfig() {
  return _requestConfigWatchLaterId;
}
export function setWatchLaterIdRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWatchLaterId = value;
}
export function patchWatchLaterIdRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWatchLaterId = patch(_requestConfigWatchLaterId ?? {});
}

let _requestConfigAddRemoveWatchLater: Partial<AxiosRequestConfig> | undefined;
export function getAddRemoveWatchLaterRequestConfig() {
  return _requestConfigAddRemoveWatchLater;
}
export function setAddRemoveWatchLaterRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAddRemoveWatchLater = value;
}
export function patchAddRemoveWatchLaterRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAddRemoveWatchLater = patch(_requestConfigAddRemoveWatchLater ?? {});
}

let _requestConfigSearch: Partial<AxiosRequestConfig> | undefined;
export function getSearchRequestConfig() {
  return _requestConfigSearch;
}
export function setSearchRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSearch = value;
}
export function patchSearchRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSearch = patch(_requestConfigSearch ?? {});
}

let _requestConfigTagsAll: Partial<AxiosRequestConfig> | undefined;
export function getTagsAllRequestConfig() {
  return _requestConfigTagsAll;
}
export function setTagsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigTagsAll = value;
}
export function patchTagsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigTagsAll = patch(_requestConfigTagsAll ?? {});
}

let _requestConfigTagsPOST: Partial<AxiosRequestConfig> | undefined;
export function getTagsPOSTRequestConfig() {
  return _requestConfigTagsPOST;
}
export function setTagsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigTagsPOST = value;
}
export function patchTagsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigTagsPOST = patch(_requestConfigTagsPOST ?? {});
}

let _requestConfigTagsWithVideos: Partial<AxiosRequestConfig> | undefined;
export function getTagsWithVideosRequestConfig() {
  return _requestConfigTagsWithVideos;
}
export function setTagsWithVideosRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigTagsWithVideos = value;
}
export function patchTagsWithVideosRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigTagsWithVideos = patch(_requestConfigTagsWithVideos ?? {});
}

let _requestConfigTagsDELETE: Partial<AxiosRequestConfig> | undefined;
export function getTagsDELETERequestConfig() {
  return _requestConfigTagsDELETE;
}
export function setTagsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigTagsDELETE = value;
}
export function patchTagsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigTagsDELETE = patch(_requestConfigTagsDELETE ?? {});
}

let _requestConfigUserGroupsAll: Partial<AxiosRequestConfig> | undefined;
export function getUserGroupsAllRequestConfig() {
  return _requestConfigUserGroupsAll;
}
export function setUserGroupsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsAll = value;
}
export function patchUserGroupsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsAll = patch(_requestConfigUserGroupsAll ?? {});
}

let _requestConfigUserGroupsPOST: Partial<AxiosRequestConfig> | undefined;
export function getUserGroupsPOSTRequestConfig() {
  return _requestConfigUserGroupsPOST;
}
export function setUserGroupsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsPOST = value;
}
export function patchUserGroupsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsPOST = patch(_requestConfigUserGroupsPOST ?? {});
}

let _requestConfigMyUsergroups: Partial<AxiosRequestConfig> | undefined;
export function getMyUsergroupsRequestConfig() {
  return _requestConfigMyUsergroups;
}
export function setMyUsergroupsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMyUsergroups = value;
}
export function patchMyUsergroupsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMyUsergroups = patch(_requestConfigMyUsergroups ?? {});
}

let _requestConfigUserGroupsGET: Partial<AxiosRequestConfig> | undefined;
export function getUserGroupsGETRequestConfig() {
  return _requestConfigUserGroupsGET;
}
export function setUserGroupsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsGET = value;
}
export function patchUserGroupsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsGET = patch(_requestConfigUserGroupsGET ?? {});
}

let _requestConfigUserGroupsPUT: Partial<AxiosRequestConfig> | undefined;
export function getUserGroupsPUTRequestConfig() {
  return _requestConfigUserGroupsPUT;
}
export function setUserGroupsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsPUT = value;
}
export function patchUserGroupsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsPUT = patch(_requestConfigUserGroupsPUT ?? {});
}

let _requestConfigUserGroupsDELETE: Partial<AxiosRequestConfig> | undefined;
export function getUserGroupsDELETERequestConfig() {
  return _requestConfigUserGroupsDELETE;
}
export function setUserGroupsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsDELETE = value;
}
export function patchUserGroupsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserGroupsDELETE = patch(_requestConfigUserGroupsDELETE ?? {});
}

let _requestConfigLogin: Partial<AxiosRequestConfig> | undefined;
export function getLoginRequestConfig() {
  return _requestConfigLogin;
}
export function setLoginRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLogin = value;
}
export function patchLoginRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLogin = patch(_requestConfigLogin ?? {});
}

let _requestConfigRegister: Partial<AxiosRequestConfig> | undefined;
export function getRegisterRequestConfig() {
  return _requestConfigRegister;
}
export function setRegisterRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRegister = value;
}
export function patchRegisterRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRegister = patch(_requestConfigRegister ?? {});
}

let _requestConfigMe: Partial<AxiosRequestConfig> | undefined;
export function getMeRequestConfig() {
  return _requestConfigMe;
}
export function setMeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMe = value;
}
export function patchMeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMe = patch(_requestConfigMe ?? {});
}

let _requestConfigUsersAll: Partial<AxiosRequestConfig> | undefined;
export function getUsersAllRequestConfig() {
  return _requestConfigUsersAll;
}
export function setUsersAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUsersAll = value;
}
export function patchUsersAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUsersAll = patch(_requestConfigUsersAll ?? {});
}

let _requestConfigUsersPUT: Partial<AxiosRequestConfig> | undefined;
export function getUsersPUTRequestConfig() {
  return _requestConfigUsersPUT;
}
export function setUsersPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUsersPUT = value;
}
export function patchUsersPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUsersPUT = patch(_requestConfigUsersPUT ?? {});
}

let _requestConfigUsersDELETE: Partial<AxiosRequestConfig> | undefined;
export function getUsersDELETERequestConfig() {
  return _requestConfigUsersDELETE;
}
export function setUsersDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUsersDELETE = value;
}
export function patchUsersDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUsersDELETE = patch(_requestConfigUsersDELETE ?? {});
}

let _requestConfigUsersGET: Partial<AxiosRequestConfig> | undefined;
export function getUsersGETRequestConfig() {
  return _requestConfigUsersGET;
}
export function setUsersGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUsersGET = value;
}
export function patchUsersGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUsersGET = patch(_requestConfigUsersGET ?? {});
}

let _requestConfigResetPassword: Partial<AxiosRequestConfig> | undefined;
export function getResetPasswordRequestConfig() {
  return _requestConfigResetPassword;
}
export function setResetPasswordRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigResetPassword = value;
}
export function patchResetPasswordRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigResetPassword = patch(_requestConfigResetPassword ?? {});
}

let _requestConfigSubmitResetPassword: Partial<AxiosRequestConfig> | undefined;
export function getSubmitResetPasswordRequestConfig() {
  return _requestConfigSubmitResetPassword;
}
export function setSubmitResetPasswordRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSubmitResetPassword = value;
}
export function patchSubmitResetPasswordRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSubmitResetPassword = patch(_requestConfigSubmitResetPassword ?? {});
}

let _requestConfigUserVideoStatsGET: Partial<AxiosRequestConfig> | undefined;
export function getUserVideoStatsGETRequestConfig() {
  return _requestConfigUserVideoStatsGET;
}
export function setUserVideoStatsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserVideoStatsGET = value;
}
export function patchUserVideoStatsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserVideoStatsGET = patch(_requestConfigUserVideoStatsGET ?? {});
}

let _requestConfigUserVideoStatsPUT: Partial<AxiosRequestConfig> | undefined;
export function getUserVideoStatsPUTRequestConfig() {
  return _requestConfigUserVideoStatsPUT;
}
export function setUserVideoStatsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserVideoStatsPUT = value;
}
export function patchUserVideoStatsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserVideoStatsPUT = patch(_requestConfigUserVideoStatsPUT ?? {});
}

let _requestConfigStats: Partial<AxiosRequestConfig> | undefined;
export function getStatsRequestConfig() {
  return _requestConfigStats;
}
export function setStatsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigStats = value;
}
export function patchStatsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigStats = patch(_requestConfigStats ?? {});
}

let _requestConfigWatched: Partial<AxiosRequestConfig> | undefined;
export function getWatchedRequestConfig() {
  return _requestConfigWatched;
}
export function setWatchedRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigWatched = value;
}
export function patchWatchedRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigWatched = patch(_requestConfigWatched ?? {});
}

let _requestConfigVideosAll: Partial<AxiosRequestConfig> | undefined;
export function getVideosAllRequestConfig() {
  return _requestConfigVideosAll;
}
export function setVideosAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosAll = value;
}
export function patchVideosAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosAll = patch(_requestConfigVideosAll ?? {});
}

let _requestConfigVideosPOST: Partial<AxiosRequestConfig> | undefined;
export function getVideosPOSTRequestConfig() {
  return _requestConfigVideosPOST;
}
export function setVideosPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosPOST = value;
}
export function patchVideosPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosPOST = patch(_requestConfigVideosPOST ?? {});
}

let _requestConfigVideosGET: Partial<AxiosRequestConfig> | undefined;
export function getVideosGETRequestConfig() {
  return _requestConfigVideosGET;
}
export function setVideosGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosGET = value;
}
export function patchVideosGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosGET = patch(_requestConfigVideosGET ?? {});
}

let _requestConfigVideosPUT: Partial<AxiosRequestConfig> | undefined;
export function getVideosPUTRequestConfig() {
  return _requestConfigVideosPUT;
}
export function setVideosPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosPUT = value;
}
export function patchVideosPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosPUT = patch(_requestConfigVideosPUT ?? {});
}

let _requestConfigVideosDELETE: Partial<AxiosRequestConfig> | undefined;
export function getVideosDELETERequestConfig() {
  return _requestConfigVideosDELETE;
}
export function setVideosDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosDELETE = value;
}
export function patchVideosDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosDELETE = patch(_requestConfigVideosDELETE ?? {});
}

let _requestConfigVideoPlaylists: Partial<AxiosRequestConfig> | undefined;
export function getVideoPlaylistsRequestConfig() {
  return _requestConfigVideoPlaylists;
}
export function setVideoPlaylistsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideoPlaylists = value;
}
export function patchVideoPlaylistsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideoPlaylists = patch(_requestConfigVideoPlaylists ?? {});
}

let _requestConfigVideoPermissions: Partial<AxiosRequestConfig> | undefined;
export function getVideoPermissionsRequestConfig() {
  return _requestConfigVideoPermissions;
}
export function setVideoPermissionsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideoPermissions = value;
}
export function patchVideoPermissionsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideoPermissions = patch(_requestConfigVideoPermissions ?? {});
}

let _requestConfigMyVideos: Partial<AxiosRequestConfig> | undefined;
export function getMyVideosRequestConfig() {
  return _requestConfigMyVideos;
}
export function setMyVideosRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMyVideos = value;
}
export function patchMyVideosRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMyVideos = patch(_requestConfigMyVideos ?? {});
}

let _requestConfigRelatedVideos: Partial<AxiosRequestConfig> | undefined;
export function getRelatedVideosRequestConfig() {
  return _requestConfigRelatedVideos;
}
export function setRelatedVideosRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRelatedVideos = value;
}
export function patchRelatedVideosRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRelatedVideos = patch(_requestConfigRelatedVideos ?? {});
}

let _requestConfigUpload: Partial<AxiosRequestConfig> | undefined;
export function getUploadRequestConfig() {
  return _requestConfigUpload;
}
export function setUploadRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpload = value;
}
export function patchUploadRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpload = patch(_requestConfigUpload ?? {});
}