//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../axios-client';
import { getAxios, getBaseUrl } from './helpers';

/**
 * @return Success
 */
export function commentsAll(config?: AxiosRequestConfig | undefined): Promise<Types.CommentDTO[]> {
    let url_ = getBaseUrl() + "/api/Comments";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCommentsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCommentsAll(_response);
    });
}

function processCommentsAll(response: AxiosResponse): Promise<Types.CommentDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.CommentDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.CommentDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CommentDTO[]>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function commentsPOST(body?: Types.CommentPostDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Comments";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCommentsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCommentsPOST(_response);
    });
}

function processCommentsPOST(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function commentsPUT(id: string, body?: Types.CommentPutDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Comments/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCommentsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCommentsPUT(_response);
    });
}

function processCommentsPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function commentsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Comments/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigCommentsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCommentsDELETE(_response);
    });
}

function processCommentsDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function myChannels(config?: AxiosRequestConfig | undefined): Promise<Types.ChannelDTO[]> {
    let url_ = getBaseUrl() + "/api/Channels/my-channels";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMyChannels,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMyChannels(_response);
    });
}

function processMyChannels(response: AxiosResponse): Promise<Types.ChannelDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.ChannelDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.ChannelDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelDTO[]>(null as any);
}

/**
 * @return Success
 */
export function channelsAll(config?: AxiosRequestConfig | undefined): Promise<Types.ChannelDTO[]> {
    let url_ = getBaseUrl() + "/api/Channels";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsAll(_response);
    });
}

function processChannelsAll(response: AxiosResponse): Promise<Types.ChannelDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.ChannelDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.ChannelDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelDTO[]>(null as any);
}

/**
 * @param name (optional) 
 * @param poster (optional) 
 * @param pinnedVideoId (optional) 
 * @param avatar (optional) 
 * @param description (optional) 
 * @param relatedChannels (optional) 
 * @return Success
 */
export function channelsPOST(name?: string | null | undefined, poster?: Types.FileParameter | null | undefined, pinnedVideoId?: string | null | undefined, avatar?: Types.FileParameter | null | undefined, description?: string | null | undefined, relatedChannels?: Types.Channel[] | null | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ChannelDTO> {
    let url_ = getBaseUrl() + "/api/Channels";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (poster !== null && poster !== undefined)
        content_.append("Poster", poster.data, poster.fileName ? poster.fileName : "Poster");
    if (pinnedVideoId !== null && pinnedVideoId !== undefined)
        content_.append("PinnedVideoId", pinnedVideoId.toString());
    if (avatar !== null && avatar !== undefined)
        content_.append("Avatar", avatar.data, avatar.fileName ? avatar.fileName : "Avatar");
    if (description !== null && description !== undefined)
        content_.append("Description", description.toString());
    if (relatedChannels !== null && relatedChannels !== undefined)
        relatedChannels.forEach(item_ => content_.append("RelatedChannels", item_.toString()));

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsPOST(_response);
    });
}

function processChannelsPOST(response: AxiosResponse): Promise<Types.ChannelDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ChannelDTO.fromJS(resultData200);
        return Promise.resolve<Types.ChannelDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelDTO>(null as any);
}

/**
 * @return Success
 */
export function channelsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ChannelDTO> {
    let url_ = getBaseUrl() + "/api/Channels/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsGET(_response);
    });
}

function processChannelsGET(response: AxiosResponse): Promise<Types.ChannelDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ChannelDTO.fromJS(resultData200);
        return Promise.resolve<Types.ChannelDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelDTO>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function channelsPUT(id: string, body?: Types.ChannelDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Channels/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsPUT(_response);
    });
}

function processChannelsPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function channelsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Channels/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsDELETE(_response);
    });
}

function processChannelsDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function channelVideos(id: string, limit?: number | undefined, offset?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.WithTotalCountOfVideoDTO> {
    let url_ = getBaseUrl() + "/api/Channels/{id}/channel-videos?";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
    else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
    if (offset === null)
        throw new Error("The parameter 'offset' cannot be null.");
    else if (offset !== undefined)
        url_ += "offset=" + encodeURIComponent("" + offset) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelVideos,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelVideos(_response);
    });
}

function processChannelVideos(response: AxiosResponse): Promise<Types.WithTotalCountOfVideoDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.WithTotalCountOfVideoDTO.fromJS(resultData200);
        return Promise.resolve<Types.WithTotalCountOfVideoDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.WithTotalCountOfVideoDTO>(null as any);
}

/**
 * @return Success
 */
export function channelAdvancedInfo(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ChannelAdvancedInfo> {
    let url_ = getBaseUrl() + "/api/Channels/{id}/channel-advanced-info";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelAdvancedInfo,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelAdvancedInfo(_response);
    });
}

function processChannelAdvancedInfo(response: AxiosResponse): Promise<Types.ChannelAdvancedInfo> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ChannelAdvancedInfo.fromJS(resultData200);
        return Promise.resolve<Types.ChannelAdvancedInfo>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelAdvancedInfo>(null as any);
}

/**
 * @return Success
 */
export function channelUserInfoGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ChannelUserSpecificInfoDTO> {
    let url_ = getBaseUrl() + "/api/Channels/{id}/channel-user-info";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelUserInfoGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelUserInfoGET(_response);
    });
}

function processChannelUserInfoGET(response: AxiosResponse): Promise<Types.ChannelUserSpecificInfoDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ChannelUserSpecificInfoDTO.fromJS(resultData200);
        return Promise.resolve<Types.ChannelUserSpecificInfoDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelUserSpecificInfoDTO>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function channelUserInfoPUT(id: string, body?: Types.ChannelUserSpecificInfoDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Channels/{id}/channel-user-info";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelUserInfoPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelUserInfoPUT(_response);
    });
}

function processChannelUserInfoPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param q (optional) 
 * @return Success
 */
export function search(q?: string | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO[]> {
    let url_ = getBaseUrl() + "/api/Search?";
    if (q === null)
        throw new Error("The parameter 'q' cannot be null.");
    else if (q !== undefined)
        url_ += "q=" + encodeURIComponent("" + q) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigSearch,
        ...config,
        method: "PUT",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processSearch(_response);
    });
}

function processSearch(response: AxiosResponse): Promise<Types.VideoDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.VideoDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.VideoDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO[]>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function login(body?: Types.LoginDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/users/login";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLogin,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLogin(_response);
    });
}

function processLogin(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function register(body?: Types.RegisterDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/users/register";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRegister,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRegister(_response);
    });
}

function processRegister(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @return Success
 */
export function me(config?: AxiosRequestConfig | undefined): Promise<Types.UserDTO> {
    let url_ = getBaseUrl() + "/api/users/me";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMe,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMe(_response);
    });
}

function processMe(response: AxiosResponse): Promise<Types.UserDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserDTO.fromJS(resultData200);
        return Promise.resolve<Types.UserDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserDTO>(null as any);
}

/**
 * @return Success
 */
export function usersAll(config?: AxiosRequestConfig | undefined): Promise<Types.UserDTO[]> {
    let url_ = getBaseUrl() + "/api/users";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUsersAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUsersAll(_response);
    });
}

function processUsersAll(response: AxiosResponse): Promise<Types.UserDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.UserDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.UserDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserDTO[]>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function usersPUT(id: string, body?: Types.UserDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/users/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUsersPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUsersPUT(_response);
    });
}

function processUsersPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function usersDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/users/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUsersDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUsersDELETE(_response);
    });
}

function processUsersDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function usersGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.UserDTO> {
    let url_ = getBaseUrl() + "/api/users/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUsersGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUsersGET(_response);
    });
}

function processUsersGET(response: AxiosResponse): Promise<Types.UserDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserDTO.fromJS(resultData200);
        return Promise.resolve<Types.UserDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserDTO>(null as any);
}

/**
 * @return Success
 */
export function userVideoStatsGET(videoId: string, config?: AxiosRequestConfig | undefined): Promise<Types.UserVideoStats> {
    let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";

    if (videoId === undefined || videoId === null)
      throw new Error("The parameter 'videoId' must be defined.");
    url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserVideoStatsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserVideoStatsGET(_response);
    });
}

function processUserVideoStatsGET(response: AxiosResponse): Promise<Types.UserVideoStats> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserVideoStats.fromJS(resultData200);
        return Promise.resolve<Types.UserVideoStats>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserVideoStats>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function userVideoStatsPUT(videoId: string, body?: Types.UserVideoStats | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";

    if (videoId === undefined || videoId === null)
      throw new Error("The parameter 'videoId' must be defined.");
    url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUserVideoStatsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUserVideoStatsPUT(_response);
    });
}

function processUserVideoStatsPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function videosAll(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO[]> {
    let url_ = getBaseUrl() + "/api/Videos?";
    if (orderBy === null)
        throw new Error("The parameter 'orderBy' cannot be null.");
    else if (orderBy !== undefined)
        url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
    if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
    else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
    if (offset === null)
        throw new Error("The parameter 'offset' cannot be null.");
    else if (offset !== undefined)
        url_ += "offset=" + encodeURIComponent("" + offset) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosAll(_response);
    });
}

function processVideosAll(response: AxiosResponse): Promise<Types.VideoDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.VideoDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.VideoDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO[]>(null as any);
}

/**
 * @param fileName (optional) 
 * @param name (optional) 
 * @param description (optional) 
 * @param durationSec (optional) 
 * @param image (optional) 
 * @param channelId (optional) 
 * @param tags (optional) 
 * @return Success
 */
export function videosPOST(fileName?: string | null | undefined, name?: string | null | undefined, description?: string | null | undefined, durationSec?: number | undefined, image?: Types.FileParameter | null | undefined, channelId?: string | undefined, tags?: Types.Tag[] | null | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PostVideoResponse> {
    let url_ = getBaseUrl() + "/api/Videos";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (fileName !== null && fileName !== undefined)
        content_.append("FileName", fileName.toString());
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (description !== null && description !== undefined)
        content_.append("Description", description.toString());
    if (durationSec === null || durationSec === undefined)
        throw new Error("The parameter 'durationSec' cannot be null.");
    else
        content_.append("DurationSec", durationSec.toString());
    if (image !== null && image !== undefined)
        content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
    if (channelId === null || channelId === undefined)
        throw new Error("The parameter 'channelId' cannot be null.");
    else
        content_.append("ChannelId", channelId.toString());
    if (tags !== null && tags !== undefined)
        tags.forEach(item_ => content_.append("Tags", item_.toString()));

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosPOST(_response);
    });
}

function processVideosPOST(response: AxiosResponse): Promise<Types.PostVideoResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.PostVideoResponse.fromJS(resultData200);
        return Promise.resolve<Types.PostVideoResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PostVideoResponse>(null as any);
}

/**
 * @return Success
 */
export function videosGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosGET(_response);
    });
}

function processVideosGET(response: AxiosResponse): Promise<Types.VideoDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.VideoDTO.fromJS(resultData200);
        return Promise.resolve<Types.VideoDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO>(null as any);
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param image (optional) 
 * @param channelId (optional) 
 * @param tags (optional) 
 * @return Success
 */
export function videosPUT(id: string, name?: string | null | undefined, description?: string | null | undefined, image?: Types.FileParameter | null | undefined, channelId?: string | undefined, tags?: Types.Tag[] | null | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (description !== null && description !== undefined)
        content_.append("Description", description.toString());
    if (image !== null && image !== undefined)
        content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
    if (channelId === null || channelId === undefined)
        throw new Error("The parameter 'channelId' cannot be null.");
    else
        content_.append("ChannelId", channelId.toString());
    if (tags !== null && tags !== undefined)
        tags.forEach(item_ => content_.append("Tags", item_.toString()));

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosPUT(_response);
    });
}

function processVideosPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function videosDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosDELETE(_response);
    });
}

function processVideosDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function myVideos(config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO[]> {
    let url_ = getBaseUrl() + "/api/Videos/my-videos";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMyVideos,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMyVideos(_response);
    });
}

function processMyVideos(response: AxiosResponse): Promise<Types.VideoDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.VideoDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.VideoDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO[]>(null as any);
}

/**
 * @return Success
 */
export function relatedVideos(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.VideoDTO[]> {
    let url_ = getBaseUrl() + "/api/Videos/{id}/related-videos";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigRelatedVideos,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRelatedVideos(_response);
    });
}

function processRelatedVideos(response: AxiosResponse): Promise<Types.VideoDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.VideoDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.VideoDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.VideoDTO[]>(null as any);
}

/**
 * @param file (optional) 
 * @return Success
 */
export function upload(file?: Types.FileParameter | null | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Videos/upload";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file !== null && file !== undefined)
        content_.append("file", file.data, file.fileName ? file.fileName : "file");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpload,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpload(_response);
    });
}

function processUpload(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
let _requestConfigCommentsAll: Partial<AxiosRequestConfig> | undefined;
export function getCommentsAllRequestConfig() {
  return _requestConfigCommentsAll;
}
export function setCommentsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCommentsAll = value;
}
export function patchCommentsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCommentsAll = patch(_requestConfigCommentsAll ?? {});
}

let _requestConfigCommentsPOST: Partial<AxiosRequestConfig> | undefined;
export function getCommentsPOSTRequestConfig() {
  return _requestConfigCommentsPOST;
}
export function setCommentsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCommentsPOST = value;
}
export function patchCommentsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCommentsPOST = patch(_requestConfigCommentsPOST ?? {});
}

let _requestConfigCommentsPUT: Partial<AxiosRequestConfig> | undefined;
export function getCommentsPUTRequestConfig() {
  return _requestConfigCommentsPUT;
}
export function setCommentsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCommentsPUT = value;
}
export function patchCommentsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCommentsPUT = patch(_requestConfigCommentsPUT ?? {});
}

let _requestConfigCommentsDELETE: Partial<AxiosRequestConfig> | undefined;
export function getCommentsDELETERequestConfig() {
  return _requestConfigCommentsDELETE;
}
export function setCommentsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCommentsDELETE = value;
}
export function patchCommentsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCommentsDELETE = patch(_requestConfigCommentsDELETE ?? {});
}

let _requestConfigMyChannels: Partial<AxiosRequestConfig> | undefined;
export function getMyChannelsRequestConfig() {
  return _requestConfigMyChannels;
}
export function setMyChannelsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMyChannels = value;
}
export function patchMyChannelsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMyChannels = patch(_requestConfigMyChannels ?? {});
}

let _requestConfigChannelsAll: Partial<AxiosRequestConfig> | undefined;
export function getChannelsAllRequestConfig() {
  return _requestConfigChannelsAll;
}
export function setChannelsAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsAll = value;
}
export function patchChannelsAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsAll = patch(_requestConfigChannelsAll ?? {});
}

let _requestConfigChannelsPOST: Partial<AxiosRequestConfig> | undefined;
export function getChannelsPOSTRequestConfig() {
  return _requestConfigChannelsPOST;
}
export function setChannelsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsPOST = value;
}
export function patchChannelsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsPOST = patch(_requestConfigChannelsPOST ?? {});
}

let _requestConfigChannelsGET: Partial<AxiosRequestConfig> | undefined;
export function getChannelsGETRequestConfig() {
  return _requestConfigChannelsGET;
}
export function setChannelsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsGET = value;
}
export function patchChannelsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsGET = patch(_requestConfigChannelsGET ?? {});
}

let _requestConfigChannelsPUT: Partial<AxiosRequestConfig> | undefined;
export function getChannelsPUTRequestConfig() {
  return _requestConfigChannelsPUT;
}
export function setChannelsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsPUT = value;
}
export function patchChannelsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsPUT = patch(_requestConfigChannelsPUT ?? {});
}

let _requestConfigChannelsDELETE: Partial<AxiosRequestConfig> | undefined;
export function getChannelsDELETERequestConfig() {
  return _requestConfigChannelsDELETE;
}
export function setChannelsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsDELETE = value;
}
export function patchChannelsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsDELETE = patch(_requestConfigChannelsDELETE ?? {});
}

let _requestConfigChannelVideos: Partial<AxiosRequestConfig> | undefined;
export function getChannelVideosRequestConfig() {
  return _requestConfigChannelVideos;
}
export function setChannelVideosRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelVideos = value;
}
export function patchChannelVideosRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelVideos = patch(_requestConfigChannelVideos ?? {});
}

let _requestConfigChannelAdvancedInfo: Partial<AxiosRequestConfig> | undefined;
export function getChannelAdvancedInfoRequestConfig() {
  return _requestConfigChannelAdvancedInfo;
}
export function setChannelAdvancedInfoRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelAdvancedInfo = value;
}
export function patchChannelAdvancedInfoRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelAdvancedInfo = patch(_requestConfigChannelAdvancedInfo ?? {});
}

let _requestConfigChannelUserInfoGET: Partial<AxiosRequestConfig> | undefined;
export function getChannelUserInfoGETRequestConfig() {
  return _requestConfigChannelUserInfoGET;
}
export function setChannelUserInfoGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelUserInfoGET = value;
}
export function patchChannelUserInfoGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelUserInfoGET = patch(_requestConfigChannelUserInfoGET ?? {});
}

let _requestConfigChannelUserInfoPUT: Partial<AxiosRequestConfig> | undefined;
export function getChannelUserInfoPUTRequestConfig() {
  return _requestConfigChannelUserInfoPUT;
}
export function setChannelUserInfoPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelUserInfoPUT = value;
}
export function patchChannelUserInfoPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelUserInfoPUT = patch(_requestConfigChannelUserInfoPUT ?? {});
}

let _requestConfigSearch: Partial<AxiosRequestConfig> | undefined;
export function getSearchRequestConfig() {
  return _requestConfigSearch;
}
export function setSearchRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigSearch = value;
}
export function patchSearchRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigSearch = patch(_requestConfigSearch ?? {});
}

let _requestConfigLogin: Partial<AxiosRequestConfig> | undefined;
export function getLoginRequestConfig() {
  return _requestConfigLogin;
}
export function setLoginRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLogin = value;
}
export function patchLoginRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLogin = patch(_requestConfigLogin ?? {});
}

let _requestConfigRegister: Partial<AxiosRequestConfig> | undefined;
export function getRegisterRequestConfig() {
  return _requestConfigRegister;
}
export function setRegisterRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRegister = value;
}
export function patchRegisterRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRegister = patch(_requestConfigRegister ?? {});
}

let _requestConfigMe: Partial<AxiosRequestConfig> | undefined;
export function getMeRequestConfig() {
  return _requestConfigMe;
}
export function setMeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMe = value;
}
export function patchMeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMe = patch(_requestConfigMe ?? {});
}

let _requestConfigUsersAll: Partial<AxiosRequestConfig> | undefined;
export function getUsersAllRequestConfig() {
  return _requestConfigUsersAll;
}
export function setUsersAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUsersAll = value;
}
export function patchUsersAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUsersAll = patch(_requestConfigUsersAll ?? {});
}

let _requestConfigUsersPUT: Partial<AxiosRequestConfig> | undefined;
export function getUsersPUTRequestConfig() {
  return _requestConfigUsersPUT;
}
export function setUsersPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUsersPUT = value;
}
export function patchUsersPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUsersPUT = patch(_requestConfigUsersPUT ?? {});
}

let _requestConfigUsersDELETE: Partial<AxiosRequestConfig> | undefined;
export function getUsersDELETERequestConfig() {
  return _requestConfigUsersDELETE;
}
export function setUsersDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUsersDELETE = value;
}
export function patchUsersDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUsersDELETE = patch(_requestConfigUsersDELETE ?? {});
}

let _requestConfigUsersGET: Partial<AxiosRequestConfig> | undefined;
export function getUsersGETRequestConfig() {
  return _requestConfigUsersGET;
}
export function setUsersGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUsersGET = value;
}
export function patchUsersGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUsersGET = patch(_requestConfigUsersGET ?? {});
}

let _requestConfigUserVideoStatsGET: Partial<AxiosRequestConfig> | undefined;
export function getUserVideoStatsGETRequestConfig() {
  return _requestConfigUserVideoStatsGET;
}
export function setUserVideoStatsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserVideoStatsGET = value;
}
export function patchUserVideoStatsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserVideoStatsGET = patch(_requestConfigUserVideoStatsGET ?? {});
}

let _requestConfigUserVideoStatsPUT: Partial<AxiosRequestConfig> | undefined;
export function getUserVideoStatsPUTRequestConfig() {
  return _requestConfigUserVideoStatsPUT;
}
export function setUserVideoStatsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUserVideoStatsPUT = value;
}
export function patchUserVideoStatsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUserVideoStatsPUT = patch(_requestConfigUserVideoStatsPUT ?? {});
}

let _requestConfigVideosAll: Partial<AxiosRequestConfig> | undefined;
export function getVideosAllRequestConfig() {
  return _requestConfigVideosAll;
}
export function setVideosAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosAll = value;
}
export function patchVideosAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosAll = patch(_requestConfigVideosAll ?? {});
}

let _requestConfigVideosPOST: Partial<AxiosRequestConfig> | undefined;
export function getVideosPOSTRequestConfig() {
  return _requestConfigVideosPOST;
}
export function setVideosPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosPOST = value;
}
export function patchVideosPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosPOST = patch(_requestConfigVideosPOST ?? {});
}

let _requestConfigVideosGET: Partial<AxiosRequestConfig> | undefined;
export function getVideosGETRequestConfig() {
  return _requestConfigVideosGET;
}
export function setVideosGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosGET = value;
}
export function patchVideosGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosGET = patch(_requestConfigVideosGET ?? {});
}

let _requestConfigVideosPUT: Partial<AxiosRequestConfig> | undefined;
export function getVideosPUTRequestConfig() {
  return _requestConfigVideosPUT;
}
export function setVideosPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosPUT = value;
}
export function patchVideosPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosPUT = patch(_requestConfigVideosPUT ?? {});
}

let _requestConfigVideosDELETE: Partial<AxiosRequestConfig> | undefined;
export function getVideosDELETERequestConfig() {
  return _requestConfigVideosDELETE;
}
export function setVideosDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosDELETE = value;
}
export function patchVideosDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosDELETE = patch(_requestConfigVideosDELETE ?? {});
}

let _requestConfigMyVideos: Partial<AxiosRequestConfig> | undefined;
export function getMyVideosRequestConfig() {
  return _requestConfigMyVideos;
}
export function setMyVideosRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMyVideos = value;
}
export function patchMyVideosRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMyVideos = patch(_requestConfigMyVideos ?? {});
}

let _requestConfigRelatedVideos: Partial<AxiosRequestConfig> | undefined;
export function getRelatedVideosRequestConfig() {
  return _requestConfigRelatedVideos;
}
export function setRelatedVideosRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRelatedVideos = value;
}
export function patchRelatedVideosRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRelatedVideos = patch(_requestConfigRelatedVideos ?? {});
}

let _requestConfigUpload: Partial<AxiosRequestConfig> | undefined;
export function getUploadRequestConfig() {
  return _requestConfigUpload;
}
export function setUploadRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpload = value;
}
export function patchUploadRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpload = patch(_requestConfigUpload ?? {});
}