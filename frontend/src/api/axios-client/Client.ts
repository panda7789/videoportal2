//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../axios-client';
import { getAxios, getBaseUrl } from './helpers';

/**
 * @return Success
 */
export function myChannels(config?: AxiosRequestConfig | undefined): Promise<Types.ChannelDTO[]> {
    let url_ = getBaseUrl() + "/api/Channels/my-channels";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMyChannels,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMyChannels(_response);
    });
}

function processMyChannels(response: AxiosResponse): Promise<Types.ChannelDTO[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.ChannelDTO.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.ChannelDTO[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelDTO[]>(null as any);
}

/**
 * @return Success
 */
export function channelsGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.ChannelDTO> {
    let url_ = getBaseUrl() + "/api/Channels/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsGET(_response);
    });
}

function processChannelsGET(response: AxiosResponse): Promise<Types.ChannelDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ChannelDTO.fromJS(resultData200);
        return Promise.resolve<Types.ChannelDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelDTO>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function channelsPUT(id: string, body?: Types.ChannelDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Channels/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsPUT(_response);
    });
}

function processChannelsPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function channelsDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Channels/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsDELETE(_response);
    });
}

function processChannelsDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @param name (optional) 
 * @param poster (optional) 
 * @param pinnedVideoId (optional) 
 * @param avatar (optional) 
 * @return Success
 */
export function channelsPOST(name?: string | null | undefined, poster?: Types.FileParameter | null | undefined, pinnedVideoId?: string | null | undefined, avatar?: Types.FileParameter | null | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.ChannelDTO> {
    let url_ = getBaseUrl() + "/api/Channels";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (poster !== null && poster !== undefined)
        content_.append("Poster", poster.data, poster.fileName ? poster.fileName : "Poster");
    if (pinnedVideoId !== null && pinnedVideoId !== undefined)
        content_.append("PinnedVideoId", pinnedVideoId.toString());
    if (avatar !== null && avatar !== undefined)
        content_.append("Avatar", avatar.data, avatar.fileName ? avatar.fileName : "Avatar");

    let options_: AxiosRequestConfig = {
        ..._requestConfigChannelsPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processChannelsPOST(_response);
    });
}

function processChannelsPOST(response: AxiosResponse): Promise<Types.ChannelDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ChannelDTO.fromJS(resultData200);
        return Promise.resolve<Types.ChannelDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ChannelDTO>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function login(body?: Types.LoginDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/users/login";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigLogin,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLogin(_response);
    });
}

function processLogin(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function register(body?: Types.RegisterDTO | undefined, config?: AxiosRequestConfig | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/api/users/register";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigRegister,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processRegister(_response);
    });
}

function processRegister(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * @return Success
 */
export function me(config?: AxiosRequestConfig | undefined): Promise<Types.UserDTO> {
    let url_ = getBaseUrl() + "/api/users/me";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigMe,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processMe(_response);
    });
}

function processMe(response: AxiosResponse): Promise<Types.UserDTO> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.UserDTO.fromJS(resultData200);
        return Promise.resolve<Types.UserDTO>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.UserDTO>(null as any);
}

/**
 * @return Success
 */
export function videosAll(config?: AxiosRequestConfig | undefined): Promise<Types.Video[]> {
    let url_ = getBaseUrl() + "/api/Videos";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosAll,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosAll(_response);
    });
}

function processVideosAll(response: AxiosResponse): Promise<Types.Video[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.Video.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.Video[]>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Video[]>(null as any);
}

/**
 * @param file (optional) 
 * @param name (optional) 
 * @param description (optional) 
 * @param durationSec (optional) 
 * @param image (optional) 
 * @param channelId (optional) 
 * @param tags (optional) 
 * @return Success
 */
export function videosPOST(file?: Types.FileParameter | null | undefined, name?: string | null | undefined, description?: string | null | undefined, durationSec?: number | undefined, image?: Types.FileParameter | null | undefined, channelId?: string | undefined, tags?: Types.Tag[] | null | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.Video> {
    let url_ = getBaseUrl() + "/api/Videos";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file !== null && file !== undefined)
        content_.append("File", file.data, file.fileName ? file.fileName : "File");
    if (name !== null && name !== undefined)
        content_.append("Name", name.toString());
    if (description !== null && description !== undefined)
        content_.append("Description", description.toString());
    if (durationSec === null || durationSec === undefined)
        throw new Error("The parameter 'durationSec' cannot be null.");
    else
        content_.append("DurationSec", durationSec.toString());
    if (image !== null && image !== undefined)
        content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
    if (channelId === null || channelId === undefined)
        throw new Error("The parameter 'channelId' cannot be null.");
    else
        content_.append("ChannelId", channelId.toString());
    if (tags !== null && tags !== undefined)
        tags.forEach(item_ => content_.append("Tags", item_.toString()));

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosPOST,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosPOST(_response);
    });
}

function processVideosPOST(response: AxiosResponse): Promise<Types.Video> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.Video.fromJS(resultData200);
        return Promise.resolve<Types.Video>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Video>(null as any);
}

/**
 * @return Success
 */
export function videosGET(id: string, config?: AxiosRequestConfig | undefined): Promise<Types.Video> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosGET,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "text/plain"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosGET(_response);
    });
}

function processVideosGET(response: AxiosResponse): Promise<Types.Video> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.Video.fromJS(resultData200);
        return Promise.resolve<Types.Video>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Video>(null as any);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function videosPUT(id: string, body?: Types.Video | undefined, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosPUT,
        ...config,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosPUT(_response);
    });
}

function processVideosPUT(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * @return Success
 */
export function videosDELETE(id: string, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/Videos/{id}";

    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigVideosDELETE,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processVideosDELETE(_response);
    });
}

function processVideosDELETE(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}
let _requestConfigMyChannels: Partial<AxiosRequestConfig> | null;
export function getMyChannelsRequestConfig() {
  return _requestConfigMyChannels;
}
export function setMyChannelsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMyChannels = value;
}
export function patchMyChannelsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMyChannels = patch(_requestConfigMyChannels ?? {});
}

let _requestConfigChannelsGET: Partial<AxiosRequestConfig> | null;
export function getChannelsGETRequestConfig() {
  return _requestConfigChannelsGET;
}
export function setChannelsGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsGET = value;
}
export function patchChannelsGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsGET = patch(_requestConfigChannelsGET ?? {});
}

let _requestConfigChannelsPUT: Partial<AxiosRequestConfig> | null;
export function getChannelsPUTRequestConfig() {
  return _requestConfigChannelsPUT;
}
export function setChannelsPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsPUT = value;
}
export function patchChannelsPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsPUT = patch(_requestConfigChannelsPUT ?? {});
}

let _requestConfigChannelsDELETE: Partial<AxiosRequestConfig> | null;
export function getChannelsDELETERequestConfig() {
  return _requestConfigChannelsDELETE;
}
export function setChannelsDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsDELETE = value;
}
export function patchChannelsDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsDELETE = patch(_requestConfigChannelsDELETE ?? {});
}

let _requestConfigChannelsPOST: Partial<AxiosRequestConfig> | null;
export function getChannelsPOSTRequestConfig() {
  return _requestConfigChannelsPOST;
}
export function setChannelsPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigChannelsPOST = value;
}
export function patchChannelsPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigChannelsPOST = patch(_requestConfigChannelsPOST ?? {});
}

let _requestConfigLogin: Partial<AxiosRequestConfig> | null;
export function getLoginRequestConfig() {
  return _requestConfigLogin;
}
export function setLoginRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLogin = value;
}
export function patchLoginRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLogin = patch(_requestConfigLogin ?? {});
}

let _requestConfigRegister: Partial<AxiosRequestConfig> | null;
export function getRegisterRequestConfig() {
  return _requestConfigRegister;
}
export function setRegisterRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigRegister = value;
}
export function patchRegisterRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigRegister = patch(_requestConfigRegister ?? {});
}

let _requestConfigMe: Partial<AxiosRequestConfig> | null;
export function getMeRequestConfig() {
  return _requestConfigMe;
}
export function setMeRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigMe = value;
}
export function patchMeRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigMe = patch(_requestConfigMe ?? {});
}

let _requestConfigVideosAll: Partial<AxiosRequestConfig> | null;
export function getVideosAllRequestConfig() {
  return _requestConfigVideosAll;
}
export function setVideosAllRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosAll = value;
}
export function patchVideosAllRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosAll = patch(_requestConfigVideosAll ?? {});
}

let _requestConfigVideosPOST: Partial<AxiosRequestConfig> | null;
export function getVideosPOSTRequestConfig() {
  return _requestConfigVideosPOST;
}
export function setVideosPOSTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosPOST = value;
}
export function patchVideosPOSTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosPOST = patch(_requestConfigVideosPOST ?? {});
}

let _requestConfigVideosGET: Partial<AxiosRequestConfig> | null;
export function getVideosGETRequestConfig() {
  return _requestConfigVideosGET;
}
export function setVideosGETRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosGET = value;
}
export function patchVideosGETRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosGET = patch(_requestConfigVideosGET ?? {});
}

let _requestConfigVideosPUT: Partial<AxiosRequestConfig> | null;
export function getVideosPUTRequestConfig() {
  return _requestConfigVideosPUT;
}
export function setVideosPUTRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosPUT = value;
}
export function patchVideosPUTRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosPUT = patch(_requestConfigVideosPUT ?? {});
}

let _requestConfigVideosDELETE: Partial<AxiosRequestConfig> | null;
export function getVideosDELETERequestConfig() {
  return _requestConfigVideosDELETE;
}
export function setVideosDELETERequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigVideosDELETE = value;
}
export function patchVideosDELETERequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigVideosDELETE = patch(_requestConfigVideosDELETE ?? {});
}