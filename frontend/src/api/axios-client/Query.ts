//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './Client'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type CommentsAllQueryParameters = {
  videoId: string ;
}

export type CommentsPUTQueryParameters = {
  id: string ;
}

export type CommentsDELETEQueryParameters = {
  id: string ;
}

export type PlaylistPermissionsQueryParameters = {
  id: string ;
}

export type PlaylistsAllQueryParameters = {
  orderBy?: string | undefined ;
  limit?: number | undefined ;
  offset?: number | undefined ;
}

export type PlaylistsPOSTMutationParameters = {
  name?: string | null | undefined ;
  description?: string | null | undefined ;
  thumbnail?: Types.FileParameter | null | undefined ;
  videos?: string[] | null | undefined ;
  isPublic?: boolean | undefined ;
  permissions_UserIds?: string[] | null | undefined ;
  permissions_GroupIds?: string[] | null | undefined ;
}

export type PlaylistsGETQueryParameters = {
  id: string ;
}

export type PlaylistsPUTQueryParameters = {
  id: string ;
  name?: string | null | undefined ;
  description?: string | null | undefined ;
  thumbnail?: Types.FileParameter | null | undefined ;
  videos?: string[] | null | undefined ;
  isPublic?: boolean | undefined ;
  permissions_UserIds?: string[] | null | undefined ;
  permissions_GroupIds?: string[] | null | undefined ;
}

export type PlaylistsPUTMutationParameters = {
  name?: string | null | undefined ;
  description?: string | null | undefined ;
  thumbnail?: Types.FileParameter | null | undefined ;
  videos?: string[] | null | undefined ;
  isPublic?: boolean | undefined ;
  permissions_UserIds?: string[] | null | undefined ;
  permissions_GroupIds?: string[] | null | undefined ;
}

export type PlaylistsDELETEQueryParameters = {
  id: string ;
}

export type AddRemoveWatchLaterQueryParameters = {
  id?: string | undefined ;
}

export type SearchQueryParameters = {
  q?: string | undefined ;
  limit?: number | undefined ;
  offset?: number | undefined ;
}


export type TagsDELETEQueryParameters = {
  id: string ;
}


export type UserGroupsGETQueryParameters = {
  id: string ;
}

export type UserGroupsPUTQueryParameters = {
  id: string ;
}

export type UserGroupsDELETEQueryParameters = {
  id: string ;
}



export type UsersPUTQueryParameters = {
  id: string ;
}

export type UsersDELETEQueryParameters = {
  id: string ;
}

export type UsersGETQueryParameters = {
  id: string ;
}

export type UserVideoStatsGETQueryParameters = {
  videoId: string ;
}

export type UserVideoStatsPUTQueryParameters = {
  videoId: string ;
}

export type WatchedQueryParameters = {
  videoId: string ;
}

export type VideosAllQueryParameters = {
  orderBy?: string | undefined ;
  limit?: number | undefined ;
  offset?: number | undefined ;
}

export type VideosPOSTMutationParameters = {
  fileName?: string | null | undefined ;
  name?: string | null | undefined ;
  description?: string | null | undefined ;
  durationSec?: number | undefined ;
  image?: Types.FileParameter | null | undefined ;
  playlistId?: string | undefined ;
  tags?: string[] | null | undefined ;
  isPublic?: boolean | undefined ;
  permissions_UserIds?: string[] | null | undefined ;
  permissions_GroupIds?: string[] | null | undefined ;
}

export type VideosGETQueryParameters = {
  id: string ;
}

export type VideosPUTQueryParameters = {
  id: string ;
  name?: string | null | undefined ;
  description?: string | null | undefined ;
  image?: Types.FileParameter | null | undefined ;
  playlistId?: string | undefined ;
  tags?: string[] | null | undefined ;
  isPublic?: boolean | undefined ;
  permissions_UserIds?: string[] | null | undefined ;
  permissions_GroupIds?: string[] | null | undefined ;
}

export type VideosPUTMutationParameters = {
  name?: string | null | undefined ;
  description?: string | null | undefined ;
  image?: Types.FileParameter | null | undefined ;
  playlistId?: string | undefined ;
  tags?: string[] | null | undefined ;
  isPublic?: boolean | undefined ;
  permissions_UserIds?: string[] | null | undefined ;
  permissions_GroupIds?: string[] | null | undefined ;
}

export type VideosDELETEQueryParameters = {
  id: string ;
}

export type VideoPlaylistsQueryParameters = {
  id: string ;
}

export type VideoPermissionsQueryParameters = {
  id: string ;
}

export type RelatedVideosQueryParameters = {
  id: string ;
}

export type UploadMutationParameters = {
  file?: Types.FileParameter | null | undefined ;
}

export function commentsAllUrl(videoId: string): string {
  let url_ = getBaseUrl() + "/api/Comments/{videoId}";
if (videoId === undefined || videoId === null)
  throw new Error("The parameter 'videoId' must be defined.");
url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let commentsAllDefaultOptions: UseQueryOptions<Types.CommentDTO[], unknown, Types.CommentDTO[]> = {
  queryFn: __commentsAll,
};
export function getCommentsAllDefaultOptions(): UseQueryOptions<Types.CommentDTO[], unknown, Types.CommentDTO[]> {
  return commentsAllDefaultOptions;
};
export function setCommentsAllDefaultOptions(options: UseQueryOptions<Types.CommentDTO[], unknown, Types.CommentDTO[]>) {
  commentsAllDefaultOptions = options;
}

export function commentsAllQueryKey(videoId: string): QueryKey;
export function commentsAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { videoId,  } = params[0] as CommentsAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'commentsAll',
        videoId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'commentsAll',
        ...params
      ]);
  }
}
function __commentsAll(context: QueryFunctionContext) {
  return Client.commentsAll(
      context.queryKey[2] as string    );
}

export function useCommentsAllQuery<TSelectData = Types.CommentDTO[], TError = unknown>(dto: CommentsAllQueryParameters, options?: UseQueryOptions<Types.CommentDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useCommentsAllQuery<TSelectData = Types.CommentDTO[], TError = unknown>(videoId: string, options?: UseQueryOptions<Types.CommentDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCommentsAllQuery<TSelectData = Types.CommentDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CommentDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let videoId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ videoId,  } = params[0] as CommentsAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [videoId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.CommentDTO[], TError, TSelectData>({
    queryFn: __commentsAll,
    queryKey: commentsAllQueryKey(videoId),
    ...commentsAllDefaultOptions as unknown as UseQueryOptions<Types.CommentDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setCommentsAllData(queryClient: QueryClient, updater: (data: Types.CommentDTO[] | undefined) => Types.CommentDTO[], videoId: string) {
  queryClient.setQueryData(commentsAllQueryKey(videoId),
    updater
  );
}

/**
 * @return Success
 */
export function setCommentsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CommentDTO[] | undefined) => Types.CommentDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function commentsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Comments/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function commentsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'commentsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useCommentsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.CommentPutDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.CommentPutDTO, TContext> {
  const key = commentsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: Types.CommentPutDTO) => Client.commentsPUT(id, body), {...options, mutationKey: key});
}
  
type CommentsPUT__MutationParameters = CommentsPUTQueryParameters & {
  body: Types.CommentPutDTO;
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useCommentsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, CommentsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CommentsPUTQueryParameters}): UseMutationResult<void, unknown, CommentsPUT__MutationParameters, TContext> {
  const key = commentsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: CommentsPUT__MutationParameters) => Client.commentsPUT(data.id ?? options?.parameters?.id!, data.body), {...options, mutationKey: key});
}
  
export function commentsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Comments/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function commentsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'commentsDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useCommentsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = commentsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation(() => Client.commentsDELETE(id), {...options, mutationKey: key});
}
  
type CommentsDELETE__MutationParameters = CommentsDELETEQueryParameters

/**
 * @return Success
 */
export function useCommentsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, CommentsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: CommentsDELETEQueryParameters}): UseMutationResult<void, unknown, CommentsDELETE__MutationParameters, TContext> {
  const key = commentsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: CommentsDELETE__MutationParameters) => Client.commentsDELETE(data.id ?? options?.parameters?.id!), {...options, mutationKey: key});
}
  
export function commentsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Comments";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function commentsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'commentsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useCommentsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.CommentPostDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.CommentPostDTO, TContext> {
  const key = commentsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: Types.CommentPostDTO) => Client.commentsPOST(body), {...options, mutationKey: key});
}
  
export function myPlaylistsUrl(): string {
  let url_ = getBaseUrl() + "/api/Playlists/my-playlists";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let myPlaylistsDefaultOptions: UseQueryOptions<Types.PlaylistDTO[], unknown, Types.PlaylistDTO[]> = {
  queryFn: __myPlaylists,
};
export function getMyPlaylistsDefaultOptions(): UseQueryOptions<Types.PlaylistDTO[], unknown, Types.PlaylistDTO[]> {
  return myPlaylistsDefaultOptions;
};
export function setMyPlaylistsDefaultOptions(options: UseQueryOptions<Types.PlaylistDTO[], unknown, Types.PlaylistDTO[]>) {
  myPlaylistsDefaultOptions = options;
}

export function myPlaylistsQueryKey(): QueryKey;
export function myPlaylistsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'myPlaylists',
    ]);
}
function __myPlaylists() {
  return Client.myPlaylists(
    );
}

/**
 * @return Success
 */
export function useMyPlaylistsQuery<TSelectData = Types.PlaylistDTO[], TError = unknown>(options?: UseQueryOptions<Types.PlaylistDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMyPlaylistsQuery<TSelectData = Types.PlaylistDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PlaylistDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.PlaylistDTO[], TError, TSelectData>({
    queryFn: __myPlaylists,
    queryKey: myPlaylistsQueryKey(),
    ...myPlaylistsDefaultOptions as unknown as UseQueryOptions<Types.PlaylistDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setMyPlaylistsData(queryClient: QueryClient, updater: (data: Types.PlaylistDTO[] | undefined) => Types.PlaylistDTO[], ) {
  queryClient.setQueryData(myPlaylistsQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setMyPlaylistsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PlaylistDTO[] | undefined) => Types.PlaylistDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function playlistPermissionsUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Playlists/{id}/playlist-permissions";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let playlistPermissionsDefaultOptions: UseQueryOptions<Types.ObjectPermissions, unknown, Types.ObjectPermissions> = {
  queryFn: __playlistPermissions,
};
export function getPlaylistPermissionsDefaultOptions(): UseQueryOptions<Types.ObjectPermissions, unknown, Types.ObjectPermissions> {
  return playlistPermissionsDefaultOptions;
};
export function setPlaylistPermissionsDefaultOptions(options: UseQueryOptions<Types.ObjectPermissions, unknown, Types.ObjectPermissions>) {
  playlistPermissionsDefaultOptions = options;
}

export function playlistPermissionsQueryKey(id: string): QueryKey;
export function playlistPermissionsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as PlaylistPermissionsQueryParameters;

    return trimArrayEnd([
        'Client',
        'playlistPermissions',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'playlistPermissions',
        ...params
      ]);
  }
}
function __playlistPermissions(context: QueryFunctionContext) {
  return Client.playlistPermissions(
      context.queryKey[2] as string    );
}

export function usePlaylistPermissionsQuery<TSelectData = Types.ObjectPermissions, TError = unknown>(dto: PlaylistPermissionsQueryParameters, options?: UseQueryOptions<Types.ObjectPermissions, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function usePlaylistPermissionsQuery<TSelectData = Types.ObjectPermissions, TError = unknown>(id: string, options?: UseQueryOptions<Types.ObjectPermissions, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePlaylistPermissionsQuery<TSelectData = Types.ObjectPermissions, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ObjectPermissions, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as PlaylistPermissionsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.ObjectPermissions, TError, TSelectData>({
    queryFn: __playlistPermissions,
    queryKey: playlistPermissionsQueryKey(id),
    ...playlistPermissionsDefaultOptions as unknown as UseQueryOptions<Types.ObjectPermissions, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setPlaylistPermissionsData(queryClient: QueryClient, updater: (data: Types.ObjectPermissions | undefined) => Types.ObjectPermissions, id: string) {
  queryClient.setQueryData(playlistPermissionsQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setPlaylistPermissionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ObjectPermissions | undefined) => Types.ObjectPermissions) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function playlistsAllUrl(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/Playlists?";
if (orderBy === null)
    throw new Error("The parameter 'orderBy' cannot be null.");
else if (orderBy !== undefined)
    url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
else if (limit !== undefined)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (offset === null)
    throw new Error("The parameter 'offset' cannot be null.");
else if (offset !== undefined)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let playlistsAllDefaultOptions: UseQueryOptions<Types.PlaylistBasicInfoDTO[], unknown, Types.PlaylistBasicInfoDTO[]> = {
  queryFn: __playlistsAll,
};
export function getPlaylistsAllDefaultOptions(): UseQueryOptions<Types.PlaylistBasicInfoDTO[], unknown, Types.PlaylistBasicInfoDTO[]> {
  return playlistsAllDefaultOptions;
};
export function setPlaylistsAllDefaultOptions(options: UseQueryOptions<Types.PlaylistBasicInfoDTO[], unknown, Types.PlaylistBasicInfoDTO[]>) {
  playlistsAllDefaultOptions = options;
}

export function playlistsAllQueryKey(dto: PlaylistsAllQueryParameters): QueryKey;
export function playlistsAllQueryKey(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined): QueryKey;
export function playlistsAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { orderBy, limit, offset,  } = params[0] as PlaylistsAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'playlistsAll',
        orderBy as any,
        limit as any,
        offset as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'playlistsAll',
        ...params
      ]);
  }
}
function __playlistsAll(context: QueryFunctionContext) {
  return Client.playlistsAll(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined    );
}

export function usePlaylistsAllQuery<TSelectData = Types.PlaylistBasicInfoDTO[], TError = unknown>(dto: PlaylistsAllQueryParameters, options?: UseQueryOptions<Types.PlaylistBasicInfoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function usePlaylistsAllQuery<TSelectData = Types.PlaylistBasicInfoDTO[], TError = unknown>(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined, options?: UseQueryOptions<Types.PlaylistBasicInfoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePlaylistsAllQuery<TSelectData = Types.PlaylistBasicInfoDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PlaylistBasicInfoDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let orderBy: any = undefined;
  let limit: any = undefined;
  let offset: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ orderBy, limit, offset,  } = params[0] as PlaylistsAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [orderBy, limit, offset, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.PlaylistBasicInfoDTO[], TError, TSelectData>({
    queryFn: __playlistsAll,
    queryKey: playlistsAllQueryKey(orderBy, limit, offset),
    ...playlistsAllDefaultOptions as unknown as UseQueryOptions<Types.PlaylistBasicInfoDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function setPlaylistsAllData(queryClient: QueryClient, updater: (data: Types.PlaylistBasicInfoDTO[] | undefined) => Types.PlaylistBasicInfoDTO[], orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined) {
  queryClient.setQueryData(playlistsAllQueryKey(orderBy, limit, offset),
    updater
  );
}

/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function setPlaylistsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PlaylistBasicInfoDTO[] | undefined) => Types.PlaylistBasicInfoDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function playlistsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Playlists";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function playlistsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'playlistsPOST',
    ]);
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param thumbnail (optional) 
 * @param videos (optional) 
 * @param isPublic (optional) 
 * @param permissions_UserIds (optional) 
 * @param permissions_GroupIds (optional) 
 * @return Success
 */
export function usePlaylistsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, PlaylistsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, PlaylistsPOSTMutationParameters, TContext> {
  const key = playlistsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((playlistsPOSTMutationParameters: PlaylistsPOSTMutationParameters) => Client.playlistsPOST(playlistsPOSTMutationParameters.name, playlistsPOSTMutationParameters.description, playlistsPOSTMutationParameters.thumbnail, playlistsPOSTMutationParameters.videos, playlistsPOSTMutationParameters.isPublic, playlistsPOSTMutationParameters.permissions_UserIds, playlistsPOSTMutationParameters.permissions_GroupIds), {...options, mutationKey: key});
}
  
export function playlistsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Playlists/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let playlistsGETDefaultOptions: UseQueryOptions<Types.PlaylistDTO, unknown, Types.PlaylistDTO> = {
  queryFn: __playlistsGET,
};
export function getPlaylistsGETDefaultOptions(): UseQueryOptions<Types.PlaylistDTO, unknown, Types.PlaylistDTO> {
  return playlistsGETDefaultOptions;
};
export function setPlaylistsGETDefaultOptions(options: UseQueryOptions<Types.PlaylistDTO, unknown, Types.PlaylistDTO>) {
  playlistsGETDefaultOptions = options;
}

export function playlistsGETQueryKey(id: string): QueryKey;
export function playlistsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as PlaylistsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'playlistsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'playlistsGET',
        ...params
      ]);
  }
}
function __playlistsGET(context: QueryFunctionContext) {
  return Client.playlistsGET(
      context.queryKey[2] as string    );
}

export function usePlaylistsGETQuery<TSelectData = Types.PlaylistDTO, TError = unknown>(dto: PlaylistsGETQueryParameters, options?: UseQueryOptions<Types.PlaylistDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function usePlaylistsGETQuery<TSelectData = Types.PlaylistDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.PlaylistDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function usePlaylistsGETQuery<TSelectData = Types.PlaylistDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PlaylistDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as PlaylistsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.PlaylistDTO, TError, TSelectData>({
    queryFn: __playlistsGET,
    queryKey: playlistsGETQueryKey(id),
    ...playlistsGETDefaultOptions as unknown as UseQueryOptions<Types.PlaylistDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setPlaylistsGETData(queryClient: QueryClient, updater: (data: Types.PlaylistDTO | undefined) => Types.PlaylistDTO, id: string) {
  queryClient.setQueryData(playlistsGETQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setPlaylistsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PlaylistDTO | undefined) => Types.PlaylistDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function playlistsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Playlists/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function playlistsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'playlistsPUT',
      id as any,
    ]);
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param thumbnail (optional) 
 * @param videos (optional) 
 * @param isPublic (optional) 
 * @param permissions_UserIds (optional) 
 * @param permissions_GroupIds (optional) 
 * @return Success
 */
export function usePlaylistsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, PlaylistsPUTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, PlaylistsPUTMutationParameters, TContext> {
  const key = playlistsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((playlistsPUTMutationParameters: PlaylistsPUTMutationParameters) => Client.playlistsPUT(id, playlistsPUTMutationParameters.name, playlistsPUTMutationParameters.description, playlistsPUTMutationParameters.thumbnail, playlistsPUTMutationParameters.videos, playlistsPUTMutationParameters.isPublic, playlistsPUTMutationParameters.permissions_UserIds, playlistsPUTMutationParameters.permissions_GroupIds), {...options, mutationKey: key});
}
  
type PlaylistsPUT__MutationParameters = PlaylistsPUTQueryParameters & {
  playlistsPUTMutationParameters: PlaylistsPUTMutationParameters;
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param thumbnail (optional) 
 * @param videos (optional) 
 * @param isPublic (optional) 
 * @param permissions_UserIds (optional) 
 * @param permissions_GroupIds (optional) 
 * @return Success
 */
export function usePlaylistsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, PlaylistsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: PlaylistsPUTQueryParameters}): UseMutationResult<void, unknown, PlaylistsPUT__MutationParameters, TContext> {
  const key = playlistsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((data: PlaylistsPUT__MutationParameters) => Client.playlistsPUT(data.id, data.name, data.description, data.thumbnail, data.videos, data.isPublic, data.permissions_UserIds, data.permissions_GroupIds), {...options, mutationKey: key});
}
  
export function playlistsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Playlists/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function playlistsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'playlistsDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function usePlaylistsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = playlistsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation(() => Client.playlistsDELETE(id), {...options, mutationKey: key});
}
  
type PlaylistsDELETE__MutationParameters = PlaylistsDELETEQueryParameters

/**
 * @return Success
 */
export function usePlaylistsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, PlaylistsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: PlaylistsDELETEQueryParameters}): UseMutationResult<void, unknown, PlaylistsDELETE__MutationParameters, TContext> {
  const key = playlistsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: PlaylistsDELETE__MutationParameters) => Client.playlistsDELETE(data.id ?? options?.parameters?.id!), {...options, mutationKey: key});
}
  
export function addRemoveWatchLaterUrl(id?: string | undefined): string {
  let url_ = getBaseUrl() + "/api/Playlists/add-remove-watch-later?";
if (id === null)
    throw new Error("The parameter 'id' cannot be null.");
else if (id !== undefined)
    url_ += "id=" + encodeURIComponent("" + id) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function addRemoveWatchLaterMutationKey(id?: string | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'addRemoveWatchLater',
      id as any,
    ]);
}

/**
 * Přidá nebo odebere video z playlistu 'Přehrát později'. V případě zdařilé operace vrací v odpovědi příznak, zdali se video do playlistu přidávalo(true), nebo odebíralo(false).
 * @param id (optional) 
 * @return Success
 */
export function useAddRemoveWatchLaterMutation<TContext>(id?: string | undefined, options?: Omit<UseMutationOptions<boolean, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<boolean, unknown, void, TContext> {
  const key = addRemoveWatchLaterMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation(() => Client.addRemoveWatchLater(id), {...options, mutationKey: key});
}
  
type AddRemoveWatchLater__MutationParameters = AddRemoveWatchLaterQueryParameters

/**
 * Přidá nebo odebere video z playlistu 'Přehrát později'. V případě zdařilé operace vrací v odpovědi příznak, zdali se video do playlistu přidávalo(true), nebo odebíralo(false).
 * @param id (optional) 
 * @return Success
 */
export function useAddRemoveWatchLaterMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<boolean, unknown, AddRemoveWatchLater__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AddRemoveWatchLaterQueryParameters}): UseMutationResult<boolean, unknown, AddRemoveWatchLater__MutationParameters, TContext> {
  const key = addRemoveWatchLaterMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: AddRemoveWatchLater__MutationParameters) => Client.addRemoveWatchLater(data.id ?? options?.parameters?.id!), {...options, mutationKey: key});
}
  
export function searchUrl(q?: string | undefined, limit?: number | undefined, offset?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/Search?";
if (q === null)
    throw new Error("The parameter 'q' cannot be null.");
else if (q !== undefined)
    url_ += "q=" + encodeURIComponent("" + q) + "&";
if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
else if (limit !== undefined)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (offset === null)
    throw new Error("The parameter 'offset' cannot be null.");
else if (offset !== undefined)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function searchMutationKey(q?: string | undefined, limit?: number | undefined, offset?: number | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'search',
      q as any,
      limit as any,
      offset as any,
    ]);
}

/**
 * @param q (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function useSearchMutation<TContext>(q?: string | undefined, limit?: number | undefined, offset?: number | undefined, options?: Omit<UseMutationOptions<Types.WithTotalCountOfVideoDTO, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.WithTotalCountOfVideoDTO, unknown, void, TContext> {
  const key = searchMutationKey(q, limit, offset);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation(() => Client.search(q, limit, offset), {...options, mutationKey: key});
}
  
type Search__MutationParameters = SearchQueryParameters

/**
 * @param q (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function useSearchMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.WithTotalCountOfVideoDTO, unknown, Search__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: SearchQueryParameters}): UseMutationResult<Types.WithTotalCountOfVideoDTO, unknown, Search__MutationParameters, TContext> {
  const key = searchMutationKey(options?.parameters?.q!, options?.parameters?.limit!, options?.parameters?.offset!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: Search__MutationParameters) => Client.search(data.q ?? options?.parameters?.q!, data.limit ?? options?.parameters?.limit!, data.offset ?? options?.parameters?.offset!), {...options, mutationKey: key});
}
  
export function tagsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/Tags";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let tagsAllDefaultOptions: UseQueryOptions<Types.TagDTO[], unknown, Types.TagDTO[]> = {
  queryFn: __tagsAll,
};
export function getTagsAllDefaultOptions(): UseQueryOptions<Types.TagDTO[], unknown, Types.TagDTO[]> {
  return tagsAllDefaultOptions;
};
export function setTagsAllDefaultOptions(options: UseQueryOptions<Types.TagDTO[], unknown, Types.TagDTO[]>) {
  tagsAllDefaultOptions = options;
}

export function tagsAllQueryKey(): QueryKey;
export function tagsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'tagsAll',
    ]);
}
function __tagsAll() {
  return Client.tagsAll(
    );
}

/**
 * @return Success
 */
export function useTagsAllQuery<TSelectData = Types.TagDTO[], TError = unknown>(options?: UseQueryOptions<Types.TagDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTagsAllQuery<TSelectData = Types.TagDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.TagDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.TagDTO[], TError, TSelectData>({
    queryFn: __tagsAll,
    queryKey: tagsAllQueryKey(),
    ...tagsAllDefaultOptions as unknown as UseQueryOptions<Types.TagDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setTagsAllData(queryClient: QueryClient, updater: (data: Types.TagDTO[] | undefined) => Types.TagDTO[], ) {
  queryClient.setQueryData(tagsAllQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setTagsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.TagDTO[] | undefined) => Types.TagDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function tagsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Tags";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function tagsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'tagsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useTagsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, string, TContext> {
  const key = tagsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: string) => Client.tagsPOST(body), {...options, mutationKey: key});
}
  
export function tagsWithVideosUrl(): string {
  let url_ = getBaseUrl() + "/api/Tags/tagsWithVideos";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let tagsWithVideosDefaultOptions: UseQueryOptions<Types.Tag[], unknown, Types.Tag[]> = {
  queryFn: __tagsWithVideos,
};
export function getTagsWithVideosDefaultOptions(): UseQueryOptions<Types.Tag[], unknown, Types.Tag[]> {
  return tagsWithVideosDefaultOptions;
};
export function setTagsWithVideosDefaultOptions(options: UseQueryOptions<Types.Tag[], unknown, Types.Tag[]>) {
  tagsWithVideosDefaultOptions = options;
}

export function tagsWithVideosQueryKey(): QueryKey;
export function tagsWithVideosQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'tagsWithVideos',
    ]);
}
function __tagsWithVideos() {
  return Client.tagsWithVideos(
    );
}

/**
 * @return Success
 */
export function useTagsWithVideosQuery<TSelectData = Types.Tag[], TError = unknown>(options?: UseQueryOptions<Types.Tag[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTagsWithVideosQuery<TSelectData = Types.Tag[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Tag[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.Tag[], TError, TSelectData>({
    queryFn: __tagsWithVideos,
    queryKey: tagsWithVideosQueryKey(),
    ...tagsWithVideosDefaultOptions as unknown as UseQueryOptions<Types.Tag[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setTagsWithVideosData(queryClient: QueryClient, updater: (data: Types.Tag[] | undefined) => Types.Tag[], ) {
  queryClient.setQueryData(tagsWithVideosQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setTagsWithVideosDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Tag[] | undefined) => Types.Tag[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function tagsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Tags/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function tagsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'tagsDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useTagsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = tagsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation(() => Client.tagsDELETE(id), {...options, mutationKey: key});
}
  
type TagsDELETE__MutationParameters = TagsDELETEQueryParameters

/**
 * @return Success
 */
export function useTagsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, TagsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: TagsDELETEQueryParameters}): UseMutationResult<void, unknown, TagsDELETE__MutationParameters, TContext> {
  const key = tagsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: TagsDELETE__MutationParameters) => Client.tagsDELETE(data.id ?? options?.parameters?.id!), {...options, mutationKey: key});
}
  
export function userGroupsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/UserGroups";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let userGroupsAllDefaultOptions: UseQueryOptions<Types.UserGroupDTO[], unknown, Types.UserGroupDTO[]> = {
  queryFn: __userGroupsAll,
};
export function getUserGroupsAllDefaultOptions(): UseQueryOptions<Types.UserGroupDTO[], unknown, Types.UserGroupDTO[]> {
  return userGroupsAllDefaultOptions;
};
export function setUserGroupsAllDefaultOptions(options: UseQueryOptions<Types.UserGroupDTO[], unknown, Types.UserGroupDTO[]>) {
  userGroupsAllDefaultOptions = options;
}

export function userGroupsAllQueryKey(): QueryKey;
export function userGroupsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'userGroupsAll',
    ]);
}
function __userGroupsAll() {
  return Client.userGroupsAll(
    );
}

/**
 * @return Success
 */
export function useUserGroupsAllQuery<TSelectData = Types.UserGroupDTO[], TError = unknown>(options?: UseQueryOptions<Types.UserGroupDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUserGroupsAllQuery<TSelectData = Types.UserGroupDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserGroupDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserGroupDTO[], TError, TSelectData>({
    queryFn: __userGroupsAll,
    queryKey: userGroupsAllQueryKey(),
    ...userGroupsAllDefaultOptions as unknown as UseQueryOptions<Types.UserGroupDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setUserGroupsAllData(queryClient: QueryClient, updater: (data: Types.UserGroupDTO[] | undefined) => Types.UserGroupDTO[], ) {
  queryClient.setQueryData(userGroupsAllQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setUserGroupsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserGroupDTO[] | undefined) => Types.UserGroupDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function userGroupsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/UserGroups";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function userGroupsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'userGroupsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUserGroupsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.UserGroup, unknown, Types.UserGroupPostPutDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.UserGroup, unknown, Types.UserGroupPostPutDTO, TContext> {
  const key = userGroupsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: Types.UserGroupPostPutDTO) => Client.userGroupsPOST(body), {...options, mutationKey: key});
}
  
export function myUsergroupsUrl(): string {
  let url_ = getBaseUrl() + "/api/UserGroups/my-usergroups";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let myUsergroupsDefaultOptions: UseQueryOptions<Types.UserGroupDTO[], unknown, Types.UserGroupDTO[]> = {
  queryFn: __myUsergroups,
};
export function getMyUsergroupsDefaultOptions(): UseQueryOptions<Types.UserGroupDTO[], unknown, Types.UserGroupDTO[]> {
  return myUsergroupsDefaultOptions;
};
export function setMyUsergroupsDefaultOptions(options: UseQueryOptions<Types.UserGroupDTO[], unknown, Types.UserGroupDTO[]>) {
  myUsergroupsDefaultOptions = options;
}

export function myUsergroupsQueryKey(): QueryKey;
export function myUsergroupsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'myUsergroups',
    ]);
}
function __myUsergroups() {
  return Client.myUsergroups(
    );
}

/**
 * @return Success
 */
export function useMyUsergroupsQuery<TSelectData = Types.UserGroupDTO[], TError = unknown>(options?: UseQueryOptions<Types.UserGroupDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMyUsergroupsQuery<TSelectData = Types.UserGroupDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserGroupDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserGroupDTO[], TError, TSelectData>({
    queryFn: __myUsergroups,
    queryKey: myUsergroupsQueryKey(),
    ...myUsergroupsDefaultOptions as unknown as UseQueryOptions<Types.UserGroupDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setMyUsergroupsData(queryClient: QueryClient, updater: (data: Types.UserGroupDTO[] | undefined) => Types.UserGroupDTO[], ) {
  queryClient.setQueryData(myUsergroupsQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setMyUsergroupsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserGroupDTO[] | undefined) => Types.UserGroupDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function userGroupsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/UserGroups/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let userGroupsGETDefaultOptions: UseQueryOptions<Types.UserGroupDTO, unknown, Types.UserGroupDTO> = {
  queryFn: __userGroupsGET,
};
export function getUserGroupsGETDefaultOptions(): UseQueryOptions<Types.UserGroupDTO, unknown, Types.UserGroupDTO> {
  return userGroupsGETDefaultOptions;
};
export function setUserGroupsGETDefaultOptions(options: UseQueryOptions<Types.UserGroupDTO, unknown, Types.UserGroupDTO>) {
  userGroupsGETDefaultOptions = options;
}

export function userGroupsGETQueryKey(id: string): QueryKey;
export function userGroupsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as UserGroupsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'userGroupsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'userGroupsGET',
        ...params
      ]);
  }
}
function __userGroupsGET(context: QueryFunctionContext) {
  return Client.userGroupsGET(
      context.queryKey[2] as string    );
}

export function useUserGroupsGETQuery<TSelectData = Types.UserGroupDTO, TError = unknown>(dto: UserGroupsGETQueryParameters, options?: UseQueryOptions<Types.UserGroupDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useUserGroupsGETQuery<TSelectData = Types.UserGroupDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.UserGroupDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUserGroupsGETQuery<TSelectData = Types.UserGroupDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserGroupDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as UserGroupsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserGroupDTO, TError, TSelectData>({
    queryFn: __userGroupsGET,
    queryKey: userGroupsGETQueryKey(id),
    ...userGroupsGETDefaultOptions as unknown as UseQueryOptions<Types.UserGroupDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setUserGroupsGETData(queryClient: QueryClient, updater: (data: Types.UserGroupDTO | undefined) => Types.UserGroupDTO, id: string) {
  queryClient.setQueryData(userGroupsGETQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setUserGroupsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserGroupDTO | undefined) => Types.UserGroupDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function userGroupsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/UserGroups/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function userGroupsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'userGroupsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUserGroupsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.UserGroupPostPutDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.UserGroupPostPutDTO, TContext> {
  const key = userGroupsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: Types.UserGroupPostPutDTO) => Client.userGroupsPUT(id, body), {...options, mutationKey: key});
}
  
type UserGroupsPUT__MutationParameters = UserGroupsPUTQueryParameters & {
  body: Types.UserGroupPostPutDTO;
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUserGroupsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UserGroupsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UserGroupsPUTQueryParameters}): UseMutationResult<void, unknown, UserGroupsPUT__MutationParameters, TContext> {
  const key = userGroupsPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: UserGroupsPUT__MutationParameters) => Client.userGroupsPUT(data.id ?? options?.parameters?.id!, data.body), {...options, mutationKey: key});
}
  
export function userGroupsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/UserGroups/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function userGroupsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'userGroupsDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useUserGroupsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = userGroupsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation(() => Client.userGroupsDELETE(id), {...options, mutationKey: key});
}
  
type UserGroupsDELETE__MutationParameters = UserGroupsDELETEQueryParameters

/**
 * @return Success
 */
export function useUserGroupsDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UserGroupsDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UserGroupsDELETEQueryParameters}): UseMutationResult<void, unknown, UserGroupsDELETE__MutationParameters, TContext> {
  const key = userGroupsDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: UserGroupsDELETE__MutationParameters) => Client.userGroupsDELETE(data.id ?? options?.parameters?.id!), {...options, mutationKey: key});
}
  
export function loginUrl(): string {
  let url_ = getBaseUrl() + "/api/users/login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function loginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'login',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useLoginMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, Types.LoginDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, Types.LoginDTO, TContext> {
  const key = loginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: Types.LoginDTO) => Client.login(body), {...options, mutationKey: key});
}
  
export function registerUrl(): string {
  let url_ = getBaseUrl() + "/api/users/register";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function registerMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'register',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useRegisterMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, Types.RegisterDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, Types.RegisterDTO, TContext> {
  const key = registerMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: Types.RegisterDTO) => Client.register(body), {...options, mutationKey: key});
}
  
export function meUrl(): string {
  let url_ = getBaseUrl() + "/api/users/me";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let meDefaultOptions: UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO> = {
  queryFn: __me,
};
export function getMeDefaultOptions(): UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO> {
  return meDefaultOptions;
};
export function setMeDefaultOptions(options: UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO>) {
  meDefaultOptions = options;
}

export function meQueryKey(): QueryKey;
export function meQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'me',
    ]);
}
function __me() {
  return Client.me(
    );
}

/**
 * @return Success
 */
export function useMeQuery<TSelectData = Types.UserDTO, TError = unknown>(options?: UseQueryOptions<Types.UserDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMeQuery<TSelectData = Types.UserDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserDTO, TError, TSelectData>({
    queryFn: __me,
    queryKey: meQueryKey(),
    ...meDefaultOptions as unknown as UseQueryOptions<Types.UserDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setMeData(queryClient: QueryClient, updater: (data: Types.UserDTO | undefined) => Types.UserDTO, ) {
  queryClient.setQueryData(meQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setMeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserDTO | undefined) => Types.UserDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function usersAllUrl(): string {
  let url_ = getBaseUrl() + "/api/users";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersAllDefaultOptions: UseQueryOptions<Types.UserDTO[], unknown, Types.UserDTO[]> = {
  queryFn: __usersAll,
};
export function getUsersAllDefaultOptions(): UseQueryOptions<Types.UserDTO[], unknown, Types.UserDTO[]> {
  return usersAllDefaultOptions;
};
export function setUsersAllDefaultOptions(options: UseQueryOptions<Types.UserDTO[], unknown, Types.UserDTO[]>) {
  usersAllDefaultOptions = options;
}

export function usersAllQueryKey(): QueryKey;
export function usersAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'usersAll',
    ]);
}
function __usersAll() {
  return Client.usersAll(
    );
}

/**
 * @return Success
 */
export function useUsersAllQuery<TSelectData = Types.UserDTO[], TError = unknown>(options?: UseQueryOptions<Types.UserDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersAllQuery<TSelectData = Types.UserDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserDTO[], TError, TSelectData>({
    queryFn: __usersAll,
    queryKey: usersAllQueryKey(),
    ...usersAllDefaultOptions as unknown as UseQueryOptions<Types.UserDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setUsersAllData(queryClient: QueryClient, updater: (data: Types.UserDTO[] | undefined) => Types.UserDTO[], ) {
  queryClient.setQueryData(usersAllQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setUsersAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserDTO[] | undefined) => Types.UserDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function usersPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function usersPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'usersPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUsersPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.UserDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.UserDTO, TContext> {
  const key = usersPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: Types.UserDTO) => Client.usersPUT(id, body), {...options, mutationKey: key});
}
  
type UsersPUT__MutationParameters = UsersPUTQueryParameters & {
  body: Types.UserDTO;
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUsersPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UsersPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UsersPUTQueryParameters}): UseMutationResult<void, unknown, UsersPUT__MutationParameters, TContext> {
  const key = usersPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: UsersPUT__MutationParameters) => Client.usersPUT(data.id ?? options?.parameters?.id!, data.body), {...options, mutationKey: key});
}
  
export function usersDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function usersDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'usersDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useUsersDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = usersDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation(() => Client.usersDELETE(id), {...options, mutationKey: key});
}
  
type UsersDELETE__MutationParameters = UsersDELETEQueryParameters

/**
 * @return Success
 */
export function useUsersDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UsersDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UsersDELETEQueryParameters}): UseMutationResult<void, unknown, UsersDELETE__MutationParameters, TContext> {
  const key = usersDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: UsersDELETE__MutationParameters) => Client.usersDELETE(data.id ?? options?.parameters?.id!), {...options, mutationKey: key});
}
  
export function usersGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/users/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersGETDefaultOptions: UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO> = {
  queryFn: __usersGET,
};
export function getUsersGETDefaultOptions(): UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO> {
  return usersGETDefaultOptions;
};
export function setUsersGETDefaultOptions(options: UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO>) {
  usersGETDefaultOptions = options;
}

export function usersGETQueryKey(id: string): QueryKey;
export function usersGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as UsersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'usersGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'usersGET',
        ...params
      ]);
  }
}
function __usersGET(context: QueryFunctionContext) {
  return Client.usersGET(
      context.queryKey[2] as string    );
}

export function useUsersGETQuery<TSelectData = Types.UserDTO, TError = unknown>(dto: UsersGETQueryParameters, options?: UseQueryOptions<Types.UserDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useUsersGETQuery<TSelectData = Types.UserDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.UserDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersGETQuery<TSelectData = Types.UserDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as UsersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserDTO, TError, TSelectData>({
    queryFn: __usersGET,
    queryKey: usersGETQueryKey(id),
    ...usersGETDefaultOptions as unknown as UseQueryOptions<Types.UserDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setUsersGETData(queryClient: QueryClient, updater: (data: Types.UserDTO | undefined) => Types.UserDTO, id: string) {
  queryClient.setQueryData(usersGETQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setUsersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserDTO | undefined) => Types.UserDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function userVideoStatsGETUrl(videoId: string): string {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";
if (videoId === undefined || videoId === null)
  throw new Error("The parameter 'videoId' must be defined.");
url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let userVideoStatsGETDefaultOptions: UseQueryOptions<Types.UserVideoStats, unknown, Types.UserVideoStats> = {
  queryFn: __userVideoStatsGET,
};
export function getUserVideoStatsGETDefaultOptions(): UseQueryOptions<Types.UserVideoStats, unknown, Types.UserVideoStats> {
  return userVideoStatsGETDefaultOptions;
};
export function setUserVideoStatsGETDefaultOptions(options: UseQueryOptions<Types.UserVideoStats, unknown, Types.UserVideoStats>) {
  userVideoStatsGETDefaultOptions = options;
}

export function userVideoStatsGETQueryKey(videoId: string): QueryKey;
export function userVideoStatsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { videoId,  } = params[0] as UserVideoStatsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'userVideoStatsGET',
        videoId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'userVideoStatsGET',
        ...params
      ]);
  }
}
function __userVideoStatsGET(context: QueryFunctionContext) {
  return Client.userVideoStatsGET(
      context.queryKey[2] as string    );
}

export function useUserVideoStatsGETQuery<TSelectData = Types.UserVideoStats, TError = unknown>(dto: UserVideoStatsGETQueryParameters, options?: UseQueryOptions<Types.UserVideoStats, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useUserVideoStatsGETQuery<TSelectData = Types.UserVideoStats, TError = unknown>(videoId: string, options?: UseQueryOptions<Types.UserVideoStats, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUserVideoStatsGETQuery<TSelectData = Types.UserVideoStats, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserVideoStats, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let videoId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ videoId,  } = params[0] as UserVideoStatsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [videoId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserVideoStats, TError, TSelectData>({
    queryFn: __userVideoStatsGET,
    queryKey: userVideoStatsGETQueryKey(videoId),
    ...userVideoStatsGETDefaultOptions as unknown as UseQueryOptions<Types.UserVideoStats, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setUserVideoStatsGETData(queryClient: QueryClient, updater: (data: Types.UserVideoStats | undefined) => Types.UserVideoStats, videoId: string) {
  queryClient.setQueryData(userVideoStatsGETQueryKey(videoId),
    updater
  );
}

/**
 * @return Success
 */
export function setUserVideoStatsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserVideoStats | undefined) => Types.UserVideoStats) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function userVideoStatsPUTUrl(videoId: string): string {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";
if (videoId === undefined || videoId === null)
  throw new Error("The parameter 'videoId' must be defined.");
url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function userVideoStatsPUTMutationKey(videoId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'userVideoStatsPUT',
      videoId as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUserVideoStatsPUTMutation<TContext>(videoId: string, options?: Omit<UseMutationOptions<void, unknown, Types.UserVideoStats, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.UserVideoStats, TContext> {
  const key = userVideoStatsPUTMutationKey(videoId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: Types.UserVideoStats) => Client.userVideoStatsPUT(videoId, body), {...options, mutationKey: key});
}
  
type UserVideoStatsPUT__MutationParameters = UserVideoStatsPUTQueryParameters & {
  body: Types.UserVideoStats;
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUserVideoStatsPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UserVideoStatsPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UserVideoStatsPUTQueryParameters}): UseMutationResult<void, unknown, UserVideoStatsPUT__MutationParameters, TContext> {
  const key = userVideoStatsPUTMutationKey(options?.parameters?.videoId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: UserVideoStatsPUT__MutationParameters) => Client.userVideoStatsPUT(data.videoId ?? options?.parameters?.videoId!, data.body), {...options, mutationKey: key});
}
  
export function watchedUrl(videoId: string): string {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}/watched";
if (videoId === undefined || videoId === null)
  throw new Error("The parameter 'videoId' must be defined.");
url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function watchedMutationKey(videoId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'watched',
      videoId as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useWatchedMutation<TContext>(videoId: string, options?: Omit<UseMutationOptions<void, unknown, number, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, number, TContext> {
  const key = watchedMutationKey(videoId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((body: number) => Client.watched(videoId, body), {...options, mutationKey: key});
}
  
type Watched__MutationParameters = WatchedQueryParameters & {
  body: number;
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useWatchedMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, Watched__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: WatchedQueryParameters}): UseMutationResult<void, unknown, Watched__MutationParameters, TContext> {
  const key = watchedMutationKey(options?.parameters?.videoId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: Watched__MutationParameters) => Client.watched(data.videoId ?? options?.parameters?.videoId!, data.body), {...options, mutationKey: key});
}
  
export function videosAllUrl(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/Videos?";
if (orderBy === null)
    throw new Error("The parameter 'orderBy' cannot be null.");
else if (orderBy !== undefined)
    url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
else if (limit !== undefined)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (offset === null)
    throw new Error("The parameter 'offset' cannot be null.");
else if (offset !== undefined)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let videosAllDefaultOptions: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> = {
  queryFn: __videosAll,
};
export function getVideosAllDefaultOptions(): UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> {
  return videosAllDefaultOptions;
};
export function setVideosAllDefaultOptions(options: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]>) {
  videosAllDefaultOptions = options;
}

export function videosAllQueryKey(dto: VideosAllQueryParameters): QueryKey;
export function videosAllQueryKey(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined): QueryKey;
export function videosAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { orderBy, limit, offset,  } = params[0] as VideosAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'videosAll',
        orderBy as any,
        limit as any,
        offset as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'videosAll',
        ...params
      ]);
  }
}
function __videosAll(context: QueryFunctionContext) {
  return Client.videosAll(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined    );
}

export function useVideosAllQuery<TSelectData = Types.VideoDTO[], TError = unknown>(dto: VideosAllQueryParameters, options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function useVideosAllQuery<TSelectData = Types.VideoDTO[], TError = unknown>(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined, options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVideosAllQuery<TSelectData = Types.VideoDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VideoDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let orderBy: any = undefined;
  let limit: any = undefined;
  let offset: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ orderBy, limit, offset,  } = params[0] as VideosAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [orderBy, limit, offset, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.VideoDTO[], TError, TSelectData>({
    queryFn: __videosAll,
    queryKey: videosAllQueryKey(orderBy, limit, offset),
    ...videosAllDefaultOptions as unknown as UseQueryOptions<Types.VideoDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function setVideosAllData(queryClient: QueryClient, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[], orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined) {
  queryClient.setQueryData(videosAllQueryKey(orderBy, limit, offset),
    updater
  );
}

/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function setVideosAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function videosPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Videos";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function videosPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'videosPOST',
    ]);
}

/**
 * @param fileName (optional) 
 * @param name (optional) 
 * @param description (optional) 
 * @param durationSec (optional) 
 * @param image (optional) 
 * @param playlistId (optional) 
 * @param tags (optional) 
 * @param isPublic (optional) 
 * @param permissions_UserIds (optional) 
 * @param permissions_GroupIds (optional) 
 * @return Success
 */
export function useVideosPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.PostVideoResponse, unknown, VideosPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PostVideoResponse, unknown, VideosPOSTMutationParameters, TContext> {
  const key = videosPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((videosPOSTMutationParameters: VideosPOSTMutationParameters) => Client.videosPOST(videosPOSTMutationParameters.fileName, videosPOSTMutationParameters.name, videosPOSTMutationParameters.description, videosPOSTMutationParameters.durationSec, videosPOSTMutationParameters.image, videosPOSTMutationParameters.playlistId, videosPOSTMutationParameters.tags, videosPOSTMutationParameters.isPublic, videosPOSTMutationParameters.permissions_UserIds, videosPOSTMutationParameters.permissions_GroupIds), {...options, mutationKey: key});
}
  
export function videosGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let videosGETDefaultOptions: UseQueryOptions<Types.VideoDTO, unknown, Types.VideoDTO> = {
  queryFn: __videosGET,
};
export function getVideosGETDefaultOptions(): UseQueryOptions<Types.VideoDTO, unknown, Types.VideoDTO> {
  return videosGETDefaultOptions;
};
export function setVideosGETDefaultOptions(options: UseQueryOptions<Types.VideoDTO, unknown, Types.VideoDTO>) {
  videosGETDefaultOptions = options;
}

export function videosGETQueryKey(id: string): QueryKey;
export function videosGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as VideosGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'videosGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'videosGET',
        ...params
      ]);
  }
}
function __videosGET(context: QueryFunctionContext) {
  return Client.videosGET(
      context.queryKey[2] as string    );
}

export function useVideosGETQuery<TSelectData = Types.VideoDTO, TError = unknown>(dto: VideosGETQueryParameters, options?: UseQueryOptions<Types.VideoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useVideosGETQuery<TSelectData = Types.VideoDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.VideoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVideosGETQuery<TSelectData = Types.VideoDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VideoDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as VideosGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.VideoDTO, TError, TSelectData>({
    queryFn: __videosGET,
    queryKey: videosGETQueryKey(id),
    ...videosGETDefaultOptions as unknown as UseQueryOptions<Types.VideoDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setVideosGETData(queryClient: QueryClient, updater: (data: Types.VideoDTO | undefined) => Types.VideoDTO, id: string) {
  queryClient.setQueryData(videosGETQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setVideosGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VideoDTO | undefined) => Types.VideoDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function videosPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function videosPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'videosPUT',
      id as any,
    ]);
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param image (optional) 
 * @param playlistId (optional) 
 * @param tags (optional) 
 * @param isPublic (optional) 
 * @param permissions_UserIds (optional) 
 * @param permissions_GroupIds (optional) 
 * @return Success
 */
export function useVideosPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, VideosPUTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, VideosPUTMutationParameters, TContext> {
  const key = videosPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((videosPUTMutationParameters: VideosPUTMutationParameters) => Client.videosPUT(id, videosPUTMutationParameters.name, videosPUTMutationParameters.description, videosPUTMutationParameters.image, videosPUTMutationParameters.playlistId, videosPUTMutationParameters.tags, videosPUTMutationParameters.isPublic, videosPUTMutationParameters.permissions_UserIds, videosPUTMutationParameters.permissions_GroupIds), {...options, mutationKey: key});
}
  
type VideosPUT__MutationParameters = VideosPUTQueryParameters & {
  videosPUTMutationParameters: VideosPUTMutationParameters;
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param image (optional) 
 * @param playlistId (optional) 
 * @param tags (optional) 
 * @param isPublic (optional) 
 * @param permissions_UserIds (optional) 
 * @param permissions_GroupIds (optional) 
 * @return Success
 */
export function useVideosPUTMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, VideosPUT__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: VideosPUTQueryParameters}): UseMutationResult<void, unknown, VideosPUT__MutationParameters, TContext> {
  const key = videosPUTMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((data: VideosPUT__MutationParameters) => Client.videosPUT(data.id, data.name, data.description, data.image, data.playlistId, data.tags, data.isPublic, data.permissions_UserIds, data.permissions_GroupIds), {...options, mutationKey: key});
}
  
export function videosDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function videosDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'videosDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useVideosDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = videosDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation(() => Client.videosDELETE(id), {...options, mutationKey: key});
}
  
type VideosDELETE__MutationParameters = VideosDELETEQueryParameters

/**
 * @return Success
 */
export function useVideosDELETEMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, VideosDELETE__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: VideosDELETEQueryParameters}): UseMutationResult<void, unknown, VideosDELETE__MutationParameters, TContext> {
  const key = videosDELETEMutationKey(options?.parameters?.id!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation((data: VideosDELETE__MutationParameters) => Client.videosDELETE(data.id ?? options?.parameters?.id!), {...options, mutationKey: key});
}
  
export function videoPlaylistsUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}/video-playlists";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let videoPlaylistsDefaultOptions: UseQueryOptions<string[], unknown, string[]> = {
  queryFn: __videoPlaylists,
};
export function getVideoPlaylistsDefaultOptions(): UseQueryOptions<string[], unknown, string[]> {
  return videoPlaylistsDefaultOptions;
};
export function setVideoPlaylistsDefaultOptions(options: UseQueryOptions<string[], unknown, string[]>) {
  videoPlaylistsDefaultOptions = options;
}

export function videoPlaylistsQueryKey(id: string): QueryKey;
export function videoPlaylistsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as VideoPlaylistsQueryParameters;

    return trimArrayEnd([
        'Client',
        'videoPlaylists',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'videoPlaylists',
        ...params
      ]);
  }
}
function __videoPlaylists(context: QueryFunctionContext) {
  return Client.videoPlaylists(
      context.queryKey[2] as string    );
}

export function useVideoPlaylistsQuery<TSelectData = string[], TError = unknown>(dto: VideoPlaylistsQueryParameters, options?: UseQueryOptions<string[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useVideoPlaylistsQuery<TSelectData = string[], TError = unknown>(id: string, options?: UseQueryOptions<string[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVideoPlaylistsQuery<TSelectData = string[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as VideoPlaylistsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<string[], TError, TSelectData>({
    queryFn: __videoPlaylists,
    queryKey: videoPlaylistsQueryKey(id),
    ...videoPlaylistsDefaultOptions as unknown as UseQueryOptions<string[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setVideoPlaylistsData(queryClient: QueryClient, updater: (data: string[] | undefined) => string[], id: string) {
  queryClient.setQueryData(videoPlaylistsQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setVideoPlaylistsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string[] | undefined) => string[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function videoPermissionsUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}/video-permissions";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let videoPermissionsDefaultOptions: UseQueryOptions<Types.ObjectPermissions, unknown, Types.ObjectPermissions> = {
  queryFn: __videoPermissions,
};
export function getVideoPermissionsDefaultOptions(): UseQueryOptions<Types.ObjectPermissions, unknown, Types.ObjectPermissions> {
  return videoPermissionsDefaultOptions;
};
export function setVideoPermissionsDefaultOptions(options: UseQueryOptions<Types.ObjectPermissions, unknown, Types.ObjectPermissions>) {
  videoPermissionsDefaultOptions = options;
}

export function videoPermissionsQueryKey(id: string): QueryKey;
export function videoPermissionsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as VideoPermissionsQueryParameters;

    return trimArrayEnd([
        'Client',
        'videoPermissions',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'videoPermissions',
        ...params
      ]);
  }
}
function __videoPermissions(context: QueryFunctionContext) {
  return Client.videoPermissions(
      context.queryKey[2] as string    );
}

export function useVideoPermissionsQuery<TSelectData = Types.ObjectPermissions, TError = unknown>(dto: VideoPermissionsQueryParameters, options?: UseQueryOptions<Types.ObjectPermissions, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useVideoPermissionsQuery<TSelectData = Types.ObjectPermissions, TError = unknown>(id: string, options?: UseQueryOptions<Types.ObjectPermissions, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVideoPermissionsQuery<TSelectData = Types.ObjectPermissions, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ObjectPermissions, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as VideoPermissionsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.ObjectPermissions, TError, TSelectData>({
    queryFn: __videoPermissions,
    queryKey: videoPermissionsQueryKey(id),
    ...videoPermissionsDefaultOptions as unknown as UseQueryOptions<Types.ObjectPermissions, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setVideoPermissionsData(queryClient: QueryClient, updater: (data: Types.ObjectPermissions | undefined) => Types.ObjectPermissions, id: string) {
  queryClient.setQueryData(videoPermissionsQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setVideoPermissionsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ObjectPermissions | undefined) => Types.ObjectPermissions) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function myVideosUrl(): string {
  let url_ = getBaseUrl() + "/api/Videos/my-videos";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let myVideosDefaultOptions: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> = {
  queryFn: __myVideos,
};
export function getMyVideosDefaultOptions(): UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> {
  return myVideosDefaultOptions;
};
export function setMyVideosDefaultOptions(options: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]>) {
  myVideosDefaultOptions = options;
}

export function myVideosQueryKey(): QueryKey;
export function myVideosQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'myVideos',
    ]);
}
function __myVideos() {
  return Client.myVideos(
    );
}

/**
 * @return Success
 */
export function useMyVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMyVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VideoDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.VideoDTO[], TError, TSelectData>({
    queryFn: __myVideos,
    queryKey: myVideosQueryKey(),
    ...myVideosDefaultOptions as unknown as UseQueryOptions<Types.VideoDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setMyVideosData(queryClient: QueryClient, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[], ) {
  queryClient.setQueryData(myVideosQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setMyVideosDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function relatedVideosUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}/related-videos";
if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let relatedVideosDefaultOptions: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> = {
  queryFn: __relatedVideos,
};
export function getRelatedVideosDefaultOptions(): UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> {
  return relatedVideosDefaultOptions;
};
export function setRelatedVideosDefaultOptions(options: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]>) {
  relatedVideosDefaultOptions = options;
}

export function relatedVideosQueryKey(id: string): QueryKey;
export function relatedVideosQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as RelatedVideosQueryParameters;

    return trimArrayEnd([
        'Client',
        'relatedVideos',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'relatedVideos',
        ...params
      ]);
  }
}
function __relatedVideos(context: QueryFunctionContext) {
  return Client.relatedVideos(
      context.queryKey[2] as string    );
}

export function useRelatedVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(dto: RelatedVideosQueryParameters, options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useRelatedVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(id: string, options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRelatedVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VideoDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as RelatedVideosQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.VideoDTO[], TError, TSelectData>({
    queryFn: __relatedVideos,
    queryKey: relatedVideosQueryKey(id),
    ...relatedVideosDefaultOptions as unknown as UseQueryOptions<Types.VideoDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setRelatedVideosData(queryClient: QueryClient, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[], id: string) {
  queryClient.setQueryData(relatedVideosQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setRelatedVideosDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function uploadUrl(): string {
  let url_ = getBaseUrl() + "/api/Videos/upload";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'upload',
    ]);
}

/**
 * @param file (optional) 
 * @return Success
 */
export function useUploadMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, UploadMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, UploadMutationParameters, TContext> {
  const key = uploadMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation((uploadMutationParameters: UploadMutationParameters) => Client.upload(uploadMutationParameters.file), {...options, mutationKey: key});
}