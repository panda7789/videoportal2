//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions  } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './Client'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type CommentsAllQueryParameters = {
  videoId: string;
};

export type ChannelsPOSTMutationParameters = {
  name?: string | null | undefined ; 
  poster?: Types.FileParameter | null | undefined ; 
  pinnedVideoId?: string | null | undefined ; 
  avatar?: Types.FileParameter | null | undefined ; 
  description?: string | null | undefined ; 
  relatedChannels?: string[] | null | undefined ; 
};

export type ChannelsGETQueryParameters = {
  id: string;
};

export type ChannelsPUTMutationParameters = {
  name?: string | null | undefined ; 
  poster?: Types.FileParameter | null | undefined ; 
  pinnedVideoId?: string | null | undefined ; 
  avatar?: Types.FileParameter | null | undefined ; 
  description?: string | null | undefined ; 
  relatedChannels?: string[] | null | undefined ; 
};

export type ChannelVideosQueryParameters = {
  id: string;
  limit?: number | undefined;
  offset?: number | undefined;
};

export type ChannelAdvancedInfoQueryParameters = {
  id: string;
};

export type ChannelUserInfoGETQueryParameters = {
  id: string;
};

export type UsersGETQueryParameters = {
  id: string;
};

export type UserVideoStatsGETQueryParameters = {
  videoId: string;
};

export type VideosAllQueryParameters = {
  orderBy?: string | undefined;
  limit?: number | undefined;
  offset?: number | undefined;
};

export type VideosPOSTMutationParameters = {
  fileName?: string | null | undefined ; 
  name?: string | null | undefined ; 
  description?: string | null | undefined ; 
  durationSec?: number | undefined ; 
  image?: Types.FileParameter | null | undefined ; 
  channelId?: string | undefined ; 
  tags?: string[] | null | undefined ; 
};

export type VideosGETQueryParameters = {
  id: string;
};

export type VideosPUTMutationParameters = {
  name?: string | null | undefined ; 
  description?: string | null | undefined ; 
  image?: Types.FileParameter | null | undefined ; 
  channelId?: string | undefined ; 
  tags?: string[] | null | undefined ; 
};

export type RelatedVideosQueryParameters = {
  id: string;
};

export type UploadMutationParameters = {
  file?: Types.FileParameter | null | undefined ; 
};

    
export function commentsAllUrl(videoId: string): string {
  let url_ = getBaseUrl() + "/api/Comments/{videoId}";

if (videoId === undefined || videoId === null)
  throw new Error("The parameter 'videoId' must be defined.");
url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let commentsAllDefaultOptions: UseQueryOptions<Types.CommentDTO[], unknown, Types.CommentDTO[]> = {
  queryFn: __commentsAll,
};
export function getCommentsAllDefaultOptions(): UseQueryOptions<Types.CommentDTO[], unknown, Types.CommentDTO[]> {
  return commentsAllDefaultOptions;
};
export function setCommentsAllDefaultOptions(options: UseQueryOptions<Types.CommentDTO[], unknown, Types.CommentDTO[]>) {
  commentsAllDefaultOptions = options;
}

export function commentsAllQueryKey(videoId: string): QueryKey;
export function commentsAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { videoId,  } = params[0] as CommentsAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'commentsAll',
        videoId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'commentsAll',
        ...params
      ]);
  }
}
function __commentsAll(context: QueryFunctionContext) {
  return Client.commentsAll(
      context.queryKey[2] as string    );
}

export function useCommentsAllQuery<TSelectData = Types.CommentDTO[], TError = unknown>(dto: CommentsAllQueryParameters, options?: UseQueryOptions<Types.CommentDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useCommentsAllQuery<TSelectData = Types.CommentDTO[], TError = unknown>(videoId: string, options?: UseQueryOptions<Types.CommentDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useCommentsAllQuery<TSelectData = Types.CommentDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CommentDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let videoId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ videoId,  } = params[0] as CommentsAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [videoId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.CommentDTO[], TError, TSelectData>({
    queryFn: __commentsAll,
    queryKey: commentsAllQueryKey(videoId),
    ...commentsAllDefaultOptions as unknown as UseQueryOptions<Types.CommentDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setCommentsAllData(queryClient: QueryClient, updater: (data: Types.CommentDTO[] | undefined) => Types.CommentDTO[], videoId: string) {
  queryClient.setQueryData(commentsAllQueryKey(videoId),
    updater
  );
}

/**
 * @return Success
 */
export function setCommentsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CommentDTO[] | undefined) => Types.CommentDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function commentsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Comments/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function commentsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'commentsPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useCommentsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.CommentPutDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.CommentPutDTO, TContext> {
  const key = commentsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.CommentPutDTO) => Client.commentsPUT(id, body), {...options, mutationKey: key});
}
  
    
export function commentsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Comments/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function commentsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'commentsDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useCommentsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = commentsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client.commentsDELETE(id), {...options, mutationKey: key});
}
  
    
export function commentsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Comments";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function commentsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'commentsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useCommentsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.CommentPostDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.CommentPostDTO, TContext> {
  const key = commentsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.CommentPostDTO) => Client.commentsPOST(body), {...options, mutationKey: key});
}
  
    
export function myChannelsUrl(): string {
  let url_ = getBaseUrl() + "/api/Channels/my-channels";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let myChannelsDefaultOptions: UseQueryOptions<Types.ChannelDTO[], unknown, Types.ChannelDTO[]> = {
  queryFn: __myChannels,
};
export function getMyChannelsDefaultOptions(): UseQueryOptions<Types.ChannelDTO[], unknown, Types.ChannelDTO[]> {
  return myChannelsDefaultOptions;
};
export function setMyChannelsDefaultOptions(options: UseQueryOptions<Types.ChannelDTO[], unknown, Types.ChannelDTO[]>) {
  myChannelsDefaultOptions = options;
}

export function myChannelsQueryKey(): QueryKey;
export function myChannelsQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'myChannels',
    ]);
}
function __myChannels() {
  return Client.myChannels(
    );
}

/**
 * @return Success
 */
export function useMyChannelsQuery<TSelectData = Types.ChannelDTO[], TError = unknown>(options?: UseQueryOptions<Types.ChannelDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMyChannelsQuery<TSelectData = Types.ChannelDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ChannelDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.ChannelDTO[], TError, TSelectData>({
    queryFn: __myChannels,
    queryKey: myChannelsQueryKey(),
    ...myChannelsDefaultOptions as unknown as UseQueryOptions<Types.ChannelDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setMyChannelsData(queryClient: QueryClient, updater: (data: Types.ChannelDTO[] | undefined) => Types.ChannelDTO[], ) {
  queryClient.setQueryData(myChannelsQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setMyChannelsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ChannelDTO[] | undefined) => Types.ChannelDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function channelsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/Channels";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let channelsAllDefaultOptions: UseQueryOptions<Types.ChannelDTO[], unknown, Types.ChannelDTO[]> = {
  queryFn: __channelsAll,
};
export function getChannelsAllDefaultOptions(): UseQueryOptions<Types.ChannelDTO[], unknown, Types.ChannelDTO[]> {
  return channelsAllDefaultOptions;
};
export function setChannelsAllDefaultOptions(options: UseQueryOptions<Types.ChannelDTO[], unknown, Types.ChannelDTO[]>) {
  channelsAllDefaultOptions = options;
}

export function channelsAllQueryKey(): QueryKey;
export function channelsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'channelsAll',
    ]);
}
function __channelsAll() {
  return Client.channelsAll(
    );
}

/**
 * @return Success
 */
export function useChannelsAllQuery<TSelectData = Types.ChannelDTO[], TError = unknown>(options?: UseQueryOptions<Types.ChannelDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useChannelsAllQuery<TSelectData = Types.ChannelDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ChannelDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.ChannelDTO[], TError, TSelectData>({
    queryFn: __channelsAll,
    queryKey: channelsAllQueryKey(),
    ...channelsAllDefaultOptions as unknown as UseQueryOptions<Types.ChannelDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setChannelsAllData(queryClient: QueryClient, updater: (data: Types.ChannelDTO[] | undefined) => Types.ChannelDTO[], ) {
  queryClient.setQueryData(channelsAllQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setChannelsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ChannelDTO[] | undefined) => Types.ChannelDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function channelsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Channels";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function channelsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'channelsPOST',
    ]);
}

/**
 * @param name (optional) 
 * @param poster (optional) 
 * @param pinnedVideoId (optional) 
 * @param avatar (optional) 
 * @param description (optional) 
 * @param relatedChannels (optional) 
 * @return Success
 */
export function useChannelsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.ChannelDTO, unknown, ChannelsPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ChannelDTO, unknown, ChannelsPOSTMutationParameters, TContext> {
  const key = channelsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((channelsPOSTMutationParameters: ChannelsPOSTMutationParameters) => Client.channelsPOST(channelsPOSTMutationParameters.name, channelsPOSTMutationParameters.poster, channelsPOSTMutationParameters.pinnedVideoId, channelsPOSTMutationParameters.avatar, channelsPOSTMutationParameters.description, channelsPOSTMutationParameters.relatedChannels), {...options, mutationKey: key});
}
  
    
export function channelsGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Channels/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let channelsGETDefaultOptions: UseQueryOptions<Types.ChannelDTO, unknown, Types.ChannelDTO> = {
  queryFn: __channelsGET,
};
export function getChannelsGETDefaultOptions(): UseQueryOptions<Types.ChannelDTO, unknown, Types.ChannelDTO> {
  return channelsGETDefaultOptions;
};
export function setChannelsGETDefaultOptions(options: UseQueryOptions<Types.ChannelDTO, unknown, Types.ChannelDTO>) {
  channelsGETDefaultOptions = options;
}

export function channelsGETQueryKey(id: string): QueryKey;
export function channelsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ChannelsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'channelsGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'channelsGET',
        ...params
      ]);
  }
}
function __channelsGET(context: QueryFunctionContext) {
  return Client.channelsGET(
      context.queryKey[2] as string    );
}

export function useChannelsGETQuery<TSelectData = Types.ChannelDTO, TError = unknown>(dto: ChannelsGETQueryParameters, options?: UseQueryOptions<Types.ChannelDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useChannelsGETQuery<TSelectData = Types.ChannelDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.ChannelDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useChannelsGETQuery<TSelectData = Types.ChannelDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ChannelDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ChannelsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.ChannelDTO, TError, TSelectData>({
    queryFn: __channelsGET,
    queryKey: channelsGETQueryKey(id),
    ...channelsGETDefaultOptions as unknown as UseQueryOptions<Types.ChannelDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setChannelsGETData(queryClient: QueryClient, updater: (data: Types.ChannelDTO | undefined) => Types.ChannelDTO, id: string) {
  queryClient.setQueryData(channelsGETQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setChannelsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ChannelDTO | undefined) => Types.ChannelDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function channelsPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Channels/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function channelsPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'channelsPUT',
      id as any,
    ]);
}

/**
 * @param name (optional) 
 * @param poster (optional) 
 * @param pinnedVideoId (optional) 
 * @param avatar (optional) 
 * @param description (optional) 
 * @param relatedChannels (optional) 
 * @return Success
 */
export function useChannelsPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, ChannelsPUTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, ChannelsPUTMutationParameters, TContext> {
  const key = channelsPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((channelsPUTMutationParameters: ChannelsPUTMutationParameters) => Client.channelsPUT(id, channelsPUTMutationParameters.name, channelsPUTMutationParameters.poster, channelsPUTMutationParameters.pinnedVideoId, channelsPUTMutationParameters.avatar, channelsPUTMutationParameters.description, channelsPUTMutationParameters.relatedChannels), {...options, mutationKey: key});
}
  
    
export function channelsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Channels/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function channelsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'channelsDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useChannelsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = channelsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client.channelsDELETE(id), {...options, mutationKey: key});
}
  
    
export function channelVideosUrl(id: string, limit?: number | undefined, offset?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-videos?";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
else if (limit !== undefined)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (offset === null)
    throw new Error("The parameter 'offset' cannot be null.");
else if (offset !== undefined)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let channelVideosDefaultOptions: UseQueryOptions<Types.WithTotalCountOfVideoDTO, unknown, Types.WithTotalCountOfVideoDTO> = {
  queryFn: __channelVideos,
};
export function getChannelVideosDefaultOptions(): UseQueryOptions<Types.WithTotalCountOfVideoDTO, unknown, Types.WithTotalCountOfVideoDTO> {
  return channelVideosDefaultOptions;
};
export function setChannelVideosDefaultOptions(options: UseQueryOptions<Types.WithTotalCountOfVideoDTO, unknown, Types.WithTotalCountOfVideoDTO>) {
  channelVideosDefaultOptions = options;
}

export function channelVideosQueryKey(dto: ChannelVideosQueryParameters): QueryKey;
export function channelVideosQueryKey(id: string, limit?: number | undefined, offset?: number | undefined): QueryKey;
export function channelVideosQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id, limit, offset,  } = params[0] as ChannelVideosQueryParameters;

    return trimArrayEnd([
        'Client',
        'channelVideos',
        id as any,
        limit as any,
        offset as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'channelVideos',
        ...params
      ]);
  }
}
function __channelVideos(context: QueryFunctionContext) {
  return Client.channelVideos(
      context.queryKey[2] as string,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined    );
}

export function useChannelVideosQuery<TSelectData = Types.WithTotalCountOfVideoDTO, TError = unknown>(dto: ChannelVideosQueryParameters, options?: UseQueryOptions<Types.WithTotalCountOfVideoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function useChannelVideosQuery<TSelectData = Types.WithTotalCountOfVideoDTO, TError = unknown>(id: string, limit?: number | undefined, offset?: number | undefined, options?: UseQueryOptions<Types.WithTotalCountOfVideoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useChannelVideosQuery<TSelectData = Types.WithTotalCountOfVideoDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.WithTotalCountOfVideoDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  let limit: any = undefined;
  let offset: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id, limit, offset,  } = params[0] as ChannelVideosQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, limit, offset, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.WithTotalCountOfVideoDTO, TError, TSelectData>({
    queryFn: __channelVideos,
    queryKey: channelVideosQueryKey(id, limit, offset),
    ...channelVideosDefaultOptions as unknown as UseQueryOptions<Types.WithTotalCountOfVideoDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function setChannelVideosData(queryClient: QueryClient, updater: (data: Types.WithTotalCountOfVideoDTO | undefined) => Types.WithTotalCountOfVideoDTO, id: string, limit?: number | undefined, offset?: number | undefined) {
  queryClient.setQueryData(channelVideosQueryKey(id, limit, offset),
    updater
  );
}

/**
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function setChannelVideosDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.WithTotalCountOfVideoDTO | undefined) => Types.WithTotalCountOfVideoDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function channelAdvancedInfoUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-advanced-info";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let channelAdvancedInfoDefaultOptions: UseQueryOptions<Types.ChannelAdvancedInfoDTO, unknown, Types.ChannelAdvancedInfoDTO> = {
  queryFn: __channelAdvancedInfo,
};
export function getChannelAdvancedInfoDefaultOptions(): UseQueryOptions<Types.ChannelAdvancedInfoDTO, unknown, Types.ChannelAdvancedInfoDTO> {
  return channelAdvancedInfoDefaultOptions;
};
export function setChannelAdvancedInfoDefaultOptions(options: UseQueryOptions<Types.ChannelAdvancedInfoDTO, unknown, Types.ChannelAdvancedInfoDTO>) {
  channelAdvancedInfoDefaultOptions = options;
}

export function channelAdvancedInfoQueryKey(id: string): QueryKey;
export function channelAdvancedInfoQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ChannelAdvancedInfoQueryParameters;

    return trimArrayEnd([
        'Client',
        'channelAdvancedInfo',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'channelAdvancedInfo',
        ...params
      ]);
  }
}
function __channelAdvancedInfo(context: QueryFunctionContext) {
  return Client.channelAdvancedInfo(
      context.queryKey[2] as string    );
}

export function useChannelAdvancedInfoQuery<TSelectData = Types.ChannelAdvancedInfoDTO, TError = unknown>(dto: ChannelAdvancedInfoQueryParameters, options?: UseQueryOptions<Types.ChannelAdvancedInfoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useChannelAdvancedInfoQuery<TSelectData = Types.ChannelAdvancedInfoDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.ChannelAdvancedInfoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useChannelAdvancedInfoQuery<TSelectData = Types.ChannelAdvancedInfoDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ChannelAdvancedInfoDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ChannelAdvancedInfoQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.ChannelAdvancedInfoDTO, TError, TSelectData>({
    queryFn: __channelAdvancedInfo,
    queryKey: channelAdvancedInfoQueryKey(id),
    ...channelAdvancedInfoDefaultOptions as unknown as UseQueryOptions<Types.ChannelAdvancedInfoDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setChannelAdvancedInfoData(queryClient: QueryClient, updater: (data: Types.ChannelAdvancedInfoDTO | undefined) => Types.ChannelAdvancedInfoDTO, id: string) {
  queryClient.setQueryData(channelAdvancedInfoQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setChannelAdvancedInfoDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ChannelAdvancedInfoDTO | undefined) => Types.ChannelAdvancedInfoDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function channelUserInfoGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-user-info";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let channelUserInfoGETDefaultOptions: UseQueryOptions<Types.ChannelUserSpecificInfoDTO, unknown, Types.ChannelUserSpecificInfoDTO> = {
  queryFn: __channelUserInfoGET,
};
export function getChannelUserInfoGETDefaultOptions(): UseQueryOptions<Types.ChannelUserSpecificInfoDTO, unknown, Types.ChannelUserSpecificInfoDTO> {
  return channelUserInfoGETDefaultOptions;
};
export function setChannelUserInfoGETDefaultOptions(options: UseQueryOptions<Types.ChannelUserSpecificInfoDTO, unknown, Types.ChannelUserSpecificInfoDTO>) {
  channelUserInfoGETDefaultOptions = options;
}

export function channelUserInfoGETQueryKey(id: string): QueryKey;
export function channelUserInfoGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as ChannelUserInfoGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'channelUserInfoGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'channelUserInfoGET',
        ...params
      ]);
  }
}
function __channelUserInfoGET(context: QueryFunctionContext) {
  return Client.channelUserInfoGET(
      context.queryKey[2] as string    );
}

export function useChannelUserInfoGETQuery<TSelectData = Types.ChannelUserSpecificInfoDTO, TError = unknown>(dto: ChannelUserInfoGETQueryParameters, options?: UseQueryOptions<Types.ChannelUserSpecificInfoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useChannelUserInfoGETQuery<TSelectData = Types.ChannelUserSpecificInfoDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.ChannelUserSpecificInfoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useChannelUserInfoGETQuery<TSelectData = Types.ChannelUserSpecificInfoDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.ChannelUserSpecificInfoDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as ChannelUserInfoGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.ChannelUserSpecificInfoDTO, TError, TSelectData>({
    queryFn: __channelUserInfoGET,
    queryKey: channelUserInfoGETQueryKey(id),
    ...channelUserInfoGETDefaultOptions as unknown as UseQueryOptions<Types.ChannelUserSpecificInfoDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setChannelUserInfoGETData(queryClient: QueryClient, updater: (data: Types.ChannelUserSpecificInfoDTO | undefined) => Types.ChannelUserSpecificInfoDTO, id: string) {
  queryClient.setQueryData(channelUserInfoGETQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setChannelUserInfoGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.ChannelUserSpecificInfoDTO | undefined) => Types.ChannelUserSpecificInfoDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function channelUserInfoPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Channels/{id}/channel-user-info";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function channelUserInfoPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'channelUserInfoPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useChannelUserInfoPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.ChannelUserSpecificInfoDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.ChannelUserSpecificInfoDTO, TContext> {
  const key = channelUserInfoPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.ChannelUserSpecificInfoDTO) => Client.channelUserInfoPUT(id, body), {...options, mutationKey: key});
}
  
    
export function searchUrl(q?: string | undefined, limit?: number | undefined, offset?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/Search?";
if (q === null)
    throw new Error("The parameter 'q' cannot be null.");
else if (q !== undefined)
    url_ += "q=" + encodeURIComponent("" + q) + "&";
if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
else if (limit !== undefined)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (offset === null)
    throw new Error("The parameter 'offset' cannot be null.");
else if (offset !== undefined)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function searchMutationKey(q?: string | undefined, limit?: number | undefined, offset?: number | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'search',
      q as any,
      limit as any,
      offset as any,
    ]);
}

/**
 * @param q (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function useSearchMutation<TContext>(q?: string | undefined, limit?: number | undefined, offset?: number | undefined, options?: Omit<UseMutationOptions<Types.WithTotalCountOfVideoDTO, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.WithTotalCountOfVideoDTO, unknown, void, TContext> {
  const key = searchMutationKey(q, limit, offset);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client.search(q, limit, offset), {...options, mutationKey: key});
}
  
    
export function tagsAllUrl(): string {
  let url_ = getBaseUrl() + "/api/Tags";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let tagsAllDefaultOptions: UseQueryOptions<Types.TagDTO[], unknown, Types.TagDTO[]> = {
  queryFn: __tagsAll,
};
export function getTagsAllDefaultOptions(): UseQueryOptions<Types.TagDTO[], unknown, Types.TagDTO[]> {
  return tagsAllDefaultOptions;
};
export function setTagsAllDefaultOptions(options: UseQueryOptions<Types.TagDTO[], unknown, Types.TagDTO[]>) {
  tagsAllDefaultOptions = options;
}

export function tagsAllQueryKey(): QueryKey;
export function tagsAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'tagsAll',
    ]);
}
function __tagsAll() {
  return Client.tagsAll(
    );
}

/**
 * @return Success
 */
export function useTagsAllQuery<TSelectData = Types.TagDTO[], TError = unknown>(options?: UseQueryOptions<Types.TagDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTagsAllQuery<TSelectData = Types.TagDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.TagDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.TagDTO[], TError, TSelectData>({
    queryFn: __tagsAll,
    queryKey: tagsAllQueryKey(),
    ...tagsAllDefaultOptions as unknown as UseQueryOptions<Types.TagDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setTagsAllData(queryClient: QueryClient, updater: (data: Types.TagDTO[] | undefined) => Types.TagDTO[], ) {
  queryClient.setQueryData(tagsAllQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setTagsAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.TagDTO[] | undefined) => Types.TagDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function tagsPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Tags";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function tagsPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'tagsPOST',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useTagsPOSTMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, string, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, string, TContext> {
  const key = tagsPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: string) => Client.tagsPOST(body), {...options, mutationKey: key});
}
  
    
export function tagsWithVideosUrl(): string {
  let url_ = getBaseUrl() + "/api/Tags/tagsWithVideos";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let tagsWithVideosDefaultOptions: UseQueryOptions<Types.Tag[], unknown, Types.Tag[]> = {
  queryFn: __tagsWithVideos,
};
export function getTagsWithVideosDefaultOptions(): UseQueryOptions<Types.Tag[], unknown, Types.Tag[]> {
  return tagsWithVideosDefaultOptions;
};
export function setTagsWithVideosDefaultOptions(options: UseQueryOptions<Types.Tag[], unknown, Types.Tag[]>) {
  tagsWithVideosDefaultOptions = options;
}

export function tagsWithVideosQueryKey(): QueryKey;
export function tagsWithVideosQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'tagsWithVideos',
    ]);
}
function __tagsWithVideos() {
  return Client.tagsWithVideos(
    );
}

/**
 * @return Success
 */
export function useTagsWithVideosQuery<TSelectData = Types.Tag[], TError = unknown>(options?: UseQueryOptions<Types.Tag[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useTagsWithVideosQuery<TSelectData = Types.Tag[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Tag[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.Tag[], TError, TSelectData>({
    queryFn: __tagsWithVideos,
    queryKey: tagsWithVideosQueryKey(),
    ...tagsWithVideosDefaultOptions as unknown as UseQueryOptions<Types.Tag[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setTagsWithVideosData(queryClient: QueryClient, updater: (data: Types.Tag[] | undefined) => Types.Tag[], ) {
  queryClient.setQueryData(tagsWithVideosQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setTagsWithVideosDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Tag[] | undefined) => Types.Tag[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function tagsDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Tags/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function tagsDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'tagsDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useTagsDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = tagsDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client.tagsDELETE(id), {...options, mutationKey: key});
}
  
    
export function loginUrl(): string {
  let url_ = getBaseUrl() + "/api/users/login";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function loginMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'login',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useLoginMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, Types.LoginDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, Types.LoginDTO, TContext> {
  const key = loginMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.LoginDTO) => Client.login(body), {...options, mutationKey: key});
}
  
    
export function registerUrl(): string {
  let url_ = getBaseUrl() + "/api/users/register";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function registerMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'register',
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useRegisterMutation<TContext>(options?: Omit<UseMutationOptions<string, unknown, Types.RegisterDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<string, unknown, Types.RegisterDTO, TContext> {
  const key = registerMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.RegisterDTO) => Client.register(body), {...options, mutationKey: key});
}
  
    
export function meUrl(): string {
  let url_ = getBaseUrl() + "/api/users/me";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let meDefaultOptions: UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO> = {
  queryFn: __me,
};
export function getMeDefaultOptions(): UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO> {
  return meDefaultOptions;
};
export function setMeDefaultOptions(options: UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO>) {
  meDefaultOptions = options;
}

export function meQueryKey(): QueryKey;
export function meQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'me',
    ]);
}
function __me() {
  return Client.me(
    );
}

/**
 * @return Success
 */
export function useMeQuery<TSelectData = Types.UserDTO, TError = unknown>(options?: UseQueryOptions<Types.UserDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMeQuery<TSelectData = Types.UserDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserDTO, TError, TSelectData>({
    queryFn: __me,
    queryKey: meQueryKey(),
    ...meDefaultOptions as unknown as UseQueryOptions<Types.UserDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setMeData(queryClient: QueryClient, updater: (data: Types.UserDTO | undefined) => Types.UserDTO, ) {
  queryClient.setQueryData(meQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setMeDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserDTO | undefined) => Types.UserDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function usersAllUrl(): string {
  let url_ = getBaseUrl() + "/api/users";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersAllDefaultOptions: UseQueryOptions<Types.UserDTO[], unknown, Types.UserDTO[]> = {
  queryFn: __usersAll,
};
export function getUsersAllDefaultOptions(): UseQueryOptions<Types.UserDTO[], unknown, Types.UserDTO[]> {
  return usersAllDefaultOptions;
};
export function setUsersAllDefaultOptions(options: UseQueryOptions<Types.UserDTO[], unknown, Types.UserDTO[]>) {
  usersAllDefaultOptions = options;
}

export function usersAllQueryKey(): QueryKey;
export function usersAllQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'usersAll',
    ]);
}
function __usersAll() {
  return Client.usersAll(
    );
}

/**
 * @return Success
 */
export function useUsersAllQuery<TSelectData = Types.UserDTO[], TError = unknown>(options?: UseQueryOptions<Types.UserDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersAllQuery<TSelectData = Types.UserDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserDTO[], TError, TSelectData>({
    queryFn: __usersAll,
    queryKey: usersAllQueryKey(),
    ...usersAllDefaultOptions as unknown as UseQueryOptions<Types.UserDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setUsersAllData(queryClient: QueryClient, updater: (data: Types.UserDTO[] | undefined) => Types.UserDTO[], ) {
  queryClient.setQueryData(usersAllQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setUsersAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserDTO[] | undefined) => Types.UserDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function usersPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/users/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function usersPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'usersPUT',
      id as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUsersPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, Types.UserDTO, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.UserDTO, TContext> {
  const key = usersPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.UserDTO) => Client.usersPUT(id, body), {...options, mutationKey: key});
}
  
    
export function usersDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/users/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function usersDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'usersDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useUsersDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = usersDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client.usersDELETE(id), {...options, mutationKey: key});
}
  
    
export function usersGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/users/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let usersGETDefaultOptions: UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO> = {
  queryFn: __usersGET,
};
export function getUsersGETDefaultOptions(): UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO> {
  return usersGETDefaultOptions;
};
export function setUsersGETDefaultOptions(options: UseQueryOptions<Types.UserDTO, unknown, Types.UserDTO>) {
  usersGETDefaultOptions = options;
}

export function usersGETQueryKey(id: string): QueryKey;
export function usersGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as UsersGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'usersGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'usersGET',
        ...params
      ]);
  }
}
function __usersGET(context: QueryFunctionContext) {
  return Client.usersGET(
      context.queryKey[2] as string    );
}

export function useUsersGETQuery<TSelectData = Types.UserDTO, TError = unknown>(dto: UsersGETQueryParameters, options?: UseQueryOptions<Types.UserDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useUsersGETQuery<TSelectData = Types.UserDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.UserDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUsersGETQuery<TSelectData = Types.UserDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as UsersGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserDTO, TError, TSelectData>({
    queryFn: __usersGET,
    queryKey: usersGETQueryKey(id),
    ...usersGETDefaultOptions as unknown as UseQueryOptions<Types.UserDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setUsersGETData(queryClient: QueryClient, updater: (data: Types.UserDTO | undefined) => Types.UserDTO, id: string) {
  queryClient.setQueryData(usersGETQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setUsersGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserDTO | undefined) => Types.UserDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function userVideoStatsGETUrl(videoId: string): string {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";

if (videoId === undefined || videoId === null)
  throw new Error("The parameter 'videoId' must be defined.");
url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let userVideoStatsGETDefaultOptions: UseQueryOptions<Types.UserVideoStats, unknown, Types.UserVideoStats> = {
  queryFn: __userVideoStatsGET,
};
export function getUserVideoStatsGETDefaultOptions(): UseQueryOptions<Types.UserVideoStats, unknown, Types.UserVideoStats> {
  return userVideoStatsGETDefaultOptions;
};
export function setUserVideoStatsGETDefaultOptions(options: UseQueryOptions<Types.UserVideoStats, unknown, Types.UserVideoStats>) {
  userVideoStatsGETDefaultOptions = options;
}

export function userVideoStatsGETQueryKey(videoId: string): QueryKey;
export function userVideoStatsGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { videoId,  } = params[0] as UserVideoStatsGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'userVideoStatsGET',
        videoId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'userVideoStatsGET',
        ...params
      ]);
  }
}
function __userVideoStatsGET(context: QueryFunctionContext) {
  return Client.userVideoStatsGET(
      context.queryKey[2] as string    );
}

export function useUserVideoStatsGETQuery<TSelectData = Types.UserVideoStats, TError = unknown>(dto: UserVideoStatsGETQueryParameters, options?: UseQueryOptions<Types.UserVideoStats, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useUserVideoStatsGETQuery<TSelectData = Types.UserVideoStats, TError = unknown>(videoId: string, options?: UseQueryOptions<Types.UserVideoStats, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useUserVideoStatsGETQuery<TSelectData = Types.UserVideoStats, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.UserVideoStats, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let videoId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ videoId,  } = params[0] as UserVideoStatsGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [videoId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.UserVideoStats, TError, TSelectData>({
    queryFn: __userVideoStatsGET,
    queryKey: userVideoStatsGETQueryKey(videoId),
    ...userVideoStatsGETDefaultOptions as unknown as UseQueryOptions<Types.UserVideoStats, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setUserVideoStatsGETData(queryClient: QueryClient, updater: (data: Types.UserVideoStats | undefined) => Types.UserVideoStats, videoId: string) {
  queryClient.setQueryData(userVideoStatsGETQueryKey(videoId),
    updater
  );
}

/**
 * @return Success
 */
export function setUserVideoStatsGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.UserVideoStats | undefined) => Types.UserVideoStats) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function userVideoStatsPUTUrl(videoId: string): string {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}";

if (videoId === undefined || videoId === null)
  throw new Error("The parameter 'videoId' must be defined.");
url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function userVideoStatsPUTMutationKey(videoId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'userVideoStatsPUT',
      videoId as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useUserVideoStatsPUTMutation<TContext>(videoId: string, options?: Omit<UseMutationOptions<void, unknown, Types.UserVideoStats, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.UserVideoStats, TContext> {
  const key = userVideoStatsPUTMutationKey(videoId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: Types.UserVideoStats) => Client.userVideoStatsPUT(videoId, body), {...options, mutationKey: key});
}
  
    
export function watchedUrl(videoId: string): string {
  let url_ = getBaseUrl() + "/api/UserVideoStats/{videoId}/watched";

if (videoId === undefined || videoId === null)
  throw new Error("The parameter 'videoId' must be defined.");
url_ = url_.replace("{videoId}", encodeURIComponent("" + videoId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function watchedMutationKey(videoId: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'watched',
      videoId as any,
    ]);
}

/**
 * @param body (optional) 
 * @return Success
 */
export function useWatchedMutation<TContext>(videoId: string, options?: Omit<UseMutationOptions<void, unknown, number, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, number, TContext> {
  const key = watchedMutationKey(videoId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((body: number) => Client.watched(videoId, body), {...options, mutationKey: key});
}
  
    
export function videosAllUrl(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined): string {
  let url_ = getBaseUrl() + "/api/Videos?";
if (orderBy === null)
    throw new Error("The parameter 'orderBy' cannot be null.");
else if (orderBy !== undefined)
    url_ += "orderBy=" + encodeURIComponent("" + orderBy) + "&";
if (limit === null)
    throw new Error("The parameter 'limit' cannot be null.");
else if (limit !== undefined)
    url_ += "limit=" + encodeURIComponent("" + limit) + "&";
if (offset === null)
    throw new Error("The parameter 'offset' cannot be null.");
else if (offset !== undefined)
    url_ += "offset=" + encodeURIComponent("" + offset) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let videosAllDefaultOptions: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> = {
  queryFn: __videosAll,
};
export function getVideosAllDefaultOptions(): UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> {
  return videosAllDefaultOptions;
};
export function setVideosAllDefaultOptions(options: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]>) {
  videosAllDefaultOptions = options;
}

export function videosAllQueryKey(dto: VideosAllQueryParameters): QueryKey;
export function videosAllQueryKey(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined): QueryKey;
export function videosAllQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { orderBy, limit, offset,  } = params[0] as VideosAllQueryParameters;

    return trimArrayEnd([
        'Client',
        'videosAll',
        orderBy as any,
        limit as any,
        offset as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'videosAll',
        ...params
      ]);
  }
}
function __videosAll(context: QueryFunctionContext) {
  return Client.videosAll(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as number | undefined,       context.queryKey[4] as number | undefined    );
}

export function useVideosAllQuery<TSelectData = Types.VideoDTO[], TError = unknown>(dto: VideosAllQueryParameters, options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function useVideosAllQuery<TSelectData = Types.VideoDTO[], TError = unknown>(orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined, options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVideosAllQuery<TSelectData = Types.VideoDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VideoDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let orderBy: any = undefined;
  let limit: any = undefined;
  let offset: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ orderBy, limit, offset,  } = params[0] as VideosAllQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [orderBy, limit, offset, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.VideoDTO[], TError, TSelectData>({
    queryFn: __videosAll,
    queryKey: videosAllQueryKey(orderBy, limit, offset),
    ...videosAllDefaultOptions as unknown as UseQueryOptions<Types.VideoDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function setVideosAllData(queryClient: QueryClient, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[], orderBy?: string | undefined, limit?: number | undefined, offset?: number | undefined) {
  queryClient.setQueryData(videosAllQueryKey(orderBy, limit, offset),
    updater
  );
}

/**
 * @param orderBy (optional) 
 * @param limit (optional) 
 * @param offset (optional) 
 * @return Success
 */
export function setVideosAllDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function videosPOSTUrl(): string {
  let url_ = getBaseUrl() + "/api/Videos";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function videosPOSTMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'videosPOST',
    ]);
}

/**
 * @param fileName (optional) 
 * @param name (optional) 
 * @param description (optional) 
 * @param durationSec (optional) 
 * @param image (optional) 
 * @param channelId (optional) 
 * @param tags (optional) 
 * @return Success
 */
export function useVideosPOSTMutation<TContext>(options?: Omit<UseMutationOptions<Types.PostVideoResponse, unknown, VideosPOSTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.PostVideoResponse, unknown, VideosPOSTMutationParameters, TContext> {
  const key = videosPOSTMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((videosPOSTMutationParameters: VideosPOSTMutationParameters) => Client.videosPOST(videosPOSTMutationParameters.fileName, videosPOSTMutationParameters.name, videosPOSTMutationParameters.description, videosPOSTMutationParameters.durationSec, videosPOSTMutationParameters.image, videosPOSTMutationParameters.channelId, videosPOSTMutationParameters.tags), {...options, mutationKey: key});
}
  
    
export function videosGETUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let videosGETDefaultOptions: UseQueryOptions<Types.VideoDTO, unknown, Types.VideoDTO> = {
  queryFn: __videosGET,
};
export function getVideosGETDefaultOptions(): UseQueryOptions<Types.VideoDTO, unknown, Types.VideoDTO> {
  return videosGETDefaultOptions;
};
export function setVideosGETDefaultOptions(options: UseQueryOptions<Types.VideoDTO, unknown, Types.VideoDTO>) {
  videosGETDefaultOptions = options;
}

export function videosGETQueryKey(id: string): QueryKey;
export function videosGETQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as VideosGETQueryParameters;

    return trimArrayEnd([
        'Client',
        'videosGET',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'videosGET',
        ...params
      ]);
  }
}
function __videosGET(context: QueryFunctionContext) {
  return Client.videosGET(
      context.queryKey[2] as string    );
}

export function useVideosGETQuery<TSelectData = Types.VideoDTO, TError = unknown>(dto: VideosGETQueryParameters, options?: UseQueryOptions<Types.VideoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useVideosGETQuery<TSelectData = Types.VideoDTO, TError = unknown>(id: string, options?: UseQueryOptions<Types.VideoDTO, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useVideosGETQuery<TSelectData = Types.VideoDTO, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VideoDTO, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as VideosGETQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.VideoDTO, TError, TSelectData>({
    queryFn: __videosGET,
    queryKey: videosGETQueryKey(id),
    ...videosGETDefaultOptions as unknown as UseQueryOptions<Types.VideoDTO, TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setVideosGETData(queryClient: QueryClient, updater: (data: Types.VideoDTO | undefined) => Types.VideoDTO, id: string) {
  queryClient.setQueryData(videosGETQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setVideosGETDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VideoDTO | undefined) => Types.VideoDTO) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function videosPUTUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function videosPUTMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'videosPUT',
      id as any,
    ]);
}

/**
 * @param name (optional) 
 * @param description (optional) 
 * @param image (optional) 
 * @param channelId (optional) 
 * @param tags (optional) 
 * @return Success
 */
export function useVideosPUTMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, VideosPUTMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, VideosPUTMutationParameters, TContext> {
  const key = videosPUTMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((videosPUTMutationParameters: VideosPUTMutationParameters) => Client.videosPUT(id, videosPUTMutationParameters.name, videosPUTMutationParameters.description, videosPUTMutationParameters.image, videosPUTMutationParameters.channelId, videosPUTMutationParameters.tags), {...options, mutationKey: key});
}
  
    
export function videosDELETEUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function videosDELETEMutationKey(id: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'videosDELETE',
      id as any,
    ]);
}

/**
 * @return Success
 */
export function useVideosDELETEMutation<TContext>(id: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = videosDELETEMutationKey(id);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation(() => Client.videosDELETE(id), {...options, mutationKey: key});
}
  
    
export function myVideosUrl(): string {
  let url_ = getBaseUrl() + "/api/Videos/my-videos";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let myVideosDefaultOptions: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> = {
  queryFn: __myVideos,
};
export function getMyVideosDefaultOptions(): UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> {
  return myVideosDefaultOptions;
};
export function setMyVideosDefaultOptions(options: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]>) {
  myVideosDefaultOptions = options;
}

export function myVideosQueryKey(): QueryKey;
export function myVideosQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'myVideos',
    ]);
}
function __myVideos() {
  return Client.myVideos(
    );
}

/**
 * @return Success
 */
export function useMyVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useMyVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VideoDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.VideoDTO[], TError, TSelectData>({
    queryFn: __myVideos,
    queryKey: myVideosQueryKey(),
    ...myVideosDefaultOptions as unknown as UseQueryOptions<Types.VideoDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setMyVideosData(queryClient: QueryClient, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[], ) {
  queryClient.setQueryData(myVideosQueryKey(),
    updater
  );
}

/**
 * @return Success
 */
export function setMyVideosDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function relatedVideosUrl(id: string): string {
  let url_ = getBaseUrl() + "/api/Videos/{id}/related-videos";

if (id === undefined || id === null)
  throw new Error("The parameter 'id' must be defined.");
url_ = url_.replace("{id}", encodeURIComponent("" + id));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let relatedVideosDefaultOptions: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> = {
  queryFn: __relatedVideos,
};
export function getRelatedVideosDefaultOptions(): UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]> {
  return relatedVideosDefaultOptions;
};
export function setRelatedVideosDefaultOptions(options: UseQueryOptions<Types.VideoDTO[], unknown, Types.VideoDTO[]>) {
  relatedVideosDefaultOptions = options;
}

export function relatedVideosQueryKey(id: string): QueryKey;
export function relatedVideosQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { id,  } = params[0] as RelatedVideosQueryParameters;

    return trimArrayEnd([
        'Client',
        'relatedVideos',
        id as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'relatedVideos',
        ...params
      ]);
  }
}
function __relatedVideos(context: QueryFunctionContext) {
  return Client.relatedVideos(
      context.queryKey[2] as string    );
}

export function useRelatedVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(dto: RelatedVideosQueryParameters, options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * @return Success
 */
export function useRelatedVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(id: string, options?: UseQueryOptions<Types.VideoDTO[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useRelatedVideosQuery<TSelectData = Types.VideoDTO[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.VideoDTO[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let id: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ id,  } = params[0] as RelatedVideosQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [id, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.VideoDTO[], TError, TSelectData>({
    queryFn: __relatedVideos,
    queryKey: relatedVideosQueryKey(id),
    ...relatedVideosDefaultOptions as unknown as UseQueryOptions<Types.VideoDTO[], TError, TSelectData>,
    ...options,
  });
}
/**
 * @return Success
 */
export function setRelatedVideosData(queryClient: QueryClient, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[], id: string) {
  queryClient.setQueryData(relatedVideosQueryKey(id),
    updater
  );
}

/**
 * @return Success
 */
export function setRelatedVideosDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.VideoDTO[] | undefined) => Types.VideoDTO[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
    
export function uploadUrl(): string {
  let url_ = getBaseUrl() + "/api/Videos/upload";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'upload',
    ]);
}

/**
 * @param file (optional) 
 * @return Success
 */
export function useUploadMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, UploadMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, UploadMutationParameters, TContext> {
  const key = uploadMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
      return useMutation((uploadMutationParameters: UploadMutationParameters) => Client.upload(uploadMutationParameters.file), {...options, mutationKey: key});
}